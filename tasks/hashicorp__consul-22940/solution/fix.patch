diff --git a/.changelog/22836.txt b/.changelog/22836.txt
new file mode 100644
index 0000000000..91d50eb28b
--- /dev/null
+++ b/.changelog/22836.txt
@@ -0,0 +1,3 @@
+```release-note:security
+security: adding a maximum Content-Length on the event endpoint to fix denial-of-service (DoS) attacks. This resolves [CVE-2025-11375](https://nvd.nist.gov/vuln/detail/CVE-2025-11375).
+```
diff --git a/agent/event_endpoint.go b/agent/event_endpoint.go
index da589632c7..3e7d4b0648 100644
--- a/agent/event_endpoint.go
+++ b/agent/event_endpoint.go
@@ -5,6 +5,7 @@ package agent
 
 import (
 	"bytes"
+	"fmt"
 	"io"
 	"net/http"
 	"strconv"
@@ -44,12 +45,29 @@ func (s *HTTPHandlers) EventFire(resp http.ResponseWriter, req *http.Request) (i
 	}
 
 	// Get the payload
-	if req.ContentLength > 0 {
+	if req.ContentLength >= 0 {
+		// The underlying gossip sets limits on the size of a user event
+		// message. It is hard to give an exact number, as it depends on various
+		// parameters of the event, but the payload should be kept very small
+		// (< 100 bytes). We've multiplied this by 3 to be safe.
+		const maxEventPayloadSize = 300
+		if req.ContentLength > maxEventPayloadSize {
+			return nil, HTTPError{
+				StatusCode: http.StatusRequestEntityTooLarge,
+				Reason: fmt.Sprintf("Event payload too large, received %d bytes, max size: %d bytes. User events should be kept small for efficient gossip propagation.",
+					req.ContentLength, maxEventPayloadSize),
+			}
+		}
+
 		var buf bytes.Buffer
-		if _, err := io.Copy(&buf, req.Body); err != nil {
-			return nil, err
+		if req.Body != nil {
+			if _, err := io.Copy(&buf, req.Body); err != nil {
+				return nil, err
+			}
+			event.Payload = buf.Bytes()
 		}
-		event.Payload = buf.Bytes()
+	} else {
+		return nil, HTTPError{StatusCode: http.StatusBadRequest, Reason: "Event payload size must be greater than zero"}
 	}
 
 	// Try to fire the event
