diff --git a/internal/pool/export_test.go b/internal/pool/export_test.go
index b723a073..2d178038 100644
--- a/internal/pool/export_test.go
+++ b/internal/pool/export_test.go
@@ -22,9 +22,3 @@ func (p *ConnPool) CheckMinIdleConns() {
 func (p *ConnPool) QueueLen() int {
 	return int(p.semaphore.Len())
 }
-
-var NoExpiration = noExpiration
-
-func (p *ConnPool) CalcConnExpiresAt() time.Time {
-	return p.calcConnExpiresAt()
-}
diff --git a/internal/pool/pool.go b/internal/pool/pool.go
index ed589781..c13c7b17 100644
--- a/internal/pool/pool.go
+++ b/internal/pool/pool.go
@@ -10,7 +10,6 @@ import (
 
 	"github.com/redis/go-redis/v9/internal"
 	"github.com/redis/go-redis/v9/internal/proto"
-	"github.com/redis/go-redis/v9/internal/rand"
 )
 
 var (
@@ -110,7 +109,6 @@ type Options struct {
 	MaxActiveConns           int32
 	ConnMaxIdleTime          time.Duration
 	ConnMaxLifetime          time.Duration
-	ConnMaxLifetimeJitter    time.Duration
 	PushNotificationsEnabled bool
 
 	// DialerRetries is the maximum number of retry attempts when dialing fails.
@@ -414,7 +412,11 @@ func (p *ConnPool) dialConn(ctx context.Context, pooled bool) (*Conn, error) {
 		// Success - create connection
 		cn := NewConnWithBufferSize(netConn, p.cfg.ReadBufferSize, p.cfg.WriteBufferSize)
 		cn.pooled = pooled
-		cn.expiresAt = p.calcConnExpiresAt()
+		if p.cfg.ConnMaxLifetime > 0 {
+			cn.expiresAt = time.Now().Add(p.cfg.ConnMaxLifetime)
+		} else {
+			cn.expiresAt = noExpiration
+		}
 
 		return cn, nil
 	}
@@ -428,25 +430,6 @@ func (p *ConnPool) dialConn(ctx context.Context, pooled bool) (*Conn, error) {
 	return nil, lastErr
 }
 
-// calcConnExpiresAt calculates the expiration time for a connection.
-// It applies random jitter to prevent all connections from expiring simultaneously,
-// avoiding the "thundering herd" problem where all connections expire at once.
-// Returns noExpiration if ConnMaxLifetime is not set.
-func (p *ConnPool) calcConnExpiresAt() time.Time {
-	if p.cfg.ConnMaxLifetime <= 0 {
-		return noExpiration
-	}
-
-	if p.cfg.ConnMaxLifetimeJitter <= 0 {
-		return time.Now().Add(p.cfg.ConnMaxLifetime)
-	}
-
-	jitter := p.cfg.ConnMaxLifetimeJitter
-	jitterRange := jitter.Nanoseconds() * 2
-	jitterNs := rand.Int63n(jitterRange) - jitter.Nanoseconds()
-	return time.Now().Add(p.cfg.ConnMaxLifetime + time.Duration(jitterNs))
-}
-
 func (p *ConnPool) tryDial() {
 	for {
 		if p.closed() {
diff --git a/internal/pool/pool_test.go b/internal/pool/pool_test.go
index 9a422c4b..757057b3 100644
--- a/internal/pool/pool_test.go
+++ b/internal/pool/pool_test.go
@@ -1095,58 +1095,6 @@ var _ = Describe("queuedNewConn", func() {
 		// We should have at least some timeouts due to the short timeout
 		Expect(timeoutCount).To(BeNumerically(">", 0))
 	})
-
-	Describe("calcConnExpiresAt", func() {
-		// Case 1: lifetime <= 0 returns noExpiration
-		It("returns noExpiration when ConnMaxLifetime is not positive", func() {
-			p := pool.NewConnPool(&pool.Options{
-				Dialer:          dummyDialer,
-				PoolSize:        1,
-				ConnMaxLifetime: 0,
-				ConnMaxLifetimeJitter: 0,
-			})
-			defer p.Close()
-			Expect(p.CalcConnExpiresAt()).To(Equal(pool.NoExpiration))
-		})
-
-		// Case 2: lifetime > 0, jitter <= 0 returns exact lifetime
-		It("returns exact lifetime when jitter is zero", func() {
-			lifetime := 1 * time.Hour
-			p := pool.NewConnPool(&pool.Options{
-				Dialer:                dummyDialer,
-				PoolSize:              1,
-				ConnMaxLifetime:       lifetime,
-				ConnMaxLifetimeJitter: 0,
-			})
-			defer p.Close()
-
-			before := time.Now()
-			expiresAt := p.CalcConnExpiresAt()
-			after := time.Now()
-
-			Expect(expiresAt).To(BeTemporally(">=", before.Add(lifetime)))
-			Expect(expiresAt).To(BeTemporally("<=", after.Add(lifetime)))
-		})
-
-		// Case 3: lifetime > 0, jitter > 0 returns value in jitter range
-		It("returns value in jitter range when jitter is positive", func() {
-			lifetime := 1 * time.Hour
-			jitter := 6 * time.Minute
-			p := pool.NewConnPool(&pool.Options{
-				Dialer:                dummyDialer,
-				PoolSize:              1,
-				ConnMaxLifetime:       lifetime,
-				ConnMaxLifetimeJitter: jitter,
-			})
-			defer p.Close()
-
-			before := time.Now()
-			expiresAt := p.CalcConnExpiresAt()
-
-			Expect(expiresAt).To(BeTemporally(">=", before.Add(lifetime-jitter)))
-			Expect(expiresAt).To(BeTemporally("<=", before.Add(lifetime+jitter)))
-		})
-	})
 })
 
 func init() {
diff --git a/options.go b/options.go
index 4c03a0e7..9773e86f 100644
--- a/options.go
+++ b/options.go
@@ -220,19 +220,6 @@ type Options struct {
 	// default: 0
 	ConnMaxLifetime time.Duration
 
-	// ConnMaxLifetimeJitter is the absolute jitter duration applied to ConnMaxLifetime
-	// to prevent all connections from expiring simultaneously.
-	//
-	// The jitter is applied as a random offset in the range [-jitter, +jitter].
-	// For example, if ConnMaxLifetime is 1 hour and ConnMaxLifetimeJitter is 6 minutes,
-	// connections will expire between 54 minutes and 66 minutes.
-	//
-	// If <= 0, no jitter is applied.
-	// If > ConnMaxLifetime, it will be capped at ConnMaxLifetime.
-	//
-	// default: 0
-	ConnMaxLifetimeJitter time.Duration
-
 	// TLSConfig to use. When set, TLS will be negotiated.
 	TLSConfig *tls.Config
 
@@ -349,8 +336,6 @@ func (opt *Options) init() {
 		opt.ConnMaxIdleTime = 30 * time.Minute
 	}
 
-	opt.ConnMaxLifetimeJitter = min(opt.ConnMaxLifetimeJitter, opt.ConnMaxLifetime)
-	
 	switch opt.MaxRetries {
 	case -1:
 		opt.MaxRetries = 0
@@ -660,9 +645,6 @@ func setupConnParams(u *url.URL, o *Options) (*Options, error) {
 	} else {
 		o.ConnMaxLifetime = q.duration("max_conn_age")
 	}
-	if q.has("conn_max_lifetime_jitter") {
-		o.ConnMaxLifetimeJitter = min(q.duration("conn_max_lifetime_jitter"), o.ConnMaxLifetime)
-	}
 	if q.err != nil {
 		return nil, q.err
 	}
@@ -729,7 +711,6 @@ func newConnPool(
 		MaxActiveConns:           maxActiveConns,
 		ConnMaxIdleTime:          opt.ConnMaxIdleTime,
 		ConnMaxLifetime:          opt.ConnMaxLifetime,
-		ConnMaxLifetimeJitter:    opt.ConnMaxLifetimeJitter,
 		ReadBufferSize:           opt.ReadBufferSize,
 		WriteBufferSize:          opt.WriteBufferSize,
 		PushNotificationsEnabled: opt.Protocol == 3,
@@ -771,7 +752,6 @@ func newPubSubPool(opt *Options, dialer func(ctx context.Context, network, addr
 		MaxActiveConns:           maxActiveConns,
 		ConnMaxIdleTime:          opt.ConnMaxIdleTime,
 		ConnMaxLifetime:          opt.ConnMaxLifetime,
-		ConnMaxLifetimeJitter:    opt.ConnMaxLifetimeJitter,
 		ReadBufferSize:           32 * 1024,
 		WriteBufferSize:          32 * 1024,
 		PushNotificationsEnabled: opt.Protocol == 3,
diff --git a/options_test.go b/options_test.go
index 391fc49f..32d75e25 100644
--- a/options_test.go
+++ b/options_test.go
@@ -73,17 +73,6 @@ func TestParseURL(t *testing.T) {
 		}, {
 			url: "redis://localhost:123/?max_concurrent_dials=0", // MaxConcurrentDials zero value
 			o:   &Options{Addr: "localhost:123", MaxConcurrentDials: 0},
-		}, {
-			url: "redis://localhost:123/?conn_max_lifetime=1h&conn_max_lifetime_jitter=6m",
-			o:   &Options{Addr: "localhost:123", ConnMaxLifetime: time.Hour, ConnMaxLifetimeJitter: 6 * time.Minute},
-		}, {
-			// jitter > lifetime should be capped
-			url: "redis://localhost:123/?conn_max_lifetime=30m&conn_max_lifetime_jitter=1h",
-			o:   &Options{Addr: "localhost:123", ConnMaxLifetime: 30 * time.Minute, ConnMaxLifetimeJitter: 30 * time.Minute},
-		}, {
-			// jitter without lifetime should be capped to 0
-			url: "redis://localhost:123/?conn_max_lifetime_jitter=6m",
-			o:   &Options{Addr: "localhost:123", ConnMaxLifetimeJitter: 0},
 		}, {
 			url: "unix:///tmp/redis.sock",
 			o:   &Options{Addr: "/tmp/redis.sock"},
@@ -214,9 +203,6 @@ func comprareOptions(t *testing.T, actual, expected *Options) {
 	if actual.ConnMaxLifetime != expected.ConnMaxLifetime {
 		t.Errorf("ConnMaxLifetime: got %v, expected %v", actual.ConnMaxLifetime, expected.ConnMaxLifetime)
 	}
-	if actual.ConnMaxLifetimeJitter != expected.ConnMaxLifetimeJitter {
-		t.Errorf("ConnMaxLifetimeJitter: got %v, expected %v", actual.ConnMaxLifetimeJitter, expected.ConnMaxLifetimeJitter)
-	}
 	if actual.MaxConcurrentDials != expected.MaxConcurrentDials {
 		t.Errorf("MaxConcurrentDials: got %v, expected %v", actual.MaxConcurrentDials, expected.MaxConcurrentDials)
 	}
diff --git a/osscluster.go b/osscluster.go
index 1df04dda..6994ae83 100644
--- a/osscluster.go
+++ b/osscluster.go
@@ -102,9 +102,8 @@ type ClusterOptions struct {
 	MinIdleConns    int
 	MaxIdleConns    int
 	MaxActiveConns  int // applies per cluster node and not for the whole cluster
-	ConnMaxIdleTime       time.Duration
-	ConnMaxLifetime       time.Duration
-	ConnMaxLifetimeJitter time.Duration
+	ConnMaxIdleTime time.Duration
+	ConnMaxLifetime time.Duration
 
 	// ReadBufferSize is the size of the bufio.Reader buffer for each connection.
 	// Larger buffers can improve performance for commands that return large responses.
@@ -330,9 +329,6 @@ func setupClusterQueryParams(u *url.URL, o *ClusterOptions) (*ClusterOptions, er
 	o.MaxActiveConns = q.int("max_active_conns")
 	o.PoolTimeout = q.duration("pool_timeout")
 	o.ConnMaxLifetime = q.duration("conn_max_lifetime")
-	if q.has("conn_max_lifetime_jitter") {
-		o.ConnMaxLifetimeJitter = min(q.duration("conn_max_lifetime_jitter"), o.ConnMaxLifetime)
-	}
 	o.ConnMaxIdleTime = q.duration("conn_max_idle_time")
 	o.FailingTimeoutSeconds = q.int("failing_timeout_seconds")
 
@@ -396,7 +392,6 @@ func (opt *ClusterOptions) clientOptions() *Options {
 		MaxActiveConns:        opt.MaxActiveConns,
 		ConnMaxIdleTime:       opt.ConnMaxIdleTime,
 		ConnMaxLifetime:       opt.ConnMaxLifetime,
-		ConnMaxLifetimeJitter: opt.ConnMaxLifetimeJitter,
 		ReadBufferSize:        opt.ReadBufferSize,
 		WriteBufferSize:       opt.WriteBufferSize,
 		DisableIdentity:       opt.DisableIdentity,
diff --git a/ring.go b/ring.go
index 8aea4dcf..3381460a 100644
--- a/ring.go
+++ b/ring.go
@@ -121,9 +121,8 @@ type RingOptions struct {
 	MinIdleConns    int
 	MaxIdleConns    int
 	MaxActiveConns  int
-	ConnMaxIdleTime       time.Duration
-	ConnMaxLifetime       time.Duration
-	ConnMaxLifetimeJitter time.Duration
+	ConnMaxIdleTime time.Duration
+	ConnMaxLifetime time.Duration
 
 	// ReadBufferSize is the size of the bufio.Reader buffer for each connection.
 	// Larger buffers can improve performance for commands that return large responses.
@@ -230,10 +229,9 @@ func (opt *RingOptions) clientOptions() *Options {
 		MinIdleConns:    opt.MinIdleConns,
 		MaxIdleConns:    opt.MaxIdleConns,
 		MaxActiveConns:  opt.MaxActiveConns,
-		ConnMaxIdleTime:       opt.ConnMaxIdleTime,
-		ConnMaxLifetime:       opt.ConnMaxLifetime,
-		ConnMaxLifetimeJitter: opt.ConnMaxLifetimeJitter,
-		ReadBufferSize:        opt.ReadBufferSize,
+		ConnMaxIdleTime: opt.ConnMaxIdleTime,
+		ConnMaxLifetime: opt.ConnMaxLifetime,
+		ReadBufferSize:  opt.ReadBufferSize,
 		WriteBufferSize: opt.WriteBufferSize,
 
 		TLSConfig: opt.TLSConfig,
diff --git a/sentinel.go b/sentinel.go
index 44d46275..663f7b1a 100644
--- a/sentinel.go
+++ b/sentinel.go
@@ -115,9 +115,8 @@ type FailoverOptions struct {
 	MinIdleConns    int
 	MaxIdleConns    int
 	MaxActiveConns  int
-	ConnMaxIdleTime       time.Duration
-	ConnMaxLifetime       time.Duration
-	ConnMaxLifetimeJitter time.Duration
+	ConnMaxIdleTime time.Duration
+	ConnMaxLifetime time.Duration
 
 	TLSConfig *tls.Config
 
@@ -186,9 +185,8 @@ func (opt *FailoverOptions) clientOptions() *Options {
 		MinIdleConns:    opt.MinIdleConns,
 		MaxIdleConns:    opt.MaxIdleConns,
 		MaxActiveConns:  opt.MaxActiveConns,
-		ConnMaxIdleTime:       opt.ConnMaxIdleTime,
-		ConnMaxLifetime:       opt.ConnMaxLifetime,
-		ConnMaxLifetimeJitter: opt.ConnMaxLifetimeJitter,
+		ConnMaxIdleTime: opt.ConnMaxIdleTime,
+		ConnMaxLifetime: opt.ConnMaxLifetime,
 
 		TLSConfig: opt.TLSConfig,
 
@@ -235,9 +233,8 @@ func (opt *FailoverOptions) sentinelOptions(addr string) *Options {
 		MinIdleConns:    opt.MinIdleConns,
 		MaxIdleConns:    opt.MaxIdleConns,
 		MaxActiveConns:  opt.MaxActiveConns,
-		ConnMaxIdleTime:       opt.ConnMaxIdleTime,
-		ConnMaxLifetime:       opt.ConnMaxLifetime,
-		ConnMaxLifetimeJitter: opt.ConnMaxLifetimeJitter,
+		ConnMaxIdleTime: opt.ConnMaxIdleTime,
+		ConnMaxLifetime: opt.ConnMaxLifetime,
 
 		TLSConfig: opt.TLSConfig,
 
@@ -411,9 +408,6 @@ func setupFailoverConnParams(u *url.URL, o *FailoverOptions) (*FailoverOptions,
 	o.MaxIdleConns = q.int("max_idle_conns")
 	o.MaxActiveConns = q.int("max_active_conns")
 	o.ConnMaxLifetime = q.duration("conn_max_lifetime")
-	if q.has("conn_max_lifetime_jitter") {
-		o.ConnMaxLifetimeJitter = min(q.duration("conn_max_lifetime_jitter"), o.ConnMaxLifetime)
-	}
 	o.ConnMaxIdleTime = q.duration("conn_max_idle_time")
 	o.PoolTimeout = q.duration("pool_timeout")
 	o.DisableIdentity = q.bool("disableIdentity")
diff --git a/sentinel_test.go b/sentinel_test.go
index babca69f..c6217f6a 100644
--- a/sentinel_test.go
+++ b/sentinel_test.go
@@ -651,9 +651,6 @@ func compareFailoverOptions(t *testing.T, a, e *redis.FailoverOptions) {
 	if a.ConnMaxLifetime != e.ConnMaxLifetime {
 		t.Errorf("ConnMaxLifeTime got %v, want %v", a.ConnMaxLifetime, e.ConnMaxLifetime)
 	}
-	if a.ConnMaxLifetimeJitter != e.ConnMaxLifetimeJitter {
-		t.Errorf("ConnMaxLifetimeJitter got %v, want %v", a.ConnMaxLifetimeJitter, e.ConnMaxLifetimeJitter)
-	}
 	if a.DisableIdentity != e.DisableIdentity {
 		t.Errorf("DisableIdentity got %v, want %v", a.DisableIdentity, e.DisableIdentity)
 	}
diff --git a/universal.go b/universal.go
index c5951366..1dc9764d 100644
--- a/universal.go
+++ b/universal.go
@@ -84,9 +84,8 @@ type UniversalOptions struct {
 	MinIdleConns    int
 	MaxIdleConns    int
 	MaxActiveConns  int
-	ConnMaxIdleTime       time.Duration
-	ConnMaxLifetime       time.Duration
-	ConnMaxLifetimeJitter time.Duration
+	ConnMaxIdleTime time.Duration
+	ConnMaxLifetime time.Duration
 
 	TLSConfig *tls.Config
 
@@ -172,9 +171,8 @@ func (o *UniversalOptions) Cluster() *ClusterOptions {
 		MinIdleConns:    o.MinIdleConns,
 		MaxIdleConns:    o.MaxIdleConns,
 		MaxActiveConns:  o.MaxActiveConns,
-		ConnMaxIdleTime:       o.ConnMaxIdleTime,
-		ConnMaxLifetime:       o.ConnMaxLifetime,
-		ConnMaxLifetimeJitter: o.ConnMaxLifetimeJitter,
+		ConnMaxIdleTime: o.ConnMaxIdleTime,
+		ConnMaxLifetime: o.ConnMaxLifetime,
 
 		TLSConfig: o.TLSConfig,
 
@@ -233,9 +231,8 @@ func (o *UniversalOptions) Failover() *FailoverOptions {
 		MinIdleConns:    o.MinIdleConns,
 		MaxIdleConns:    o.MaxIdleConns,
 		MaxActiveConns:  o.MaxActiveConns,
-		ConnMaxIdleTime:       o.ConnMaxIdleTime,
-		ConnMaxLifetime:       o.ConnMaxLifetime,
-		ConnMaxLifetimeJitter: o.ConnMaxLifetimeJitter,
+		ConnMaxIdleTime: o.ConnMaxIdleTime,
+		ConnMaxLifetime: o.ConnMaxLifetime,
 
 		TLSConfig: o.TLSConfig,
 
