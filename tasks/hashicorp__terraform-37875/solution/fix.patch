diff --git a/internal/command/init_run_experiment.go b/internal/command/init_run_experiment.go
index 67525e80d1..34983553f6 100644
--- a/internal/command/init_run_experiment.go
+++ b/internal/command/init_run_experiment.go
@@ -378,7 +378,7 @@ func (c *InitCommand) initPssBackend(ctx context.Context, root *configs.Module,
 		return nil, true, diags
 	case root.StateStore != nil:
 		// state_store config present
-		factory, fDiags := c.Meta.GetStateStoreProviderFactory(root.StateStore, configLocks)
+		factory, fDiags := c.Meta.StateStoreProviderFactoryFromConfig(root.StateStore, configLocks)
 		diags = diags.Append(fDiags)
 		if fDiags.HasErrors() {
 			return nil, true, diags
@@ -439,7 +439,6 @@ func (c *InitCommand) initPssBackend(ctx context.Context, root *configs.Module,
 		opts = &BackendOpts{
 			StateStoreConfig:       root.StateStore,
 			Locks:                  configLocks,
-			ProviderFactory:        factory,
 			CreateDefaultWorkspace: initArgs.CreateDefaultWorkspace,
 			ConfigOverride:         configOverride,
 			Init:                   true,
@@ -492,6 +491,7 @@ func (c *InitCommand) initPssBackend(ctx context.Context, root *configs.Module,
 
 		opts = &BackendOpts{
 			BackendConfig:  backendConfig,
+			Locks:          configLocks,
 			ConfigOverride: configOverride,
 			Init:           true,
 			ViewType:       initArgs.ViewType,
@@ -526,6 +526,7 @@ the backend configuration is present and valid.
 
 		opts = &BackendOpts{
 			Init:     true,
+			Locks:    configLocks,
 			ViewType: initArgs.ViewType,
 		}
 	}
diff --git a/internal/command/meta_backend.go b/internal/command/meta_backend.go
index e3d3bd9de9..d8282bac98 100644
--- a/internal/command/meta_backend.go
+++ b/internal/command/meta_backend.go
@@ -60,18 +60,9 @@ type BackendOpts struct {
 	// the root module, or nil if no such block is present.
 	StateStoreConfig *configs.StateStore
 
-	// ProvidersFactory contains a factory for creating instances of the
-	// provider used for pluggable state storage. Each call created a new instance,
-	// so be conscious of when the provider needs to be configured, etc.
-	//
-	// This will only be set if the configuration contains a state_store block.
-	ProviderFactory providers.Factory
-
 	// Locks allows state-migration logic to detect when the provider used for pluggable state storage
 	// during the last init (i.e. what's in the backend state file) is mismatched with the provider
 	// version in use currently.
-	//
-	// This will only be set if the configuration contains a state_store block.
 	Locks *depsfile.Locks
 
 	// ConfigOverride is an hcl.Body that, if non-nil, will be used with
@@ -577,16 +568,13 @@ func (m *Meta) stateStoreConfig(opts *BackendOpts) (*configs.StateStore, int, tf
 		return nil, 0, diags
 	}
 
-	// Check - is the state store type in the config supported by the provider?
-	if opts.ProviderFactory == nil {
-		diags = diags.Append(&hcl.Diagnostic{
-			Severity: hcl.DiagError,
-			Summary:  "Missing provider details when configuring state store",
-			Detail:   "Terraform attempted to configure a state store and no provider factory was available to launch it. This is a bug in Terraform and should be reported.",
-		})
+	pFactory, pDiags := m.StateStoreProviderFactoryFromConfig(opts.StateStoreConfig, opts.Locks)
+	diags = diags.Append(pDiags)
+	if pDiags.HasErrors() {
 		return nil, 0, diags
 	}
-	provider, err := opts.ProviderFactory()
+
+	provider, err := pFactory()
 	if err != nil {
 		diags = diags.Append(fmt.Errorf("error when obtaining provider instance during state store initialization: %w", err))
 		return nil, 0, diags
@@ -781,11 +769,19 @@ func (m *Meta) backendFromConfig(opts *BackendOpts) (backend.Backend, tfdiags.Di
 			s.StateStore.Provider.Source.Type,
 			s.StateStore.Provider.Source,
 		)
-		return nil, diags.Append(&hcl.Diagnostic{
-			Severity: hcl.DiagError,
-			Summary:  "Not implemented yet",
-			Detail:   "Unsetting a state store is not implemented yet",
-		})
+
+		initReason := fmt.Sprintf("Unsetting the previously set state store %q", s.StateStore.Type)
+		if !opts.Init {
+			diags = diags.Append(errStateStoreInitDiag(initReason))
+			return nil, diags
+		}
+
+		if !m.migrateState {
+			diags = diags.Append(migrateOrReconfigStateStoreDiag)
+			return nil, diags
+		}
+
+		return m.stateStore_c_S(sMgr, opts.ViewType)
 
 	// Configuring a backend for the first time or -reconfigure flag was used
 	case backendConfig != nil && s.Backend.Empty() &&
@@ -941,7 +937,7 @@ func (m *Meta) backendFromConfig(opts *BackendOpts) (backend.Backend, tfdiags.Di
 		// AND we're not providing any overrides. An override can mean a change overriding an unchanged backend block (indicated by the hash value).
 		if (uint64(cHash) == s.StateStore.Hash) && (!opts.Init || opts.ConfigOverride == nil) {
 			log.Printf("[TRACE] Meta.Backend: using already-initialized, unchanged %q state_store configuration", stateStoreConfig.Type)
-			savedStateStore, sssDiags := m.savedStateStore(sMgr, opts.ProviderFactory)
+			savedStateStore, sssDiags := m.savedStateStore(sMgr)
 			diags = diags.Append(sssDiags)
 			// Verify that selected workspace exist. Otherwise prompt user to create one
 			if opts.Init && savedStateStore != nil {
@@ -1587,43 +1583,37 @@ func (m *Meta) backend(configPath string, viewType arguments.ViewType) (backendr
 		return nil, diags
 	}
 
+	locks, lDiags := m.lockedDependencies()
+	diags = diags.Append(lDiags)
+	if lDiags.HasErrors() {
+		return nil, diags
+	}
+
 	var opts *BackendOpts
 	switch {
 	case root.Backend != nil:
 		opts = &BackendOpts{
 			BackendConfig: root.Backend,
+			Locks:         locks,
 			ViewType:      viewType,
 		}
 	case root.CloudConfig != nil:
 		backendConfig := root.CloudConfig.ToBackendConfig()
 		opts = &BackendOpts{
 			BackendConfig: &backendConfig,
+			Locks:         locks,
 			ViewType:      viewType,
 		}
 	case root.StateStore != nil:
-		// In addition to config, use of a state_store requires
-		// provider factory and provider locks data
-		locks, lDiags := m.lockedDependencies()
-		diags = diags.Append(lDiags)
-		if lDiags.HasErrors() {
-			return nil, diags
-		}
-
-		factory, fDiags := m.GetStateStoreProviderFactory(root.StateStore, locks)
-		diags = diags.Append(fDiags)
-		if fDiags.HasErrors() {
-			return nil, diags
-		}
-
 		opts = &BackendOpts{
 			StateStoreConfig: root.StateStore,
-			ProviderFactory:  factory,
 			Locks:            locks,
 			ViewType:         viewType,
 		}
 	default:
 		// there is no config; defaults to local state storage
 		opts = &BackendOpts{
+			Locks:    locks,
 			ViewType: viewType,
 		}
 	}
@@ -1702,7 +1692,7 @@ func (m *Meta) stateStore_C_s(c *configs.StateStore, stateStoreHash int, backend
 	}
 
 	// Get the state store as an instance of backend.Backend
-	b, storeConfigVal, providerConfigVal, moreDiags := m.stateStoreInitFromConfig(c, opts.ProviderFactory)
+	b, storeConfigVal, providerConfigVal, moreDiags := m.stateStoreInitFromConfig(c, opts.Locks)
 	diags = diags.Append(moreDiags)
 	if diags.HasErrors() {
 		return nil, diags
@@ -1869,6 +1859,60 @@ func (m *Meta) stateStore_C_s(c *configs.StateStore, stateStoreHash int, backend
 	return b, diags
 }
 
+// Unconfiguring a state store (moving from state store => local).
+func (m *Meta) stateStore_c_S(ssSMgr *clistate.LocalState, viewType arguments.ViewType) (backend.Backend, tfdiags.Diagnostics) {
+	var diags tfdiags.Diagnostics
+
+	s := ssSMgr.State()
+	stateStoreType := s.StateStore.Type
+
+	m.Ui.Output(fmt.Sprintf(strings.TrimSpace(outputStateStoreMigrateLocal), stateStoreType))
+
+	// Grab a purely local backend to get the local state if it exists
+	localB, moreDiags := m.Backend(&BackendOpts{ForceLocal: true, Init: true})
+	diags = diags.Append(moreDiags)
+	if moreDiags.HasErrors() {
+		return nil, diags
+	}
+
+	// Initialize the configured state store
+	ss, moreDiags := m.savedStateStore(ssSMgr)
+	diags = diags.Append(moreDiags)
+	if moreDiags.HasErrors() {
+		return nil, diags
+	}
+
+	// Perform the migration
+	err := m.backendMigrateState(&backendMigrateOpts{
+		SourceType:      stateStoreType,
+		DestinationType: "local",
+		Source:          ss,
+		Destination:     localB,
+		ViewType:        viewType,
+	})
+	if err != nil {
+		diags = diags.Append(err)
+		return nil, diags
+	}
+
+	// Remove the stored metadata
+	s.StateStore = nil
+	if err := ssSMgr.WriteState(s); err != nil {
+		diags = diags.Append(errStateStoreClearSaved{err})
+		return nil, diags
+	}
+	if err := ssSMgr.PersistState(); err != nil {
+		diags = diags.Append(errStateStoreClearSaved{err})
+		return nil, diags
+	}
+
+	v := views.NewInit(viewType, m.View)
+	v.Output(views.InitMessageCode("state_store_unset"), stateStoreType)
+
+	// Return no state store
+	return nil, diags
+}
+
 // getStateStorageProviderVersion gets the current version of the state store provider that's in use. This is achieved
 // by inspecting the current locks.
 //
@@ -1939,7 +1983,7 @@ func (m *Meta) createDefaultWorkspace(c *configs.StateStore, b backend.Backend)
 }
 
 // Initializing a saved state store from the backend state file (aka 'cache file', aka 'legacy state file')
-func (m *Meta) savedStateStore(sMgr *clistate.LocalState, factory providers.Factory) (backend.Backend, tfdiags.Diagnostics) {
+func (m *Meta) savedStateStore(sMgr *clistate.LocalState) (backend.Backend, tfdiags.Diagnostics) {
 	// We're preparing a state_store version of backend.Backend.
 	//
 	// The provider and state store will be configured using the backend state file.
@@ -1947,14 +1991,14 @@ func (m *Meta) savedStateStore(sMgr *clistate.LocalState, factory providers.Fact
 	var diags tfdiags.Diagnostics
 	var b backend.Backend
 
-	if factory == nil {
-		diags = diags.Append(&hcl.Diagnostic{
-			Severity: hcl.DiagError,
-			Summary:  "Missing provider details when configuring state store",
-			Detail:   "Terraform attempted to configure a state store and no provider factory was available to launch it. This is a bug in Terraform and should be reported.",
-		})
+	s := sMgr.State()
+
+	factory, pDiags := m.StateStoreProviderFactoryFromConfigState(s.StateStore)
+	diags = diags.Append(pDiags)
+	if pDiags.HasErrors() {
 		return nil, diags
 	}
+
 	provider, err := factory()
 	if err != nil {
 		diags = diags.Append(fmt.Errorf("error when obtaining provider instance during state store initialization: %w", err))
@@ -1964,7 +2008,6 @@ func (m *Meta) savedStateStore(sMgr *clistate.LocalState, factory providers.Fact
 	// running provider instance inside the returned backend.Backend instance.
 	// Stopping the provider process is the responsibility of the calling code.
 
-	s := sMgr.State()
 	resp := provider.GetProviderSchema()
 
 	if len(resp.StateStores) == 0 {
@@ -2242,17 +2285,15 @@ func (m *Meta) backendInitFromConfig(c *configs.Backend) (backend.Backend, cty.V
 //
 // NOTE: the backend version of this method, `backendInitFromConfig`, prompts users for input if any required fields
 // are missing from the backend config. In `stateStoreInitFromConfig` we don't do this, and instead users will see an error.
-func (m *Meta) stateStoreInitFromConfig(c *configs.StateStore, factory providers.Factory) (backend.Backend, cty.Value, cty.Value, tfdiags.Diagnostics) {
+func (m *Meta) stateStoreInitFromConfig(c *configs.StateStore, locks *depsfile.Locks) (backend.Backend, cty.Value, cty.Value, tfdiags.Diagnostics) {
 	var diags tfdiags.Diagnostics
 
-	if factory == nil {
-		diags = diags.Append(&hcl.Diagnostic{
-			Severity: hcl.DiagError,
-			Summary:  "Missing provider details when configuring state store",
-			Detail:   "Terraform attempted to configure a state store and no provider factory was available to launch it. This is a bug in Terraform and should be reported.",
-		})
+	factory, pDiags := m.StateStoreProviderFactoryFromConfig(c, locks)
+	diags = diags.Append(pDiags)
+	if pDiags.HasErrors() {
 		return nil, cty.NilVal, cty.NilVal, diags
 	}
+
 	provider, err := factory()
 	if err != nil {
 		diags = diags.Append(fmt.Errorf("error when obtaining provider instance during state store initialization: %w", err))
@@ -2482,7 +2523,7 @@ func (m *Meta) assertSupportedCloudInitOptions(mode cloud.ConfigChangeMode) tfdi
 	return diags
 }
 
-func (m *Meta) GetStateStoreProviderFactory(config *configs.StateStore, locks *depsfile.Locks) (providers.Factory, tfdiags.Diagnostics) {
+func (m *Meta) StateStoreProviderFactoryFromConfig(config *configs.StateStore, locks *depsfile.Locks) (providers.Factory, tfdiags.Diagnostics) {
 	var diags tfdiags.Diagnostics
 
 	if config == nil || locks == nil {
@@ -2533,6 +2574,53 @@ func (m *Meta) GetStateStoreProviderFactory(config *configs.StateStore, locks *d
 	return factory, diags
 }
 
+func (m *Meta) StateStoreProviderFactoryFromConfigState(cfgState *workdir.StateStoreConfigState) (providers.Factory, tfdiags.Diagnostics) {
+	var diags tfdiags.Diagnostics
+
+	if cfgState == nil {
+		panic("nil config passed to StateStoreProviderFactoryFromConfigState")
+	}
+
+	if cfgState.Provider == nil || cfgState.Provider.Source.IsZero() {
+		// This should not happen; this data is populated when storing config state
+		return nil, diags.Append(&hcl.Diagnostic{
+			Severity: hcl.DiagError,
+			Summary:  "Unknown provider used for state storage",
+			Detail:   "Terraform could not find the provider used with the state_store. This is a bug in Terraform and should be reported.",
+		})
+	}
+
+	factories, err := m.ProviderFactories()
+	if err != nil {
+		// This may happen if the provider isn't present in the provider cache.
+		// This should be caught earlier by logic that diffs the config against the backend state file.
+		return nil, diags.Append(&hcl.Diagnostic{
+			Severity: hcl.DiagError,
+			Summary:  "Provider unavailable",
+			Detail: fmt.Sprintf("Terraform experienced an error when trying to use provider %s (%q) to initialize the %q state store: %s",
+				cfgState.Type,
+				cfgState.Provider.Source,
+				cfgState.Type,
+				err),
+		})
+	}
+
+	factory, exists := factories[*cfgState.Provider.Source]
+	if !exists {
+		return nil, diags.Append(&hcl.Diagnostic{
+			Severity: hcl.DiagError,
+			Summary:  "Provider unavailable",
+			Detail: fmt.Sprintf("The provider %s (%q) is required to initialize the %q state store, but the matching provider factory is missing. This is a bug in Terraform and should be reported.",
+				cfgState.Type,
+				cfgState.Provider.Source,
+				cfgState.Type,
+			),
+		})
+	}
+
+	return factory, diags
+}
+
 //-------------------------------------------------------------------
 // Output constants and initialization code
 //-------------------------------------------------------------------
@@ -2545,6 +2633,10 @@ const outputBackendMigrateLocal = `
 Terraform has detected you're unconfiguring your previously set %q backend.
 `
 
+const outputStateStoreMigrateLocal = `
+Terraform has detected you're unconfiguring your previously set %q state store.
+`
+
 const outputBackendReconfigure = `
 [reset][bold]Backend configuration changed![reset]
 
diff --git a/internal/command/meta_backend_errors.go b/internal/command/meta_backend_errors.go
index 65221f1a30..74314bf752 100644
--- a/internal/command/meta_backend_errors.go
+++ b/internal/command/meta_backend_errors.go
@@ -232,3 +232,29 @@ var migrateOrReconfigDiag = tfdiags.Sourceless(
 	"A change in the backend configuration has been detected, which may require migrating existing state.\n\n"+
 		"If you wish to attempt automatic migration of the state, use \"terraform init -migrate-state\".\n"+
 		`If you wish to store the current configuration with no changes to the state, use "terraform init -reconfigure".`)
+
+// migrateOrReconfigStateStoreDiag creates a diagnostic to present to users when
+// an init command encounters a mismatch in state store config state and the current config
+// and Terraform needs users to provide additional instructions about how it
+// should proceed.
+var migrateOrReconfigStateStoreDiag = tfdiags.Sourceless(
+	tfdiags.Error,
+	"State store configuration changed",
+	"A change in the state store configuration has been detected, which may require migrating existing state.\n\n"+
+		"If you wish to attempt automatic migration of the state, use \"terraform init -migrate-state\".\n"+
+		`If you wish to store the current configuration with no changes to the state, use "terraform init -reconfigure".`)
+
+// errStateStoreClearSaved is a custom error used to alert users that
+// Terraform failed to empty the state store state file's contents.
+type errStateStoreClearSaved struct {
+	innerError error
+}
+
+func (e *errStateStoreClearSaved) Error() string {
+	return fmt.Sprintf(`Error clearing the state store configuration: %s
+
+Terraform removes the saved state store configuration when you're removing a
+configured state store. This must be done so future Terraform runs know to not
+use the state store configuration. Please look at the error above, resolve it,
+and try again.`, e.innerError)
+}
diff --git a/internal/command/testdata/init-state-store/main.tf b/internal/command/testdata/init-state-store/main.tf
new file mode 100644
index 0000000000..9f39a46e77
--- /dev/null
+++ b/internal/command/testdata/init-state-store/main.tf
@@ -0,0 +1,6 @@
+terraform {
+  state_store "test_store" {
+    provider "test" {}
+    value = "foobar"
+  }
+}
diff --git a/internal/command/testdata/init-state-store/providers.tf b/internal/command/testdata/init-state-store/providers.tf
new file mode 100644
index 0000000000..a6475e1bcf
--- /dev/null
+++ b/internal/command/testdata/init-state-store/providers.tf
@@ -0,0 +1,7 @@
+terraform {
+  required_providers {
+    test = {
+      source = "hashicorp/test"
+    }
+  }
+}
diff --git a/internal/command/testdata/state-store-unset/.terraform.lock.hcl b/internal/command/testdata/state-store-unset/.terraform.lock.hcl
deleted file mode 100644
index e5c03757a7..0000000000
--- a/internal/command/testdata/state-store-unset/.terraform.lock.hcl
+++ /dev/null
@@ -1,6 +0,0 @@
-# This file is maintained automatically by "terraform init".
-# Manual edits may be lost in future updates.
-
-provider "registry.terraform.io/hashicorp/test" {
-  version = "1.2.3"
-}
diff --git a/internal/command/testdata/state-store-unset/.terraform/terraform.tfstate b/internal/command/testdata/state-store-unset/.terraform/terraform.tfstate
deleted file mode 100644
index b7e79f2497..0000000000
--- a/internal/command/testdata/state-store-unset/.terraform/terraform.tfstate
+++ /dev/null
@@ -1,19 +0,0 @@
-{
-    "version": 3,
-    "serial": 0,
-    "lineage": "666f9301-7e65-4b19-ae23-71184bb19b03",
-    "state_store": {
-        "type": "test_store",
-        "config": {
-            "value": "foobar"
-        },
-        "provider": {
-            "version": "1.2.3",
-            "source": "registry.terraform.io/hashicorp/test",
-            "config": {
-                "region": null
-            }
-        },
-        "hash": 0
-    }
-}
\ No newline at end of file
diff --git a/internal/command/views/init.go b/internal/command/views/init.go
index ab16c436b1..4a633ce69b 100644
--- a/internal/command/views/init.go
+++ b/internal/command/views/init.go
@@ -258,6 +258,10 @@ var MessageRegistry map[InitMessageCode]InitMessage = map[InitMessageCode]InitMe
 		HumanValue: errInitConfigError,
 		JSONValue:  errInitConfigErrorJSON,
 	},
+	"state_store_unset": {
+		HumanValue: "[reset][green]\n\nSuccessfully unset the state store %q. Terraform will now operate locally.",
+		JSONValue:  "Successfully unset the state store %q. Terraform will now operate locally.",
+	},
 	"empty_message": {
 		HumanValue: "",
 		JSONValue:  "",
