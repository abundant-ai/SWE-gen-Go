diff --git a/log/deprecated_levels/levels.go b/log/deprecated_levels/levels.go
new file mode 100644
index 0000000..da6b681
--- /dev/null
+++ b/log/deprecated_levels/levels.go
@@ -0,0 +1,127 @@
+package levels
+
+import "github.com/go-kit/kit/log"
+
+// Levels provides a leveled logging wrapper around a logger. It has five
+// levels: debug, info, warning (warn), error, and critical (crit). If you
+// want a different set of levels, you can create your own levels type very
+// easily, and you can elide the configuration.
+type Levels struct {
+	ctx      *log.Context
+	levelKey string
+
+	// We have a choice between storing level values in string fields or
+	// making a separate context for each level. When using string fields the
+	// Log method must combine the base context, the level data, and the
+	// logged keyvals; but the With method only requires updating one context.
+	// If we instead keep a separate context for each level the Log method
+	// must only append the new keyvals; but the With method would have to
+	// update all five contexts.
+
+	// Roughly speaking, storing multiple contexts breaks even if the ratio of
+	// Log/With calls is more than the number of levels. We have chosen to
+	// make the With method cheap and the Log method a bit more costly because
+	// we do not expect most applications to Log more than five times for each
+	// call to With.
+
+	debugValue string
+	infoValue  string
+	warnValue  string
+	errorValue string
+	critValue  string
+}
+
+// New creates a new leveled logger, wrapping the passed logger.
+func New(logger log.Logger, options ...Option) Levels {
+	l := Levels{
+		ctx:      log.NewContext(logger),
+		levelKey: "level",
+
+		debugValue: "debug",
+		infoValue:  "info",
+		warnValue:  "warn",
+		errorValue: "error",
+		critValue:  "crit",
+	}
+	for _, option := range options {
+		option(&l)
+	}
+	return l
+}
+
+// With returns a new leveled logger that includes keyvals in all log events.
+func (l Levels) With(keyvals ...interface{}) Levels {
+	return Levels{
+		ctx:        l.ctx.With(keyvals...),
+		levelKey:   l.levelKey,
+		debugValue: l.debugValue,
+		infoValue:  l.infoValue,
+		warnValue:  l.warnValue,
+		errorValue: l.errorValue,
+		critValue:  l.critValue,
+	}
+}
+
+// Debug returns a debug level logger.
+func (l Levels) Debug() log.Logger {
+	return l.ctx.WithPrefix(l.levelKey, l.debugValue)
+}
+
+// Info returns an info level logger.
+func (l Levels) Info() log.Logger {
+	return l.ctx.WithPrefix(l.levelKey, l.infoValue)
+}
+
+// Warn returns a warning level logger.
+func (l Levels) Warn() log.Logger {
+	return l.ctx.WithPrefix(l.levelKey, l.warnValue)
+}
+
+// Error returns an error level logger.
+func (l Levels) Error() log.Logger {
+	return l.ctx.WithPrefix(l.levelKey, l.errorValue)
+}
+
+// Crit returns a critical level logger.
+func (l Levels) Crit() log.Logger {
+	return l.ctx.WithPrefix(l.levelKey, l.critValue)
+}
+
+// Option sets a parameter for leveled loggers.
+type Option func(*Levels)
+
+// Key sets the key for the field used to indicate log level. By default,
+// the key is "level".
+func Key(key string) Option {
+	return func(l *Levels) { l.levelKey = key }
+}
+
+// DebugValue sets the value for the field used to indicate the debug log
+// level. By default, the value is "debug".
+func DebugValue(value string) Option {
+	return func(l *Levels) { l.debugValue = value }
+}
+
+// InfoValue sets the value for the field used to indicate the info log level.
+// By default, the value is "info".
+func InfoValue(value string) Option {
+	return func(l *Levels) { l.infoValue = value }
+}
+
+// WarnValue sets the value for the field used to indicate the warning log
+// level. By default, the value is "warn".
+func WarnValue(value string) Option {
+	return func(l *Levels) { l.warnValue = value }
+}
+
+// ErrorValue sets the value for the field used to indicate the error log
+// level. By default, the value is "error".
+func ErrorValue(value string) Option {
+	return func(l *Levels) { l.errorValue = value }
+}
+
+// CritValue sets the value for the field used to indicate the critical log
+// level. By default, the value is "crit".
+func CritValue(value string) Option {
+	return func(l *Levels) { l.critValue = value }
+}
diff --git a/log/level/doc.go b/log/level/doc.go
new file mode 100644
index 0000000..63a4469
--- /dev/null
+++ b/log/level/doc.go
@@ -0,0 +1,24 @@
+// Package level is an EXPERIMENTAL levelled logging package. The API will
+// definitely have breaking changes and may be deleted altogether. Be warned!
+//
+// To use the level package, create a logger as per normal in your func main,
+// and wrap it with level.NewFilter.
+//
+//    var logger log.Logger
+//    logger = log.NewLogfmtLogger(os.Stderr)
+//    logger = level.NewFilter(logger, level.AllowInfoAndAbove()) // <--
+//    logger = log.NewContext(logger).With("ts", log.DefaultTimestampUTC)
+//
+// Then, at the callsites, use one of the level.Debug, Info, Warn, or Error
+// helper methods to emit leveled log events.
+//
+//    logger.Log("foo", "bar") // as normal, no level
+//    level.Debug(logger).Log("request_id", reqID, "trace_data", trace.Get())
+//    if value > 100 {
+//        level.Error(logger).Log("value", value)
+//    }
+//
+// NewFilter allows precise control over what happens when a log event is
+// emitted without a level key, or if a squelched level is used. Check the
+// Option functions for details.
+package level
diff --git a/log/level/level.go b/log/level/level.go
new file mode 100644
index 0000000..9120e61
--- /dev/null
+++ b/log/level/level.go
@@ -0,0 +1,205 @@
+package level
+
+import "github.com/go-kit/kit/log"
+
+// Error returns a logger that includes a Key/ErrorValue pair.
+func Error(logger log.Logger) log.Logger {
+	return log.NewContext(logger).WithPrefix(Key(), ErrorValue())
+}
+
+// Warn returns a logger that includes a Key/WarnValue pair.
+func Warn(logger log.Logger) log.Logger {
+	return log.NewContext(logger).WithPrefix(Key(), WarnValue())
+}
+
+// Info returns a logger that includes a Key/InfoValue pair.
+func Info(logger log.Logger) log.Logger {
+	return log.NewContext(logger).WithPrefix(Key(), InfoValue())
+}
+
+// Debug returns a logger that includes a Key/DebugValue pair.
+func Debug(logger log.Logger) log.Logger {
+	return log.NewContext(logger).WithPrefix(Key(), DebugValue())
+}
+
+// NewFilter wraps next and implements level filtering. See the commentary on
+// the Option functions for a detailed description of how to configure levels.
+// If no options are provided, all leveled log events created with Debug,
+// Info, Warn or Error helper methods are squelched and non-leveled log
+// events are passed to next unmodified.
+func NewFilter(next log.Logger, options ...Option) log.Logger {
+	l := &logger{
+		next: next,
+	}
+	for _, option := range options {
+		option(l)
+	}
+	return l
+}
+
+type logger struct {
+	next           log.Logger
+	allowed        level
+	squelchNoLevel bool
+	errNotAllowed  error
+	errNoLevel     error
+}
+
+func (l *logger) Log(keyvals ...interface{}) error {
+	var hasLevel, levelAllowed bool
+	for i := 1; i < len(keyvals); i += 2 {
+		if v, ok := keyvals[i].(*levelValue); ok {
+			hasLevel = true
+			levelAllowed = l.allowed&v.level != 0
+			break
+		}
+	}
+	if !hasLevel && l.squelchNoLevel {
+		return l.errNoLevel
+	}
+	if hasLevel && !levelAllowed {
+		return l.errNotAllowed
+	}
+	return l.next.Log(keyvals...)
+}
+
+// Option sets a parameter for the leveled logger.
+type Option func(*logger)
+
+// AllowAll is an alias for AllowDebug.
+func AllowAll() Option {
+	return AllowDebug()
+}
+
+// AllowDebug allows error, warn, info and debug level log events to pass.
+func AllowDebug() Option {
+	return allowed(levelError | levelWarn | levelInfo | levelDebug)
+}
+
+// AllowInfo allows error, warn and info level log events to pass.
+func AllowInfo() Option {
+	return allowed(levelError | levelWarn | levelInfo)
+}
+
+// AllowWarn allows error and warn level log events to pass.
+func AllowWarn() Option {
+	return allowed(levelError | levelWarn)
+}
+
+// AllowError allows only error level log events to pass.
+func AllowError() Option {
+	return allowed(levelError)
+}
+
+// AllowNone allows no leveled log events to pass.
+func AllowNone() Option {
+	return allowed(0)
+}
+
+func allowed(allowed level) Option {
+	return func(l *logger) { l.allowed = allowed }
+}
+
+// ErrNotAllowed sets the error to return from Log when it squelches a log
+// event disallowed by the configured Allow[Level] option. By default,
+// ErrNotAllowed is nil; in this case the log event is squelched with no
+// error.
+func ErrNotAllowed(err error) Option {
+	return func(l *logger) { l.errNotAllowed = err }
+}
+
+// SquelchNoLevel instructs Log to squelch log events with no level, so that
+// they don't proceed through to the wrapped logger. If SquelchNoLevel is set
+// to true and a log event is squelched in this way, the error value
+// configured with ErrNoLevel is returned to the caller.
+func SquelchNoLevel(squelch bool) Option {
+	return func(l *logger) { l.squelchNoLevel = squelch }
+}
+
+// ErrNoLevel sets the error to return from Log when it squelches a log event
+// with no level. By default, ErrNoLevel is nil; in this case the log event is
+// squelched with no error.
+func ErrNoLevel(err error) Option {
+	return func(l *logger) { l.errNoLevel = err }
+}
+
+// NewInjector wraps next and returns a logger that adds a Key/level pair to
+// the beginning of log events that don't already contain a level. In effect,
+// this gives a default level to logs without a level.
+func NewInjector(next log.Logger, level Value) log.Logger {
+	return &injector{
+		next:  next,
+		level: level,
+	}
+}
+
+type injector struct {
+	next  log.Logger
+	level interface{}
+}
+
+func (l *injector) Log(keyvals ...interface{}) error {
+	for i := 1; i < len(keyvals); i += 2 {
+		if _, ok := keyvals[i].(*levelValue); ok {
+			return l.next.Log(keyvals...)
+		}
+	}
+	kvs := make([]interface{}, len(keyvals)+2)
+	kvs[0], kvs[1] = key, l.level
+	copy(kvs[2:], keyvals)
+	return l.next.Log(kvs...)
+}
+
+// Value is the interface that each of the canonical level values implement.
+// It contains unexported methods that prevent types from other packages from
+// implementing it and guaranteeing that NewFilter can distinguish the levels
+// defined in this package from all other values.
+type Value interface {
+	String() string
+	levelVal()
+}
+
+// Key returns the unique key added to log events by the loggers in this
+// package.
+func Key() interface{} { return key }
+
+// ErrorValue returns the unique value added to log events by Error.
+func ErrorValue() Value { return errorValue }
+
+// WarnValue returns the unique value added to log events by Warn.
+func WarnValue() Value { return warnValue }
+
+// InfoValue returns the unique value added to log events by Info.
+func InfoValue() Value { return infoValue }
+
+// DebugValue returns the unique value added to log events by Warn.
+func DebugValue() Value { return debugValue }
+
+var (
+	// key is of type interfae{} so that it allocates once during package
+	// initialization and avoids allocating every type the value is added to a
+	// []interface{} later.
+	key interface{} = "level"
+
+	errorValue = &levelValue{level: levelError, name: "error"}
+	warnValue  = &levelValue{level: levelWarn, name: "warn"}
+	infoValue  = &levelValue{level: levelInfo, name: "info"}
+	debugValue = &levelValue{level: levelDebug, name: "debug"}
+)
+
+type level byte
+
+const (
+	levelDebug level = 1 << iota
+	levelInfo
+	levelWarn
+	levelError
+)
+
+type levelValue struct {
+	name string
+	level
+}
+
+func (v *levelValue) String() string { return v.name }
+func (v *levelValue) levelVal()      {}
