diff --git a/bash_completions.go b/bash_completions.go
index fd8060f..54933b0 100644
--- a/bash_completions.go
+++ b/bash_completions.go
@@ -123,10 +123,6 @@ __handle_reply()
     fi
     COMPREPLY=( $(compgen -W "${completions[*]}" -- "$cur") )
 
-    if [[ ${#COMPREPLY[@]} -eq 0 && ${#noun_aliases[@]} -gt 0 && ${#must_have_one_noun[@]} -ne 0 ]]; then
-        COMPREPLY=( $(compgen -W "${noun_aliases[*]}" -- "$cur") )
-    fi
-
     if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
         declare -F __custom_func >/dev/null && __custom_func
     fi
@@ -193,7 +189,7 @@ __handle_noun()
 
     if __contains_word "${words[c]}" "${must_have_one_noun[@]}"; then
         must_have_one_noun=()
-    elif __contains_word "${words[c]}" "${noun_aliases[@]}"; then
+    elif __contains_word "${words[c]%s}" "${must_have_one_noun[@]}"; then
         must_have_one_noun=()
     fi
 
@@ -464,7 +460,7 @@ func writeRequiredFlag(cmd *Command, w io.Writer) error {
 	return visitErr
 }
 
-func writeRequiredNouns(cmd *Command, w io.Writer) error {
+func writeRequiredNoun(cmd *Command, w io.Writer) error {
 	if _, err := fmt.Fprintf(w, "    must_have_one_noun=()\n"); err != nil {
 		return err
 	}
@@ -477,19 +473,6 @@ func writeRequiredNouns(cmd *Command, w io.Writer) error {
 	return nil
 }
 
-func writeArgAliases(cmd *Command, w io.Writer) error {
-	if _, err := fmt.Fprintf(w, "    noun_aliases=()\n"); err != nil {
-		return err
-	}
-	sort.Sort(sort.StringSlice(cmd.ArgAliases))
-	for _, value := range cmd.ArgAliases {
-		if _, err := fmt.Fprintf(w, "    noun_aliases+=(%q)\n", value); err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
 func gen(cmd *Command, w io.Writer) error {
 	for _, c := range cmd.Commands() {
 		if !c.IsAvailableCommand() || c == cmd.helpCommand {
@@ -517,10 +500,7 @@ func gen(cmd *Command, w io.Writer) error {
 	if err := writeRequiredFlag(cmd, w); err != nil {
 		return err
 	}
-	if err := writeRequiredNouns(cmd, w); err != nil {
-		return err
-	}
-	if err := writeArgAliases(cmd, w); err != nil {
+	if err := writeRequiredNoun(cmd, w); err != nil {
 		return err
 	}
 	if _, err := fmt.Fprintf(w, "}\n\n"); err != nil {
diff --git a/bash_completions.md b/bash_completions.md
index 84d5b01..691b1b7 100644
--- a/bash_completions.md
+++ b/bash_completions.md
@@ -80,7 +80,7 @@ The `BashCompletionFunction` option is really only valid/useful on the root comm
 In the above example "pod" was assumed to already be typed. But if you want `kubectl get [tab][tab]` to show a list of valid "nouns" you have to set them. Simplified code from `kubectl get` looks like:
 
 ```go
-validArgs []string = { "pod", "node", "service", "replicationcontroller" }
+validArgs []string = { "pods", "nodes", "services", "replicationControllers" }
 
 cmd := &cobra.Command{
 	Use:     "get [(-o|--output=)json|yaml|template|...] (RESOURCE [NAME] | RESOURCE/NAME ...)",
@@ -99,34 +99,9 @@ Notice we put the "ValidArgs" on the "get" subcommand. Doing so will give result
 
 ```bash
 # kubectl get [tab][tab]
-node                 pod                    replicationcontroller  service
+nodes                 pods                    replicationControllers  services
 ```
 
-## Plural form and shortcuts for nouns
-
-If your nouns have a number of aliases, you can define them alongside `ValidArgs` using `ArgAliases`:
-
-```go`
-argAliases []string = { "pods", "nodes", "services", "svc", "replicationcontrollers", "rc" }
-
-cmd := &cobra.Command{
-    ...
-	ValidArgs:  validArgs,
-	ArgAliases: argAliases
-}
-```
-
-The aliases are not shown to the user on tab completion, but they are accepted as valid nouns by
-the completion aglorithm if entered manually, e.g. in:
-
-```bash
-# kubectl get rc [tab][tab]
-backend        frontend       database 
-```
-
-Note that without declaring `rc` as an alias, the completion algorithm would show the list of nouns
-in this example again instead of the replication controllers.
-
 ## Mark flags as required
 
 Most of the time completions will only show subcommands. But if a flag is required to make a subcommand work, you probably want it to show up when the user types [tab][tab].  Marking a flag as 'Required' is incredibly easy.
diff --git a/bash_completions_test.go b/bash_completions_test.go
index fd0958c..cf2661c 100644
--- a/bash_completions_test.go
+++ b/bash_completions_test.go
@@ -43,13 +43,9 @@ func TestBashCompletions(t *testing.T) {
 	c.MarkFlagRequired("introot")
 
 	// valid nouns
-	validArgs := []string{"pod", "node", "service", "replicationcontroller"}
+	validArgs := []string{"pods", "nodes", "services", "replicationControllers"}
 	c.ValidArgs = validArgs
 
-	// noun aliases
-	argAliases := []string{"pods", "nodes", "services", "replicationcontrollers", "po", "no", "svc", "rc"}
-	c.ArgAliases = argAliases
-
 	// filename
 	var flagval string
 	c.Flags().StringVar(&flagval, "filename", "", "Enter a filename")
@@ -92,11 +88,7 @@ func TestBashCompletions(t *testing.T) {
 	// check for custom completion function
 	check(t, str, `COMPREPLY=( "hello" )`)
 	// check for required nouns
-	check(t, str, `must_have_one_noun+=("pod")`)
-	// check for noun aliases
-	check(t, str, `noun_aliases+=("pods")`)
-	check(t, str, `noun_aliases+=("rc")`)
-	checkOmit(t, str, `must_have_one_noun+=("pods")`)
+	check(t, str, `must_have_one_noun+=("pods")`)
 	// check for filename extension flags
 	check(t, str, `flags_completion+=("_filedir")`)
 	// check for filename extension flags
diff --git a/command.go b/command.go
index 3be395e..7671ce5 100644
--- a/command.go
+++ b/command.go
@@ -45,11 +45,8 @@ type Command struct {
 	Long string
 	// Examples of how to use the command
 	Example string
-	// List of all valid non-flag arguments that are accepted in bash completions
+	// List of all valid non-flag arguments, used for bash completions *TODO* actually validate these
 	ValidArgs []string
-	// List of aliases for ValidArgs. These are not suggested to the user in the bash
-	// completion, but accepted if entered manually.
-	ArgAliases []string
 	// Custom functions used by the bash autocompletion generator
 	BashCompletionFunction string
 	// Is this command deprecated and should print this string when used?
