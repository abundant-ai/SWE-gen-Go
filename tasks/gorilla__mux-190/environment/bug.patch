diff --git a/mux.go b/mux.go
index d66ec38..3263a00 100644
--- a/mux.go
+++ b/mux.go
@@ -53,8 +53,6 @@ type Router struct {
 	// This has no effect when go1.7+ is used, since the context is stored
 	// on the request itself.
 	KeepContext bool
-	// see Router.UseEncodedPath(). This defines a flag for all routes.
-	useEncodedPath bool
 }
 
 // Match matches registered routes against the request.
@@ -79,10 +77,7 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 // mux.Vars(request).
 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	if !r.skipClean {
-		path := req.URL.Path
-		if r.useEncodedPath {
-			path = getPath(req)
-		}
+		path := getPath(req)
 		// Clean path to canonical form and redirect.
 		if p := cleanPath(path); p != path {
 
@@ -157,21 +152,6 @@ func (r *Router) SkipClean(value bool) *Router {
 	return r
 }
 
-// UseEncodedPath tells the router to match the encoded original path
-// to the routes.
-// For eg. "/path/foo%2Fbar/to" will match the path "/path/{var}/to".
-// This behavior has the drawback of needing to match routes against
-// r.RequestURI instead of r.URL.Path. Any modifications (such as http.StripPrefix)
-// to r.URL.Path will not affect routing when this flag is on and thus may
-// induce unintended behavior.
-//
-// If not called, the router will match the unencoded path to the routes.
-// For eg. "/path/foo%2Fbar/to" will match the path "/path/foo/bar/to"
-func (r *Router) UseEncodedPath() *Router {
-	r.useEncodedPath = true
-	return r
-}
-
 // ----------------------------------------------------------------------------
 // parentRoute
 // ----------------------------------------------------------------------------
@@ -209,7 +189,7 @@ func (r *Router) buildVars(m map[string]string) map[string]string {
 
 // NewRoute registers an empty route.
 func (r *Router) NewRoute() *Route {
-	route := &Route{parent: r, strictSlash: r.strictSlash, skipClean: r.skipClean, useEncodedPath: r.useEncodedPath}
+	route := &Route{parent: r, strictSlash: r.strictSlash, skipClean: r.skipClean}
 	r.routes = append(r.routes, route)
 	return route
 }
diff --git a/mux_test.go b/mux_test.go
index 39a099c..c540e4d 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -335,6 +335,16 @@ func TestPath(t *testing.T) {
 			pathTemplate: `/111/{v1:[0-9]{3}}/333`,
 			shouldMatch:  false,
 		},
+		{
+			title:        "Path route, URL with encoded slash does match",
+			route:        new(Route).Path("/v1/{v1}/v2"),
+			request:      newRequest("GET", "http://localhost/v1/1%2F2/v2"),
+			vars:         map[string]string{"v1": "1%2F2"},
+			host:         "",
+			path:         "/v1/1%2F2/v2",
+			pathTemplate: `/v1/{v1}/v2`,
+			shouldMatch:  true,
+		},
 		{
 			title:        "Path route with multiple patterns, match",
 			route:        new(Route).Path("/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}"),
@@ -420,7 +430,6 @@ func TestPath(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -498,7 +507,6 @@ func TestPathPrefix(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -575,7 +583,6 @@ func TestHostPath(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -902,7 +909,6 @@ func TestQueries(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -1062,7 +1068,6 @@ func TestSubRouter(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -1156,40 +1161,6 @@ func TestStrictSlash(t *testing.T) {
 		},
 	}
 
-	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
-	}
-}
-
-func TestUseEncodedPath(t *testing.T) {
-	r := NewRouter()
-	r.UseEncodedPath()
-
-	tests := []routeTest{
-		{
-			title:        "Router with useEncodedPath, URL with encoded slash does match",
-			route:        r.NewRoute().Path("/v1/{v1}/v2"),
-			request:      newRequest("GET", "http://localhost/v1/1%2F2/v2"),
-			vars:         map[string]string{"v1": "1%2F2"},
-			host:         "",
-			path:         "/v1/1%2F2/v2",
-			pathTemplate: `/v1/{v1}/v2`,
-			shouldMatch:  true,
-		},
-		{
-			title:        "Router with useEncodedPath, URL with encoded slash doesn't match",
-			route:        r.NewRoute().Path("/v1/1/2/v2"),
-			request:      newRequest("GET", "http://localhost/v1/1%2F2/v2"),
-			vars:         map[string]string{"v1": "1%2F2"},
-			host:         "",
-			path:         "/v1/1%2F2/v2",
-			pathTemplate: `/v1/1/2/v2`,
-			shouldMatch:  false,
-		},
-	}
-
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
@@ -1404,11 +1375,6 @@ func testRoute(t *testing.T, test routeTest) {
 	}
 }
 
-func testUseEscapedRoute(t *testing.T, test routeTest) {
-	test.route.useEncodedPath = true
-	testRoute(t, test)
-}
-
 func testTemplate(t *testing.T, test routeTest) {
 	route := test.route
 	pathTemplate := test.pathTemplate
diff --git a/old_test.go b/old_test.go
index 9bdc5e5..c385a25 100644
--- a/old_test.go
+++ b/old_test.go
@@ -687,7 +687,7 @@ func TestNewRegexp(t *testing.T) {
 	}
 
 	for pattern, paths := range tests {
-		p, _ = newRouteRegexp(pattern, false, false, false, false, false)
+		p, _ = newRouteRegexp(pattern, false, false, false, false)
 		for path, result := range paths {
 			matches = p.regexp.FindStringSubmatch(path)
 			if result == nil {
diff --git a/regexp.go b/regexp.go
index fd8fe39..f645332 100644
--- a/regexp.go
+++ b/regexp.go
@@ -24,7 +24,7 @@ import (
 // Previously we accepted only Python-like identifiers for variable
 // names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that
 // name and pattern can't be empty, and names can't contain a colon.
-func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash, useEncodedPath bool) (*routeRegexp, error) {
+func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash bool) (*routeRegexp, error) {
 	// Check if it is well-formed.
 	idxs, errBraces := braceIndices(tpl)
 	if errBraces != nil {
@@ -111,15 +111,14 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash,
 	}
 	// Done!
 	return &routeRegexp{
-		template:       template,
-		matchHost:      matchHost,
-		matchQuery:     matchQuery,
-		strictSlash:    strictSlash,
-		useEncodedPath: useEncodedPath,
-		regexp:         reg,
-		reverse:        reverse.String(),
-		varsN:          varsN,
-		varsR:          varsR,
+		template:    template,
+		matchHost:   matchHost,
+		matchQuery:  matchQuery,
+		strictSlash: strictSlash,
+		regexp:      reg,
+		reverse:     reverse.String(),
+		varsN:       varsN,
+		varsR:       varsR,
 	}, nil
 }
 
@@ -134,9 +133,6 @@ type routeRegexp struct {
 	matchQuery bool
 	// The strictSlash value defined on the route, but disabled if PathPrefix was used.
 	strictSlash bool
-	// Determines whether to use encoded path from getPath function or unencoded
-	// req.URL.Path for path matching
-	useEncodedPath bool
 	// Expanded regexp.
 	regexp *regexp.Regexp
 	// Reverse template.
@@ -153,10 +149,7 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 		if r.matchQuery {
 			return r.matchQueryString(req)
 		}
-		path := req.URL.Path
-		if r.useEncodedPath {
-			path = getPath(req)
-		}
+		path := getPath(req)
 		return r.regexp.MatchString(path)
 	}
 
@@ -260,10 +253,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
-	path := req.URL.Path
-	if r.useEncodedPath {
-		path = getPath(req)
-	}
+	path := getPath(req)
 	// Store path variables.
 	if v.path != nil {
 		matches := v.path.regexp.FindStringSubmatchIndex(path)
diff --git a/route.go b/route.go
index 293b6d4..6c53f9f 100644
--- a/route.go
+++ b/route.go
@@ -29,8 +29,6 @@ type Route struct {
 	// If true, when the path pattern is "/path//to", accessing "/path//to"
 	// will not redirect
 	skipClean bool
-	// If true, "/path/foo%2Fbar/to" will match the path "/path/{var}/to"
-	useEncodedPath bool
 	// If true, this route never matches: it is only used to build URLs.
 	buildOnly bool
 	// The name used to build URLs.
@@ -160,7 +158,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 			tpl = strings.TrimRight(r.regexp.path.template, "/") + tpl
 		}
 	}
-	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, matchQuery, r.strictSlash, r.useEncodedPath)
+	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, matchQuery, r.strictSlash)
 	if err != nil {
 		return err
 	}
