diff --git a/schema/relationship.go b/schema/relationship.go
index 5699ec5..84556ba 100644
--- a/schema/relationship.go
+++ b/schema/relationship.go
@@ -7,6 +7,7 @@ import (
 
 	"github.com/jinzhu/inflection"
 	"gorm.io/gorm/clause"
+	"gorm.io/gorm/utils"
 )
 
 // RelationshipType relationship type
@@ -77,8 +78,6 @@ func (schema *Schema) parseRelation(field *Field) *Relationship {
 		schema.buildPolymorphicRelation(relation, field, polymorphic)
 	} else if many2many := field.TagSettings["MANY2MANY"]; many2many != "" {
 		schema.buildMany2ManyRelation(relation, field, many2many)
-	} else if belongsTo := field.TagSettings["BELONGSTO"]; belongsTo != "" {
-		schema.guessRelation(relation, field, guessBelongs)
 	} else {
 		switch field.IndirectFieldType.Kind() {
 		case reflect.Struct:
@@ -406,11 +405,14 @@ func (schema *Schema) guessRelation(relation *Relationship, field *Field, cgl gu
 
 	if len(relation.foreignKeys) > 0 {
 		for _, foreignKey := range relation.foreignKeys {
-			if f := foreignSchema.LookUpField(foreignKey); f != nil {
-				foreignFields = append(foreignFields, f)
-			} else {
+			ff := foreignSchema.LookUpField(foreignKey)
+			pf := primarySchema.LookUpField(foreignKey)
+			isKeySame := utils.ExistsIn(foreignKey, &relation.primaryKeys)
+			if ff == nil || (pf != nil && ff != nil && schema == primarySchema && primarySchema != foreignSchema && !isKeySame && field.IndirectFieldType.Kind() == reflect.Struct) {
 				reguessOrErr()
 				return
+			} else {
+				foreignFields = append(foreignFields, ff)
 			}
 		}
 	} else {
diff --git a/schema/relationship_test.go b/schema/relationship_test.go
index cb616fc..d0ffc28 100644
--- a/schema/relationship_test.go
+++ b/schema/relationship_test.go
@@ -144,25 +144,6 @@ func TestHasOneOverrideReferences(t *testing.T) {
 	})
 }
 
-func TestHasOneOverrideReferences2(t *testing.T) {
-
-	type Profile struct {
-		gorm.Model
-		Name string
-	}
-
-	type User struct {
-		gorm.Model
-		ProfileID uint     `gorm:"column:profile_id"`
-		Profile   *Profile `gorm:"foreignKey:ID;references:ProfileID"`
-	}
-
-	checkStructRelation(t, &User{}, Relation{
-		Name: "Profile", Type: schema.HasOne, Schema: "User", FieldSchema: "Profile",
-		References: []Reference{{"ProfileID", "User", "ID", "Profile", "", true}},
-	})
-}
-
 func TestHasOneWithOnlyReferences(t *testing.T) {
 	type Profile struct {
 		gorm.Model
@@ -502,47 +483,22 @@ func TestSameForeignKey(t *testing.T) {
 	)
 }
 
-func TestBelongsToSameForeignKey(t *testing.T) {
-
-	type User struct {
-		gorm.Model
-		Name string
-		UUID string
-	}
-
-	type UserAux struct {
-		gorm.Model
-		Aux  string
-		UUID string
-		User User `gorm:"ForeignKey:UUID;references:UUID;belongsTo"`
-	}
-
-	checkStructRelation(t, &UserAux{},
-		Relation{
-			Name: "User", Type: schema.BelongsTo, Schema: "UserAux", FieldSchema: "User",
-			References: []Reference{
-				{"UUID", "User", "UUID", "UserAux", "", false},
-			},
-		},
-	)
-}
-
-func TestHasOneWithSameForeignKey(t *testing.T) {
+func TestBelongsToWithSameForeignKey(t *testing.T) {
 	type Profile struct {
 		gorm.Model
 		Name         string
-		ProfileRefer int // not used in relationship
+		ProfileRefer int
 	}
 
 	type User struct {
 		gorm.Model
-		Profile      Profile `gorm:"ForeignKey:ID;references:ProfileRefer"`
+		Profile      Profile `gorm:"ForeignKey:ProfileRefer"`
 		ProfileRefer int
 	}
 
 	checkStructRelation(t, &User{}, Relation{
-		Name: "Profile", Type: schema.HasOne, Schema: "User", FieldSchema: "Profile",
-		References: []Reference{{"ProfileRefer", "User", "ID", "Profile", "", true}},
+		Name: "Profile", Type: schema.BelongsTo, Schema: "User", FieldSchema: "Profile",
+		References: []Reference{{"ID", "Profile", "ProfileRefer", "User", "", false}},
 	})
 }
 
diff --git a/utils/utils.go b/utils/utils.go
index 9c238ac..1110c7a 100644
--- a/utils/utils.go
+++ b/utils/utils.go
@@ -114,3 +114,15 @@ func ToString(value interface{}) string {
 	}
 	return ""
 }
+
+func ExistsIn(a string, list *[]string) bool {
+	if list == nil {
+		return false
+	}
+	for _, b := range *list {
+		if b == a {
+			return true
+		}
+	}
+	return false
+}
