diff --git a/internal/command/arguments/extended.go b/internal/command/arguments/extended.go
index 0c05e8f0e4..26a0204767 100644
--- a/internal/command/arguments/extended.go
+++ b/internal/command/arguments/extended.go
@@ -238,6 +238,15 @@ func (o *Operation) Parse() tfdiags.Diagnostics {
 		}
 	}
 
+	if !o.Refresh && len(o.ActionTargets) > 0 {
+		// TODO: Check this? Can we trigger actions without refreshing?
+		diags = diags.Append(tfdiags.Sourceless(
+			tfdiags.Error,
+			"Incompatible refresh options",
+			"Action invocations will always refresh the relevant resources before execution.",
+		))
+	}
+
 	return diags
 }
 
diff --git a/internal/terraform/context_apply_action_test.go b/internal/terraform/context_apply_action_test.go
index 0423689de0..74c098d3c6 100644
--- a/internal/terraform/context_apply_action_test.go
+++ b/internal/terraform/context_apply_action_test.go
@@ -1573,56 +1573,6 @@ action "act_unlinked" "one" {
 			}),
 		},
 
-		"invoke action with reference (drift, skip refresh)": {
-			module: map[string]string{
-				"main.tf": `
-resource "test_object" "a" {
-  name = "hello"
-}
-
-action "act_unlinked" "one" {
-  config {
-    attr = test_object.a.name
-  }
-}
-`,
-			},
-			planOpts: &PlanOpts{
-				Mode:        plans.RefreshOnlyMode,
-				SkipRefresh: true,
-				ActionTargets: []addrs.Targetable{
-					addrs.AbsAction{
-						Action: addrs.Action{
-							Type: "act_unlinked",
-							Name: "one",
-						},
-					},
-				},
-			},
-			expectInvokeActionCalled: true,
-			expectInvokeActionCalls: []providers.InvokeActionRequest{
-				{
-					ActionType: "act_unlinked",
-					PlannedActionData: cty.ObjectVal(map[string]cty.Value{
-						"attr": cty.StringVal("hello"),
-					}),
-				},
-			},
-			readResourceFn: func(t *testing.T, request providers.ReadResourceRequest) providers.ReadResourceResponse {
-				return providers.ReadResourceResponse{
-					NewState: cty.ObjectVal(map[string]cty.Value{
-						"name": cty.StringVal("drifted value"),
-					}),
-				}
-			},
-			prevRunState: states.BuildState(func(state *states.SyncState) {
-				state.SetResourceInstanceCurrent(mustResourceInstanceAddr("test_object.a"), &states.ResourceInstanceObjectSrc{
-					AttrsJSON: []byte(`{"name":"hello"}`),
-					Status:    states.ObjectReady,
-				}, mustProviderConfig(`provider["registry.terraform.io/hashicorp/test"]`))
-			}),
-		},
-
 		"nested action config single + list blocks applies": {
 			module: map[string]string{
 				"main.tf": `
diff --git a/internal/terraform/context_plan.go b/internal/terraform/context_plan.go
index cf1ea9a196..8216199e54 100644
--- a/internal/terraform/context_plan.go
+++ b/internal/terraform/context_plan.go
@@ -225,10 +225,9 @@ func (c *Context) PlanAndEval(config *configs.Config, prevRunState *states.State
 	case plans.NormalMode, plans.DestroyMode:
 		// OK
 	case plans.RefreshOnlyMode:
-		if opts.SkipRefresh && len(opts.ActionTargets) == 0 {
+		if opts.SkipRefresh {
 			// The CLI layer (and other similar callers) should prevent this
-			// combination of options - although it is okay if we are invoking
-			// actions.
+			// combination of options.
 			diags = diags.Append(tfdiags.Sourceless(
 				tfdiags.Error,
 				"Incompatible plan options",
@@ -266,6 +265,8 @@ func (c *Context) PlanAndEval(config *configs.Config, prevRunState *states.State
 	}
 
 	if len(opts.ActionTargets) > 0 {
+		// We panic here, as the command package shouldn't be setting
+
 		if len(opts.Targets) != 0 {
 			// The CLI layer (and other similar callers) should prevent this
 			// combination of options.
diff --git a/internal/terraform/context_plan_actions_test.go b/internal/terraform/context_plan_actions_test.go
index a37b7e42f9..36a55d1ddd 100644
--- a/internal/terraform/context_plan_actions_test.go
+++ b/internal/terraform/context_plan_actions_test.go
@@ -2083,74 +2083,6 @@ action "test_unlinked" "one" {
 			},
 		},
 
-		"invoke action with reference (drift, no refresh)": {
-			module: map[string]string{
-				"main.tf": `
-resource "test_object" "a" {
-  name = "hello"
-}
-
-action "test_unlinked" "one" {
-  config {
-    attr = test_object.a.name
-  }
-}
-`,
-			},
-			planOpts: &PlanOpts{
-				Mode:        plans.RefreshOnlyMode,
-				SkipRefresh: true,
-				ActionTargets: []addrs.Targetable{
-					addrs.AbsAction{
-						Action: addrs.Action{
-							Type: "test_unlinked",
-							Name: "one",
-						},
-					},
-				},
-			},
-			expectPlanActionCalled: true,
-			buildState: func(state *states.SyncState) {
-				state.SetResourceInstanceCurrent(mustResourceInstanceAddr("test_object.a"), &states.ResourceInstanceObjectSrc{
-					AttrsJSON: []byte(`{"name":"hello"}`),
-					Status:    states.ObjectReady,
-				}, mustProviderConfig(`provider["registry.terraform.io/hashicorp/test"]`))
-			},
-			assertPlan: func(t *testing.T, plan *plans.Plan) {
-				if len(plan.Changes.ActionInvocations) != 1 {
-					t.Fatalf("expected exactly one invocation, and found %d", len(plan.Changes.ActionInvocations))
-				}
-
-				ais := plan.Changes.ActionInvocations[0]
-				ai, err := ais.Decode(&unlinkedActionSchema)
-				if err != nil {
-					t.Fatal(err)
-				}
-
-				if _, ok := ai.ActionTrigger.(*plans.InvokeActionTrigger); !ok {
-					t.Fatalf("expected invoke action trigger type but was %T", ai.ActionTrigger)
-				}
-
-				expected := cty.ObjectVal(map[string]cty.Value{
-					"attr": cty.StringVal("hello"),
-				})
-				if diff := cmp.Diff(ai.ConfigValue, expected, ctydebug.CmpOptions); len(diff) > 0 {
-					t.Fatalf("wrong value in plan: %s", diff)
-				}
-
-				if !ai.Addr.Equal(mustActionInstanceAddr(t, "action.test_unlinked.one")) {
-					t.Fatalf("wrong address in plan: %s", ai.Addr)
-				}
-			},
-			readResourceFn: func(t *testing.T, request providers.ReadResourceRequest) providers.ReadResourceResponse {
-				return providers.ReadResourceResponse{
-					NewState: cty.ObjectVal(map[string]cty.Value{
-						"name": cty.StringVal("drifted value"),
-					}),
-				}
-			},
-		},
-
 		"non-referenced resource isn't refreshed during invoke": {
 			module: map[string]string{
 				"main.tf": `
