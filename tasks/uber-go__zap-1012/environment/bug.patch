diff --git a/internal/ztest/clock.go b/internal/ztest/clock.go
deleted file mode 100644
index fe8026d..0000000
--- a/internal/ztest/clock.go
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright (c) 2021 Uber Technologies, Inc.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights
-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-// copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-// THE SOFTWARE.
-
-package ztest
-
-import (
-	"time"
-
-	"github.com/benbjohnson/clock"
-)
-
-// MockClock provides control over the time.
-type MockClock struct{ m *clock.Mock }
-
-// NewMockClock builds a new mock clock that provides control of time.
-func NewMockClock() *MockClock {
-	return &MockClock{clock.NewMock()}
-}
-
-// Now reports the current time.
-func (c *MockClock) Now() time.Time {
-	return c.m.Now()
-}
-
-// NewTicker returns a time.Ticker that ticks at the specified frequency.
-func (c *MockClock) NewTicker(d time.Duration) *time.Ticker {
-	return &time.Ticker{C: c.m.Ticker(d).C}
-}
-
-// Add progresses time by the given duration.
-func (c *MockClock) Add(d time.Duration) {
-	c.m.Add(d)
-}
diff --git a/internal/ztest/clock_test.go b/internal/ztest/clock_test.go
deleted file mode 100644
index 377daf9..0000000
--- a/internal/ztest/clock_test.go
+++ /dev/null
@@ -1,57 +0,0 @@
-// Copyright (c) 2021 Uber Technologies, Inc.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights
-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-// copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-// THE SOFTWARE.
-
-package ztest
-
-import (
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"go.uber.org/atomic"
-)
-
-func TestMockClock_NewTicker(t *testing.T) {
-	var n atomic.Int32
-	clock := NewMockClock()
-
-	done := make(chan struct{})
-	defer func() { <-done }() // wait for end
-
-	quit := make(chan struct{})
-	// Create a channel to increment every microsecond.
-	go func(ticker *time.Ticker) {
-		defer close(done)
-		for {
-			select {
-			case <-quit:
-				ticker.Stop()
-				return
-			case <-ticker.C:
-				n.Inc()
-			}
-		}
-	}(clock.NewTicker(time.Microsecond))
-
-	// Move clock forward.
-	clock.Add(2 * time.Microsecond)
-	assert.Equal(t, int32(2), n.Load())
-	close(quit)
-}
diff --git a/zapcore/buffered_write_syncer_test.go b/zapcore/buffered_write_syncer_test.go
index 8a36ad6..72d4d6f 100644
--- a/zapcore/buffered_write_syncer_test.go
+++ b/zapcore/buffered_write_syncer_test.go
@@ -107,7 +107,7 @@ func TestBufferWriter(t *testing.T) {
 
 	t.Run("flush timer", func(t *testing.T) {
 		buf := &bytes.Buffer{}
-		clock := ztest.NewMockClock()
+		clock := newControlledClock()
 		ws := &BufferedWriteSyncer{
 			WS:            AddSync(buf),
 			Size:          6,
diff --git a/zapcore/clock.go b/zapcore/clock.go
index 422fd82..d2ea95b 100644
--- a/zapcore/clock.go
+++ b/zapcore/clock.go
@@ -20,7 +20,9 @@
 
 package zapcore
 
-import "time"
+import (
+	"time"
+)
 
 // DefaultClock is the default clock used by Zap in operations that require
 // time. This clock uses the system clock for all operations.
diff --git a/zapcore/clock_test.go b/zapcore/clock_test.go
index 0dff349..aab682f 100644
--- a/zapcore/clock_test.go
+++ b/zapcore/clock_test.go
@@ -24,11 +24,49 @@ import (
 	"testing"
 	"time"
 
-	"go.uber.org/zap/internal/ztest"
+	"github.com/benbjohnson/clock"
+	"github.com/stretchr/testify/assert"
+	"go.uber.org/atomic"
 )
 
-// Verify that the mock clock satisfies the Clock interface.
-var _ Clock = (*ztest.MockClock)(nil)
+// controlledClock provides control over the time via a mock clock.
+type controlledClock struct{ *clock.Mock }
+
+func newControlledClock() *controlledClock {
+	return &controlledClock{clock.NewMock()}
+}
+
+func (c *controlledClock) NewTicker(d time.Duration) *time.Ticker {
+	return &time.Ticker{C: c.Ticker(d).C}
+}
+
+func TestControlledClock_NewTicker(t *testing.T) {
+	var n atomic.Int32
+	ctrlMock := newControlledClock()
+
+	done := make(chan struct{})
+	defer func() { <-done }() // wait for end
+
+	quit := make(chan struct{})
+	// Create a channel to increment every microsecond.
+	go func(ticker *time.Ticker) {
+		defer close(done)
+		for {
+			select {
+			case <-quit:
+				ticker.Stop()
+				return
+			case <-ticker.C:
+				n.Inc()
+			}
+		}
+	}(ctrlMock.NewTicker(time.Microsecond))
+
+	// Move clock forward.
+	ctrlMock.Add(2 * time.Microsecond)
+	assert.Equal(t, int32(2), n.Load())
+	close(quit)
+}
 
 func TestSystemClock_NewTicker(t *testing.T) {
 	want := 3
diff --git a/zapcore/sampler_test.go b/zapcore/sampler_test.go
index fbcdd46..5bcc37a 100644
--- a/zapcore/sampler_test.go
+++ b/zapcore/sampler_test.go
@@ -22,7 +22,6 @@ package zapcore_test
 
 import (
 	"fmt"
-	"runtime"
 	"sync"
 	"testing"
 	"time"
@@ -159,80 +158,50 @@ func TestSamplerConcurrent(t *testing.T) {
 		numMessages   = 5
 		numTicks      = 25
 		numGoroutines = 10
-		tick          = 10 * time.Millisecond
-
-		// We'll make a total of,
-		// (numGoroutines * numTicks * logsPerTick * 2) log attempts
-		// with numMessages unique messages.
-		numLogAttempts = numGoroutines * logsPerTick * numTicks * 2
-		// Of those, we'll accept (logsPerTick * numTicks) entries
-		// for each unique message.
 		expectedCount = numMessages * logsPerTick * numTicks
-		// The rest will be dropped.
-		expectedDropped = numLogAttempts - expectedCount
 	)
 
-	clock := ztest.NewMockClock()
-
+	tick := ztest.Timeout(10 * time.Millisecond)
 	cc := &countingCore{}
+	sampler := NewSamplerWithOptions(cc, tick, logsPerTick, 100000)
 
-	hook, dropped, sampled := makeSamplerCountingHook()
-	sampler := NewSamplerWithOptions(cc, tick, logsPerTick, 100000, SamplerHook(hook))
-
-	stop := make(chan struct{})
-	var wg sync.WaitGroup
+	var (
+		done atomic.Bool
+		wg   sync.WaitGroup
+	)
 	for i := 0; i < numGoroutines; i++ {
 		wg.Add(1)
-		go func(i int, ticker *time.Ticker) {
+		go func(i int) {
 			defer wg.Done()
-			defer ticker.Stop()
 
 			for {
-				select {
-				case <-stop:
+				if done.Load() {
 					return
-
-				case <-ticker.C:
-					for j := 0; j < logsPerTick*2; j++ {
-						msg := fmt.Sprintf("msg%v", i%numMessages)
-						ent := Entry{
-							Level:   DebugLevel,
-							Message: msg,
-							Time:    clock.Now(),
-						}
-						if ce := sampler.Check(ent, nil); ce != nil {
-							ce.Write()
-						}
-
-						// Give a chance for other goroutines to run.
-						runtime.Gosched()
-					}
 				}
+				msg := fmt.Sprintf("msg%v", i%numMessages)
+				ent := Entry{Level: DebugLevel, Message: msg, Time: time.Now()}
+				if ce := sampler.Check(ent, nil); ce != nil {
+					ce.Write()
+				}
+
+				// Give a chance for other goroutines to run.
+				time.Sleep(time.Microsecond)
 			}
-		}(i, clock.NewTicker(tick))
+		}(i)
 	}
 
-	clock.Add(tick * numTicks)
-	close(stop)
+	time.AfterFunc(numTicks*tick, func() {
+		done.Store(true)
+	})
 	wg.Wait()
 
-	assert.Equal(
+	assert.InDelta(
 		t,
 		expectedCount,
-		int(cc.logs.Load()),
+		cc.logs.Load(),
+		expectedCount/10,
 		"Unexpected number of logs",
 	)
-	assert.Equal(t,
-		expectedCount,
-		int(sampled.Load()),
-		"Unexpected number of logs sampled",
-	)
-	assert.Equal(t,
-		expectedDropped,
-		int(dropped.Load()),
-		"Unexpected number of logs dropped",
-	)
-
 }
 
 func TestSamplerRaces(t *testing.T) {
