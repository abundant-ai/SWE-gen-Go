diff --git a/README.md b/README.md
index 64b2a29..851fcc0 100644
--- a/README.md
+++ b/README.md
@@ -45,7 +45,6 @@ Many of the most widely used Go projects are built using Cobra including:
   * [Suggestions when "unknown command" happens](#suggestions-when-unknown-command-happens)
   * [Generating documentation for your command](#generating-documentation-for-your-command)
   * [Generating bash completions](#generating-bash-completions)
-  * [Generating zsh completions](#generating-zsh-completions)
 - [Contributing](#contributing)
 - [License](#license)
 
@@ -722,11 +721,6 @@ Cobra can generate documentation based on subcommands, flags, etc. in the follow
 
 Cobra can generate a bash-completion file. If you add more information to your command, these completions can be amazingly powerful and flexible.  Read more about it in [Bash Completions](bash_completions.md).
 
-## Generating zsh completions
-
-Cobra can generate zsh-completion file. Read more about it in
-[Zsh Completions](zsh_completions.md).
-
 # Contributing
 
 1. Fork it
diff --git a/bash_completions.go b/bash_completions.go
index 81b4c7c..8fa8f48 100644
--- a/bash_completions.go
+++ b/bash_completions.go
@@ -534,3 +534,51 @@ func (c *Command) GenBashCompletionFile(filename string) error {
 
 	return c.GenBashCompletion(outFile)
 }
+
+// MarkFlagRequired adds the BashCompOneRequiredFlag annotation to the named flag if it exists,
+// and causes your command to report an error if invoked without the flag.
+func (c *Command) MarkFlagRequired(name string) error {
+	return MarkFlagRequired(c.Flags(), name)
+}
+
+// MarkPersistentFlagRequired adds the BashCompOneRequiredFlag annotation to the named persistent flag if it exists,
+// and causes your command to report an error if invoked without the flag.
+func (c *Command) MarkPersistentFlagRequired(name string) error {
+	return MarkFlagRequired(c.PersistentFlags(), name)
+}
+
+// MarkFlagRequired adds the BashCompOneRequiredFlag annotation to the named flag if it exists,
+// and causes your command to report an error if invoked without the flag.
+func MarkFlagRequired(flags *pflag.FlagSet, name string) error {
+	return flags.SetAnnotation(name, BashCompOneRequiredFlag, []string{"true"})
+}
+
+// MarkFlagFilename adds the BashCompFilenameExt annotation to the named flag, if it exists.
+// Generated bash autocompletion will select filenames for the flag, limiting to named extensions if provided.
+func (c *Command) MarkFlagFilename(name string, extensions ...string) error {
+	return MarkFlagFilename(c.Flags(), name, extensions...)
+}
+
+// MarkFlagCustom adds the BashCompCustom annotation to the named flag, if it exists.
+// Generated bash autocompletion will call the bash function f for the flag.
+func (c *Command) MarkFlagCustom(name string, f string) error {
+	return MarkFlagCustom(c.Flags(), name, f)
+}
+
+// MarkPersistentFlagFilename adds the BashCompFilenameExt annotation to the named persistent flag, if it exists.
+// Generated bash autocompletion will select filenames for the flag, limiting to named extensions if provided.
+func (c *Command) MarkPersistentFlagFilename(name string, extensions ...string) error {
+	return MarkFlagFilename(c.PersistentFlags(), name, extensions...)
+}
+
+// MarkFlagFilename adds the BashCompFilenameExt annotation to the named flag in the flag set, if it exists.
+// Generated bash autocompletion will select filenames for the flag, limiting to named extensions if provided.
+func MarkFlagFilename(flags *pflag.FlagSet, name string, extensions ...string) error {
+	return flags.SetAnnotation(name, BashCompFilenameExt, extensions)
+}
+
+// MarkFlagCustom adds the BashCompCustom annotation to the named flag in the flag set, if it exists.
+// Generated bash autocompletion will call the bash function f for the flag.
+func MarkFlagCustom(flags *pflag.FlagSet, name string, f string) error {
+	return flags.SetAnnotation(name, BashCompCustom, []string{f})
+}
diff --git a/shell_completions.go b/shell_completions.go
deleted file mode 100644
index ba0af9c..0000000
--- a/shell_completions.go
+++ /dev/null
@@ -1,85 +0,0 @@
-package cobra
-
-import (
-	"github.com/spf13/pflag"
-)
-
-// MarkFlagRequired adds the BashCompOneRequiredFlag annotation to the named flag if it exists,
-// and causes your command to report an error if invoked without the flag.
-func (c *Command) MarkFlagRequired(name string) error {
-	return MarkFlagRequired(c.Flags(), name)
-}
-
-// MarkPersistentFlagRequired adds the BashCompOneRequiredFlag annotation to the named persistent flag if it exists,
-// and causes your command to report an error if invoked without the flag.
-func (c *Command) MarkPersistentFlagRequired(name string) error {
-	return MarkFlagRequired(c.PersistentFlags(), name)
-}
-
-// MarkFlagRequired adds the BashCompOneRequiredFlag annotation to the named flag if it exists,
-// and causes your command to report an error if invoked without the flag.
-func MarkFlagRequired(flags *pflag.FlagSet, name string) error {
-	return flags.SetAnnotation(name, BashCompOneRequiredFlag, []string{"true"})
-}
-
-// MarkFlagFilename adds the BashCompFilenameExt annotation to the named flag, if it exists.
-// Generated bash autocompletion will select filenames for the flag, limiting to named extensions if provided.
-func (c *Command) MarkFlagFilename(name string, extensions ...string) error {
-	return MarkFlagFilename(c.Flags(), name, extensions...)
-}
-
-// MarkFlagCustom adds the BashCompCustom annotation to the named flag, if it exists.
-// Generated bash autocompletion will call the bash function f for the flag.
-func (c *Command) MarkFlagCustom(name string, f string) error {
-	return MarkFlagCustom(c.Flags(), name, f)
-}
-
-// MarkPersistentFlagFilename instructs the various shell completion
-// implementations to limit completions for this persistent flag to the
-// specified extensions (patterns).
-//
-// Shell Completion compatibility matrix: bash, zsh
-func (c *Command) MarkPersistentFlagFilename(name string, extensions ...string) error {
-	return MarkFlagFilename(c.PersistentFlags(), name, extensions...)
-}
-
-// MarkFlagFilename instructs the various shell completion implementations to
-// limit completions for this flag to the specified extensions (patterns).
-//
-// Shell Completion compatibility matrix: bash, zsh
-func MarkFlagFilename(flags *pflag.FlagSet, name string, extensions ...string) error {
-	return flags.SetAnnotation(name, BashCompFilenameExt, extensions)
-}
-
-// MarkFlagCustom instructs the various shell completion implementations to
-// limit completions for this flag to the specified extensions (patterns).
-//
-// Shell Completion compatibility matrix: bash, zsh
-func MarkFlagCustom(flags *pflag.FlagSet, name string, f string) error {
-	return flags.SetAnnotation(name, BashCompCustom, []string{f})
-}
-
-// MarkFlagDirname instructs the various shell completion implementations to
-// complete only directories with this named flag.
-//
-// Shell Completion compatibility matrix: zsh
-func (c *Command) MarkFlagDirname(name string) error {
-	return MarkFlagDirname(c.Flags(), name)
-}
-
-// MarkPersistentFlagDirname instructs the various shell completion
-// implementations to complete only directories with this persistent named flag.
-//
-// Shell Completion compatibility matrix: zsh
-func (c *Command) MarkPersistentFlagDirname(name string) error {
-	return MarkFlagDirname(c.PersistentFlags(), name)
-}
-
-// MarkFlagDirname instructs the various shell completion implementations to
-// complete only directories with this specified flag.
-//
-// Shell Completion compatibility matrix: zsh
-func MarkFlagDirname(flags *pflag.FlagSet, name string) error {
-	zshPattern := "-(/)"
-	return flags.SetAnnotation(name, zshCompDirname, []string{zshPattern})
-}
diff --git a/zsh_completions.go b/zsh_completions.go
index 1275548..889c22e 100644
--- a/zsh_completions.go
+++ b/zsh_completions.go
@@ -1,102 +1,13 @@
 package cobra
 
 import (
-	"encoding/json"
+	"bytes"
 	"fmt"
 	"io"
 	"os"
-	"sort"
 	"strings"
-	"text/template"
-
-	"github.com/spf13/pflag"
-)
-
-const (
-	zshCompArgumentAnnotation   = "cobra_annotations_zsh_completion_argument_annotation"
-	zshCompArgumentFilenameComp = "cobra_annotations_zsh_completion_argument_file_completion"
-	zshCompArgumentWordComp     = "cobra_annotations_zsh_completion_argument_word_completion"
-	zshCompDirname              = "cobra_annotations_zsh_dirname"
-)
-
-var (
-	zshCompFuncMap = template.FuncMap{
-		"genZshFuncName":              zshCompGenFuncName,
-		"extractFlags":                zshCompExtractFlag,
-		"genFlagEntryForZshArguments": zshCompGenFlagEntryForArguments,
-		"extractArgsCompletions":      zshCompExtractArgumentCompletionHintsForRendering,
-	}
-	zshCompletionText = `
-{{/* should accept Command (that contains subcommands) as parameter */}}
-{{define "argumentsC" -}}
-{{ $cmdPath := genZshFuncName .}}
-function {{$cmdPath}} {
-  local -a commands
-
-  _arguments -C \{{- range extractFlags .}}
-    {{genFlagEntryForZshArguments .}} \{{- end}}
-    "1: :->cmnds" \
-    "*::arg:->args"
-
-  case $state in
-  cmnds)
-    commands=({{range .Commands}}{{if not .Hidden}}
-      "{{.Name}}:{{.Short}}"{{end}}{{end}}
-    )
-    _describe "command" commands
-    ;;
-  esac
-
-  case "$words[1]" in {{- range .Commands}}{{if not .Hidden}}
-  {{.Name}})
-    {{$cmdPath}}_{{.Name}}
-    ;;{{end}}{{end}}
-  esac
-}
-{{range .Commands}}{{if not .Hidden}}
-{{template "selectCmdTemplate" .}}
-{{- end}}{{end}}
-{{- end}}
-
-{{/* should accept Command without subcommands as parameter */}}
-{{define "arguments" -}}
-function {{genZshFuncName .}} {
-{{"  _arguments"}}{{range extractFlags .}} \
-    {{genFlagEntryForZshArguments . -}}
-{{end}}{{range extractArgsCompletions .}} \
-    {{.}}{{end}}
-}
-{{end}}
-
-{{/* dispatcher for commands with or without subcommands */}}
-{{define "selectCmdTemplate" -}}
-{{if .Hidden}}{{/* ignore hidden*/}}{{else -}}
-{{if .Commands}}{{template "argumentsC" .}}{{else}}{{template "arguments" .}}{{end}}
-{{- end}}
-{{- end}}
-
-{{/* template entry point */}}
-{{define "Main" -}}
-#compdef _{{.Name}} {{.Name}}
-
-{{template "selectCmdTemplate" .}}
-{{end}}
-`
 )
 
-// zshCompArgsAnnotation is used to encode/decode zsh completion for
-// arguments to/from Command.Annotations.
-type zshCompArgsAnnotation map[int]zshCompArgHint
-
-type zshCompArgHint struct {
-	// Indicates the type of the completion to use. One of:
-	// zshCompArgumentFilenameComp or zshCompArgumentWordComp
-	Tipe string `json:"type"`
-
-	// A value for the type above (globs for file completion or words)
-	Options []string `json:"options"`
-}
-
 // GenZshCompletionFile generates zsh completion file.
 func (c *Command) GenZshCompletionFile(filename string) error {
 	outFile, err := os.Create(filename)
@@ -108,229 +19,108 @@ func (c *Command) GenZshCompletionFile(filename string) error {
 	return c.GenZshCompletion(outFile)
 }
 
-// GenZshCompletion generates a zsh completion file and writes to the passed
-// writer. The completion always run on the root command regardless of the
-// command it was called from.
+// GenZshCompletion generates a zsh completion file and writes to the passed writer.
 func (c *Command) GenZshCompletion(w io.Writer) error {
-	tmpl, err := template.New("Main").Funcs(zshCompFuncMap).Parse(zshCompletionText)
-	if err != nil {
-		return fmt.Errorf("error creating zsh completion template: %v", err)
-	}
-	return tmpl.Execute(w, c.Root())
-}
-
-// MarkZshCompPositionalArgumentFile marks the specified argument (first
-// argument is 1) as completed by file selection. patterns (e.g. "*.txt") are
-// optional - if not provided the completion will search for all files.
-func (c *Command) MarkZshCompPositionalArgumentFile(argPosition int, patterns ...string) error {
-	if argPosition < 1 {
-		return fmt.Errorf("Invalid argument position (%d)", argPosition)
-	}
-	annotation, err := c.zshCompGetArgsAnnotations()
-	if err != nil {
-		return err
-	}
-	if c.zshcompArgsAnnotationnIsDuplicatePosition(annotation, argPosition) {
-		return fmt.Errorf("Duplicate annotation for positional argument at index %d", argPosition)
-	}
-	annotation[argPosition] = zshCompArgHint{
-		Tipe:    zshCompArgumentFilenameComp,
-		Options: patterns,
-	}
-	return c.zshCompSetArgsAnnotations(annotation)
-}
-
-// MarkZshCompPositionalArgumentWords marks the specified positional argument
-// (first argument is 1) as completed by the provided words. At east one word
-// must be provided, spaces within words will be offered completion with
-// "word\ word".
-func (c *Command) MarkZshCompPositionalArgumentWords(argPosition int, words ...string) error {
-	if argPosition < 1 {
-		return fmt.Errorf("Invalid argument position (%d)", argPosition)
-	}
-	if len(words) == 0 {
-		return fmt.Errorf("Trying to set empty word list for positional argument %d", argPosition)
-	}
-	annotation, err := c.zshCompGetArgsAnnotations()
-	if err != nil {
-		return err
-	}
-	if c.zshcompArgsAnnotationnIsDuplicatePosition(annotation, argPosition) {
-		return fmt.Errorf("Duplicate annotation for positional argument at index %d", argPosition)
-	}
-	annotation[argPosition] = zshCompArgHint{
-		Tipe:    zshCompArgumentWordComp,
-		Options: words,
-	}
-	return c.zshCompSetArgsAnnotations(annotation)
-}
+	buf := new(bytes.Buffer)
 
-func zshCompExtractArgumentCompletionHintsForRendering(c *Command) ([]string, error) {
-	var result []string
-	annotation, err := c.zshCompGetArgsAnnotations()
-	if err != nil {
-		return nil, err
-	}
-	for k, v := range annotation {
-		s, err := zshCompRenderZshCompArgHint(k, v)
-		if err != nil {
-			return nil, err
-		}
-		result = append(result, s)
-	}
-	if len(c.ValidArgs) > 0 {
-		if _, positionOneExists := annotation[1]; !positionOneExists {
-			s, err := zshCompRenderZshCompArgHint(1, zshCompArgHint{
-				Tipe:    zshCompArgumentWordComp,
-				Options: c.ValidArgs,
-			})
-			if err != nil {
-				return nil, err
-			}
-			result = append(result, s)
-		}
-	}
-	sort.Strings(result)
-	return result, nil
-}
+	writeHeader(buf, c)
+	maxDepth := maxDepth(c)
+	writeLevelMapping(buf, maxDepth)
+	writeLevelCases(buf, maxDepth, c)
 
-func zshCompRenderZshCompArgHint(i int, z zshCompArgHint) (string, error) {
-	switch t := z.Tipe; t {
-	case zshCompArgumentFilenameComp:
-		var globs []string
-		for _, g := range z.Options {
-			globs = append(globs, fmt.Sprintf(`-g "%s"`, g))
-		}
-		return fmt.Sprintf(`'%d: :_files %s'`, i, strings.Join(globs, " ")), nil
-	case zshCompArgumentWordComp:
-		var words []string
-		for _, w := range z.Options {
-			words = append(words, fmt.Sprintf("%q", w))
-		}
-		return fmt.Sprintf(`'%d: :(%s)'`, i, strings.Join(words, " ")), nil
-	default:
-		return "", fmt.Errorf("Invalid zsh argument completion annotation: %s", t)
-	}
+	_, err := buf.WriteTo(w)
+	return err
 }
 
-func (c *Command) zshcompArgsAnnotationnIsDuplicatePosition(annotation zshCompArgsAnnotation, position int) bool {
-	_, dup := annotation[position]
-	return dup
+func writeHeader(w io.Writer, cmd *Command) {
+	fmt.Fprintf(w, "#compdef %s\n\n", cmd.Name())
 }
 
-func (c *Command) zshCompGetArgsAnnotations() (zshCompArgsAnnotation, error) {
-	annotation := make(zshCompArgsAnnotation)
-	annotationString, ok := c.Annotations[zshCompArgumentAnnotation]
-	if !ok {
-		return annotation, nil
+func maxDepth(c *Command) int {
+	if len(c.Commands()) == 0 {
+		return 0
 	}
-	err := json.Unmarshal([]byte(annotationString), &annotation)
-	if err != nil {
-		return annotation, fmt.Errorf("Error unmarshaling zsh argument annotation: %v", err)
-	}
-	return annotation, nil
-}
-
-func (c *Command) zshCompSetArgsAnnotations(annotation zshCompArgsAnnotation) error {
-	jsn, err := json.Marshal(annotation)
-	if err != nil {
-		return fmt.Errorf("Error marshaling zsh argument annotation: %v", err)
-	}
-	if c.Annotations == nil {
-		c.Annotations = make(map[string]string)
+	maxDepthSub := 0
+	for _, s := range c.Commands() {
+		subDepth := maxDepth(s)
+		if subDepth > maxDepthSub {
+			maxDepthSub = subDepth
+		}
 	}
-	c.Annotations[zshCompArgumentAnnotation] = string(jsn)
-	return nil
+	return 1 + maxDepthSub
 }
 
-func zshCompGenFuncName(c *Command) string {
-	if c.HasParent() {
-		return zshCompGenFuncName(c.Parent()) + "_" + c.Name()
+func writeLevelMapping(w io.Writer, numLevels int) {
+	fmt.Fprintln(w, `_arguments \`)
+	for i := 1; i <= numLevels; i++ {
+		fmt.Fprintf(w, `  '%d: :->level%d' \`, i, i)
+		fmt.Fprintln(w)
 	}
-	return "_" + c.Name()
+	fmt.Fprintf(w, `  '%d: :%s'`, numLevels+1, "_files")
+	fmt.Fprintln(w)
 }
 
-func zshCompExtractFlag(c *Command) []*pflag.Flag {
-	var flags []*pflag.Flag
-	c.LocalFlags().VisitAll(func(f *pflag.Flag) {
-		if !f.Hidden {
-			flags = append(flags, f)
-		}
-	})
-	c.InheritedFlags().VisitAll(func(f *pflag.Flag) {
-		if !f.Hidden {
-			flags = append(flags, f)
-		}
-	})
-	return flags
-}
+func writeLevelCases(w io.Writer, maxDepth int, root *Command) {
+	fmt.Fprintln(w, "case $state in")
+	defer fmt.Fprintln(w, "esac")
 
-// zshCompGenFlagEntryForArguments returns an entry that matches _arguments
-// zsh-completion parameters. It's too complicated to generate in a template.
-func zshCompGenFlagEntryForArguments(f *pflag.Flag) string {
-	if f.Name == "" || f.Shorthand == "" {
-		return zshCompGenFlagEntryForSingleOptionFlag(f)
+	for i := 1; i <= maxDepth; i++ {
+		fmt.Fprintf(w, "  level%d)\n", i)
+		writeLevel(w, root, i)
+		fmt.Fprintln(w, "  ;;")
 	}
-	return zshCompGenFlagEntryForMultiOptionFlag(f)
+	fmt.Fprintln(w, "  *)")
+	fmt.Fprintln(w, "    _arguments '*: :_files'")
+	fmt.Fprintln(w, "  ;;")
 }
 
-func zshCompGenFlagEntryForSingleOptionFlag(f *pflag.Flag) string {
-	var option, multiMark, extras string
+func writeLevel(w io.Writer, root *Command, i int) {
+	fmt.Fprintf(w, "    case $words[%d] in\n", i)
+	defer fmt.Fprintln(w, "    esac")
 
-	if zshCompFlagCouldBeSpecifiedMoreThenOnce(f) {
-		multiMark = "*"
-	}
+	commands := filterByLevel(root, i)
+	byParent := groupByParent(commands)
 
-	option = "--" + f.Name
-	if option == "--" {
-		option = "-" + f.Shorthand
+	for p, c := range byParent {
+		names := names(c)
+		fmt.Fprintf(w, "      %s)\n", p)
+		fmt.Fprintf(w, "        _arguments '%d: :(%s)'\n", i, strings.Join(names, " "))
+		fmt.Fprintln(w, "      ;;")
 	}
-	extras = zshCompGenFlagEntryExtras(f)
+	fmt.Fprintln(w, "      *)")
+	fmt.Fprintln(w, "        _arguments '*: :_files'")
+	fmt.Fprintln(w, "      ;;")
 
-	return fmt.Sprintf(`'%s%s[%s]%s'`, multiMark, option, zshCompQuoteFlagDescription(f.Usage), extras)
 }
 
-func zshCompGenFlagEntryForMultiOptionFlag(f *pflag.Flag) string {
-	var options, parenMultiMark, curlyMultiMark, extras string
-
-	if zshCompFlagCouldBeSpecifiedMoreThenOnce(f) {
-		parenMultiMark = "*"
-		curlyMultiMark = "\\*"
+func filterByLevel(c *Command, l int) []*Command {
+	cs := make([]*Command, 0)
+	if l == 0 {
+		cs = append(cs, c)
+		return cs
 	}
-
-	options = fmt.Sprintf(`'(%s-%s %s--%s)'{%s-%s,%s--%s}`,
-		parenMultiMark, f.Shorthand, parenMultiMark, f.Name, curlyMultiMark, f.Shorthand, curlyMultiMark, f.Name)
-	extras = zshCompGenFlagEntryExtras(f)
-
-	return fmt.Sprintf(`%s'[%s]%s'`, options, zshCompQuoteFlagDescription(f.Usage), extras)
-}
-
-func zshCompGenFlagEntryExtras(f *pflag.Flag) string {
-	if f.NoOptDefVal != "" {
-		return ""
+	for _, s := range c.Commands() {
+		cs = append(cs, filterByLevel(s, l-1)...)
 	}
+	return cs
+}
 
-	extras := ":" // allow options for flag (even without assistance)
-	for key, values := range f.Annotations {
-		switch key {
-		case zshCompDirname:
-			extras = fmt.Sprintf(":filename:_files -g %q", values[0])
-		case BashCompFilenameExt:
-			extras = ":filename:_files"
-			for _, pattern := range values {
-				extras = extras + fmt.Sprintf(` -g "%s"`, pattern)
-			}
+func groupByParent(commands []*Command) map[string][]*Command {
+	m := make(map[string][]*Command)
+	for _, c := range commands {
+		parent := c.Parent()
+		if parent == nil {
+			continue
 		}
+		m[parent.Name()] = append(m[parent.Name()], c)
 	}
-
-	return extras
-}
-
-func zshCompFlagCouldBeSpecifiedMoreThenOnce(f *pflag.Flag) bool {
-	return strings.Contains(f.Value.Type(), "Slice") ||
-		strings.Contains(f.Value.Type(), "Array")
+	return m
 }
 
-func zshCompQuoteFlagDescription(s string) string {
-	return strings.Replace(s, "'", `'\''`, -1)
+func names(commands []*Command) []string {
+	ns := make([]string, len(commands))
+	for i, c := range commands {
+		ns[i] = c.Name()
+	}
+	return ns
 }
diff --git a/zsh_completions.md b/zsh_completions.md
deleted file mode 100644
index df9c2ea..0000000
--- a/zsh_completions.md
+++ /dev/null
@@ -1,39 +0,0 @@
-## Generating Zsh Completion for your cobra.Command
-
-Cobra supports native Zsh completion generated from the root `cobra.Command`.
-The generated completion script should be put somewhere in your `$fpath` named
-`_<YOUR COMMAND>`.
-
-### What's Supported
-
-* Completion for all non-hidden subcommands using their `.Short` description.
-* Completion for all non-hidden flags using the following rules:
-  * Filename completion works by marking the flag with `cmd.MarkFlagFilename...`
-    family of commands.
-  * The requirement for argument to the flag is decided by the `.NoOptDefVal`
-    flag value - if it's empty then completion will expect an argument.
-  * Flags of one of the various `*Array` and `*Slice` types supports multiple
-    specifications (with or without argument depending on the specific type).
-* Completion of positional arguments using the following rules:
-  * Argument position for all options below starts at `1`. If argument position
-    `0` is requested it will raise an error.
-  * Use `command.MarkZshCompPositionalArgumentFile` to complete filenames. Glob
-    patterns (e.g. `"*.log"`) are optional - if not specified it will offer to
-    complete all file types.
-  * Use `command.MarkZshCompPositionalArgumentWords` to offer specific words for
-    completion. At least one word is required.
-  * It's possible to specify completion for some arguments and leave some
-    unspecified (e.g. offer words for second argument but nothing for first
-    argument). This will cause no completion for first argument but words
-    completion for second argument.
-  * If no argument completion was specified for 1st argument (but optionally was
-    specified for 2nd) and the command has `ValidArgs` it will be used as
-    completion options for 1st argument.
-  * Argument completions only offered for commands with no subcommands.
-
-### What's not yet Supported
-
-* Custom completion scripts are not supported yet (We should probably create zsh
-  specific one, doesn't make sense to re-use the bash one as the functions will
-  be different).
-* Whatever other feature you're looking for and doesn't exist :)
diff --git a/zsh_completions_test.go b/zsh_completions_test.go
index e53fa88..34e6949 100644
--- a/zsh_completions_test.go
+++ b/zsh_completions_test.go
@@ -2,474 +2,88 @@ package cobra
 
 import (
 	"bytes"
-	"regexp"
 	"strings"
 	"testing"
 )
 
-func TestGenZshCompletion(t *testing.T) {
-	var debug bool
-	var option string
-
+func TestZshCompletion(t *testing.T) {
 	tcs := []struct {
 		name                string
 		root                *Command
 		expectedExpressions []string
-		invocationArgs      []string
-		skip                string
 	}{
 		{
-			name: "simple command",
-			root: func() *Command {
-				r := &Command{
-					Use:  "mycommand",
-					Long: "My Command long description",
-					Run:  emptyRun,
-				}
-				r.Flags().BoolVar(&debug, "debug", debug, "description")
-				return r
-			}(),
-			expectedExpressions: []string{
-				`(?s)function _mycommand {\s+_arguments \\\s+'--debug\[description\]'.*--help.*}`,
-				"#compdef _mycommand mycommand",
-			},
-		},
-		{
-			name: "flags with both long and short flags",
-			root: func() *Command {
-				r := &Command{
-					Use:  "testcmd",
-					Long: "long description",
-					Run:  emptyRun,
-				}
-				r.Flags().BoolVarP(&debug, "debug", "d", debug, "debug description")
-				return r
-			}(),
-			expectedExpressions: []string{
-				`'\(-d --debug\)'{-d,--debug}'\[debug description\]'`,
-			},
-		},
-		{
-			name: "command with subcommands and flags with values",
-			root: func() *Command {
-				r := &Command{
-					Use:  "rootcmd",
-					Long: "Long rootcmd description",
-				}
-				d := &Command{
-					Use:   "subcmd1",
-					Short: "Subcmd1 short description",
-					Run:   emptyRun,
-				}
-				e := &Command{
-					Use:  "subcmd2",
-					Long: "Subcmd2 short description",
-					Run:  emptyRun,
-				}
-				r.PersistentFlags().BoolVar(&debug, "debug", debug, "description")
-				d.Flags().StringVarP(&option, "option", "o", option, "option description")
-				r.AddCommand(d, e)
-				return r
-			}(),
-			expectedExpressions: []string{
-				`commands=\(\n\s+"help:.*\n\s+"subcmd1:.*\n\s+"subcmd2:.*\n\s+\)`,
-				`_arguments \\\n.*'--debug\[description]'`,
-				`_arguments -C \\\n.*'--debug\[description]'`,
-				`function _rootcmd_subcmd1 {`,
-				`function _rootcmd_subcmd1 {`,
-				`_arguments \\\n.*'\(-o --option\)'{-o,--option}'\[option description]:' \\\n`,
-			},
-		},
-		{
-			name: "filename completion with and without globs",
-			root: func() *Command {
-				var file string
-				r := &Command{
-					Use:   "mycmd",
-					Short: "my command short description",
-					Run:   emptyRun,
-				}
-				r.Flags().StringVarP(&file, "config", "c", file, "config file")
-				r.MarkFlagFilename("config")
-				r.Flags().String("output", "", "output file")
-				r.MarkFlagFilename("output", "*.log", "*.txt")
-				return r
-			}(),
-			expectedExpressions: []string{
-				`\n +'\(-c --config\)'{-c,--config}'\[config file]:filename:_files'`,
-				`:_files -g "\*.log" -g "\*.txt"`,
-			},
-		},
-		{
-			name: "repeated variables both with and without value",
-			root: func() *Command {
-				r := genTestCommand("mycmd", true)
-				_ = r.Flags().BoolSliceP("debug", "d", []bool{}, "debug usage")
-				_ = r.Flags().StringArray("option", []string{}, "options")
-				return r
-			}(),
-			expectedExpressions: []string{
-				`'\*--option\[options]`,
-				`'\(\*-d \*--debug\)'{\\\*-d,\\\*--debug}`,
-			},
-		},
-		{
-			name: "generated flags --help and --version should be created even when not executing root cmd",
-			root: func() *Command {
-				r := &Command{
-					Use:     "mycmd",
-					Short:   "mycmd short description",
-					Version: "myversion",
-				}
-				s := genTestCommand("sub1", true)
-				r.AddCommand(s)
-				return s
-			}(),
-			expectedExpressions: []string{
-				"--version",
-				"--help",
-			},
-			invocationArgs: []string{
-				"sub1",
-			},
-			skip: "--version and --help are currently not generated when not running on root command",
-		},
-		{
-			name: "zsh generation should run on root command",
-			root: func() *Command {
-				r := genTestCommand("root", false)
-				s := genTestCommand("sub1", true)
-				r.AddCommand(s)
-				return s
-			}(),
-			expectedExpressions: []string{
-				"function _root {",
-			},
-		},
-		{
-			name: "flag description with single quote (') shouldn't break quotes in completion file",
-			root: func() *Command {
-				r := genTestCommand("root", true)
-				r.Flags().Bool("private", false, "Don't show public info")
-				return r
-			}(),
-			expectedExpressions: []string{
-				`--private\[Don'\\''t show public info]`,
-			},
-		},
-		{
-			name: "argument completion for file with and without patterns",
-			root: func() *Command {
-				r := genTestCommand("root", true)
-				r.MarkZshCompPositionalArgumentFile(1, "*.log")
-				r.MarkZshCompPositionalArgumentFile(2)
-				return r
-			}(),
-			expectedExpressions: []string{
-				`'1: :_files -g "\*.log"' \\\n\s+'2: :_files`,
-			},
-		},
-		{
-			name: "argument zsh completion for words",
-			root: func() *Command {
-				r := genTestCommand("root", true)
-				r.MarkZshCompPositionalArgumentWords(1, "word1", "word2")
-				return r
-			}(),
-			expectedExpressions: []string{
-				`'1: :\("word1" "word2"\)`,
-			},
-		},
-		{
-			name: "argument completion for words with spaces",
-			root: func() *Command {
-				r := genTestCommand("root", true)
-				r.MarkZshCompPositionalArgumentWords(1, "single", "multiple words")
-				return r
-			}(),
-			expectedExpressions: []string{
-				`'1: :\("single" "multiple words"\)'`,
-			},
+			name:                "trivial",
+			root:                &Command{Use: "trivialapp"},
+			expectedExpressions: []string{"#compdef trivial"},
 		},
 		{
-			name: "argument completion when command has ValidArgs and no annotation for argument completion",
+			name: "linear",
 			root: func() *Command {
-				r := genTestCommand("root", true)
-				r.ValidArgs = []string{"word1", "word2"}
+				r := &Command{Use: "linear"}
+
+				sub1 := &Command{Use: "sub1"}
+				r.AddCommand(sub1)
+
+				sub2 := &Command{Use: "sub2"}
+				sub1.AddCommand(sub2)
+
+				sub3 := &Command{Use: "sub3"}
+				sub2.AddCommand(sub3)
 				return r
 			}(),
-			expectedExpressions: []string{
-				`'1: :\("word1" "word2"\)'`,
-			},
+			expectedExpressions: []string{"sub1", "sub2", "sub3"},
 		},
 		{
-			name: "argument completion when command has ValidArgs and no annotation for argument at argPosition 1",
+			name: "flat",
 			root: func() *Command {
-				r := genTestCommand("root", true)
-				r.ValidArgs = []string{"word1", "word2"}
-				r.MarkZshCompPositionalArgumentFile(2)
+				r := &Command{Use: "flat"}
+				r.AddCommand(&Command{Use: "c1"})
+				r.AddCommand(&Command{Use: "c2"})
 				return r
 			}(),
-			expectedExpressions: []string{
-				`'1: :\("word1" "word2"\)' \\`,
-			},
+			expectedExpressions: []string{"(c1 c2)"},
 		},
 		{
-			name: "directory completion for flag",
+			name: "tree",
 			root: func() *Command {
-				r := genTestCommand("root", true)
-				r.Flags().String("test", "", "test")
-				r.PersistentFlags().String("ptest", "", "ptest")
-				r.MarkFlagDirname("test")
-				r.MarkPersistentFlagDirname("ptest")
-				return r
-			}(),
-			expectedExpressions: []string{
-				`--test\[test]:filename:_files -g "-\(/\)"`,
-				`--ptest\[ptest]:filename:_files -g "-\(/\)"`,
-			},
-		},
-	}
+				r := &Command{Use: "tree"}
 
-	for _, tc := range tcs {
-		t.Run(tc.name, func(t *testing.T) {
-			if tc.skip != "" {
-				t.Skip(tc.skip)
-			}
-			tc.root.Root().SetArgs(tc.invocationArgs)
-			tc.root.Execute()
-			buf := new(bytes.Buffer)
-			if err := tc.root.GenZshCompletion(buf); err != nil {
-				t.Error(err)
-			}
-			output := buf.Bytes()
+				sub1 := &Command{Use: "sub1"}
+				r.AddCommand(sub1)
 
-			for _, expr := range tc.expectedExpressions {
-				rgx, err := regexp.Compile(expr)
-				if err != nil {
-					t.Errorf("error compiling expression (%s): %v", expr, err)
-				}
-				if !rgx.Match(output) {
-					t.Errorf("expected completion (%s) to match '%s'", buf.String(), expr)
-				}
-			}
-		})
-	}
-}
+				sub11 := &Command{Use: "sub11"}
+				sub12 := &Command{Use: "sub12"}
 
-func TestGenZshCompletionHidden(t *testing.T) {
-	tcs := []struct {
-		name                string
-		root                *Command
-		expectedExpressions []string
-	}{
-		{
-			name: "hidden commands",
-			root: func() *Command {
-				r := &Command{
-					Use:   "main",
-					Short: "main short description",
-				}
-				s1 := &Command{
-					Use:    "sub1",
-					Hidden: true,
-					Run:    emptyRun,
-				}
-				s2 := &Command{
-					Use:   "sub2",
-					Short: "short sub2 description",
-					Run:   emptyRun,
-				}
-				r.AddCommand(s1, s2)
+				sub1.AddCommand(sub11)
+				sub1.AddCommand(sub12)
+
+				sub2 := &Command{Use: "sub2"}
+				r.AddCommand(sub2)
+
+				sub21 := &Command{Use: "sub21"}
+				sub22 := &Command{Use: "sub22"}
+
+				sub2.AddCommand(sub21)
+				sub2.AddCommand(sub22)
 
 				return r
 			}(),
-			expectedExpressions: []string{
-				"sub1",
-			},
-		},
-		{
-			name: "hidden flags",
-			root: func() *Command {
-				var hidden string
-				r := &Command{
-					Use:   "root",
-					Short: "root short description",
-					Run:   emptyRun,
-				}
-				r.Flags().StringVarP(&hidden, "hidden", "H", hidden, "hidden usage")
-				if err := r.Flags().MarkHidden("hidden"); err != nil {
-					t.Errorf("Error setting flag hidden: %v\n", err)
-				}
-				return r
-			}(),
-			expectedExpressions: []string{
-				"--hidden",
-			},
+			expectedExpressions: []string{"(sub11 sub12)", "(sub21 sub22)"},
 		},
 	}
 
 	for _, tc := range tcs {
 		t.Run(tc.name, func(t *testing.T) {
-			tc.root.Execute()
 			buf := new(bytes.Buffer)
-			if err := tc.root.GenZshCompletion(buf); err != nil {
-				t.Error(err)
-			}
+			tc.root.GenZshCompletion(buf)
 			output := buf.String()
 
-			for _, expr := range tc.expectedExpressions {
-				if strings.Contains(output, expr) {
-					t.Errorf("Expected completion (%s) not to contain '%s' but it does", output, expr)
+			for _, expectedExpression := range tc.expectedExpressions {
+				if !strings.Contains(output, expectedExpression) {
+					t.Errorf("Expected completion to contain %q somewhere; got %q", expectedExpression, output)
 				}
 			}
 		})
 	}
 }
-
-func TestMarkZshCompPositionalArgumentFile(t *testing.T) {
-	t.Run("Doesn't allow overwriting existing positional argument", func(t *testing.T) {
-		c := &Command{}
-		if err := c.MarkZshCompPositionalArgumentFile(1, "*.log"); err != nil {
-			t.Errorf("Received error when we shouldn't have: %v\n", err)
-		}
-		if err := c.MarkZshCompPositionalArgumentFile(1); err == nil {
-			t.Error("Didn't receive an error when trying to overwrite argument position")
-		}
-	})
-
-	t.Run("Refuses to accept argPosition less then 1", func(t *testing.T) {
-		c := &Command{}
-		err := c.MarkZshCompPositionalArgumentFile(0, "*")
-		if err == nil {
-			t.Fatal("Error was not thrown when indicating argument position 0")
-		}
-		if !strings.Contains(err.Error(), "position") {
-			t.Errorf("expected error message '%s' to contain 'position'", err.Error())
-		}
-	})
-}
-
-func TestMarkZshCompPositionalArgumentWords(t *testing.T) {
-	t.Run("Doesn't allow overwriting existing positional argument", func(t *testing.T) {
-		c := &Command{}
-		if err := c.MarkZshCompPositionalArgumentFile(1, "*.log"); err != nil {
-			t.Errorf("Received error when we shouldn't have: %v\n", err)
-		}
-		if err := c.MarkZshCompPositionalArgumentWords(1, "hello"); err == nil {
-			t.Error("Didn't receive an error when trying to overwrite argument position")
-		}
-	})
-
-	t.Run("Doesn't allow calling without words", func(t *testing.T) {
-		c := &Command{}
-		if err := c.MarkZshCompPositionalArgumentWords(0); err == nil {
-			t.Error("Should not allow saving empty word list for annotation")
-		}
-	})
-
-	t.Run("Refuses to accept argPosition less then 1", func(t *testing.T) {
-		c := &Command{}
-		err := c.MarkZshCompPositionalArgumentWords(0, "word")
-		if err == nil {
-			t.Fatal("Should not allow setting argument position less then 1")
-		}
-		if !strings.Contains(err.Error(), "position") {
-			t.Errorf("Expected error '%s' to contain 'position' but didn't", err.Error())
-		}
-	})
-}
-
-func BenchmarkMediumSizeConstruct(b *testing.B) {
-	root := constructLargeCommandHierarchy()
-	// if err := root.GenZshCompletionFile("_mycmd"); err != nil {
-	// 	b.Error(err)
-	// }
-
-	for i := 0; i < b.N; i++ {
-		buf := new(bytes.Buffer)
-		err := root.GenZshCompletion(buf)
-		if err != nil {
-			b.Error(err)
-		}
-	}
-}
-
-func TestExtractFlags(t *testing.T) {
-	var debug, cmdc, cmdd bool
-	c := &Command{
-		Use:  "cmdC",
-		Long: "Command C",
-	}
-	c.PersistentFlags().BoolVarP(&debug, "debug", "d", debug, "debug mode")
-	c.Flags().BoolVar(&cmdc, "cmd-c", cmdc, "Command C")
-	d := &Command{
-		Use:  "CmdD",
-		Long: "Command D",
-	}
-	d.Flags().BoolVar(&cmdd, "cmd-d", cmdd, "Command D")
-	c.AddCommand(d)
-
-	resC := zshCompExtractFlag(c)
-	resD := zshCompExtractFlag(d)
-
-	if len(resC) != 2 {
-		t.Errorf("expected Command C to return 2 flags, got %d", len(resC))
-	}
-	if len(resD) != 2 {
-		t.Errorf("expected Command D to return 2 flags, got %d", len(resD))
-	}
-}
-
-func constructLargeCommandHierarchy() *Command {
-	var config, st1, st2 string
-	var long, debug bool
-	var in1, in2 int
-	var verbose []bool
-
-	r := genTestCommand("mycmd", false)
-	r.PersistentFlags().StringVarP(&config, "config", "c", config, "config usage")
-	if err := r.MarkPersistentFlagFilename("config", "*"); err != nil {
-		panic(err)
-	}
-	s1 := genTestCommand("sub1", true)
-	s1.Flags().BoolVar(&long, "long", long, "long description")
-	s1.Flags().BoolSliceVar(&verbose, "verbose", verbose, "verbose description")
-	s1.Flags().StringArray("option", []string{}, "various options")
-	s2 := genTestCommand("sub2", true)
-	s2.PersistentFlags().BoolVar(&debug, "debug", debug, "debug description")
-	s3 := genTestCommand("sub3", true)
-	s3.Hidden = true
-	s1_1 := genTestCommand("sub1sub1", true)
-	s1_1.Flags().StringVar(&st1, "st1", st1, "st1 description")
-	s1_1.Flags().StringVar(&st2, "st2", st2, "st2 description")
-	s1_2 := genTestCommand("sub1sub2", true)
-	s1_3 := genTestCommand("sub1sub3", true)
-	s1_3.Flags().IntVar(&in1, "int1", in1, "int1 description")
-	s1_3.Flags().IntVar(&in2, "int2", in2, "int2 description")
-	s1_3.Flags().StringArrayP("option", "O", []string{}, "more options")
-	s2_1 := genTestCommand("sub2sub1", true)
-	s2_2 := genTestCommand("sub2sub2", true)
-	s2_3 := genTestCommand("sub2sub3", true)
-	s2_4 := genTestCommand("sub2sub4", true)
-	s2_5 := genTestCommand("sub2sub5", true)
-
-	s1.AddCommand(s1_1, s1_2, s1_3)
-	s2.AddCommand(s2_1, s2_2, s2_3, s2_4, s2_5)
-	r.AddCommand(s1, s2, s3)
-	r.Execute()
-	return r
-}
-
-func genTestCommand(name string, withRun bool) *Command {
-	r := &Command{
-		Use:   name,
-		Short: name + " short description",
-		Long:  "Long description for " + name,
-	}
-	if withRun {
-		r.Run = emptyRun
-	}
-
-	return r
-}
