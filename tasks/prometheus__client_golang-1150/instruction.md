Prometheus client histograms need to support the experimental “sparse buckets” (native histogram) mode in addition to the existing classic bucketed histogram behavior.

Currently, creating and using a histogram via NewHistogram(HistogramOpts{...}) only produces the classic cumulative bucket representation. When users set any of the new sparse-bucket options in HistogramOpts (especially SparseBucketsFactor, and optionally SparseBucketsMaxNumber), the histogram should instead (or additionally, depending on options) track observations in sparse/exponential buckets and expose them correctly through Write(*dto.Metric).

The feature must be transparent unless a user opts in: with default HistogramOpts (and with only Buckets set), histogram behavior and output must remain unchanged.

When sparse buckets are enabled:
- NewHistogram(HistogramOpts{SparseBucketsFactor: <value>}) must create a histogram that accepts Observe(float64) calls and records them into sparse buckets.
- The output produced by Write must include the new-style bucket representation expected by Prometheus native histograms (along with count and sum as appropriate).
- Sparse bucket configuration must be validated. Invalid configurations should fail fast similarly to existing bucket validation (e.g., classic bucket bounds must be strictly increasing and have +Inf only as the last bound). Sparse bucket options should have analogous guardrails: factors must be valid (e.g., > 1), maximum bucket limits (if set) must be enforced, and any impossible/contradictory settings should result in a panic during construction rather than silently producing incorrect metrics.
- Concurrent Observe and Write calls must be safe and performant, as histograms are commonly used in hot paths. Enabling sparse buckets must not introduce races or corrupt output under concurrent observation and collection.

Expected behavior examples:
- Creating a histogram with non-monotonic classic Buckets (duplicates, descending order, or +Inf not last) must still panic during NewHistogram, unchanged.
- Creating a histogram with sparse buckets enabled should not require changes to Observe usage: calling Observe on a wide range of values (including very large values) should not overflow internal indexing or produce invalid bucket layouts.
- When SparseBucketsMaxNumber is configured, the histogram must not grow without bound in the number of tracked sparse buckets; it must respect the configured maximum while keeping count and sum correct.

Implement/adjust the relevant histogram types and their encoding so that dto.Metric generated by Write correctly represents either classic histograms (default) or sparse/native histograms (when opted in), and ensure existing classic-histogram semantics remain intact when sparse options are unused.