diff --git a/chainable_api.go b/chainable_api.go
index 68b4d1a..ab3a1a3 100644
--- a/chainable_api.go
+++ b/chainable_api.go
@@ -244,7 +244,7 @@ func (db *DB) Order(value interface{}) (tx *DB) {
 // Limit specify the number of records to be retrieved
 func (db *DB) Limit(limit int) (tx *DB) {
 	tx = db.getInstance()
-	tx.Statement.AddClause(clause.Limit{Limit: limit})
+	tx.Statement.AddClause(clause.Limit{Limit: &limit})
 	return
 }
 
diff --git a/clause/limit.go b/clause/limit.go
index 184f602..3ede738 100644
--- a/clause/limit.go
+++ b/clause/limit.go
@@ -4,7 +4,7 @@ import "strconv"
 
 // Limit limit clause
 type Limit struct {
-	Limit  int
+	Limit  *int
 	Offset int
 }
 
@@ -15,12 +15,12 @@ func (limit Limit) Name() string {
 
 // Build build where clause
 func (limit Limit) Build(builder Builder) {
-	if limit.Limit > 0 {
+	if limit.Limit != nil && *limit.Limit >= 0 {
 		builder.WriteString("LIMIT ")
-		builder.WriteString(strconv.Itoa(limit.Limit))
+		builder.WriteString(strconv.Itoa(*limit.Limit))
 	}
 	if limit.Offset > 0 {
-		if limit.Limit > 0 {
+		if limit.Limit != nil && *limit.Limit >= 0 {
 			builder.WriteByte(' ')
 		}
 		builder.WriteString("OFFSET ")
@@ -33,7 +33,7 @@ func (limit Limit) MergeClause(clause *Clause) {
 	clause.Name = ""
 
 	if v, ok := clause.Expression.(Limit); ok {
-		if limit.Limit == 0 && v.Limit != 0 {
+		if (limit.Limit == nil || *limit.Limit == 0) && (v.Limit != nil && *v.Limit != 0) {
 			limit.Limit = v.Limit
 		}
 
diff --git a/finisher_api.go b/finisher_api.go
index 835a698..5516c0a 100644
--- a/finisher_api.go
+++ b/finisher_api.go
@@ -185,7 +185,9 @@ func (db *DB) FindInBatches(dest interface{}, batchSize int, fc func(tx *DB, bat
 	var totalSize int
 	if c, ok := tx.Statement.Clauses["LIMIT"]; ok {
 		if limit, ok := c.Expression.(clause.Limit); ok {
-			totalSize = limit.Limit
+			if limit.Limit != nil {
+				totalSize = *limit.Limit
+			}
 
 			if totalSize > 0 && batchSize > totalSize {
 				batchSize = totalSize
