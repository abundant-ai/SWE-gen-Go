diff --git a/auth/jwt/transport.go b/auth/jwt/transport.go
index 57b3aae..7be7db4 100644
--- a/auth/jwt/transport.go
+++ b/auth/jwt/transport.go
@@ -17,9 +17,9 @@ const (
 	bearerFormat string = "Bearer %s"
 )
 
-// HTTPToContext moves a JWT from request header to context. Particularly
+// ToHTTPContext moves JWT token from request header to context. Particularly
 // useful for servers.
-func HTTPToContext() http.RequestFunc {
+func ToHTTPContext() http.RequestFunc {
 	return func(ctx context.Context, r *stdhttp.Request) context.Context {
 		token, ok := extractTokenFromAuthHeader(r.Header.Get("Authorization"))
 		if !ok {
@@ -30,9 +30,9 @@ func HTTPToContext() http.RequestFunc {
 	}
 }
 
-// ContextToHTTP moves a JWT from context to request header. Particularly
+// FromHTTPContext moves JWT token from context to request header. Particularly
 // useful for clients.
-func ContextToHTTP() http.RequestFunc {
+func FromHTTPContext() http.RequestFunc {
 	return func(ctx context.Context, r *stdhttp.Request) context.Context {
 		token, ok := ctx.Value(JWTTokenContextKey).(string)
 		if ok {
@@ -42,9 +42,9 @@ func ContextToHTTP() http.RequestFunc {
 	}
 }
 
-// GRPCToContext moves a JWT from grpc metadata to context. Particularly
+// ToGRPCContext moves JWT token from grpc metadata to context. Particularly
 // userful for servers.
-func GRPCToContext() grpc.ServerRequestFunc {
+func ToGRPCContext() grpc.ServerRequestFunc {
 	return func(ctx context.Context, md metadata.MD) context.Context {
 		// capital "Key" is illegal in HTTP/2.
 		authHeader, ok := md["authorization"]
@@ -61,9 +61,9 @@ func GRPCToContext() grpc.ServerRequestFunc {
 	}
 }
 
-// ContextToGRPC moves a JWT from context to grpc metadata. Particularly
+// FromGRPCContext moves JWT token from context to grpc metadata. Particularly
 // useful for clients.
-func ContextToGRPC() grpc.ClientRequestFunc {
+func FromGRPCContext() grpc.ClientRequestFunc {
 	return func(ctx context.Context, md *metadata.MD) context.Context {
 		token, ok := ctx.Value(JWTTokenContextKey).(string)
 		if ok {
diff --git a/auth/jwt/transport_test.go b/auth/jwt/transport_test.go
index 83d0f17..b04d76f 100644
--- a/auth/jwt/transport_test.go
+++ b/auth/jwt/transport_test.go
@@ -9,8 +9,8 @@ import (
 	"google.golang.org/grpc/metadata"
 )
 
-func TestHTTPToContext(t *testing.T) {
-	reqFunc := HTTPToContext()
+func TestToHTTPContext(t *testing.T) {
+	reqFunc := ToHTTPContext()
 
 	// When the header doesn't exist
 	ctx := reqFunc(context.Background(), &http.Request{})
@@ -38,8 +38,8 @@ func TestHTTPToContext(t *testing.T) {
 	}
 }
 
-func TestContextToHTTP(t *testing.T) {
-	reqFunc := ContextToHTTP()
+func TestFromHTTPContext(t *testing.T) {
+	reqFunc := FromHTTPContext()
 
 	// No JWT Token is passed in the context
 	ctx := context.Background()
@@ -64,9 +64,9 @@ func TestContextToHTTP(t *testing.T) {
 	}
 }
 
-func TestGRPCToContext(t *testing.T) {
+func TestToGRPCContext(t *testing.T) {
 	md := metadata.MD{}
-	reqFunc := GRPCToContext()
+	reqFunc := ToGRPCContext()
 
 	// No Authorization header is passed
 	ctx := reqFunc(context.Background(), md)
@@ -96,8 +96,8 @@ func TestGRPCToContext(t *testing.T) {
 	}
 }
 
-func TestContextToGRPC(t *testing.T) {
-	reqFunc := ContextToGRPC()
+func TestFromGRPCContext(t *testing.T) {
+	reqFunc := FromGRPCContext()
 
 	// No JWT Token is passed in the context
 	ctx := context.Background()
diff --git a/examples/addsvc/pkg/addtransport/grpc.go b/examples/addsvc/pkg/addtransport/grpc.go
index ec05baa..cfb4243 100644
--- a/examples/addsvc/pkg/addtransport/grpc.go
+++ b/examples/addsvc/pkg/addtransport/grpc.go
@@ -39,13 +39,13 @@ func NewGRPCServer(endpoints addendpoint.Set, tracer stdopentracing.Tracer, logg
 			endpoints.SumEndpoint,
 			decodeGRPCSumRequest,
 			encodeGRPCSumResponse,
-			append(options, grpctransport.ServerBefore(opentracing.GRPCToContext(tracer, "Sum", logger)))...,
+			append(options, grpctransport.ServerBefore(opentracing.FromGRPCRequest(tracer, "Sum", logger)))...,
 		),
 		concat: grpctransport.NewServer(
 			endpoints.ConcatEndpoint,
 			decodeGRPCConcatRequest,
 			encodeGRPCConcatResponse,
-			append(options, grpctransport.ServerBefore(opentracing.GRPCToContext(tracer, "Concat", logger)))...,
+			append(options, grpctransport.ServerBefore(opentracing.FromGRPCRequest(tracer, "Concat", logger)))...,
 		),
 	}
 }
@@ -91,7 +91,7 @@ func NewGRPCClient(conn *grpc.ClientConn, tracer stdopentracing.Tracer, logger l
 			encodeGRPCSumRequest,
 			decodeGRPCSumResponse,
 			pb.SumReply{},
-			grpctransport.ClientBefore(opentracing.ContextToGRPC(tracer, logger)),
+			grpctransport.ClientBefore(opentracing.ToGRPCRequest(tracer, logger)),
 		).Endpoint()
 		sumEndpoint = opentracing.TraceClient(tracer, "Sum")(sumEndpoint)
 		sumEndpoint = limiter(sumEndpoint)
@@ -112,7 +112,7 @@ func NewGRPCClient(conn *grpc.ClientConn, tracer stdopentracing.Tracer, logger l
 			encodeGRPCConcatRequest,
 			decodeGRPCConcatResponse,
 			pb.ConcatReply{},
-			grpctransport.ClientBefore(opentracing.ContextToGRPC(tracer, logger)),
+			grpctransport.ClientBefore(opentracing.ToGRPCRequest(tracer, logger)),
 		).Endpoint()
 		concatEndpoint = opentracing.TraceClient(tracer, "Concat")(concatEndpoint)
 		concatEndpoint = limiter(concatEndpoint)
diff --git a/examples/addsvc/pkg/addtransport/http.go b/examples/addsvc/pkg/addtransport/http.go
index ecdee92..9759d15 100644
--- a/examples/addsvc/pkg/addtransport/http.go
+++ b/examples/addsvc/pkg/addtransport/http.go
@@ -38,13 +38,13 @@ func NewHTTPHandler(endpoints addendpoint.Set, tracer stdopentracing.Tracer, log
 		endpoints.SumEndpoint,
 		decodeHTTPSumRequest,
 		encodeHTTPGenericResponse,
-		append(options, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "Sum", logger)))...,
+		append(options, httptransport.ServerBefore(opentracing.FromHTTPRequest(tracer, "Sum", logger)))...,
 	))
 	m.Handle("/concat", httptransport.NewServer(
 		endpoints.ConcatEndpoint,
 		decodeHTTPConcatRequest,
 		encodeHTTPGenericResponse,
-		append(options, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "Concat", logger)))...,
+		append(options, httptransport.ServerBefore(opentracing.FromHTTPRequest(tracer, "Concat", logger)))...,
 	))
 	return m
 }
@@ -81,7 +81,7 @@ func NewHTTPClient(instance string, tracer stdopentracing.Tracer, logger log.Log
 			copyURL(u, "/sum"),
 			encodeHTTPGenericRequest,
 			decodeHTTPSumResponse,
-			httptransport.ClientBefore(opentracing.ContextToHTTP(tracer, logger)),
+			httptransport.ClientBefore(opentracing.ToHTTPRequest(tracer, logger)),
 		).Endpoint()
 		sumEndpoint = opentracing.TraceClient(tracer, "Sum")(sumEndpoint)
 		sumEndpoint = limiter(sumEndpoint)
@@ -100,7 +100,7 @@ func NewHTTPClient(instance string, tracer stdopentracing.Tracer, logger log.Log
 			copyURL(u, "/concat"),
 			encodeHTTPGenericRequest,
 			decodeHTTPConcatResponse,
-			httptransport.ClientBefore(opentracing.ContextToHTTP(tracer, logger)),
+			httptransport.ClientBefore(opentracing.ToHTTPRequest(tracer, logger)),
 		).Endpoint()
 		concatEndpoint = opentracing.TraceClient(tracer, "Concat")(concatEndpoint)
 		concatEndpoint = limiter(concatEndpoint)
diff --git a/tracing/opentracing/grpc.go b/tracing/opentracing/grpc.go
index 0122d65..fa45440 100644
--- a/tracing/opentracing/grpc.go
+++ b/tracing/opentracing/grpc.go
@@ -12,10 +12,10 @@ import (
 	"github.com/go-kit/kit/log"
 )
 
-// ContextToGRPC returns a grpc RequestFunc that injects an OpenTracing Span
+// ToGRPCRequest returns a grpc RequestFunc that injects an OpenTracing Span
 // found in `ctx` into the grpc Metadata. If no such Span can be found, the
 // RequestFunc is a noop.
-func ContextToGRPC(tracer opentracing.Tracer, logger log.Logger) func(ctx context.Context, md *metadata.MD) context.Context {
+func ToGRPCRequest(tracer opentracing.Tracer, logger log.Logger) func(ctx context.Context, md *metadata.MD) context.Context {
 	return func(ctx context.Context, md *metadata.MD) context.Context {
 		if span := opentracing.SpanFromContext(ctx); span != nil {
 			// There's nothing we can do with an error here.
@@ -27,12 +27,12 @@ func ContextToGRPC(tracer opentracing.Tracer, logger log.Logger) func(ctx contex
 	}
 }
 
-// GRPCToContext returns a grpc RequestFunc that tries to join with an
+// FromGRPCRequest returns a grpc RequestFunc that tries to join with an
 // OpenTracing trace found in `req` and starts a new Span called
 // `operationName` accordingly. If no trace could be found in `req`, the Span
 // will be a trace root. The Span is incorporated in the returned Context and
 // can be retrieved with opentracing.SpanFromContext(ctx).
-func GRPCToContext(tracer opentracing.Tracer, operationName string, logger log.Logger) func(ctx context.Context, md metadata.MD) context.Context {
+func FromGRPCRequest(tracer opentracing.Tracer, operationName string, logger log.Logger) func(ctx context.Context, md metadata.MD) context.Context {
 	return func(ctx context.Context, md metadata.MD) context.Context {
 		var span opentracing.Span
 		wireContext, err := tracer.Extract(opentracing.TextMap, metadataReaderWriter{&md})
diff --git a/tracing/opentracing/grpc_test.go b/tracing/opentracing/grpc_test.go
index a36fa15..3d07a14 100644
--- a/tracing/opentracing/grpc_test.go
+++ b/tracing/opentracing/grpc_test.go
@@ -22,7 +22,7 @@ func TestTraceGRPCRequestRoundtrip(t *testing.T) {
 	beforeSpan.SetBaggageItem("baggage", "check")
 	beforeCtx := opentracing.ContextWithSpan(context.Background(), beforeSpan)
 
-	toGRPCFunc := kitot.ContextToGRPC(tracer, logger)
+	toGRPCFunc := kitot.ToGRPCRequest(tracer, logger)
 	md := metadata.Pairs()
 	// Call the RequestFunc.
 	afterCtx := toGRPCFunc(beforeCtx, &md)
@@ -39,8 +39,8 @@ func TestTraceGRPCRequestRoundtrip(t *testing.T) {
 		t.Errorf("Want %v span(s), found %v", want, have)
 	}
 
-	// Use GRPCToContext to verify that we can join with the trace given MD.
-	fromGRPCFunc := kitot.GRPCToContext(tracer, "joined", logger)
+	// Use FromGRPCRequest to verify that we can join with the trace given MD.
+	fromGRPCFunc := kitot.FromGRPCRequest(tracer, "joined", logger)
 	joinCtx := fromGRPCFunc(afterCtx, md)
 	joinedSpan := opentracing.SpanFromContext(joinCtx).(*mocktracer.MockSpan)
 
diff --git a/tracing/opentracing/http.go b/tracing/opentracing/http.go
index 09dd714..78286cd 100644
--- a/tracing/opentracing/http.go
+++ b/tracing/opentracing/http.go
@@ -13,10 +13,10 @@ import (
 	kithttp "github.com/go-kit/kit/transport/http"
 )
 
-// ContextToHTTP returns an http RequestFunc that injects an OpenTracing Span
+// ToHTTPRequest returns an http RequestFunc that injects an OpenTracing Span
 // found in `ctx` into the http headers. If no such Span can be found, the
 // RequestFunc is a noop.
-func ContextToHTTP(tracer opentracing.Tracer, logger log.Logger) kithttp.RequestFunc {
+func ToHTTPRequest(tracer opentracing.Tracer, logger log.Logger) kithttp.RequestFunc {
 	return func(ctx context.Context, req *http.Request) context.Context {
 		// Try to find a Span in the Context.
 		if span := opentracing.SpanFromContext(ctx); span != nil {
@@ -46,12 +46,12 @@ func ContextToHTTP(tracer opentracing.Tracer, logger log.Logger) kithttp.Request
 	}
 }
 
-// HTTPToContext returns an http RequestFunc that tries to join with an
+// FromHTTPRequest returns an http RequestFunc that tries to join with an
 // OpenTracing trace found in `req` and starts a new Span called
 // `operationName` accordingly. If no trace could be found in `req`, the Span
 // will be a trace root. The Span is incorporated in the returned Context and
 // can be retrieved with opentracing.SpanFromContext(ctx).
-func HTTPToContext(tracer opentracing.Tracer, operationName string, logger log.Logger) kithttp.RequestFunc {
+func FromHTTPRequest(tracer opentracing.Tracer, operationName string, logger log.Logger) kithttp.RequestFunc {
 	return func(ctx context.Context, req *http.Request) context.Context {
 		// Try to join to a trace propagated in `req`.
 		var span opentracing.Span
diff --git a/tracing/opentracing/http_test.go b/tracing/opentracing/http_test.go
index 548777e..61c1c16 100644
--- a/tracing/opentracing/http_test.go
+++ b/tracing/opentracing/http_test.go
@@ -24,7 +24,7 @@ func TestTraceHTTPRequestRoundtrip(t *testing.T) {
 	beforeSpan.SetBaggageItem("baggage", "check")
 	beforeCtx := opentracing.ContextWithSpan(context.Background(), beforeSpan)
 
-	toHTTPFunc := kitot.ContextToHTTP(tracer, logger)
+	toHTTPFunc := kitot.ToHTTPRequest(tracer, logger)
 	req, _ := http.NewRequest("GET", "http://test.biz/path", nil)
 	// Call the RequestFunc.
 	afterCtx := toHTTPFunc(beforeCtx, req)
@@ -41,8 +41,8 @@ func TestTraceHTTPRequestRoundtrip(t *testing.T) {
 		t.Errorf("Want %v span(s), found %v", want, have)
 	}
 
-	// Use HTTPToContext to verify that we can join with the trace given a req.
-	fromHTTPFunc := kitot.HTTPToContext(tracer, "joined", logger)
+	// Use FromHTTPRequest to verify that we can join with the trace given a req.
+	fromHTTPFunc := kitot.FromHTTPRequest(tracer, "joined", logger)
 	joinCtx := fromHTTPFunc(afterCtx, req)
 	joinedSpan := opentracing.SpanFromContext(joinCtx).(*mocktracer.MockSpan)
 
@@ -65,14 +65,14 @@ func TestTraceHTTPRequestRoundtrip(t *testing.T) {
 	}
 }
 
-func TestContextToHTTPTags(t *testing.T) {
+func TestToHTTPRequestTags(t *testing.T) {
 	tracer := mocktracer.New()
 	span := tracer.StartSpan("to_inject").(*mocktracer.MockSpan)
 	defer span.Finish()
 	ctx := opentracing.ContextWithSpan(context.Background(), span)
 	req, _ := http.NewRequest("GET", "http://test.biz/path", nil)
 
-	kitot.ContextToHTTP(tracer, log.NewNopLogger())(ctx, req)
+	kitot.ToHTTPRequest(tracer, log.NewNopLogger())(ctx, req)
 
 	expectedTags := map[string]interface{}{
 		string(ext.HTTPMethod):   "GET",
@@ -84,14 +84,14 @@ func TestContextToHTTPTags(t *testing.T) {
 	}
 }
 
-func TestHTTPToContextTags(t *testing.T) {
+func TestFromHTTPRequestTags(t *testing.T) {
 	tracer := mocktracer.New()
 	parentSpan := tracer.StartSpan("to_extract").(*mocktracer.MockSpan)
 	defer parentSpan.Finish()
 	req, _ := http.NewRequest("GET", "http://test.biz/path", nil)
 	tracer.Inject(parentSpan.Context(), opentracing.TextMap, opentracing.HTTPHeadersCarrier(req.Header))
 
-	ctx := kitot.HTTPToContext(tracer, "op", log.NewNopLogger())(context.Background(), req)
+	ctx := kitot.FromHTTPRequest(tracer, "op", log.NewNopLogger())(context.Background(), req)
 	opentracing.SpanFromContext(ctx).Finish()
 
 	childSpan := tracer.FinishedSpans()[0]
