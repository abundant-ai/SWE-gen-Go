diff --git a/bench_decode_test.go b/bench_decode_test.go
index 50e33908..de53064f 100644
--- a/bench_decode_test.go
+++ b/bench_decode_test.go
@@ -30,7 +30,6 @@ func NewClientStub(resp []byte) *ClientStub {
 		Dialer: func(ctx context.Context, network, addr string) (net.Conn, error) {
 			return stub.stubConn(initHello), nil
 		},
-		DisableIndentity: true,
 	})
 	return stub
 }
@@ -46,8 +45,6 @@ func NewClusterClientStub(resp []byte) *ClientStub {
 		Dialer: func(ctx context.Context, network, addr string) (net.Conn, error) {
 			return stub.stubConn(initHello), nil
 		},
-		DisableIndentity: true,
-
 		ClusterSlots: func(_ context.Context) ([]ClusterSlot, error) {
 			return []ClusterSlot{
 				{
diff --git a/cluster.go b/cluster.go
index b30e2263..941838dd 100644
--- a/cluster.go
+++ b/cluster.go
@@ -83,8 +83,7 @@ type ClusterOptions struct {
 	ConnMaxIdleTime time.Duration
 	ConnMaxLifetime time.Duration
 
-	TLSConfig        *tls.Config
-	DisableIndentity bool // Disable set-lib on connect. Default is false.
+	TLSConfig *tls.Config
 }
 
 func (opt *ClusterOptions) init() {
@@ -278,15 +277,15 @@ func (opt *ClusterOptions) clientOptions() *Options {
 		ReadTimeout:  opt.ReadTimeout,
 		WriteTimeout: opt.WriteTimeout,
 
-		PoolFIFO:         opt.PoolFIFO,
-		PoolSize:         opt.PoolSize,
-		PoolTimeout:      opt.PoolTimeout,
-		MinIdleConns:     opt.MinIdleConns,
-		MaxIdleConns:     opt.MaxIdleConns,
-		ConnMaxIdleTime:  opt.ConnMaxIdleTime,
-		ConnMaxLifetime:  opt.ConnMaxLifetime,
-		DisableIndentity: opt.DisableIndentity,
-		TLSConfig:        opt.TLSConfig,
+		PoolFIFO:        opt.PoolFIFO,
+		PoolSize:        opt.PoolSize,
+		PoolTimeout:     opt.PoolTimeout,
+		MinIdleConns:    opt.MinIdleConns,
+		MaxIdleConns:    opt.MaxIdleConns,
+		ConnMaxIdleTime: opt.ConnMaxIdleTime,
+		ConnMaxLifetime: opt.ConnMaxLifetime,
+
+		TLSConfig: opt.TLSConfig,
 		// If ClusterSlots is populated, then we probably have an artificial
 		// cluster whose nodes are not in clustering mode (otherwise there isn't
 		// much use for ClusterSlots config).  This means we cannot execute the
diff --git a/commands.go b/commands.go
index 2b2abfb7..4a3cd9ac 100644
--- a/commands.go
+++ b/commands.go
@@ -4,11 +4,9 @@ import (
 	"context"
 	"encoding"
 	"errors"
-	"fmt"
 	"io"
 	"net"
 	"reflect"
-	"runtime"
 	"strings"
 	"time"
 
@@ -586,8 +584,7 @@ func (c statefulCmdable) ClientSetInfo(ctx context.Context, info LibraryInfo) *S
 
 	var cmd *StatusCmd
 	if info.LibName != nil {
-		libName := fmt.Sprintf("go-redis(%s,%s)", *info.LibName, runtime.Version())
-		cmd = NewStatusCmd(ctx, "client", "setinfo", "LIB-NAME", libName)
+		cmd = NewStatusCmd(ctx, "client", "setinfo", "LIB-NAME", *info.LibName)
 	} else {
 		cmd = NewStatusCmd(ctx, "client", "setinfo", "LIB-VER", *info.LibVer)
 	}
diff --git a/commands_test.go b/commands_test.go
index b7744768..c8ea0f7b 100644
--- a/commands_test.go
+++ b/commands_test.go
@@ -2052,9 +2052,10 @@ var _ = Describe("Commands", func() {
 
 			logEntries, err := client.ACLLog(ctx, 10).Result()
 			Expect(err).NotTo(HaveOccurred())
-			Expect(len(logEntries)).To(Equal(4))
+			Expect(len(logEntries)).To(Equal(3))
 
 			for _, entry := range logEntries {
+				Expect(entry.Count).To(BeNumerically("==", 1))
 				Expect(entry.Reason).To(Equal("command"))
 				Expect(entry.Context).To(Equal("toplevel"))
 				Expect(entry.Object).NotTo(BeEmpty())
diff --git a/options.go b/options.go
index f10bad38..bb4816b2 100644
--- a/options.go
+++ b/options.go
@@ -136,9 +136,6 @@ type Options struct {
 
 	// Enables read only queries on slave/follower nodes.
 	readOnly bool
-
-	// // Disable set-lib on connect. Default is false.
-	DisableIndentity bool
 }
 
 func (opt *Options) init() {
diff --git a/redis.go b/redis.go
index 9430eb75..c7fbd0de 100644
--- a/redis.go
+++ b/redis.go
@@ -299,14 +299,7 @@ func (c *baseClient) initConn(ctx context.Context, cn *pool.Conn) error {
 		// difficult to rely on error strings to determine all results.
 		return err
 	}
-	if !c.opt.DisableIndentity {
-		libName := ""
-		libVer := Version()
-		libInfo := LibraryInfo{LibName: &libName}
-		conn.ClientSetInfo(ctx, libInfo)
-		libInfo = LibraryInfo{LibVer: &libVer}
-		conn.ClientSetInfo(ctx, libInfo)
-	}
+
 	_, err := conn.Pipelined(ctx, func(pipe Pipeliner) error {
 		if !auth && password != "" {
 			if username != "" {
