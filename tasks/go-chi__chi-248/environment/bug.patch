diff --git a/.travis.yml b/.travis.yml
index e9d2f4e..8776eb7 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,7 +3,6 @@ language: go
 go:
   - 1.7.x
   - 1.8.x
-  - 1.9.x
   - tip
 
 install:
diff --git a/README.md b/README.md
index 2d1712e..3315a62 100644
--- a/README.md
+++ b/README.md
@@ -24,7 +24,7 @@ included some useful/optional subpackages: [middleware](/middleware), [render](h
 
 ## Features
 
-* **Lightweight** - cloc'd in ~1000 LOC for the chi router
+* **Lightweight** - cloc'd in <1000 LOC for the chi router
 * **Fast** - yes, see [benchmarks](#benchmarks)
 * **100% compatible with net/http** - use any http or middleware pkg in the ecosystem that is also compatible with `net/http`
 * **Designed for modular/composable APIs** - middlewares, inline middlewares, route groups and subrouter mounting
@@ -316,7 +316,6 @@ with `net/http` can be used with chi's mux.
 | chi/middlware Handler | description                                                                     |
 |:----------------------|:---------------------------------------------------------------------------------
 | Compress              | Gzip compression for clients that accept compressed responses                   |
-| GetHead               | Automatically route undefined HEAD requests to GET handlers                     |
 | Heartbeat             | Monitoring endpoint to check the servers pulse                                  |
 | Logger                | Logs the start and end of each request with the elapsed processing time         |
 | NoCache               | Sets response headers to prevent clients from caching                           |
@@ -363,29 +362,27 @@ and..
 
 The benchmark suite: https://github.com/pkieltyka/go-http-routing-benchmark
 
-Results as of Aug 31, 2017 on Go 1.9.0
+Comparison with other routers (as of June 21, 2017): https://gist.github.com/pkieltyka/c089f309abeb179cfc4deaa519956d8c
 
 ```shell
-BenchmarkChi_Param        	 3000000	       607 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_Param5       	 2000000	       935 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_Param20      	 1000000	      1944 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_ParamWrite   	 2000000	       664 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_GithubStatic 	 2000000	       627 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_GithubParam  	 2000000	       847 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_GithubAll    	   10000	    175556 ns/op	   87700 B/op	     609 allocs/op
-BenchmarkChi_GPlusStatic  	 3000000	       566 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_GPlusParam   	 2000000	       652 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_GPlus2Params 	 2000000	       767 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_GPlusAll     	  200000	      9794 ns/op	    5616 B/op	      39 allocs/op
-BenchmarkChi_ParseStatic  	 3000000	       590 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_ParseParam   	 2000000	       656 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_Parse2Params 	 2000000	       715 ns/op	     432 B/op	       3 allocs/op
-BenchmarkChi_ParseAll     	  100000	     18045 ns/op	   11232 B/op	      78 allocs/op
-BenchmarkChi_StaticAll    	   10000	    108871 ns/op	   67827 B/op	     471 allocs/op
+BenchmarkChi_Param        	 3000000	       427 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_Param5       	 2000000	       631 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_Param20      	 1000000	      1343 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_ParamWrite   	 3000000	       477 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_GithubStatic 	 3000000	       452 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_GithubParam  	 2000000	       616 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_GithubAll    	   10000	    130637 ns/op	   61716 B/op	     406 allocs/op
+BenchmarkChi_GPlusStatic  	 3000000	       415 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_GPlusParam   	 3000000	       465 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_GPlus2Params 	 3000000	       548 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_GPlusAll     	  200000	      6895 ns/op	    3952 B/op	      26 allocs/op
+BenchmarkChi_ParseStatic  	 3000000	       407 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_ParseParam   	 3000000	       451 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_Parse2Params 	 3000000	       504 ns/op	     304 B/op	       2 allocs/op
+BenchmarkChi_ParseAll     	  100000	     13221 ns/op	    7904 B/op	      52 allocs/op
+BenchmarkChi_StaticAll    	   20000	     84327 ns/op	   47731 B/op	     314 allocs/op
 ```
 
-Comparison with other routers: https://gist.github.com/pkieltyka/c089f309abeb179cfc4deaa519956d8c
-
 NOTE: the allocs in the benchmark above are from the calls to http.Request's
 `WithContext(context.Context)` method that clones the http.Request, sets the `Context()`
 on the duplicated (alloc'd) request and returns it the new request object. This is just
diff --git a/chi.go b/chi.go
index 393e433..9f8d38a 100644
--- a/chi.go
+++ b/chi.go
@@ -96,11 +96,6 @@ type Routes interface {
 
 	// Middlewares returns the list of middlewares in use by the router.
 	Middlewares() Middlewares
-
-	// Match searches the routing tree for a handler that matches
-	// the method/path - similar to routing a http request, but without
-	// executing the handler thereafter.
-	Match(rctx *Context, method, path string) bool
 }
 
 // Middlewares type is a slice of standard middleware handlers with methods
diff --git a/context.go b/context.go
index 30c5afe..155dcc9 100644
--- a/context.go
+++ b/context.go
@@ -16,12 +16,9 @@ var (
 // request context to track route patterns, URL parameters and
 // an optional routing path.
 type Context struct {
-	Routes Routes
-
-	// Routing path/method override used during the route search.
+	// Routing path override used during the route search.
 	// See Mux#routeHTTP method.
-	RoutePath   string
-	RouteMethod string
+	RoutePath string
 
 	// Routing pattern stack throughout the lifecycle of the request,
 	// across all connected routers. It is a record of all matching
@@ -51,11 +48,9 @@ func NewRouteContext() *Context {
 	return &Context{}
 }
 
-// Reset a routing context to its initial state.
-func (x *Context) Reset() {
-	x.Routes = nil
+// reset a routing context to its initial state.
+func (x *Context) reset() {
 	x.RoutePath = ""
-	x.RouteMethod = ""
 	x.RoutePatterns = x.RoutePatterns[:0]
 	x.URLParams.Keys = x.URLParams.Keys[:0]
 	x.URLParams.Values = x.URLParams.Values[:0]
diff --git a/middleware/get_head.go b/middleware/get_head.go
deleted file mode 100644
index 32b8dbb..0000000
--- a/middleware/get_head.go
+++ /dev/null
@@ -1,38 +0,0 @@
-package middleware
-
-import (
-	"net/http"
-
-	"github.com/go-chi/chi"
-)
-
-func GetHead(next http.Handler) http.Handler {
-	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		if r.Method == "HEAD" {
-			rctx := chi.RouteContext(r.Context())
-			routePath := rctx.RoutePath
-			if routePath == "" {
-				if r.URL.RawPath != "" {
-					routePath = r.URL.RawPath
-				} else {
-					routePath = r.URL.Path
-				}
-			}
-
-			// Temporary routing context to look-ahead before routing the request
-			tctx := chi.NewRouteContext()
-
-			// Attempt to find a HEAD handler for the routing path, if not found, traverse
-			// the router as through its a GET route, but proceed with the request
-			// with the HEAD method.
-			if !rctx.Routes.Match(tctx, "HEAD", routePath) {
-				rctx.RouteMethod = "GET"
-				rctx.RoutePath = routePath
-				next.ServeHTTP(w, r)
-				return
-			}
-		}
-
-		next.ServeHTTP(w, r)
-	})
-}
diff --git a/middleware/get_head_test.go b/middleware/get_head_test.go
deleted file mode 100644
index edfeb5b..0000000
--- a/middleware/get_head_test.go
+++ /dev/null
@@ -1,66 +0,0 @@
-package middleware
-
-import (
-	"net/http"
-	"net/http/httptest"
-	"testing"
-
-	"github.com/go-chi/chi"
-)
-
-func TestGetHead(t *testing.T) {
-	r := chi.NewRouter()
-	r.Use(GetHead)
-	r.Get("/hi", func(w http.ResponseWriter, r *http.Request) {
-		w.Header().Set("X-Test", "yes")
-		w.Write([]byte("bye"))
-	})
-	r.Route("/articles", func(r chi.Router) {
-		r.Get("/{id}", func(w http.ResponseWriter, r *http.Request) {
-			id := chi.URLParam(r, "id")
-			w.Header().Set("X-Article", id)
-			w.Write([]byte("article:" + id))
-		})
-	})
-	r.Route("/users", func(r chi.Router) {
-		r.Head("/{id}", func(w http.ResponseWriter, r *http.Request) {
-			w.Header().Set("X-User", "-")
-			w.Write([]byte("user"))
-		})
-		r.Get("/{id}", func(w http.ResponseWriter, r *http.Request) {
-			id := chi.URLParam(r, "id")
-			w.Header().Set("X-User", id)
-			w.Write([]byte("user:" + id))
-		})
-	})
-
-	ts := httptest.NewServer(r)
-	defer ts.Close()
-
-	if _, body := testRequest(t, ts, "GET", "/hi", nil); body != "bye" {
-		t.Fatalf(body)
-	}
-	if req, body := testRequest(t, ts, "HEAD", "/hi", nil); body != "" || req.Header.Get("X-Test") != "yes" {
-		t.Fatalf(body)
-	}
-	if _, body := testRequest(t, ts, "GET", "/", nil); body != "404 page not found\n" {
-		t.Fatalf(body)
-	}
-	if req, body := testRequest(t, ts, "HEAD", "/", nil); body != "" || req.StatusCode != 404 {
-		t.Fatalf(body)
-	}
-
-	if _, body := testRequest(t, ts, "GET", "/articles/5", nil); body != "article:5" {
-		t.Fatalf(body)
-	}
-	if req, body := testRequest(t, ts, "HEAD", "/articles/5", nil); body != "" || req.Header.Get("X-Article") != "5" {
-		t.Fatalf("expecting X-Article header '5' but got '%s'", req.Header.Get("X-Article"))
-	}
-
-	if _, body := testRequest(t, ts, "GET", "/users/1", nil); body != "user:1" {
-		t.Fatalf(body)
-	}
-	if req, body := testRequest(t, ts, "HEAD", "/users/1", nil); body != "" || req.Header.Get("X-User") != "-" {
-		t.Fatalf("expecting X-User header '-' but got '%s'", req.Header.Get("X-User"))
-	}
-}
diff --git a/middleware/middleware_test.go b/middleware/middleware_test.go
index e004b29..1c0925d 100644
--- a/middleware/middleware_test.go
+++ b/middleware/middleware_test.go
@@ -22,27 +22,27 @@ func init() {
 	testdataDir = path.Join(path.Dir(filename), "/../testdata")
 }
 
-func testRequest(t *testing.T, ts *httptest.Server, method, path string, body io.Reader) (*http.Response, string) {
+func testRequest(t *testing.T, ts *httptest.Server, method, path string, body io.Reader) (int, string) {
 	req, err := http.NewRequest(method, ts.URL+path, body)
 	if err != nil {
 		t.Fatal(err)
-		return nil, ""
+		return 0, ""
 	}
 
 	resp, err := http.DefaultClient.Do(req)
 	if err != nil {
 		t.Fatal(err)
-		return nil, ""
+		return resp.StatusCode, ""
 	}
 
 	respBody, err := ioutil.ReadAll(resp.Body)
 	if err != nil {
 		t.Fatal(err)
-		return nil, ""
+		return resp.StatusCode, ""
 	}
 	defer resp.Body.Close()
 
-	return resp, string(respBody)
+	return resp.StatusCode, string(respBody)
 }
 
 func assertNoError(t *testing.T, err error) {
diff --git a/middleware/strip_test.go b/middleware/strip_test.go
index f54479e..08affb4 100644
--- a/middleware/strip_test.go
+++ b/middleware/strip_test.go
@@ -114,25 +114,25 @@ func TestRedirectSlashes(t *testing.T) {
 	ts := httptest.NewServer(r)
 	defer ts.Close()
 
-	if req, resp := testRequest(t, ts, "GET", "/", nil); resp != "root" && req.StatusCode != 200 {
+	if status, resp := testRequest(t, ts, "GET", "/", nil); resp != "root" && status != 200 {
 		t.Fatalf(resp)
 	}
 
 	// NOTE: the testRequest client will follow the redirection..
-	if req, resp := testRequest(t, ts, "GET", "//", nil); resp != "root" && req.StatusCode != 200 {
+	if status, resp := testRequest(t, ts, "GET", "//", nil); resp != "root" && status != 200 {
 		t.Fatalf(resp)
 	}
 
-	if req, resp := testRequest(t, ts, "GET", "/accounts/admin", nil); resp != "admin" && req.StatusCode != 200 {
+	if status, resp := testRequest(t, ts, "GET", "/accounts/admin", nil); resp != "admin" && status != 200 {
 		t.Fatalf(resp)
 	}
 
 	// NOTE: the testRequest client will follow the redirection..
-	if req, resp := testRequest(t, ts, "GET", "/accounts/admin/", nil); resp != "admin" && req.StatusCode != 200 {
+	if status, resp := testRequest(t, ts, "GET", "/accounts/admin/", nil); resp != "admin" && status != 200 {
 		t.Fatalf(resp)
 	}
 
-	if req, resp := testRequest(t, ts, "GET", "/nothing-here", nil); resp != "nothing here" && req.StatusCode != 200 {
+	if status, resp := testRequest(t, ts, "GET", "/nothing-here", nil); resp != "nothing here" && status != 200 {
 		t.Fatalf(resp)
 	}
 }
diff --git a/mux.go b/mux.go
index ee6af83..b2f7e2a 100644
--- a/mux.go
+++ b/mux.go
@@ -75,8 +75,7 @@ func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 	// Once the request is finished, reset the routing context and put it back
 	// into the pool for reuse from another request.
 	rctx = mx.pool.Get().(*Context)
-	rctx.Reset()
-	rctx.Routes = mx
+	rctx.reset()
 	r = r.WithContext(context.WithValue(r.Context(), RouteCtxKey, rctx))
 	mx.handler.ServeHTTP(w, r)
 	mx.pool.Put(rctx)
@@ -270,7 +269,7 @@ func (mx *Mux) Route(pattern string, fn func(r Router)) Router {
 func (mx *Mux) Mount(pattern string, handler http.Handler) {
 	// Provide runtime safety for ensuring a pattern isn't mounted on an existing
 	// routing pattern.
-	if mx.tree.findPattern(pattern+"*") || mx.tree.findPattern(pattern+"/*") {
+	if mx.tree.matchPattern(pattern+"*") || mx.tree.matchPattern(pattern+"/*") {
 		panic(fmt.Sprintf("chi: attempting to Mount() a handler on an existing path, '%s'", pattern))
 	}
 
@@ -286,7 +285,13 @@ func (mx *Mux) Mount(pattern string, handler http.Handler) {
 	// Wrap the sub-router in a handlerFunc to scope the request path for routing.
 	mountHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		rctx := RouteContext(r.Context())
-		rctx.RoutePath = mx.nextRoutePath(rctx)
+		rctx.RoutePath = "/"
+
+		nx := len(rctx.routeParams.Keys) - 1 // index of last param in list
+		if nx >= 0 && rctx.routeParams.Keys[nx] == "*" && len(rctx.routeParams.Values) > nx {
+			rctx.RoutePath += rctx.routeParams.Values[nx]
+		}
+
 		handler.ServeHTTP(w, r)
 	})
 
@@ -312,37 +317,15 @@ func (mx *Mux) Mount(pattern string, handler http.Handler) {
 	}
 }
 
-// Routes returns a slice of routing information from the tree,
-// useful for traversing available routes of a router.
-func (mx *Mux) Routes() []Route {
-	return mx.tree.routes()
-}
-
 // Middlewares returns a slice of middleware handler functions.
 func (mx *Mux) Middlewares() Middlewares {
 	return mx.middlewares
 }
 
-// Match searches the routing tree for a handler that matches the method/path.
-// It's similar to routing a http request, but without executing the handler
-// thereafter.
-//
-// Note: the *Context state is updated during execution, so manage
-// the state carefully or make a NewRouteContext().
-func (mx *Mux) Match(rctx *Context, method, path string) bool {
-	m, ok := methodMap[method]
-	if !ok {
-		return false
-	}
-
-	node, _, h := mx.tree.FindRoute(rctx, m, path)
-
-	if node != nil && node.subroutes != nil {
-		rctx.RoutePath = mx.nextRoutePath(rctx)
-		return node.subroutes.Match(rctx, method, rctx.RoutePath)
-	}
-
-	return h != nil
+// Routes returns a slice of routing information from the tree,
+// useful for traversing available routes of a router.
+func (mx *Mux) Routes() []Route {
+	return mx.tree.routes()
 }
 
 // NotFoundHandler returns the default Mux 404 responder whenever a route
@@ -413,20 +396,26 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	}
 
 	// Check if method is supported by chi
-	if rctx.RouteMethod == "" {
-		rctx.RouteMethod = r.Method
-	}
-	method, ok := methodMap[rctx.RouteMethod]
+	method, ok := methodMap[r.Method]
 	if !ok {
 		mx.MethodNotAllowedHandler().ServeHTTP(w, r)
 		return
 	}
 
 	// Find the route
-	if _, _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
+	if _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
 		h.ServeHTTP(w, r)
 		return
 	}
+	if method == mHEAD {
+		// Try again with GET for HEAD
+		method = mGET
+		if _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
+			h.ServeHTTP(w, r)
+			return
+		}
+	}
+
 	if rctx.methodNotAllowed {
 		mx.MethodNotAllowedHandler().ServeHTTP(w, r)
 	} else {
@@ -434,15 +423,6 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	}
 }
 
-func (mx *Mux) nextRoutePath(rctx *Context) string {
-	routePath := "/"
-	nx := len(rctx.routeParams.Keys) - 1 // index of last param in list
-	if nx >= 0 && rctx.routeParams.Keys[nx] == "*" && len(rctx.routeParams.Values) > nx {
-		routePath += rctx.routeParams.Values[nx]
-	}
-	return routePath
-}
-
 // Recursively update data on child routers.
 func (mx *Mux) updateSubRoutes(fn func(subMux *Mux)) {
 	for _, r := range mx.tree.routes() {
diff --git a/mux_test.go b/mux_test.go
index 58d039c..c6e4d52 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -712,6 +712,32 @@ func TestMuxRouteGroups(t *testing.T) {
 	if stdmwInit2 != 1 || stdmwHandler2 != 1 {
 		t.Fatalf("stdmw2 counters failed, should be 1:1, got %d:%d", stdmwInit2, stdmwHandler2)
 	}
+
+}
+
+func TestMuxHeadGet(t *testing.T) {
+	r := NewRouter()
+	r.Get("/hi", func(w http.ResponseWriter, r *http.Request) {
+		w.Header().Set("X-Test", "yes")
+		w.Write([]byte("bye"))
+	})
+
+	ts := httptest.NewServer(r)
+	defer ts.Close()
+
+	if _, body := testRequest(t, ts, "GET", "/hi", nil); body != "bye" {
+		t.Fatalf(body)
+	}
+	if req, body := testRequest(t, ts, "HEAD", "/hi", nil); body != "" || req.Header.Get("X-Test") != "yes" {
+		t.Fatalf(body)
+	}
+	if _, body := testRequest(t, ts, "GET", "/", nil); body != "404 page not found\n" {
+		t.Fatalf(body)
+	}
+	if req, body := testRequest(t, ts, "HEAD", "/", nil); body != "" || req.StatusCode != 404 {
+		t.Fatalf(body)
+	}
+
 }
 
 func TestMuxBig(t *testing.T) {
@@ -1434,44 +1460,6 @@ func TestEscapedURLParams(t *testing.T) {
 	}
 }
 
-func TestMuxMatch(t *testing.T) {
-	r := NewRouter()
-	r.Get("/hi", func(w http.ResponseWriter, r *http.Request) {
-		w.Header().Set("X-Test", "yes")
-		w.Write([]byte("bye"))
-	})
-	r.Route("/articles", func(r Router) {
-		r.Get("/{id}", func(w http.ResponseWriter, r *http.Request) {
-			id := URLParam(r, "id")
-			w.Header().Set("X-Article", id)
-			w.Write([]byte("article:" + id))
-		})
-	})
-	r.Route("/users", func(r Router) {
-		r.Head("/{id}", func(w http.ResponseWriter, r *http.Request) {
-			w.Header().Set("X-User", "-")
-			w.Write([]byte("user"))
-		})
-		r.Get("/{id}", func(w http.ResponseWriter, r *http.Request) {
-			id := URLParam(r, "id")
-			w.Header().Set("X-User", id)
-			w.Write([]byte("user:" + id))
-		})
-	})
-
-	tctx := NewRouteContext()
-
-	tctx.Reset()
-	if r.Match(tctx, "GET", "/users/1") == false {
-		t.Fatal("expecting to find match for route:", "GET", "/users/1")
-	}
-
-	tctx.Reset()
-	if r.Match(tctx, "HEAD", "/articles/10") == true {
-		t.Fatal("not expecting to find match for route:", "HEAD", "/articles/10")
-	}
-}
-
 func TestServerBaseContext(t *testing.T) {
 	r := NewRouter()
 	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
diff --git a/tree.go b/tree.go
index b5021e4..c2f6438 100644
--- a/tree.go
+++ b/tree.go
@@ -341,7 +341,7 @@ func (n *node) setEndpoint(method methodTyp, handler http.Handler, pattern strin
 	}
 }
 
-func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, endpoints, http.Handler) {
+func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (endpoints, http.Handler) {
 	// Reset the context routing pattern and params
 	rctx.routePattern = ""
 	rctx.routeParams.Keys = rctx.routeParams.Keys[:0]
@@ -350,7 +350,7 @@ func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, e
 	// Find the routing handlers for the path
 	rn := n.findRoute(rctx, method, path)
 	if rn == nil {
-		return nil, nil, nil
+		return nil, nil
 	}
 
 	// Record the routing params in the request lifecycle
@@ -363,7 +363,7 @@ func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, e
 		rctx.RoutePatterns = append(rctx.RoutePatterns, rctx.routePattern)
 	}
 
-	return rn, rn.endpoints, rn.endpoints[method].handler
+	return rn.endpoints, rn.endpoints[method].handler
 }
 
 // Recursive edge traversal by checking all nodeTyp groups along the way.
@@ -514,7 +514,7 @@ func (n *node) isLeaf() bool {
 	return n.endpoints != nil
 }
 
-func (n *node) findPattern(pattern string) bool {
+func (n *node) matchPattern(pattern string) bool {
 	nn := n
 	for _, nds := range nn.children {
 		if len(nds) == 0 {
@@ -551,7 +551,7 @@ func (n *node) findPattern(pattern string) bool {
 			return true
 		}
 
-		return n.findPattern(xpattern)
+		return n.matchPattern(xpattern)
 	}
 	return false
 }
diff --git a/tree_test.go b/tree_test.go
index 11dfd14..096d940 100644
--- a/tree_test.go
+++ b/tree_test.go
@@ -129,7 +129,7 @@ func TestTree(t *testing.T) {
 	for i, tt := range tests {
 		rctx := NewRouteContext()
 
-		_, handlers, _ := tr.FindRoute(rctx, mGET, tt.r)
+		handlers, _ := tr.FindRoute(rctx, mGET, tt.r)
 
 		var handler http.Handler
 		if methodHandler, ok := handlers[mGET]; ok {
@@ -245,7 +245,7 @@ func TestTreeMoar(t *testing.T) {
 	for i, tt := range tests {
 		rctx := NewRouteContext()
 
-		_, handlers, _ := tr.FindRoute(rctx, tt.m, tt.r)
+		handlers, _ := tr.FindRoute(rctx, tt.m, tt.r)
 
 		var handler http.Handler
 		if methodHandler, ok := handlers[tt.m]; ok {
@@ -311,7 +311,7 @@ func TestTreeRegexp(t *testing.T) {
 	for i, tt := range tests {
 		rctx := NewRouteContext()
 
-		_, handlers, _ := tr.FindRoute(rctx, mGET, tt.r)
+		handlers, _ := tr.FindRoute(rctx, mGET, tt.r)
 
 		var handler http.Handler
 		if methodHandler, ok := handlers[mGET]; ok {
@@ -333,7 +333,7 @@ func TestTreeRegexp(t *testing.T) {
 	}
 }
 
-func TestTreeFindPattern(t *testing.T) {
+func TestTreeMatchPattern(t *testing.T) {
 	hStub1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})
 	hStub2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})
 	hStub3 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})
@@ -343,22 +343,22 @@ func TestTreeFindPattern(t *testing.T) {
 	tr.InsertRoute(mGET, "/articles/{id}/*", hStub2)
 	tr.InsertRoute(mGET, "/articles/{slug}/{uid}/*", hStub3)
 
-	if tr.findPattern("/pages") != false {
+	if tr.matchPattern("/pages") != false {
 		t.Errorf("find /pages failed")
 	}
-	if tr.findPattern("/pages*") != false {
+	if tr.matchPattern("/pages*") != false {
 		t.Errorf("find /pages* failed - should be nil")
 	}
-	if tr.findPattern("/pages/*") == false {
+	if tr.matchPattern("/pages/*") == false {
 		t.Errorf("find /pages/* failed")
 	}
-	if tr.findPattern("/articles/{id}/*") == false {
+	if tr.matchPattern("/articles/{id}/*") == false {
 		t.Errorf("find /articles/{id}/* failed")
 	}
-	if tr.findPattern("/articles/{something}/*") == false {
+	if tr.matchPattern("/articles/{something}/*") == false {
 		t.Errorf("find /articles/{something}/* failed")
 	}
-	if tr.findPattern("/articles/{slug}/{uid}/*") == false {
+	if tr.matchPattern("/articles/{slug}/{uid}/*") == false {
 		t.Errorf("find /articles/{slug}/{uid}/* failed")
 	}
 }
@@ -423,7 +423,7 @@ func BenchmarkTreeGet(b *testing.B) {
 	b.ResetTimer()
 
 	for i := 0; i < b.N; i++ {
-		mctx.Reset()
+		mctx.reset()
 		tr.FindRoute(mctx, mGET, "/ping/123/456")
 	}
 }
