diff --git a/.travis.yml b/.travis.yml
index 8776eb7..e9d2f4e 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,6 +3,7 @@ language: go
 go:
   - 1.7.x
   - 1.8.x
+  - 1.9.x
   - tip
 
 install:
diff --git a/README.md b/README.md
index 3315a62..2d1712e 100644
--- a/README.md
+++ b/README.md
@@ -24,7 +24,7 @@ included some useful/optional subpackages: [middleware](/middleware), [render](h
 
 ## Features
 
-* **Lightweight** - cloc'd in <1000 LOC for the chi router
+* **Lightweight** - cloc'd in ~1000 LOC for the chi router
 * **Fast** - yes, see [benchmarks](#benchmarks)
 * **100% compatible with net/http** - use any http or middleware pkg in the ecosystem that is also compatible with `net/http`
 * **Designed for modular/composable APIs** - middlewares, inline middlewares, route groups and subrouter mounting
@@ -316,6 +316,7 @@ with `net/http` can be used with chi's mux.
 | chi/middlware Handler | description                                                                     |
 |:----------------------|:---------------------------------------------------------------------------------
 | Compress              | Gzip compression for clients that accept compressed responses                   |
+| GetHead               | Automatically route undefined HEAD requests to GET handlers                     |
 | Heartbeat             | Monitoring endpoint to check the servers pulse                                  |
 | Logger                | Logs the start and end of each request with the elapsed processing time         |
 | NoCache               | Sets response headers to prevent clients from caching                           |
@@ -362,27 +363,29 @@ and..
 
 The benchmark suite: https://github.com/pkieltyka/go-http-routing-benchmark
 
-Comparison with other routers (as of June 21, 2017): https://gist.github.com/pkieltyka/c089f309abeb179cfc4deaa519956d8c
+Results as of Aug 31, 2017 on Go 1.9.0
 
 ```shell
-BenchmarkChi_Param        	 3000000	       427 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_Param5       	 2000000	       631 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_Param20      	 1000000	      1343 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_ParamWrite   	 3000000	       477 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_GithubStatic 	 3000000	       452 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_GithubParam  	 2000000	       616 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_GithubAll    	   10000	    130637 ns/op	   61716 B/op	     406 allocs/op
-BenchmarkChi_GPlusStatic  	 3000000	       415 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_GPlusParam   	 3000000	       465 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_GPlus2Params 	 3000000	       548 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_GPlusAll     	  200000	      6895 ns/op	    3952 B/op	      26 allocs/op
-BenchmarkChi_ParseStatic  	 3000000	       407 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_ParseParam   	 3000000	       451 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_Parse2Params 	 3000000	       504 ns/op	     304 B/op	       2 allocs/op
-BenchmarkChi_ParseAll     	  100000	     13221 ns/op	    7904 B/op	      52 allocs/op
-BenchmarkChi_StaticAll    	   20000	     84327 ns/op	   47731 B/op	     314 allocs/op
+BenchmarkChi_Param        	 3000000	       607 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_Param5       	 2000000	       935 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_Param20      	 1000000	      1944 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_ParamWrite   	 2000000	       664 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_GithubStatic 	 2000000	       627 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_GithubParam  	 2000000	       847 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_GithubAll    	   10000	    175556 ns/op	   87700 B/op	     609 allocs/op
+BenchmarkChi_GPlusStatic  	 3000000	       566 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_GPlusParam   	 2000000	       652 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_GPlus2Params 	 2000000	       767 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_GPlusAll     	  200000	      9794 ns/op	    5616 B/op	      39 allocs/op
+BenchmarkChi_ParseStatic  	 3000000	       590 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_ParseParam   	 2000000	       656 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_Parse2Params 	 2000000	       715 ns/op	     432 B/op	       3 allocs/op
+BenchmarkChi_ParseAll     	  100000	     18045 ns/op	   11232 B/op	      78 allocs/op
+BenchmarkChi_StaticAll    	   10000	    108871 ns/op	   67827 B/op	     471 allocs/op
 ```
 
+Comparison with other routers: https://gist.github.com/pkieltyka/c089f309abeb179cfc4deaa519956d8c
+
 NOTE: the allocs in the benchmark above are from the calls to http.Request's
 `WithContext(context.Context)` method that clones the http.Request, sets the `Context()`
 on the duplicated (alloc'd) request and returns it the new request object. This is just
diff --git a/chi.go b/chi.go
index 9f8d38a..393e433 100644
--- a/chi.go
+++ b/chi.go
@@ -96,6 +96,11 @@ type Routes interface {
 
 	// Middlewares returns the list of middlewares in use by the router.
 	Middlewares() Middlewares
+
+	// Match searches the routing tree for a handler that matches
+	// the method/path - similar to routing a http request, but without
+	// executing the handler thereafter.
+	Match(rctx *Context, method, path string) bool
 }
 
 // Middlewares type is a slice of standard middleware handlers with methods
diff --git a/context.go b/context.go
index 155dcc9..30c5afe 100644
--- a/context.go
+++ b/context.go
@@ -16,9 +16,12 @@ var (
 // request context to track route patterns, URL parameters and
 // an optional routing path.
 type Context struct {
-	// Routing path override used during the route search.
+	Routes Routes
+
+	// Routing path/method override used during the route search.
 	// See Mux#routeHTTP method.
-	RoutePath string
+	RoutePath   string
+	RouteMethod string
 
 	// Routing pattern stack throughout the lifecycle of the request,
 	// across all connected routers. It is a record of all matching
@@ -48,9 +51,11 @@ func NewRouteContext() *Context {
 	return &Context{}
 }
 
-// reset a routing context to its initial state.
-func (x *Context) reset() {
+// Reset a routing context to its initial state.
+func (x *Context) Reset() {
+	x.Routes = nil
 	x.RoutePath = ""
+	x.RouteMethod = ""
 	x.RoutePatterns = x.RoutePatterns[:0]
 	x.URLParams.Keys = x.URLParams.Keys[:0]
 	x.URLParams.Values = x.URLParams.Values[:0]
diff --git a/middleware/get_head.go b/middleware/get_head.go
new file mode 100644
index 0000000..32b8dbb
--- /dev/null
+++ b/middleware/get_head.go
@@ -0,0 +1,38 @@
+package middleware
+
+import (
+	"net/http"
+
+	"github.com/go-chi/chi"
+)
+
+func GetHead(next http.Handler) http.Handler {
+	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		if r.Method == "HEAD" {
+			rctx := chi.RouteContext(r.Context())
+			routePath := rctx.RoutePath
+			if routePath == "" {
+				if r.URL.RawPath != "" {
+					routePath = r.URL.RawPath
+				} else {
+					routePath = r.URL.Path
+				}
+			}
+
+			// Temporary routing context to look-ahead before routing the request
+			tctx := chi.NewRouteContext()
+
+			// Attempt to find a HEAD handler for the routing path, if not found, traverse
+			// the router as through its a GET route, but proceed with the request
+			// with the HEAD method.
+			if !rctx.Routes.Match(tctx, "HEAD", routePath) {
+				rctx.RouteMethod = "GET"
+				rctx.RoutePath = routePath
+				next.ServeHTTP(w, r)
+				return
+			}
+		}
+
+		next.ServeHTTP(w, r)
+	})
+}
diff --git a/mux.go b/mux.go
index b2f7e2a..ee6af83 100644
--- a/mux.go
+++ b/mux.go
@@ -75,7 +75,8 @@ func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 	// Once the request is finished, reset the routing context and put it back
 	// into the pool for reuse from another request.
 	rctx = mx.pool.Get().(*Context)
-	rctx.reset()
+	rctx.Reset()
+	rctx.Routes = mx
 	r = r.WithContext(context.WithValue(r.Context(), RouteCtxKey, rctx))
 	mx.handler.ServeHTTP(w, r)
 	mx.pool.Put(rctx)
@@ -269,7 +270,7 @@ func (mx *Mux) Route(pattern string, fn func(r Router)) Router {
 func (mx *Mux) Mount(pattern string, handler http.Handler) {
 	// Provide runtime safety for ensuring a pattern isn't mounted on an existing
 	// routing pattern.
-	if mx.tree.matchPattern(pattern+"*") || mx.tree.matchPattern(pattern+"/*") {
+	if mx.tree.findPattern(pattern+"*") || mx.tree.findPattern(pattern+"/*") {
 		panic(fmt.Sprintf("chi: attempting to Mount() a handler on an existing path, '%s'", pattern))
 	}
 
@@ -285,13 +286,7 @@ func (mx *Mux) Mount(pattern string, handler http.Handler) {
 	// Wrap the sub-router in a handlerFunc to scope the request path for routing.
 	mountHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		rctx := RouteContext(r.Context())
-		rctx.RoutePath = "/"
-
-		nx := len(rctx.routeParams.Keys) - 1 // index of last param in list
-		if nx >= 0 && rctx.routeParams.Keys[nx] == "*" && len(rctx.routeParams.Values) > nx {
-			rctx.RoutePath += rctx.routeParams.Values[nx]
-		}
-
+		rctx.RoutePath = mx.nextRoutePath(rctx)
 		handler.ServeHTTP(w, r)
 	})
 
@@ -317,15 +312,37 @@ func (mx *Mux) Mount(pattern string, handler http.Handler) {
 	}
 }
 
+// Routes returns a slice of routing information from the tree,
+// useful for traversing available routes of a router.
+func (mx *Mux) Routes() []Route {
+	return mx.tree.routes()
+}
+
 // Middlewares returns a slice of middleware handler functions.
 func (mx *Mux) Middlewares() Middlewares {
 	return mx.middlewares
 }
 
-// Routes returns a slice of routing information from the tree,
-// useful for traversing available routes of a router.
-func (mx *Mux) Routes() []Route {
-	return mx.tree.routes()
+// Match searches the routing tree for a handler that matches the method/path.
+// It's similar to routing a http request, but without executing the handler
+// thereafter.
+//
+// Note: the *Context state is updated during execution, so manage
+// the state carefully or make a NewRouteContext().
+func (mx *Mux) Match(rctx *Context, method, path string) bool {
+	m, ok := methodMap[method]
+	if !ok {
+		return false
+	}
+
+	node, _, h := mx.tree.FindRoute(rctx, m, path)
+
+	if node != nil && node.subroutes != nil {
+		rctx.RoutePath = mx.nextRoutePath(rctx)
+		return node.subroutes.Match(rctx, method, rctx.RoutePath)
+	}
+
+	return h != nil
 }
 
 // NotFoundHandler returns the default Mux 404 responder whenever a route
@@ -396,26 +413,20 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	}
 
 	// Check if method is supported by chi
-	method, ok := methodMap[r.Method]
+	if rctx.RouteMethod == "" {
+		rctx.RouteMethod = r.Method
+	}
+	method, ok := methodMap[rctx.RouteMethod]
 	if !ok {
 		mx.MethodNotAllowedHandler().ServeHTTP(w, r)
 		return
 	}
 
 	// Find the route
-	if _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
+	if _, _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
 		h.ServeHTTP(w, r)
 		return
 	}
-	if method == mHEAD {
-		// Try again with GET for HEAD
-		method = mGET
-		if _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
-			h.ServeHTTP(w, r)
-			return
-		}
-	}
-
 	if rctx.methodNotAllowed {
 		mx.MethodNotAllowedHandler().ServeHTTP(w, r)
 	} else {
@@ -423,6 +434,15 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	}
 }
 
+func (mx *Mux) nextRoutePath(rctx *Context) string {
+	routePath := "/"
+	nx := len(rctx.routeParams.Keys) - 1 // index of last param in list
+	if nx >= 0 && rctx.routeParams.Keys[nx] == "*" && len(rctx.routeParams.Values) > nx {
+		routePath += rctx.routeParams.Values[nx]
+	}
+	return routePath
+}
+
 // Recursively update data on child routers.
 func (mx *Mux) updateSubRoutes(fn func(subMux *Mux)) {
 	for _, r := range mx.tree.routes() {
diff --git a/tree.go b/tree.go
index c2f6438..b5021e4 100644
--- a/tree.go
+++ b/tree.go
@@ -341,7 +341,7 @@ func (n *node) setEndpoint(method methodTyp, handler http.Handler, pattern strin
 	}
 }
 
-func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (endpoints, http.Handler) {
+func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, endpoints, http.Handler) {
 	// Reset the context routing pattern and params
 	rctx.routePattern = ""
 	rctx.routeParams.Keys = rctx.routeParams.Keys[:0]
@@ -350,7 +350,7 @@ func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (endpoint
 	// Find the routing handlers for the path
 	rn := n.findRoute(rctx, method, path)
 	if rn == nil {
-		return nil, nil
+		return nil, nil, nil
 	}
 
 	// Record the routing params in the request lifecycle
@@ -363,7 +363,7 @@ func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (endpoint
 		rctx.RoutePatterns = append(rctx.RoutePatterns, rctx.routePattern)
 	}
 
-	return rn.endpoints, rn.endpoints[method].handler
+	return rn, rn.endpoints, rn.endpoints[method].handler
 }
 
 // Recursive edge traversal by checking all nodeTyp groups along the way.
@@ -514,7 +514,7 @@ func (n *node) isLeaf() bool {
 	return n.endpoints != nil
 }
 
-func (n *node) matchPattern(pattern string) bool {
+func (n *node) findPattern(pattern string) bool {
 	nn := n
 	for _, nds := range nn.children {
 		if len(nds) == 0 {
@@ -551,7 +551,7 @@ func (n *node) matchPattern(pattern string) bool {
 			return true
 		}
 
-		return n.matchPattern(xpattern)
+		return n.findPattern(xpattern)
 	}
 	return false
 }
