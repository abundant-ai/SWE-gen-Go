diff --git a/internal/backend/local/backend_plan.go b/internal/backend/local/backend_plan.go
index 75f8533297..0fa256fd3e 100644
--- a/internal/backend/local/backend_plan.go
+++ b/internal/backend/local/backend_plan.go
@@ -158,7 +158,7 @@ func (b *Local) opPlan(
 			op.ReportResult(runningOp, diags)
 			return
 		}
-		plan.Backend = *op.PlanOutBackend
+		plan.Backend = op.PlanOutBackend
 
 		// We may have updated the state in the refresh step above, but we
 		// will freeze that updated state in the plan file for now and
diff --git a/internal/command/apply.go b/internal/command/apply.go
index 9148f04dc4..74e8e0378e 100644
--- a/internal/command/apply.go
+++ b/internal/command/apply.go
@@ -210,7 +210,7 @@ func (c *ApplyCommand) PrepareBackend(planFile *planfile.WrappedPlanFile, args *
 			))
 			return nil, diags
 		}
-		if plan.Backend.Config == nil {
+		if plan.Backend == nil {
 			// Should never happen; always indicates a bug in the creation of the plan file
 			diags = diags.Append(tfdiags.Sourceless(
 				tfdiags.Error,
@@ -220,7 +220,7 @@ func (c *ApplyCommand) PrepareBackend(planFile *planfile.WrappedPlanFile, args *
 			return nil, diags
 		}
 		// TODO: Update BackendForLocalPlan to use state storage, and plan to be able to contain State Store config details
-		be, beDiags = c.BackendForLocalPlan(plan.Backend)
+		be, beDiags = c.BackendForLocalPlan(*plan.Backend)
 	} else {
 
 		// Load the backend
diff --git a/internal/plans/plan.go b/internal/plans/plan.go
index 42a1ba4851..53b18c9515 100644
--- a/internal/plans/plan.go
+++ b/internal/plans/plan.go
@@ -74,8 +74,8 @@ type Plan struct {
 	ActionTargetAddrs         []addrs.Targetable
 	ForceReplaceAddrs         []addrs.AbsResourceInstance
 
-	Backend    Backend
-	StateStore StateStore
+	Backend    *Backend
+	StateStore *StateStore
 
 	// Complete is true if Terraform considers this to be a "complete" plan,
 	// which is to say that it includes a planned action (even if no-op)
diff --git a/internal/plans/planfile/tfplan.go b/internal/plans/planfile/tfplan.go
index 179a53a082..b89ed65e66 100644
--- a/internal/plans/planfile/tfplan.go
+++ b/internal/plans/planfile/tfplan.go
@@ -222,7 +222,7 @@ func readTfplan(r io.Reader) (*plans.Plan, error) {
 		if err != nil {
 			return nil, fmt.Errorf("plan file has invalid backend configuration: %s", err)
 		}
-		plan.Backend = plans.Backend{
+		plan.Backend = &plans.Backend{
 			Type:      rawBackend.Type,
 			Config:    config,
 			Workspace: rawBackend.Workspace,
@@ -243,7 +243,7 @@ func readTfplan(r io.Reader) (*plans.Plan, error) {
 			return nil, fmt.Errorf("plan file has invalid state_store provider version: %s", err)
 		}
 
-		plan.StateStore = plans.StateStore{
+		plan.StateStore = &plans.StateStore{
 			Type:      rawStateStore.Type,
 			Provider:  provider,
 			Config:    config,
@@ -737,25 +737,23 @@ func writeTfplan(plan *plans.Plan, w io.Writer) error {
 	}
 
 	// Store details about accessing state
-	backendInUse := plan.Backend.Type != "" && plan.Backend.Config != nil
-	stateStoreInUse := plan.StateStore.Type != "" && plan.StateStore.Config != nil
 	switch {
-	case !backendInUse && !stateStoreInUse:
+	case plan.Backend == nil && plan.StateStore == nil:
 		// This suggests a bug in the code that created the plan, since it
 		// ought to always have either a backend or state_store populated, even if it's the default
 		// "local" backend with a local state file.
 		return fmt.Errorf("plan does not have a backend or state_store configuration")
-	case backendInUse && stateStoreInUse:
+	case plan.Backend != nil && plan.StateStore != nil:
 		// This suggests a bug in the code that created the plan, since it
 		// should never have both a backend and state_store populated.
 		return fmt.Errorf("plan contains both backend and state_store configurations, only one is expected")
-	case backendInUse:
+	case plan.Backend != nil:
 		rawPlan.Backend = &planproto.Backend{
 			Type:      plan.Backend.Type,
 			Config:    valueToTfplan(plan.Backend.Config),
 			Workspace: plan.Backend.Workspace,
 		}
-	case stateStoreInUse:
+	case plan.StateStore != nil:
 		rawPlan.StateStore = &planproto.StateStore{
 			Type: plan.StateStore.Type,
 			Provider: &planproto.Provider{
