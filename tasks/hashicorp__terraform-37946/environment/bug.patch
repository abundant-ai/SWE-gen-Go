diff --git a/internal/backend/local/backend_local_test.go b/internal/backend/local/backend_local_test.go
index 2e84d01f6a..10fd9c85ca 100644
--- a/internal/backend/local/backend_local_test.go
+++ b/internal/backend/local/backend_local_test.go
@@ -160,7 +160,7 @@ func TestLocalRun_stalePlan(t *testing.T) {
 	plan := &plans.Plan{
 		UIMode:  plans.NormalMode,
 		Changes: plans.NewChangesSrc(),
-		Backend: &plans.Backend{
+		Backend: plans.Backend{
 			Type:   "local",
 			Config: backendConfigRaw,
 		},
diff --git a/internal/backend/local/backend_plan.go b/internal/backend/local/backend_plan.go
index 0fa256fd3e..75f8533297 100644
--- a/internal/backend/local/backend_plan.go
+++ b/internal/backend/local/backend_plan.go
@@ -158,7 +158,7 @@ func (b *Local) opPlan(
 			op.ReportResult(runningOp, diags)
 			return
 		}
-		plan.Backend = op.PlanOutBackend
+		plan.Backend = *op.PlanOutBackend
 
 		// We may have updated the state in the refresh step above, but we
 		// will freeze that updated state in the plan file for now and
diff --git a/internal/command/apply.go b/internal/command/apply.go
index 74e8e0378e..9148f04dc4 100644
--- a/internal/command/apply.go
+++ b/internal/command/apply.go
@@ -210,7 +210,7 @@ func (c *ApplyCommand) PrepareBackend(planFile *planfile.WrappedPlanFile, args *
 			))
 			return nil, diags
 		}
-		if plan.Backend == nil {
+		if plan.Backend.Config == nil {
 			// Should never happen; always indicates a bug in the creation of the plan file
 			diags = diags.Append(tfdiags.Sourceless(
 				tfdiags.Error,
@@ -220,7 +220,7 @@ func (c *ApplyCommand) PrepareBackend(planFile *planfile.WrappedPlanFile, args *
 			return nil, diags
 		}
 		// TODO: Update BackendForLocalPlan to use state storage, and plan to be able to contain State Store config details
-		be, beDiags = c.BackendForLocalPlan(*plan.Backend)
+		be, beDiags = c.BackendForLocalPlan(plan.Backend)
 	} else {
 
 		// Load the backend
diff --git a/internal/command/apply_test.go b/internal/command/apply_test.go
index 38b416f711..e1815c6a81 100644
--- a/internal/command/apply_test.go
+++ b/internal/command/apply_test.go
@@ -821,7 +821,7 @@ func TestApply_plan_remoteState(t *testing.T) {
 		t.Fatal(err)
 	}
 	planPath := testPlanFile(t, snap, state, &plans.Plan{
-		Backend: &plans.Backend{
+		Backend: plans.Backend{
 			Type:   "http",
 			Config: backendConfigRaw,
 		},
diff --git a/internal/command/command_test.go b/internal/command/command_test.go
index 2c0486dca3..9346e78114 100644
--- a/internal/command/command_test.go
+++ b/internal/command/command_test.go
@@ -188,7 +188,7 @@ func testPlan(t *testing.T) *plans.Plan {
 	}
 
 	return &plans.Plan{
-		Backend: &plans.Backend{
+		Backend: plans.Backend{
 			// This is just a placeholder so that the plan file can be written
 			// out. Caller may wish to override it to something more "real"
 			// where the plan will actually be subsequently applied.
diff --git a/internal/command/graph_test.go b/internal/command/graph_test.go
index dc98f74c71..0cec9f432d 100644
--- a/internal/command/graph_test.go
+++ b/internal/command/graph_test.go
@@ -325,7 +325,7 @@ func TestGraph_applyPhaseSavedPlan(t *testing.T) {
 		},
 	})
 
-	plan.Backend = &plans.Backend{
+	plan.Backend = plans.Backend{
 		// Doesn't actually matter since we aren't going to activate the backend
 		// for this command anyway, but we need something here for the plan
 		// file writer to succeed.
diff --git a/internal/command/plan_test.go b/internal/command/plan_test.go
index 710dfef29e..b3e726c8c0 100644
--- a/internal/command/plan_test.go
+++ b/internal/command/plan_test.go
@@ -447,9 +447,6 @@ func TestPlan_outBackend(t *testing.T) {
 		t.Fatalf("Expected empty plan to be written to plan file, got: %s", spew.Sdump(plan))
 	}
 
-	if plan.Backend == nil {
-		t.Fatal("unexpected nil Backend")
-	}
 	if got, want := plan.Backend.Type, "http"; got != want {
 		t.Errorf("wrong backend type %q; want %q", got, want)
 	}
diff --git a/internal/plans/plan.go b/internal/plans/plan.go
index 53b18c9515..42a1ba4851 100644
--- a/internal/plans/plan.go
+++ b/internal/plans/plan.go
@@ -74,8 +74,8 @@ type Plan struct {
 	ActionTargetAddrs         []addrs.Targetable
 	ForceReplaceAddrs         []addrs.AbsResourceInstance
 
-	Backend    *Backend
-	StateStore *StateStore
+	Backend    Backend
+	StateStore StateStore
 
 	// Complete is true if Terraform considers this to be a "complete" plan,
 	// which is to say that it includes a planned action (even if no-op)
diff --git a/internal/plans/planfile/planfile_test.go b/internal/plans/planfile/planfile_test.go
index b50189bc1f..923ed3b0ba 100644
--- a/internal/plans/planfile/planfile_test.go
+++ b/internal/plans/planfile/planfile_test.go
@@ -63,7 +63,7 @@ func TestRoundtrip(t *testing.T) {
 		VariableValues: map[string]plans.DynamicValue{
 			"foo": plans.DynamicValue([]byte("foo placeholder")),
 		},
-		Backend: &plans.Backend{
+		Backend: plans.Backend{
 			Type:      "local",
 			Config:    plans.DynamicValue([]byte("config placeholder")),
 			Workspace: "default",
diff --git a/internal/plans/planfile/tfplan.go b/internal/plans/planfile/tfplan.go
index b89ed65e66..179a53a082 100644
--- a/internal/plans/planfile/tfplan.go
+++ b/internal/plans/planfile/tfplan.go
@@ -222,7 +222,7 @@ func readTfplan(r io.Reader) (*plans.Plan, error) {
 		if err != nil {
 			return nil, fmt.Errorf("plan file has invalid backend configuration: %s", err)
 		}
-		plan.Backend = &plans.Backend{
+		plan.Backend = plans.Backend{
 			Type:      rawBackend.Type,
 			Config:    config,
 			Workspace: rawBackend.Workspace,
@@ -243,7 +243,7 @@ func readTfplan(r io.Reader) (*plans.Plan, error) {
 			return nil, fmt.Errorf("plan file has invalid state_store provider version: %s", err)
 		}
 
-		plan.StateStore = &plans.StateStore{
+		plan.StateStore = plans.StateStore{
 			Type:      rawStateStore.Type,
 			Provider:  provider,
 			Config:    config,
@@ -737,23 +737,25 @@ func writeTfplan(plan *plans.Plan, w io.Writer) error {
 	}
 
 	// Store details about accessing state
+	backendInUse := plan.Backend.Type != "" && plan.Backend.Config != nil
+	stateStoreInUse := plan.StateStore.Type != "" && plan.StateStore.Config != nil
 	switch {
-	case plan.Backend == nil && plan.StateStore == nil:
+	case !backendInUse && !stateStoreInUse:
 		// This suggests a bug in the code that created the plan, since it
 		// ought to always have either a backend or state_store populated, even if it's the default
 		// "local" backend with a local state file.
 		return fmt.Errorf("plan does not have a backend or state_store configuration")
-	case plan.Backend != nil && plan.StateStore != nil:
+	case backendInUse && stateStoreInUse:
 		// This suggests a bug in the code that created the plan, since it
 		// should never have both a backend and state_store populated.
 		return fmt.Errorf("plan contains both backend and state_store configurations, only one is expected")
-	case plan.Backend != nil:
+	case backendInUse:
 		rawPlan.Backend = &planproto.Backend{
 			Type:      plan.Backend.Type,
 			Config:    valueToTfplan(plan.Backend.Config),
 			Workspace: plan.Backend.Workspace,
 		}
-	case plan.StateStore != nil:
+	case stateStoreInUse:
 		rawPlan.StateStore = &planproto.StateStore{
 			Type: plan.StateStore.Type,
 			Provider: &planproto.Provider{
diff --git a/internal/plans/planfile/tfplan_test.go b/internal/plans/planfile/tfplan_test.go
index 0541f37052..590c97d560 100644
--- a/internal/plans/planfile/tfplan_test.go
+++ b/internal/plans/planfile/tfplan_test.go
@@ -39,16 +39,14 @@ func TestTFPlanRoundTrip(t *testing.T) {
 			plan: func() *plans.Plan {
 				rawPlan := examplePlanForTest(t)
 				// remove backend data from example plan
-				rawPlan.Backend = nil
-
-				// add state store instead
+				rawPlan.Backend = plans.Backend{}
 				ver, err := version.NewVersion("9.9.9")
 				if err != nil {
 					t.Fatalf("error encountered during test setup: %s", err)
 				}
 
 				// add state store instead
-				rawPlan.StateStore = &plans.StateStore{
+				rawPlan.StateStore = plans.StateStore{
 					Type: "foo_bar",
 					Provider: &plans.Provider{
 						Version: ver,
@@ -112,7 +110,8 @@ func Test_writeTfplan_validation(t *testing.T) {
 			plan: func() *plans.Plan {
 				rawPlan := examplePlanForTest(t)
 				// remove backend from example plan
-				rawPlan.Backend = nil
+				rawPlan.Backend.Type = ""
+				rawPlan.Backend.Config = nil
 				return rawPlan
 			}(),
 			wantWriteErrMsg: "plan does not have a backend or state_store configuration",
@@ -127,7 +126,7 @@ func Test_writeTfplan_validation(t *testing.T) {
 				if err != nil {
 					t.Fatalf("error encountered during test setup: %s", err)
 				}
-				rawPlan.StateStore = &plans.StateStore{
+				rawPlan.StateStore = plans.StateStore{
 					Type: "foo_bar",
 					Provider: &plans.Provider{
 						Version: ver,
@@ -526,7 +525,7 @@ func examplePlanForTest(t *testing.T) *plans.Plan {
 				Name: "woot",
 			}.Absolute(addrs.RootModuleInstance),
 		},
-		Backend: &plans.Backend{
+		Backend: plans.Backend{
 			Type: "local",
 			Config: mustNewDynamicValue(
 				cty.ObjectVal(map[string]cty.Value{
@@ -630,7 +629,7 @@ func TestTFPlanRoundTripDestroy(t *testing.T) {
 				Name: "woot",
 			}.Absolute(addrs.RootModuleInstance),
 		},
-		Backend: &plans.Backend{
+		Backend: plans.Backend{
 			Type: "local",
 			Config: mustNewDynamicValue(
 				cty.ObjectVal(map[string]cty.Value{
diff --git a/internal/terraform/context_test.go b/internal/terraform/context_test.go
index 84d3dbc2ce..520b39705e 100644
--- a/internal/terraform/context_test.go
+++ b/internal/terraform/context_test.go
@@ -782,16 +782,14 @@ func contextOptsForPlanViaFile(t *testing.T, configSnap *configload.Snapshot, pl
 	// backend configuration if they didn't set one, since the backend is
 	// usually dealt with in a calling package and so tests in this package
 	// don't really care about it.
-	if plan.Backend == nil {
+	if plan.Backend.Config == nil {
 		cfg, err := plans.NewDynamicValue(cty.EmptyObjectVal, cty.EmptyObject)
 		if err != nil {
 			panic(fmt.Sprintf("NewDynamicValue failed: %s", err)) // shouldn't happen because we control the inputs
 		}
-		plan.Backend = &plans.Backend{
-			Type:      "local",
-			Config:    cfg,
-			Workspace: "default",
-		}
+		plan.Backend.Type = "local"
+		plan.Backend.Config = cfg
+		plan.Backend.Workspace = "default"
 	}
 
 	filename := filepath.Join(dir, "tfplan")
