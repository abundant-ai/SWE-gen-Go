diff --git a/assert/assertion_format.go b/assert/assertion_format.go
index b8c3b4e..9e29b3b 100644
--- a/assert/assertion_format.go
+++ b/assert/assertion_format.go
@@ -28,17 +28,6 @@ func Containsf(t TestingT, s interface{}, contains interface{}, msg string, args
 	return Contains(t, s, contains, append([]interface{}{msg}, args...)...)
 }
 
-// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should match.
-//
-// assert.ElementsMatchf(t, [1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted"))
-//
-// Returns whether the assertion was successful (true) or not (false).
-func ElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) bool {
-	return ElementsMatch(t, listA, listB, append([]interface{}{msg}, args...)...)
-}
-
 // Emptyf asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
 // a slice or a channel with len == 0.
 //
diff --git a/assert/assertion_forward.go b/assert/assertion_forward.go
index 4771f99..d173878 100644
--- a/assert/assertion_forward.go
+++ b/assert/assertion_forward.go
@@ -45,28 +45,6 @@ func (a *Assertions) Containsf(s interface{}, contains interface{}, msg string,
 	return Containsf(a.t, s, contains, msg, args...)
 }
 
-// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should match.
-//
-// a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2]))
-//
-// Returns whether the assertion was successful (true) or not (false).
-func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) bool {
-	return ElementsMatch(a.t, listA, listB, msgAndArgs...)
-}
-
-// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should match.
-//
-// a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted"))
-//
-// Returns whether the assertion was successful (true) or not (false).
-func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) bool {
-	return ElementsMatchf(a.t, listA, listB, msg, args...)
-}
-
 // Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
 // a slice or a channel with len == 0.
 //
diff --git a/assert/assertions.go b/assert/assertions.go
index 3f1f6f7..209ff84 100644
--- a/assert/assertions.go
+++ b/assert/assertions.go
@@ -728,62 +728,6 @@ func NotSubset(t TestingT, list, subset interface{}, msgAndArgs ...interface{})
 	return Fail(t, fmt.Sprintf("%q is a subset of %q", subset, list), msgAndArgs...)
 }
 
-// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should match.
-//
-// assert.ElementsMatch(t, [1, 3, 2, 3], [1, 3, 3, 2]))
-//
-// Returns whether the assertion was successful (true) or not (false).
-func ElementsMatch(t TestingT, listA, listB interface{}, msgAndArgs ...interface{}) (ok bool) {
-	if isEmpty(listA) && isEmpty(listB) {
-		return true
-	}
-
-	aKind := reflect.TypeOf(listA).Kind()
-	bKind := reflect.TypeOf(listB).Kind()
-
-	if aKind != reflect.Array && aKind != reflect.Slice {
-		return Fail(t, fmt.Sprintf("%q has an unsupported type %s", listA, aKind), msgAndArgs...)
-	}
-
-	if bKind != reflect.Array && bKind != reflect.Slice {
-		return Fail(t, fmt.Sprintf("%q has an unsupported type %s", listB, bKind), msgAndArgs...)
-	}
-
-	aValue := reflect.ValueOf(listA)
-	bValue := reflect.ValueOf(listB)
-
-	aLen := aValue.Len()
-	bLen := bValue.Len()
-
-	if aLen != bLen {
-		return Fail(t, fmt.Sprintf("lengths don't match: %d != %d", aLen, bLen), msgAndArgs...)
-	}
-
-	// Mark indexes in bValue that we already used
-	visited := make([]bool, bLen)
-	for i := 0; i < aLen; i++ {
-		element := aValue.Index(i).Interface()
-		found := false
-		for j := 0; j < bLen; j++ {
-			if visited[j] {
-				continue
-			}
-			if ObjectsAreEqual(bValue.Index(j).Interface(), element) {
-				visited[j] = true
-				found = true
-				break
-			}
-		}
-		if !found {
-			return Fail(t, fmt.Sprintf("element %s appears more times in %s than in %s", element, aValue, bValue), msgAndArgs...)
-		}
-	}
-
-	return true
-}
-
 // Condition uses a Comparison to assert a complex condition.
 func Condition(t TestingT, comp Comparison, msgAndArgs ...interface{}) bool {
 	result := comp()
diff --git a/assert/assertions_test.go b/assert/assertions_test.go
index 8c64edf..353e97b 100644
--- a/assert/assertions_test.go
+++ b/assert/assertions_test.go
@@ -612,57 +612,6 @@ func Test_includeElement(t *testing.T) {
 	False(t, found)
 }
 
-func TestElementsMatch(t *testing.T) {
-	mockT := new(testing.T)
-
-	if !ElementsMatch(mockT, nil, nil) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []int{}, []int{}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []int{1}, []int{1}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []int{1, 1}, []int{1, 1}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []int{1, 2}, []int{1, 2}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []int{1, 2}, []int{2, 1}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, [2]int{1, 2}, [2]int{2, 1}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []string{"hello", "world"}, []string{"world", "hello"}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []string{"hello", "hello"}, []string{"hello", "hello"}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []string{"hello", "hello", "world"}, []string{"hello", "world", "hello"}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, [3]string{"hello", "hello", "world"}, [3]string{"hello", "world", "hello"}) {
-		t.Error("ElementsMatch should return true")
-	}
-	if !ElementsMatch(mockT, []int{}, nil) {
-		t.Error("ElementsMatch should return true")
-	}
-
-	if ElementsMatch(mockT, []int{1}, []int{1, 1}) {
-		t.Error("ElementsMatch should return false")
-	}
-	if ElementsMatch(mockT, []int{1, 2}, []int{2, 2}) {
-		t.Error("ElementsMatch should return false")
-	}
-	if ElementsMatch(mockT, []string{"hello", "hello"}, []string{"hello"}) {
-		t.Error("ElementsMatch should return false")
-	}
-}
-
 func TestCondition(t *testing.T) {
 	mockT := new(testing.T)
 
diff --git a/require/require.go b/require/require.go
index c4587c4..51baa17 100644
--- a/require/require.go
+++ b/require/require.go
@@ -54,32 +54,6 @@ func Containsf(t TestingT, s interface{}, contains interface{}, msg string, args
 	}
 }
 
-// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should match.
-//
-// assert.ElementsMatch(t, [1, 3, 2, 3], [1, 3, 3, 2]))
-//
-// Returns whether the assertion was successful (true) or not (false).
-func ElementsMatch(t TestingT, listA interface{}, listB interface{}, msgAndArgs ...interface{}) {
-	if !assert.ElementsMatch(t, listA, listB, msgAndArgs...) {
-		t.FailNow()
-	}
-}
-
-// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should match.
-//
-// assert.ElementsMatchf(t, [1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted"))
-//
-// Returns whether the assertion was successful (true) or not (false).
-func ElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) {
-	if !assert.ElementsMatchf(t, listA, listB, msg, args...) {
-		t.FailNow()
-	}
-}
-
 // Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
 // a slice or a channel with len == 0.
 //
diff --git a/require/require_forward.go b/require/require_forward.go
index 79c8f29..0036d6e 100644
--- a/require/require_forward.go
+++ b/require/require_forward.go
@@ -46,28 +46,6 @@ func (a *Assertions) Containsf(s interface{}, contains interface{}, msg string,
 	Containsf(a.t, s, contains, msg, args...)
 }
 
-// ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should match.
-//
-// a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2]))
-//
-// Returns whether the assertion was successful (true) or not (false).
-func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) {
-	ElementsMatch(a.t, listA, listB, msgAndArgs...)
-}
-
-// ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should match.
-//
-// a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted"))
-//
-// Returns whether the assertion was successful (true) or not (false).
-func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) {
-	ElementsMatchf(a.t, listA, listB, msg, args...)
-}
-
 // Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
 // a slice or a channel with len == 0.
 //
