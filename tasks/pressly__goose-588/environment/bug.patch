diff --git a/create.go b/create.go
index db47a2e..d9ec002 100644
--- a/create.go
+++ b/create.go
@@ -30,7 +30,7 @@ func CreateWithTemplate(db *sql.DB, dir string, tmpl *template.Template, name, m
 
 	if sequential {
 		// always use DirFS here because it's modifying operation
-		migrations, err := collectMigrationsFS(osFS{}, dir, minVersion, maxVersion, registeredGoMigrations)
+		migrations, err := collectMigrationsFS(osFS{}, dir, minVersion, maxVersion)
 		if err != nil && !errors.Is(err, ErrNoMigrationFiles) {
 			return err
 		}
diff --git a/fix.go b/fix.go
index a498358..7bc7ed5 100644
--- a/fix.go
+++ b/fix.go
@@ -11,7 +11,7 @@ const seqVersionTemplate = "%05v"
 
 func Fix(dir string) error {
 	// always use osFS here because it's modifying operation
-	migrations, err := collectMigrationsFS(osFS{}, dir, minVersion, maxVersion, registeredGoMigrations)
+	migrations, err := collectMigrationsFS(osFS{}, dir, minVersion, maxVersion)
 	if err != nil {
 		return err
 	}
diff --git a/migrate.go b/migrate.go
index dc9a1a0..b7130a4 100644
--- a/migrate.go
+++ b/migrate.go
@@ -236,19 +236,17 @@ func register(
 	return nil
 }
 
-func collectMigrationsFS(
-	fsys fs.FS,
-	dirpath string,
-	current, target int64,
-	registered map[int64]*Migration,
-) (Migrations, error) {
+func collectMigrationsFS(fsys fs.FS, dirpath string, current, target int64) (Migrations, error) {
 	if _, err := fs.Stat(fsys, dirpath); err != nil {
 		if errors.Is(err, fs.ErrNotExist) {
 			return nil, fmt.Errorf("%s directory does not exist", dirpath)
 		}
+
 		return nil, err
 	}
+
 	var migrations Migrations
+
 	// SQL migration files.
 	sqlMigrationFiles, err := fs.Glob(fsys, path.Join(dirpath, "*.sql"))
 	if err != nil {
@@ -260,30 +258,68 @@ func collectMigrationsFS(
 			return nil, fmt.Errorf("could not parse SQL migration file %q: %w", file, err)
 		}
 		if versionFilter(v, current, target) {
-			migrations = append(migrations, &Migration{
-				Version:  v,
-				Next:     -1,
-				Previous: -1,
-				Source:   file,
-			})
+			migration := &Migration{Version: v, Next: -1, Previous: -1, Source: file}
+			migrations = append(migrations, migration)
 		}
 	}
-	// Go migration files.
-	goMigrations, err := collectGoMigrations(fsys, dirpath, registered, current, target)
+
+	// Go migration files
+	fsGoMigrations := map[int64]*Migration{}
+	goMigrationFiles, err := fs.Glob(fsys, path.Join(dirpath, "*.go"))
 	if err != nil {
 		return nil, err
 	}
-	migrations = append(migrations, goMigrations...)
+	for _, file := range goMigrationFiles {
+		v, err := NumericComponent(file)
+		if err != nil {
+			continue // Skip any files that don't have version prefix.
+		}
+
+		if strings.HasSuffix(file, "_test.go") {
+			continue // Skip Go test files.
+		}
+
+		if versionFilter(v, current, target) {
+			migration := &Migration{Version: v, Next: -1, Previous: -1, Source: file, Registered: false}
+			fsGoMigrations[v] = migration
+		}
+	}
+
+	// Go migrations registered via goose.AddMigration().
+	for _, migration := range registeredGoMigrations {
+		v, err := NumericComponent(migration.Source)
+		if err != nil {
+			return nil, fmt.Errorf("could not parse go migration file %q: %w", migration.Source, err)
+		}
+		if !versionFilter(v, current, target) {
+			continue
+		}
+		if _, ok := fsGoMigrations[v]; ok {
+			migrations = append(migrations, migration)
+		}
+	}
+
+	for _, fsMigration := range fsGoMigrations {
+		// Skip migrations already existing migrations registered via goose.AddMigration().
+		if _, ok := registeredGoMigrations[fsMigration.Version]; ok {
+			continue
+		}
+		migrations = append(migrations, fsMigration)
+	}
+
 	if len(migrations) == 0 {
 		return nil, ErrNoMigrationFiles
 	}
-	return sortAndConnectMigrations(migrations), nil
+
+	migrations = sortAndConnectMigrations(migrations)
+
+	return migrations, nil
 }
 
 // CollectMigrations returns all the valid looking migration scripts in the
 // migrations folder and go func registry, and key them by version.
 func CollectMigrations(dirpath string, current, target int64) (Migrations, error) {
-	return collectMigrationsFS(baseFS, dirpath, current, target, registeredGoMigrations)
+	return collectMigrationsFS(baseFS, dirpath, current, target)
 }
 
 func sortAndConnectMigrations(migrations Migrations) Migrations {
@@ -304,12 +340,15 @@ func sortAndConnectMigrations(migrations Migrations) Migrations {
 }
 
 func versionFilter(v, current, target int64) bool {
+
 	if target > current {
 		return v > current && v <= target
 	}
+
 	if target < current {
 		return v <= current && v > target
 	}
+
 	return false
 }
 
@@ -412,97 +451,3 @@ func withoutContext[T any](fn func(context.Context, T) error) func(T) error {
 		return fn(context.Background(), t)
 	}
 }
-
-// collectGoMigrations collects Go migrations from the filesystem and merges them with registered
-// migrations.
-//
-// If Go migrations have been registered globally, with [goose.AddNamedMigration...], but there are
-// no corresponding .go files in the filesystem, add them to the migrations slice.
-//
-// If Go migrations have been registered, and there are .go files in the filesystem dirpath, ONLY
-// include those in the migrations slices.
-//
-// Lastly, if there are .go files in the filesystem but they have not been registered, raise an
-// error. This is to prevent users from accidentally adding valid looking Go files to the migrations
-// folder without registering them.
-func collectGoMigrations(
-	fsys fs.FS,
-	dirpath string,
-	registeredGoMigrations map[int64]*Migration,
-	current, target int64,
-) (Migrations, error) {
-	// Sanity check registered migrations have the correct version prefix.
-	for _, m := range registeredGoMigrations {
-		if _, err := NumericComponent(m.Source); err != nil {
-			return nil, fmt.Errorf("could not parse go migration file %s: %w", m.Source, err)
-		}
-	}
-	goFiles, err := fs.Glob(fsys, path.Join(dirpath, "*.go"))
-	if err != nil {
-		return nil, err
-	}
-	// If there are no Go files in the filesystem and no registered Go migrations, return early.
-	if len(goFiles) == 0 && len(registeredGoMigrations) == 0 {
-		return nil, nil
-	}
-	type source struct {
-		fullpath string
-		version  int64
-	}
-	// Find all Go files that have a version prefix and are within the requested range.
-	var sources []source
-	for _, fullpath := range goFiles {
-		v, err := NumericComponent(fullpath)
-		if err != nil {
-			continue // Skip any files that don't have version prefix.
-		}
-		if strings.HasSuffix(fullpath, "_test.go") {
-			continue // Skip Go test files.
-		}
-		if versionFilter(v, current, target) {
-			sources = append(sources, source{
-				fullpath: fullpath,
-				version:  v,
-			})
-		}
-	}
-	var (
-		migrations Migrations
-	)
-	if len(sources) > 0 {
-		for _, s := range sources {
-			migration, ok := registeredGoMigrations[s.version]
-			if ok {
-				migrations = append(migrations, migration)
-			} else {
-				// TODO(mf): something that bothers me about this implementation is it will be
-				// lazily evaluated and the error will only be raised if the user tries to run the
-				// migration. It would be better to raise an error much earlier in the process.
-				migrations = append(migrations, &Migration{
-					Version:    s.version,
-					Next:       -1,
-					Previous:   -1,
-					Source:     s.fullpath,
-					Registered: false,
-				})
-			}
-		}
-	} else {
-		// Some users may register Go migrations manually via AddNamedMigration_ functions but not
-		// provide the corresponding .go files in the filesystem. In this case, we include them
-		// wholesale in the migrations slice.
-		//
-		// This is a valid use case because users may want to build a custom binary that only embeds
-		// the SQL migration files and some other mechanism for registering Go migrations.
-		for _, migration := range registeredGoMigrations {
-			v, err := NumericComponent(migration.Source)
-			if err != nil {
-				return nil, fmt.Errorf("could not parse go migration file %s: %w", migration.Source, err)
-			}
-			if versionFilter(v, current, target) {
-				migrations = append(migrations, migration)
-			}
-		}
-	}
-	return migrations, nil
-}
diff --git a/migrate_test.go b/migrate_test.go
index 9158829..ac30b48 100644
--- a/migrate_test.go
+++ b/migrate_test.go
@@ -1,13 +1,7 @@
 package goose
 
 import (
-	"io/fs"
-	"math"
-	"os"
-	"path/filepath"
 	"testing"
-
-	"github.com/pressly/goose/v3/internal/check"
 )
 
 func TestMigrationSort(t *testing.T) {
@@ -62,204 +56,3 @@ func validateMigrationSort(t *testing.T, ms Migrations, sorted []int64) {
 
 	t.Log(ms)
 }
-
-func TestCollectMigrations(t *testing.T) {
-	// Not safe to run in parallel
-	t.Run("no_migration_files_found", func(t *testing.T) {
-		tmp := t.TempDir()
-		err := os.MkdirAll(filepath.Join(tmp, "migrations-test"), 0755)
-		check.NoError(t, err)
-		_, err = collectMigrationsFS(os.DirFS(tmp), "migrations-test", 0, math.MaxInt64, nil)
-		check.HasError(t, err)
-		check.Contains(t, err.Error(), "no migration files found")
-	})
-	t.Run("filesystem_registered_with_single_dirpath", func(t *testing.T) {
-		t.Cleanup(func() { clearMap(registeredGoMigrations) })
-		file1, file2 := "09081_a.go", "09082_b.go"
-		file3, file4 := "19081_a.go", "19082_b.go"
-		AddNamedMigrationContext(file1, nil, nil)
-		AddNamedMigrationContext(file2, nil, nil)
-		check.Number(t, len(registeredGoMigrations), 2)
-		tmp := t.TempDir()
-		dir := filepath.Join(tmp, "migrations", "dir1")
-		err := os.MkdirAll(dir, 0755)
-		check.NoError(t, err)
-		createEmptyFile(t, dir, file1)
-		createEmptyFile(t, dir, file2)
-		createEmptyFile(t, dir, file3)
-		createEmptyFile(t, dir, file4)
-		fsys := os.DirFS(tmp)
-		files, err := fs.ReadDir(fsys, "migrations/dir1")
-		check.NoError(t, err)
-		check.Number(t, len(files), 4)
-		all, err := collectMigrationsFS(fsys, "migrations/dir1", 0, math.MaxInt64, registeredGoMigrations)
-		check.NoError(t, err)
-		check.Number(t, len(all), 4)
-		check.Number(t, all[0].Version, 9081)
-		check.Number(t, all[1].Version, 9082)
-		check.Number(t, all[2].Version, 19081)
-		check.Number(t, all[3].Version, 19082)
-	})
-	t.Run("filesystem_registered_with_multiple_dirpath", func(t *testing.T) {
-		t.Cleanup(func() { clearMap(registeredGoMigrations) })
-		file1, file2, file3 := "00001_a.go", "00002_b.go", "01111_c.go"
-		AddNamedMigrationContext(file1, nil, nil)
-		AddNamedMigrationContext(file2, nil, nil)
-		AddNamedMigrationContext(file3, nil, nil)
-		check.Number(t, len(registeredGoMigrations), 3)
-		tmp := t.TempDir()
-		dir1 := filepath.Join(tmp, "migrations", "dir1")
-		dir2 := filepath.Join(tmp, "migrations", "dir2")
-		err := os.MkdirAll(dir1, 0755)
-		check.NoError(t, err)
-		err = os.MkdirAll(dir2, 0755)
-		check.NoError(t, err)
-		createEmptyFile(t, dir1, file1)
-		createEmptyFile(t, dir1, file2)
-		createEmptyFile(t, dir2, file3)
-		fsys := os.DirFS(tmp)
-		// Validate if dirpath 1 is specified we get the two Go migrations in migrations/dir1 folder
-		// even though 3 Go migrations have been registered.
-		{
-			all, err := collectMigrationsFS(fsys, "migrations/dir1", 0, math.MaxInt64, registeredGoMigrations)
-			check.NoError(t, err)
-			check.Number(t, len(all), 2)
-			check.Number(t, all[0].Version, 1)
-			check.Number(t, all[1].Version, 2)
-		}
-		// Validate if dirpath 2 is specified we only get the one Go migration in migrations/dir2 folder
-		// even though 3 Go migrations have been registered.
-		{
-			all, err := collectMigrationsFS(fsys, "migrations/dir2", 0, math.MaxInt64, registeredGoMigrations)
-			check.NoError(t, err)
-			check.Number(t, len(all), 1)
-			check.Number(t, all[0].Version, 1111)
-		}
-	})
-	t.Run("empty_filesystem_registered_manually", func(t *testing.T) {
-		t.Cleanup(func() { clearMap(registeredGoMigrations) })
-		AddNamedMigrationContext("00101_a.go", nil, nil)
-		AddNamedMigrationContext("00102_b.go", nil, nil)
-		check.Number(t, len(registeredGoMigrations), 2)
-		tmp := t.TempDir()
-		err := os.MkdirAll(filepath.Join(tmp, "migrations"), 0755)
-		check.NoError(t, err)
-		all, err := collectMigrationsFS(os.DirFS(tmp), "migrations", 0, math.MaxInt64, registeredGoMigrations)
-		check.NoError(t, err)
-		check.Number(t, len(all), 2)
-		check.Number(t, all[0].Version, 101)
-		check.Number(t, all[1].Version, 102)
-	})
-	t.Run("unregistered_go_migrations", func(t *testing.T) {
-		t.Cleanup(func() { clearMap(registeredGoMigrations) })
-		file1, file2, file3 := "00001_a.go", "00998_b.go", "00999_c.go"
-		// Only register file1 and file3, somehow user forgot to init in the
-		// valid looking file2 Go migration
-		AddNamedMigrationContext(file1, nil, nil)
-		AddNamedMigrationContext(file3, nil, nil)
-		check.Number(t, len(registeredGoMigrations), 2)
-		tmp := t.TempDir()
-		dir1 := filepath.Join(tmp, "migrations", "dir1")
-		err := os.MkdirAll(dir1, 0755)
-		check.NoError(t, err)
-		// Include the valid file2 with file1, file3. But remember, it has NOT been
-		// registered.
-		createEmptyFile(t, dir1, file1)
-		createEmptyFile(t, dir1, file2)
-		createEmptyFile(t, dir1, file3)
-		all, err := collectMigrationsFS(os.DirFS(tmp), "migrations/dir1", 0, math.MaxInt64, registeredGoMigrations)
-		check.NoError(t, err)
-		check.Number(t, len(all), 3)
-		check.Number(t, all[0].Version, 1)
-		check.Bool(t, all[0].Registered, true)
-		check.Number(t, all[1].Version, 998)
-		// This migrations is marked unregistered and will lazily raise an error if/when this
-		// migration is run
-		check.Bool(t, all[1].Registered, false)
-		check.Number(t, all[2].Version, 999)
-		check.Bool(t, all[2].Registered, true)
-	})
-	t.Run("with_skipped_go_files", func(t *testing.T) {
-		t.Cleanup(func() { clearMap(registeredGoMigrations) })
-		file1, file2, file3, file4 := "00001_a.go", "00002_b.sql", "00999_c_test.go", "embed.go"
-		AddNamedMigrationContext(file1, nil, nil)
-		check.Number(t, len(registeredGoMigrations), 1)
-		tmp := t.TempDir()
-		dir1 := filepath.Join(tmp, "migrations", "dir1")
-		err := os.MkdirAll(dir1, 0755)
-		check.NoError(t, err)
-		createEmptyFile(t, dir1, file1)
-		createEmptyFile(t, dir1, file2)
-		createEmptyFile(t, dir1, file3)
-		createEmptyFile(t, dir1, file4)
-		all, err := collectMigrationsFS(os.DirFS(tmp), "migrations/dir1", 0, math.MaxInt64, registeredGoMigrations)
-		check.NoError(t, err)
-		check.Number(t, len(all), 2)
-		check.Number(t, all[0].Version, 1)
-		check.Bool(t, all[0].Registered, true)
-		check.Number(t, all[1].Version, 2)
-		check.Bool(t, all[1].Registered, false)
-	})
-	t.Run("current_and_target", func(t *testing.T) {
-		t.Cleanup(func() { clearMap(registeredGoMigrations) })
-		file1, file2, file3 := "01001_a.go", "01002_b.sql", "01003_c.go"
-		AddNamedMigrationContext(file1, nil, nil)
-		AddNamedMigrationContext(file3, nil, nil)
-		check.Number(t, len(registeredGoMigrations), 2)
-		tmp := t.TempDir()
-		dir1 := filepath.Join(tmp, "migrations", "dir1")
-		err := os.MkdirAll(dir1, 0755)
-		check.NoError(t, err)
-		createEmptyFile(t, dir1, file1)
-		createEmptyFile(t, dir1, file2)
-		createEmptyFile(t, dir1, file3)
-		all, err := collectMigrationsFS(os.DirFS(tmp), "migrations/dir1", 1001, 1003, registeredGoMigrations)
-		check.NoError(t, err)
-		check.Number(t, len(all), 2)
-		check.Number(t, all[0].Version, 1002)
-		check.Number(t, all[1].Version, 1003)
-	})
-}
-
-func TestVersionFilter(t *testing.T) {
-	t.Parallel()
-
-	tests := []struct {
-		v       int64
-		current int64
-		target  int64
-		want    bool
-	}{
-		{2, 1, 3, true},  // v is within the range
-		{4, 1, 3, false}, // v is outside the range
-		{2, 3, 1, true},  // v is within the reversed range
-		{4, 3, 1, false}, // v is outside the reversed range
-		{3, 1, 3, true},  // v is equal to target
-		{1, 1, 3, false}, // v is equal to current, not within the range
-		{1, 3, 1, false}, // v is equal to current, not within the reversed range
-		// Always return false if current equal target
-		{1, 2, 2, false},
-		{2, 2, 2, false},
-		{3, 2, 2, false},
-	}
-	for _, tc := range tests {
-		t.Run("", func(t *testing.T) {
-			got := versionFilter(tc.v, tc.current, tc.target)
-			if got != tc.want {
-				t.Errorf("versionFilter(%d, %d, %d) = %v, want %v", tc.v, tc.current, tc.target, got, tc.want)
-			}
-		})
-	}
-}
-func createEmptyFile(t *testing.T, dir, name string) {
-	path := filepath.Join(dir, name)
-	f, err := os.Create(path)
-	check.NoError(t, err)
-	defer f.Close()
-}
-
-func clearMap(m map[int64]*Migration) {
-	for k := range m {
-		delete(m, k)
-	}
-}
