diff --git a/CHANGELOG.md b/CHANGELOG.md
index 28b2652..1d4fa25 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,118 +1,5 @@
 # Changelog
 
-## v4.15.0 - TBD
-
-**DEPRECATION NOTICE** Timeout Middleware Deprecated - Use ContextTimeout Instead
-
-The `middleware.Timeout` middleware has been **deprecated** due to fundamental architectural issues that cause
-data races. Use `middleware.ContextTimeout` or `middleware.ContextTimeoutWithConfig` instead.
-
-**Why is this being deprecated?**
-
-The Timeout middleware manipulates response writers across goroutine boundaries, which causes data races that
-cannot be reliably fixed without a complete architectural redesign. The middleware:
-
-- Swaps the response writer using `http.TimeoutHandler`
-- Must be the first middleware in the chain (fragile constraint)
-- Can cause races with other middleware (Logger, metrics, custom middleware)
-- Has been the source of multiple race condition fixes over the years
-
-**What should you use instead?**
-
-The `ContextTimeout` middleware (available since v4.12.0) provides timeout functionality using Go's standard
-context mechanism. It is:
-
-- Race-free by design
-- Can be placed anywhere in the middleware chain
-- Simpler and more maintainable
-- Compatible with all other middleware
-
-**Migration Guide:**
-
-```go
-// Before (deprecated):
-e.Use(middleware.Timeout())
-
-// After (recommended):
-e.Use(middleware.ContextTimeout(30 * time.Second))
-```
-
-With configuration:
-```go
-// Before (deprecated):
-e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
-    Timeout: 30 * time.Second,
-    Skipper: func(c echo.Context) bool {
-        return c.Path() == "/health"
-    },
-}))
-
-// After (recommended):
-e.Use(middleware.ContextTimeoutWithConfig(middleware.ContextTimeoutConfig{
-    Timeout: 30 * time.Second,
-    Skipper: func(c echo.Context) bool {
-        return c.Path() == "/health"
-    },
-}))
-```
-
-**Important Behavioral Differences:**
-
-1. **Handler cooperation required**: With ContextTimeout, your handlers must check `context.Done()` for cooperative
-   cancellation. The old Timeout middleware would send a 503 response regardless of handler cooperation, but had
-   data race issues.
-
-2. **Error handling**: ContextTimeout returns errors through the standard error handling flow. Handlers that receive
-   `context.DeadlineExceeded` should handle it appropriately:
-
-```go
-e.GET("/long-task", func(c echo.Context) error {
-    ctx := c.Request().Context()
-
-    // Example: database query with context
-    result, err := db.QueryContext(ctx, "SELECT * FROM large_table")
-    if err != nil {
-        if errors.Is(err, context.DeadlineExceeded) {
-            // Handle timeout
-            return echo.NewHTTPError(http.StatusServiceUnavailable, "Request timeout")
-        }
-        return err
-    }
-
-    return c.JSON(http.StatusOK, result)
-})
-```
-
-3. **Background tasks**: For long-running background tasks, use goroutines with context:
-
-```go
-e.GET("/async-task", func(c echo.Context) error {
-    ctx := c.Request().Context()
-
-    resultCh := make(chan Result, 1)
-    errCh := make(chan error, 1)
-
-    go func() {
-        result, err := performLongTask(ctx)
-        if err != nil {
-            errCh <- err
-            return
-        }
-        resultCh <- result
-    }()
-
-    select {
-    case result := <-resultCh:
-        return c.JSON(http.StatusOK, result)
-    case err := <-errCh:
-        return err
-    case <-ctx.Done():
-        return echo.NewHTTPError(http.StatusServiceUnavailable, "Request timeout")
-    }
-})
-```
-
-
 ## v4.14.0 - 2025-12-11
 
 `middleware.Logger` has been deprecated. For request logging, use `middleware.RequestLogger` or
diff --git a/middleware/body_dump.go b/middleware/body_dump.go
index add778d..e4119ec 100644
--- a/middleware/body_dump.go
+++ b/middleware/body_dump.go
@@ -66,12 +66,8 @@ func BodyDumpWithConfig(config BodyDumpConfig) echo.MiddlewareFunc {
 
 			// Request
 			reqBody := []byte{}
-			if c.Request().Body != nil {
-				var readErr error
-				reqBody, readErr = io.ReadAll(c.Request().Body)
-				if readErr != nil {
-					return readErr
-				}
+			if c.Request().Body != nil { // Read
+				reqBody, _ = io.ReadAll(c.Request().Body)
 			}
 			c.Request().Body = io.NopCloser(bytes.NewBuffer(reqBody)) // Reset
 
diff --git a/middleware/body_dump_test.go b/middleware/body_dump_test.go
index 7a7dee3..e880af4 100644
--- a/middleware/body_dump_test.go
+++ b/middleware/body_dump_test.go
@@ -140,65 +140,3 @@ func TestBodyDumpResponseWriter_CanNotHijack(t *testing.T) {
 	_, _, err := bdrw.Hijack()
 	assert.EqualError(t, err, "feature not supported")
 }
-
-func TestBodyDump_ReadError(t *testing.T) {
-	e := echo.New()
-
-	// Create a reader that fails during read
-	failingReader := &failingReadCloser{
-		data:     []byte("partial data"),
-		failAt:   7, // Fail after 7 bytes
-		failWith: errors.New("connection reset"),
-	}
-
-	req := httptest.NewRequest(http.MethodPost, "/", failingReader)
-	rec := httptest.NewRecorder()
-	c := e.NewContext(req, rec)
-
-	h := func(c echo.Context) error {
-		// This handler should not be reached if body read fails
-		body, _ := io.ReadAll(c.Request().Body)
-		return c.String(http.StatusOK, string(body))
-	}
-
-	requestBodyReceived := ""
-	mw := BodyDump(func(c echo.Context, reqBody, resBody []byte) {
-		requestBodyReceived = string(reqBody)
-	})
-
-	err := mw(h)(c)
-
-	// Verify error is propagated
-	assert.Error(t, err)
-	assert.Contains(t, err.Error(), "connection reset")
-
-	// Verify handler was not executed (callback wouldn't have received data)
-	assert.Empty(t, requestBodyReceived)
-}
-
-// failingReadCloser is a helper type for testing read errors
-type failingReadCloser struct {
-	data     []byte
-	pos      int
-	failAt   int
-	failWith error
-}
-
-func (f *failingReadCloser) Read(p []byte) (n int, err error) {
-	if f.pos >= f.failAt {
-		return 0, f.failWith
-	}
-
-	n = copy(p, f.data[f.pos:])
-	f.pos += n
-
-	if f.pos >= f.failAt {
-		return n, f.failWith
-	}
-
-	return n, nil
-}
-
-func (f *failingReadCloser) Close() error {
-	return nil
-}
diff --git a/middleware/body_limit.go b/middleware/body_limit.go
index d13ad2c..7d3c665 100644
--- a/middleware/body_limit.go
+++ b/middleware/body_limit.go
@@ -6,7 +6,6 @@ package middleware
 import (
 	"fmt"
 	"io"
-	"net/http"
 	"sync"
 
 	"github.com/labstack/echo/v4"
@@ -78,10 +77,7 @@ func BodyLimitWithConfig(config BodyLimitConfig) echo.MiddlewareFunc {
 			}
 
 			// Based on content read
-			r, ok := pool.Get().(*limitedReader)
-			if !ok {
-				return echo.NewHTTPError(http.StatusInternalServerError, "invalid pool object")
-			}
+			r := pool.Get().(*limitedReader)
 			r.Reset(req.Body)
 			defer pool.Put(r)
 			req.Body = r
diff --git a/middleware/compress.go b/middleware/compress.go
index 48ccc98..012b76b 100644
--- a/middleware/compress.go
+++ b/middleware/compress.go
@@ -96,7 +96,7 @@ func GzipWithConfig(config GzipConfig) echo.MiddlewareFunc {
 				i := pool.Get()
 				w, ok := i.(*gzip.Writer)
 				if !ok {
-					return echo.NewHTTPError(http.StatusInternalServerError, "invalid pool object")
+					return echo.NewHTTPError(http.StatusInternalServerError, i.(error).Error())
 				}
 				rw := res.Writer
 				w.Reset(rw)
@@ -189,9 +189,7 @@ func (w *gzipResponseWriter) Flush() {
 		w.Writer.Write(w.buffer.Bytes())
 	}
 
-	if gw, ok := w.Writer.(*gzip.Writer); ok {
-		gw.Flush()
-	}
+	w.Writer.(*gzip.Writer).Flush()
 	_ = http.NewResponseController(w.ResponseWriter).Flush()
 }
 
diff --git a/middleware/compress_test.go b/middleware/compress_test.go
index c9083ee..4bbdfdb 100644
--- a/middleware/compress_test.go
+++ b/middleware/compress_test.go
@@ -284,7 +284,7 @@ func TestGzipErrorReturnedInvalidConfig(t *testing.T) {
 	rec := httptest.NewRecorder()
 	e.ServeHTTP(rec, req)
 	assert.Equal(t, http.StatusInternalServerError, rec.Code)
-	assert.Contains(t, rec.Body.String(), `{"message":"invalid pool object"}`)
+	assert.Contains(t, rec.Body.String(), "gzip")
 }
 
 // Issue #806
diff --git a/middleware/context_timeout.go b/middleware/context_timeout.go
index 5d9ae97..02bd6d1 100644
--- a/middleware/context_timeout.go
+++ b/middleware/context_timeout.go
@@ -11,39 +11,6 @@ import (
 	"github.com/labstack/echo/v4"
 )
 
-// ContextTimeout Middleware
-//
-// ContextTimeout provides request timeout functionality using Go's context mechanism.
-// It is the recommended replacement for the deprecated Timeout middleware.
-//
-//
-// Basic Usage:
-//
-//	e.Use(middleware.ContextTimeout(30 * time.Second))
-//
-// With Configuration:
-//
-//	e.Use(middleware.ContextTimeoutWithConfig(middleware.ContextTimeoutConfig{
-//	    Timeout: 30 * time.Second,
-//	    Skipper: middleware.DefaultSkipper,
-//	}))
-//
-// Handler Example:
-//
-//	e.GET("/task", func(c echo.Context) error {
-//	    ctx := c.Request().Context()
-//
-//	    result, err := performTaskWithContext(ctx)
-//	    if err != nil {
-//	        if errors.Is(err, context.DeadlineExceeded) {
-//	            return echo.NewHTTPError(http.StatusServiceUnavailable, "timeout")
-//	        }
-//	        return err
-//	    }
-//
-//	    return c.JSON(http.StatusOK, result)
-//	})
-
 // ContextTimeoutConfig defines the config for ContextTimeout middleware.
 type ContextTimeoutConfig struct {
 	// Skipper defines a function to skip middleware.
diff --git a/middleware/logger.go b/middleware/logger.go
index 5902095..c800a8a 100644
--- a/middleware/logger.go
+++ b/middleware/logger.go
@@ -5,6 +5,7 @@ package middleware
 
 import (
 	"bytes"
+	"encoding/json"
 	"io"
 	"strconv"
 	"strings"
@@ -374,7 +375,10 @@ func LoggerWithConfig(config LoggerConfig) echo.MiddlewareFunc {
 					return buf.WriteString(s)
 				case "error":
 					if err != nil {
-						return writeJSONSafeString(buf, err.Error())
+						// Error may contain invalid JSON e.g. `"`
+						b, _ := json.Marshal(err.Error())
+						b = b[1 : len(b)-1]
+						return buf.Write(b)
 					}
 				case "latency":
 					l := stop.Sub(start)
diff --git a/middleware/logger_strings_test.go b/middleware/logger_strings_test.go
index 3d66404..90231a6 100644
--- a/middleware/logger_strings_test.go
+++ b/middleware/logger_strings_test.go
@@ -1,6 +1,3 @@
-// SPDX-License-Identifier: MIT
-// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors
-
 package middleware
 
 import (
diff --git a/middleware/logger_test.go b/middleware/logger_test.go
index e4b783d..7c58ce0 100644
--- a/middleware/logger_test.go
+++ b/middleware/logger_test.go
@@ -47,21 +47,6 @@ func TestLoggerDefaultMW(t *testing.T) {
 			whenError: errors.New("error"),
 			expect:    `{"time":"2020-04-28T01:26:40Z","id":"","remote_ip":"192.0.2.1","host":"example.com","method":"GET","uri":"/","user_agent":"","status":500,"error":"error","latency":1,"latency_human":"1µs","bytes_in":0,"bytes_out":36}` + "\n",
 		},
-		{
-			name:      "error with invalid UTF-8 sequences",
-			whenError: errors.New("invalid data: \xFF\xFE"),
-			expect:    `{"time":"2020-04-28T01:26:40Z","id":"","remote_ip":"192.0.2.1","host":"example.com","method":"GET","uri":"/","user_agent":"","status":500,"error":"invalid data: \ufffd\ufffd","latency":1,"latency_human":"1µs","bytes_in":0,"bytes_out":36}` + "\n",
-		},
-		{
-			name:      "error with JSON special characters (quotes and backslashes)",
-			whenError: errors.New(`error with "quotes" and \backslash`),
-			expect:    `{"time":"2020-04-28T01:26:40Z","id":"","remote_ip":"192.0.2.1","host":"example.com","method":"GET","uri":"/","user_agent":"","status":500,"error":"error with \"quotes\" and \\backslash","latency":1,"latency_human":"1µs","bytes_in":0,"bytes_out":36}` + "\n",
-		},
-		{
-			name:      "error with control characters (newlines and tabs)",
-			whenError: errors.New("error\nwith\nnewlines\tand\ttabs"),
-			expect:    `{"time":"2020-04-28T01:26:40Z","id":"","remote_ip":"192.0.2.1","host":"example.com","method":"GET","uri":"/","user_agent":"","status":500,"error":"error\nwith\nnewlines\tand\ttabs","latency":1,"latency_human":"1µs","bytes_in":0,"bytes_out":36}` + "\n",
-		},
 		{
 			name:           "ok, remote_ip from X-Real-Ip header",
 			whenHeader:     map[string]string{echo.HeaderXRealIP: "127.0.0.1"},
diff --git a/middleware/proxy.go b/middleware/proxy.go
index f268700..050c59d 100644
--- a/middleware/proxy.go
+++ b/middleware/proxy.go
@@ -169,21 +169,15 @@ func proxyRaw(t *ProxyTarget, c echo.Context, config ProxyConfig) http.Handler {
 
 		errCh := make(chan error, 2)
 		cp := func(dst io.Writer, src io.Reader) {
-			_, copyErr := io.Copy(dst, src)
-			errCh <- copyErr
+			_, err = io.Copy(dst, src)
+			errCh <- err
 		}
 
 		go cp(out, in)
 		go cp(in, out)
-
-		// Wait for BOTH goroutines to complete
-		err1 := <-errCh
-		err2 := <-errCh
-
-		if err1 != nil && err1 != io.EOF {
-			c.Set("_error", fmt.Errorf("proxy raw, copy body error=%w, url=%s", err1, t.URL))
-		} else if err2 != nil && err2 != io.EOF {
-			c.Set("_error", fmt.Errorf("proxy raw, copy body error=%w, url=%s", err2, t.URL))
+		err = <-errCh
+		if err != nil && err != io.EOF {
+			c.Set("_error", fmt.Errorf("proxy raw, copy body error=%w, url=%s", err, t.URL))
 		}
 	})
 }
diff --git a/middleware/rate_limiter.go b/middleware/rate_limiter.go
index 2746a3d..70b89b0 100644
--- a/middleware/rate_limiter.go
+++ b/middleware/rate_limiter.go
@@ -4,7 +4,6 @@
 package middleware
 
 import (
-	"math"
 	"net/http"
 	"sync"
 	"time"
@@ -216,7 +215,7 @@ func NewRateLimiterMemoryStoreWithConfig(config RateLimiterMemoryStoreConfig) (s
 		store.expiresIn = DefaultRateLimiterMemoryStoreConfig.ExpiresIn
 	}
 	if config.Burst == 0 {
-		store.burst = int(math.Max(1, math.Ceil(float64(config.Rate))))
+		store.burst = int(config.Rate)
 	}
 	store.visitors = make(map[string]*Visitor)
 	store.timeNow = time.Now
@@ -250,9 +249,8 @@ func (store *RateLimiterMemoryStore) Allow(identifier string) (bool, error) {
 	if now.Sub(store.lastCleanup) > store.expiresIn {
 		store.cleanupStaleVisitors()
 	}
-	allowed := limiter.AllowN(now, 1)
 	store.mutex.Unlock()
-	return allowed, nil
+	return limiter.AllowN(store.timeNow(), 1), nil
 }
 
 /*
diff --git a/middleware/rate_limiter_test.go b/middleware/rate_limiter_test.go
index 655d473..1de7b63 100644
--- a/middleware/rate_limiter_test.go
+++ b/middleware/rate_limiter_test.go
@@ -9,7 +9,6 @@ import (
 	"net/http"
 	"net/http/httptest"
 	"sync"
-	"sync/atomic"
 	"testing"
 	"time"
 
@@ -410,33 +409,6 @@ func TestNewRateLimiterMemoryStore(t *testing.T) {
 	}
 }
 
-func TestRateLimiterMemoryStore_FractionalRateDefaultBurst(t *testing.T) {
-	store := NewRateLimiterMemoryStoreWithConfig(RateLimiterMemoryStoreConfig{
-		Rate: 0.5, // fractional rate should get a burst of at least 1
-	})
-
-	base := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
-	store.timeNow = func() time.Time {
-		return base
-	}
-
-	allowed, err := store.Allow("user")
-	assert.NoError(t, err)
-	assert.True(t, allowed, "first request should not be blocked")
-
-	allowed, err = store.Allow("user")
-	assert.NoError(t, err)
-	assert.False(t, allowed, "burst token should be consumed immediately")
-
-	store.timeNow = func() time.Time {
-		return base.Add(2 * time.Second)
-	}
-
-	allowed, err = store.Allow("user")
-	assert.NoError(t, err)
-	assert.True(t, allowed, "token should refill for fractional rate after time passes")
-}
-
 func generateAddressList(count int) []string {
 	addrs := make([]string, count)
 	for i := 0; i < count; i++ {
@@ -485,142 +457,3 @@ func BenchmarkRateLimiterMemoryStore_conc100_10000(b *testing.B) {
 	var store = NewRateLimiterMemoryStoreWithConfig(RateLimiterMemoryStoreConfig{Rate: 100, Burst: 200, ExpiresIn: testExpiresIn})
 	benchmarkStore(store, 100, 10000, b)
 }
-
-// TestRateLimiterMemoryStore_TOCTOUFix verifies that the TOCTOU race condition is fixed
-// by ensuring timeNow() is only called once per Allow() call
-func TestRateLimiterMemoryStore_TOCTOUFix(t *testing.T) {
-	t.Parallel()
-
-	store := NewRateLimiterMemoryStoreWithConfig(RateLimiterMemoryStoreConfig{
-		Rate:      1,
-		Burst:     1,
-		ExpiresIn: 2 * time.Second,
-	})
-
-	// Track time calls to verify we use the same time value
-	timeCallCount := 0
-	baseTime := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
-
-	store.timeNow = func() time.Time {
-		timeCallCount++
-		return baseTime
-	}
-
-	// First request - should succeed
-	allowed, err := store.Allow("127.0.0.1")
-	assert.NoError(t, err)
-	assert.True(t, allowed, "First request should be allowed")
-
-	// Verify timeNow() was only called once
-	assert.Equal(t, 1, timeCallCount, "timeNow() should only be called once per Allow()")
-}
-
-// TestRateLimiterMemoryStore_ConcurrentAccess verifies rate limiting correctness under concurrent load
-func TestRateLimiterMemoryStore_ConcurrentAccess(t *testing.T) {
-	t.Parallel()
-
-	store := NewRateLimiterMemoryStoreWithConfig(RateLimiterMemoryStoreConfig{
-		Rate:      10,
-		Burst:     5,
-		ExpiresIn: 5 * time.Second,
-	})
-
-	const goroutines = 50
-	const requestsPerGoroutine = 20
-
-	var wg sync.WaitGroup
-	var allowedCount, deniedCount int32
-
-	for i := 0; i < goroutines; i++ {
-		wg.Add(1)
-		go func() {
-			defer wg.Done()
-			for j := 0; j < requestsPerGoroutine; j++ {
-				allowed, err := store.Allow("test-user")
-				assert.NoError(t, err)
-				if allowed {
-					atomic.AddInt32(&allowedCount, 1)
-				} else {
-					atomic.AddInt32(&deniedCount, 1)
-				}
-				time.Sleep(time.Millisecond)
-			}
-		}()
-	}
-
-	wg.Wait()
-
-	totalRequests := goroutines * requestsPerGoroutine
-	allowed := int(allowedCount)
-	denied := int(deniedCount)
-
-	assert.Equal(t, totalRequests, allowed+denied, "All requests should be processed")
-	assert.Greater(t, denied, 0, "Some requests should be denied due to rate limiting")
-	assert.Greater(t, allowed, 0, "Some requests should be allowed")
-}
-
-// TestRateLimiterMemoryStore_RaceDetection verifies no data races with high concurrency
-// Run with: go test -race ./middleware -run TestRateLimiterMemoryStore_RaceDetection
-func TestRateLimiterMemoryStore_RaceDetection(t *testing.T) {
-	t.Parallel()
-
-	store := NewRateLimiterMemoryStoreWithConfig(RateLimiterMemoryStoreConfig{
-		Rate:      100,
-		Burst:     200,
-		ExpiresIn: 1 * time.Second,
-	})
-
-	const goroutines = 100
-	const requestsPerGoroutine = 100
-
-	var wg sync.WaitGroup
-	identifiers := []string{"user1", "user2", "user3", "user4", "user5"}
-
-	for i := 0; i < goroutines; i++ {
-		wg.Add(1)
-		go func(routineID int) {
-			defer wg.Done()
-			for j := 0; j < requestsPerGoroutine; j++ {
-				identifier := identifiers[routineID%len(identifiers)]
-				_, err := store.Allow(identifier)
-				assert.NoError(t, err)
-			}
-		}(i)
-	}
-
-	wg.Wait()
-}
-
-// TestRateLimiterMemoryStore_TimeOrdering verifies time ordering consistency in rate limiting decisions
-func TestRateLimiterMemoryStore_TimeOrdering(t *testing.T) {
-	t.Parallel()
-
-	store := NewRateLimiterMemoryStoreWithConfig(RateLimiterMemoryStoreConfig{
-		Rate:      1,
-		Burst:     2,
-		ExpiresIn: 5 * time.Second,
-	})
-
-	currentTime := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
-	store.timeNow = func() time.Time {
-		return currentTime
-	}
-
-	// First two requests should succeed (burst=2)
-	allowed1, _ := store.Allow("user1")
-	assert.True(t, allowed1, "Request 1 should be allowed (burst)")
-
-	allowed2, _ := store.Allow("user1")
-	assert.True(t, allowed2, "Request 2 should be allowed (burst)")
-
-	// Third request should be denied
-	allowed3, _ := store.Allow("user1")
-	assert.False(t, allowed3, "Request 3 should be denied (burst exhausted)")
-
-	// Advance time by 1 second
-	currentTime = currentTime.Add(1 * time.Second)
-
-	// Fourth request should succeed
-	allowed4, _ := store.Allow("user1")
-	assert.True(t, allowed4, "Request 4 should be allowed (1 token available)")
-}
diff --git a/middleware/static.go b/middleware/static.go
index 2d946c1..1016f1b 100644
--- a/middleware/static.go
+++ b/middleware/static.go
@@ -174,12 +174,6 @@ func StaticWithConfig(config StaticConfig) echo.MiddlewareFunc {
 			if err != nil {
 				return
 			}
-			// Security: We use path.Clean() (not filepath.Clean()) because:
-			// 1. HTTP URLs always use forward slashes, regardless of server OS
-			// 2. path.Clean() provides platform-independent behavior for URL paths
-			// 3. The "/" prefix forces absolute path interpretation, removing ".." components
-			// 4. Backslashes are treated as literal characters (not path separators), preventing traversal
-			// See static_windows.go for Go 1.20+ filepath.Clean compatibility notes
 			name := path.Join(config.Root, path.Clean("/"+p)) // "/"+ for security
 
 			if config.IgnoreBase {
diff --git a/middleware/static_test.go b/middleware/static_test.go
index a9722c0..a10ab80 100644
--- a/middleware/static_test.go
+++ b/middleware/static_test.go
@@ -100,48 +100,6 @@ func TestStatic(t *testing.T) {
 			expectCode:     http.StatusNotFound,
 			expectContains: "{\"message\":\"Not Found\"}\n",
 		},
-		{
-			name:           "nok, URL encoded path traversal (single encoding)",
-			whenURL:        "/%2e%2e%2fmiddleware/basic_auth.go",
-			expectCode:     http.StatusNotFound,
-			expectContains: "{\"message\":\"Not Found\"}\n",
-		},
-		{
-			name:           "nok, URL encoded path traversal (double encoding)",
-			whenURL:        "/%252e%252e%252fmiddleware/basic_auth.go",
-			expectCode:     http.StatusNotFound,
-			expectContains: "{\"message\":\"Not Found\"}\n",
-		},
-		{
-			name:           "nok, URL encoded path traversal (mixed encoding)",
-			whenURL:        "/%2e%2e/middleware/basic_auth.go",
-			expectCode:     http.StatusNotFound,
-			expectContains: "{\"message\":\"Not Found\"}\n",
-		},
-		{
-			name:           "nok, backslash URL encoded",
-			whenURL:        "/..%5c..%5cmiddleware/basic_auth.go",
-			expectCode:     http.StatusNotFound,
-			expectContains: "{\"message\":\"Not Found\"}\n",
-		},
-		//{ // Disabled: returns 404 under Windows
-		//	name:           "nok, null byte injection",
-		//	whenURL:        "/index.html%00.jpg",
-		//	expectCode:     http.StatusInternalServerError,
-		//	expectContains: "{\"message\":\"Internal Server Error\"}\n",
-		//},
-		{
-			name:           "nok, mixed backslash and forward slash traversal",
-			whenURL:        "/..\\../middleware/basic_auth.go",
-			expectCode:     http.StatusNotFound,
-			expectContains: "{\"message\":\"Not Found\"}\n",
-		},
-		{
-			name:           "nok, trailing dots (Windows edge case)",
-			whenURL:        "/../middleware/basic_auth.go...",
-			expectCode:     http.StatusNotFound,
-			expectContains: "{\"message\":\"Not Found\"}\n",
-		},
 		{
 			name:           "ok, do not serve file, when a handler took care of the request",
 			whenURL:        "/regular-handler",
diff --git a/middleware/timeout.go b/middleware/timeout.go
index c0a77a4..c2aebef 100644
--- a/middleware/timeout.go
+++ b/middleware/timeout.go
@@ -59,12 +59,6 @@ import (
 //
 
 // TimeoutConfig defines the config for Timeout middleware.
-//
-// Deprecated: Use ContextTimeoutConfig with ContextTimeout or ContextTimeoutWithConfig instead.
-// The Timeout middleware has architectural issues that cause data races due to response writer
-// manipulation across goroutines. It must be the first middleware in the chain, making it fragile.
-// The ContextTimeout middleware provides timeout functionality using Go's context mechanism,
-// which is race-free and can be placed anywhere in the middleware chain.
 type TimeoutConfig struct {
 	// Skipper defines a function to skip middleware.
 	Skipper Skipper
@@ -95,38 +89,11 @@ var DefaultTimeoutConfig = TimeoutConfig{
 
 // Timeout returns a middleware which returns error (503 Service Unavailable error) to client immediately when handler
 // call runs for longer than its time limit. NB: timeout does not stop handler execution.
-//
-// Deprecated: Use ContextTimeout instead. This middleware has known data race issues due to response writer
-// manipulation. See https://github.com/labstack/echo/blob/master/middleware/context_timeout.go for the
-// recommended alternative.
-//
-// Example migration:
-//
-//	// Before:
-//	e.Use(middleware.Timeout())
-//
-//	// After:
-//	e.Use(middleware.ContextTimeout(30 * time.Second))
 func Timeout() echo.MiddlewareFunc {
 	return TimeoutWithConfig(DefaultTimeoutConfig)
 }
 
 // TimeoutWithConfig returns a Timeout middleware with config or panics on invalid configuration.
-//
-// Deprecated: Use ContextTimeoutWithConfig instead. This middleware has architectural data race issues.
-// See the ContextTimeout middleware for a race-free alternative that uses Go's context mechanism.
-//
-// Example migration:
-//
-//	// Before:
-//	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
-//		Timeout: 30 * time.Second,
-//	}))
-//
-//	// After:
-//	e.Use(middleware.ContextTimeoutWithConfig(middleware.ContextTimeoutConfig{
-//		Timeout: 30 * time.Second,
-//	}))
 func TimeoutWithConfig(config TimeoutConfig) echo.MiddlewareFunc {
 	mw, err := config.ToMiddleware()
 	if err != nil {
@@ -136,8 +103,6 @@ func TimeoutWithConfig(config TimeoutConfig) echo.MiddlewareFunc {
 }
 
 // ToMiddleware converts Config to middleware or returns an error for invalid configuration
-//
-// Deprecated: Use ContextTimeoutConfig.ToMiddleware instead.
 func (config TimeoutConfig) ToMiddleware() (echo.MiddlewareFunc, error) {
 	if config.Skipper == nil {
 		config.Skipper = DefaultTimeoutConfig.Skipper
diff --git a/middleware/timeout_test.go b/middleware/timeout_test.go
index 4cdd425..e8415d6 100644
--- a/middleware/timeout_test.go
+++ b/middleware/timeout_test.go
@@ -181,25 +181,25 @@ func TestTimeoutTestRequestClone(t *testing.T) {
 
 }
 
-//func TestTimeoutRecoversPanic(t *testing.T) {
-//	t.Parallel()
-//	e := echo.New()
-//	e.Use(Recover()) // recover middleware will handler our panic
-//	e.Use(TimeoutWithConfig(TimeoutConfig{
-//		Timeout: 50 * time.Millisecond,
-//	}))
-//
-//	e.GET("/", func(c echo.Context) error {
-//		panic("panic!!!")
-//	})
-//
-//	req := httptest.NewRequest(http.MethodGet, "/", nil)
-//	rec := httptest.NewRecorder()
-//
-//	assert.NotPanics(t, func() {
-//		e.ServeHTTP(rec, req)
-//	})
-//}
+func TestTimeoutRecoversPanic(t *testing.T) {
+	t.Parallel()
+	e := echo.New()
+	e.Use(Recover()) // recover middleware will handler our panic
+	e.Use(TimeoutWithConfig(TimeoutConfig{
+		Timeout: 50 * time.Millisecond,
+	}))
+
+	e.GET("/", func(c echo.Context) error {
+		panic("panic!!!")
+	})
+
+	req := httptest.NewRequest(http.MethodGet, "/", nil)
+	rec := httptest.NewRecorder()
+
+	assert.NotPanics(t, func() {
+		e.ServeHTTP(rec, req)
+	})
+}
 
 func TestTimeoutDataRace(t *testing.T) {
 	t.Parallel()
