diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000..2d261e8
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,7 @@
+# Changelog
+
+## 0.9.0 (2016-03-31)
+
+- Reuse context objects via sync.Pool for zero-allocation routing [#33](https://github.com/pressly/chi/pull/33)
+- BREAKING NOTE: due to subtle API changes, previously `chi.URLParams(ctx)["id"]` used to access url parameters
+  has changed to: `chi.URLParam(ctx, "id")`
diff --git a/README.md b/README.md
index 6bb1e87..7cfab65 100644
--- a/README.md
+++ b/README.md
@@ -19,11 +19,12 @@ scaled very well.
 
 ## Features
 
-* Lightweight - cloc`d in ~600 LOC for the chi router
-* Fast - yes, see [benchmarks](#benchmarks)
-* Expressive routing - middlewares, inline middleware groups/chains, and subrouter mounting
-* Request context control (value chaining, deadlines and timeouts) - built on `net/context`
-* Robust (tested, used in production)
+* **Lightweight** - cloc'd in <1000 LOC for the chi router
+* **Fast** - yes, see [benchmarks](#benchmarks)
+* **Zero allocations** - no GC pressure during routing
+* **Designed for modular/composable APIs** - middlewares, inline middleware groups/chains, and subrouter mounting
+* **Context control** - built on `net/context` with value chaining, deadlines and timeouts
+* **Robust** - tested / used in production
 
 ## Router design
 
@@ -122,7 +123,7 @@ func StdHandler(w http.ResponseWriter, r *http.Request) {
 ```go
 // net/context HTTP request handler
 func CtxHandler(ctx context.Context, w http.ResponseWriter, r *http.Request) {
-  userID := chi.URLParams(ctx)["userID"] // from a route like /users/:userID
+  userID := chi.URLParam(ctx, "userID") // from a route like /users/:userID
   key := ctx.Value("key").(string)
   w.Write([]byte(fmt.Sprintf("hi %v, %v", userID, key)))
 }
@@ -200,7 +201,7 @@ func main() {
 
 func ArticleCtx(next chi.Handler) chi.Handler {
   return chi.HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
-    articleID := chi.URLParams(ctx)["articleID"]
+    articleID := chi.URLParam(ctx, "articleID")
     article, err := dbGetArticle(articleID)
     if err != nil {
       http.Error(w, http.StatusText(404), 404)
@@ -284,11 +285,24 @@ See discussions:
 
 The benchmark suite: https://github.com/pkieltyka/go-http-routing-benchmark
 
-The results as of Nov. 6, 2015 - https://gist.github.com/pkieltyka/505b07b09f5c63e36ef5
-
-Note: by design, chi allocates new routing URLParams map for each request, as opposed
-to reusing URLParams from a pool.
-
+```shell
+BenchmarkChi_Param       	10000000	       181 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_Param5      	 3000000	       570 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_Param20     	 1000000	      2057 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_ParamWrite  	 5000000	       245 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_GithubStatic	 5000000	       250 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_GithubParam 	 2000000	       589 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_GithubAll   	   10000	    102664 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_GPlusStatic 	10000000	       161 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_GPlusParam  	 5000000	       291 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_GPlus2Params	 5000000	       393 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_GPlusAll    	  300000	      4335 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_ParseStatic 	10000000	       162 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_ParseParam  	10000000	       227 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_Parse2Params	 5000000	       327 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_ParseAll    	  200000	      7368 ns/op	       0 B/op	       0 allocs/op
+BenchmarkChi_StaticAll   	   30000	     57990 ns/op	       0 B/op	       0 allocs/op
+```
 
 ## Credits
 
@@ -298,18 +312,6 @@ to reusing URLParams from a pool.
 * Armon Dadgar for https://github.com/armon/go-radix
 * Contributions: [@VojtechVitek](https://github.com/VojtechVitek)
 
-
-## TODO
-
-* Mux options
-  * Trailing slash?
-  * Case insensitive paths?
-  * GET for HEAD requests (auto fallback)?
-* Register error handler (500's), ServerError() handler?
-* HTTP2 example
-  * both http 1.1 and http2 automatically.. just turn it on :)
-* Regexp support in router "/:id([0-9]+)" or "#id^[0-9]+$" or ..
-
 We'll be more than happy to see [your contributions](./CONTRIBUTING.md)!
 
 ## License
diff --git a/_examples/rest/main.go b/_examples/rest/main.go
index 5e584ea..34afb6c 100644
--- a/_examples/rest/main.go
+++ b/_examples/rest/main.go
@@ -9,8 +9,8 @@ import (
 	"time"
 
 	"github.com/pressly/chi"
-	"github.com/pressly/chi/_examples/rest/render"
 	"github.com/pressly/chi/middleware"
+	"github.com/pressly/chi/render"
 	"golang.org/x/net/context"
 )
 
@@ -113,7 +113,7 @@ type Article struct {
 
 func ArticleCtx(next chi.Handler) chi.Handler {
 	return chi.HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
-		articleID := chi.URLParams(ctx)["articleID"]
+		articleID := chi.URLParam(ctx, "articleID")
 		article, err := dbGetArticle(articleID)
 		if err != nil {
 			http.Error(w, http.StatusText(404), 404)
@@ -229,7 +229,7 @@ func adminRouter() http.Handler { // or chi.Router {
 		w.Write([]byte("admin: list accounts.."))
 	})
 	r.Get("/users/:userId", func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(fmt.Sprintf("admin: view user id %v", chi.URLParams(ctx)["userId"])))
+		w.Write([]byte(fmt.Sprintf("admin: view user id %v", chi.URLParam(ctx, "userId"))))
 	})
 	return r
 }
diff --git a/_examples/rest/render/render.go b/_examples/rest/render/render.go
deleted file mode 100644
index 2535818..0000000
--- a/_examples/rest/render/render.go
+++ /dev/null
@@ -1,49 +0,0 @@
-// Responder as a wrapper of https://github.com/unrolled/render
-// --
-// This is a good base to work off and extend for your own uses, or build your own.
-// For example, adding pagination to JSON() where you add a "Link" header that is
-// a cursor URL to the next page of results (check how GitHubb does it in their API docs).
-// The power is yours.
-package render
-
-import (
-	"net/http"
-
-	renderer "github.com/unrolled/render"
-)
-
-var (
-	Renderer *renderer.Render
-)
-
-func init() {
-	Renderer = renderer.New()
-}
-
-func Render(w http.ResponseWriter, e renderer.Engine, data interface{}) error {
-	return Renderer.Render(w, e, data)
-}
-
-func Data(w http.ResponseWriter, status int, v []byte) error {
-	return Renderer.Data(w, status, v)
-}
-
-func HTML(w http.ResponseWriter, status int, name string, binding interface{}, htmlOpt ...renderer.HTMLOptions) error {
-	return Renderer.HTML(w, status, name, binding, htmlOpt...)
-}
-
-func JSON(w http.ResponseWriter, status int, v interface{}) error {
-	return Renderer.JSON(w, status, v)
-}
-
-func JSONP(w http.ResponseWriter, status int, callback string, v interface{}) error {
-	return Renderer.JSONP(w, status, callback, v)
-}
-
-func Text(w http.ResponseWriter, status int, v string) error {
-	return Renderer.Text(w, status, v)
-}
-
-func XML(w http.ResponseWriter, status int, v interface{}) error {
-	return Renderer.XML(w, status, v)
-}
diff --git a/_examples/simple/main.go b/_examples/simple/main.go
index f6cb00b..cc6bec8 100644
--- a/_examples/simple/main.go
+++ b/_examples/simple/main.go
@@ -108,7 +108,7 @@ func createAccount(w http.ResponseWriter, r *http.Request) {
 }
 
 func getAccount(ctx context.Context, w http.ResponseWriter, r *http.Request) {
-	accountID := chi.URLParams(ctx)["accountID"]
+	accountID := chi.URLParam(ctx, "accountID")
 	account := ctx.Value("account").(string)
 	w.Write([]byte(fmt.Sprintf("get account id:%s details:%s", accountID, account)))
 }
diff --git a/chi.go b/chi.go
index f0adad7..3120329 100644
--- a/chi.go
+++ b/chi.go
@@ -58,9 +58,18 @@ func (h HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 	h(context.Background(), w, r)
 }
 
-func URLParams(ctx context.Context) map[string]string {
-	if urlParams, ok := ctx.Value(URLParamsCtxKey).(map[string]string); ok {
-		return urlParams
+// Returns the root level chi Context object
+func RootContext(ctx context.Context) *Context {
+	rctx, _ := ctx.(*Context)
+	if rctx == nil {
+		rctx = ctx.Value(rootCtxKey).(*Context)
 	}
-	return nil
+	return rctx
+}
+
+func URLParam(ctx context.Context, key string) string {
+	if rctx := RootContext(ctx); rctx != nil {
+		return rctx.Param(key)
+	}
+	return ""
 }
diff --git a/context.go b/context.go
new file mode 100644
index 0000000..a132fa7
--- /dev/null
+++ b/context.go
@@ -0,0 +1,60 @@
+package chi
+
+import "golang.org/x/net/context"
+
+var _ context.Context = &Context{}
+
+type ctxKey int
+
+const (
+	rootCtxKey ctxKey = iota
+)
+
+type Context struct {
+	context.Context
+
+	// URL parameter key and values
+	pkeys, pvalues []string
+
+	// Routing path override
+	routePath string
+}
+
+func newContext() *Context {
+	rctx := &Context{}
+	ctx := context.WithValue(context.Background(), rootCtxKey, rctx)
+	rctx.Context = ctx
+	return rctx
+}
+
+func (x *Context) Param(key string) string {
+	for i, k := range x.pkeys {
+		if k == key {
+			return x.pvalues[i]
+		}
+	}
+	return ""
+}
+
+func (x *Context) addParam(key string, value string) {
+	x.pkeys = append(x.pkeys, key)
+	x.pvalues = append(x.pvalues, value)
+}
+
+func (x *Context) delParam(key string) string {
+	for i, k := range x.pkeys {
+		if k == key {
+			v := x.pvalues[i]
+			x.pkeys = append(x.pkeys[:i], x.pkeys[i+1:]...)
+			x.pvalues = append(x.pvalues[:i], x.pvalues[i+1:]...)
+			return v
+		}
+	}
+	return ""
+}
+
+func (x *Context) reset() {
+	x.pkeys = x.pkeys[:0]
+	x.pvalues = x.pvalues[:0]
+	x.routePath = ""
+}
diff --git a/mux.go b/mux.go
index 3f54300..b71acb0 100644
--- a/mux.go
+++ b/mux.go
@@ -3,6 +3,7 @@ package chi
 import (
 	"fmt"
 	"net/http"
+	"sync"
 
 	"golang.org/x/net/context"
 )
@@ -23,6 +24,9 @@ type Mux struct {
 	// Controls the behaviour of middleware chain generation when a mux
 	// is registered as an inline group inside another mux.
 	inline bool
+
+	// Routing context pool
+	pool sync.Pool
 }
 
 type methodTyp int
@@ -54,15 +58,12 @@ var methodMap = map[string]methodTyp{
 	"TRACE":   mTRACE,
 }
 
-type ctxKey int
-
-const (
-	URLParamsCtxKey ctxKey = iota
-	SubRouterCtxKey
-)
-
 func NewMux() *Mux {
-	return &Mux{router: newTreeRouter(), handler: nil}
+	mux := &Mux{router: newTreeRouter(), handler: nil}
+	mux.pool.New = func() interface{} {
+		return newContext()
+	}
+	return mux
 }
 
 // Append to the middleware stack
@@ -188,8 +189,8 @@ func (mx *Mux) Mount(path string, handlers ...interface{}) {
 
 	// Wrap the sub-router in a handlerFunc to scope the request path for routing.
 	subHandler := HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
-		path := URLParams(ctx)["*"]
-		ctx = context.WithValue(ctx, SubRouterCtxKey, "/"+path)
+		rctx := RootContext(ctx)
+		rctx.routePath = "/" + rctx.delParam("*")
 		h.ServeHTTPC(ctx, w, r)
 	})
 
@@ -202,7 +203,10 @@ func (mx *Mux) Mount(path string, handlers ...interface{}) {
 }
 
 func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	mx.ServeHTTPC(context.Background(), w, r)
+	ctx := mx.pool.Get().(*Context)
+	mx.ServeHTTPC(ctx, w, r)
+	ctx.reset()
+	mx.pool.Put(ctx)
 }
 
 func (mx *Mux) ServeHTTPC(ctx context.Context, w http.ResponseWriter, r *http.Request) {
@@ -238,18 +242,15 @@ func (tr treeRouter) NotFoundHandlerFn() HandlerFunc {
 }
 
 func (tr treeRouter) ServeHTTPC(ctx context.Context, w http.ResponseWriter, r *http.Request) {
-	// Allocate a new url params map at the start of each request.
-	params, ok := ctx.Value(URLParamsCtxKey).(map[string]string)
-	if !ok || params == nil {
-		params = make(map[string]string, 0)
-		ctx = context.WithValue(ctx, URLParamsCtxKey, params)
+	// Grab the root context object
+	rctx, _ := ctx.(*Context)
+	if rctx == nil {
+		rctx = ctx.Value(rootCtxKey).(*Context)
 	}
 
 	// The request path
-	routePath, ok := ctx.Value(SubRouterCtxKey).(string)
-	if ok {
-		delete(params, "*")
-	} else {
+	routePath := rctx.routePath
+	if routePath == "" {
 		routePath = r.URL.Path
 	}
 
@@ -261,7 +262,8 @@ func (tr treeRouter) ServeHTTPC(ctx context.Context, w http.ResponseWriter, r *h
 	}
 
 	// Find the handler in the router
-	cxh := tr.routes[method].Find(routePath, params)
+	cxh := tr.routes[method].Find(rctx, routePath)
+
 	if cxh == nil {
 		tr.NotFoundHandlerFn().ServeHTTPC(ctx, w, r)
 		return
diff --git a/tree.go b/tree.go
index 2ad82d2..7e19b01 100644
--- a/tree.go
+++ b/tree.go
@@ -180,7 +180,7 @@ func (n *node) findEdge(ntyp nodeTyp, label byte) *node {
 
 // Recursive edge traversal by checking all nodeTyp groups along the way.
 // It's like searching through a three-dimensional radix trie.
-func (n *node) findNode(path string, params map[string]string) *node {
+func (n *node) findNode(ctx *Context, path string) *node {
 	nn := n
 	search := path
 
@@ -213,9 +213,9 @@ func (n *node) findNode(path string, params map[string]string) *node {
 			}
 
 			if xn.typ == ntCatchAll {
-				params["*"] = xsearch
+				ctx.addParam("*", xsearch)
 			} else {
-				params[xn.prefix[1:]] = xsearch[:p]
+				ctx.addParam(xn.prefix[1:], xsearch[:p])
 			}
 
 			xsearch = xsearch[p:]
@@ -233,7 +233,7 @@ func (n *node) findNode(path string, params map[string]string) *node {
 		}
 
 		// recursively find the next node..
-		fin := xn.findNode(xsearch, params)
+		fin := xn.findNode(ctx, xsearch)
 		if fin != nil {
 			// found a node, return it
 			return fin
@@ -241,9 +241,9 @@ func (n *node) findNode(path string, params map[string]string) *node {
 			// let's remove the param here if it was set
 			if xn.typ > ntStatic {
 				if xn.typ == ntCatchAll {
-					delete(params, "*")
+					ctx.delParam("*")
 				} else {
-					delete(params, xn.prefix[1:])
+					ctx.delParam(xn.prefix[1:])
 				}
 			}
 		}
@@ -368,8 +368,8 @@ func (t *tree) Insert(pattern string, handler Handler) {
 	return
 }
 
-func (t *tree) Find(path string, params map[string]string) Handler {
-	node := t.root.findNode(path, params)
+func (t *tree) Find(ctx *Context, path string) Handler {
+	node := t.root.findNode(ctx, path)
 	if node == nil {
 		return nil
 	}
