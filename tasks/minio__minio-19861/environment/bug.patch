diff --git a/cmd/api-response.go b/cmd/api-response.go
index 5caa76bb5..01a96cac4 100644
--- a/cmd/api-response.go
+++ b/cmd/api-response.go
@@ -789,7 +789,7 @@ func generateInitiateMultipartUploadResponse(bucket, key, uploadID string) Initi
 }
 
 // generates CompleteMultipartUploadResponse for given bucket, key, location and ETag.
-func generateCompleteMultipartUploadResponse(bucket, key, location string, oi ObjectInfo) CompleteMultipartUploadResponse {
+func generateCompleteMultpartUploadResponse(bucket, key, location string, oi ObjectInfo) CompleteMultipartUploadResponse {
 	cs := oi.decryptChecksums(0)
 	c := CompleteMultipartUploadResponse{
 		Location: location,
diff --git a/cmd/object-api-utils.go b/cmd/object-api-utils.go
index 944a6bbc7..cc84b8935 100644
--- a/cmd/object-api-utils.go
+++ b/cmd/object-api-utils.go
@@ -1206,20 +1206,7 @@ func hasSpaceFor(di []*DiskInfo, size int64) (bool, error) {
 	}
 
 	if nDisks < len(di)/2 || nDisks <= 0 {
-		var errs []error
-		for index, disk := range di {
-			switch {
-			case disk == nil:
-				errs = append(errs, fmt.Errorf("disk[%d]: offline", index))
-			case disk.Error != "":
-				errs = append(errs, fmt.Errorf("disk %s: %s", disk.Endpoint, disk.Error))
-			case disk.Total == 0:
-				errs = append(errs, fmt.Errorf("disk %s: total is zero", disk.Endpoint))
-			}
-		}
-		// Log disk errors.
-		peersLogIf(context.Background(), errors.Join(errs...))
-		return false, fmt.Errorf("not enough online disks to calculate the available space, need %d, found %d", (len(di)/2)+1, nDisks)
+		return false, fmt.Errorf("not enough online disks to calculate the available space, expected (%d)/(%d)", (len(di)/2)+1, nDisks)
 	}
 
 	// Check we have enough on each disk, ignoring diskFillFraction.
diff --git a/cmd/object-handlers_test.go b/cmd/object-handlers_test.go
index 33de77680..0925c38c8 100644
--- a/cmd/object-handlers_test.go
+++ b/cmd/object-handlers_test.go
@@ -2914,7 +2914,7 @@ func testAPICompleteMultipartHandler(obj ObjectLayer, instanceType, bucketName s
 	s3MD5 := getCompleteMultipartMD5(inputParts[3].parts)
 
 	// generating the response body content for the success case.
-	successResponse := generateCompleteMultipartUploadResponse(bucketName, objectName, getGetObjectURL("", bucketName, objectName), ObjectInfo{ETag: s3MD5})
+	successResponse := generateCompleteMultpartUploadResponse(bucketName, objectName, getGetObjectURL("", bucketName, objectName), ObjectInfo{ETag: s3MD5})
 	encodedSuccessResponse := encodeResponse(successResponse)
 
 	ctx := context.Background()
diff --git a/cmd/object-multipart-handlers.go b/cmd/object-multipart-handlers.go
index ed6d3d56e..328494efc 100644
--- a/cmd/object-multipart-handlers.go
+++ b/cmd/object-multipart-handlers.go
@@ -1040,7 +1040,7 @@ func (api objectAPIHandlers) CompleteMultipartUploadHandler(w http.ResponseWrite
 	// Get object location.
 	location := getObjectLocation(r, globalDomainNames, bucket, object)
 	// Generate complete multipart response.
-	response := generateCompleteMultipartUploadResponse(bucket, object, location, objInfo)
+	response := generateCompleteMultpartUploadResponse(bucket, object, location, objInfo)
 	encodedSuccessResponse := encodeResponse(response)
 
 	// Write success response.
