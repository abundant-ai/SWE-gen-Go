diff --git a/.changes/v1.15/NEW FEATURES-20260212-104240.yaml b/.changes/v1.15/NEW FEATURES-20260212-104240.yaml
new file mode 100644
index 0000000000..1567580d89
--- /dev/null
+++ b/.changes/v1.15/NEW FEATURES-20260212-104240.yaml	
@@ -0,0 +1,5 @@
+kind: NEW FEATURES
+body: "validate: The validate command now checks the `backend` block. This ensures the backend type exists, that all required attributes are present, and that the backend's own validation logic passes."
+time: 2026-02-12T10:42:40.333849Z
+custom:
+    Issue: "38021"
diff --git a/internal/command/testdata/invalid-backend-configuration/missing-required-attr/main.tf b/internal/command/testdata/invalid-backend-configuration/missing-required-attr/main.tf
new file mode 100644
index 0000000000..ca9cb7b956
--- /dev/null
+++ b/internal/command/testdata/invalid-backend-configuration/missing-required-attr/main.tf
@@ -0,0 +1,9 @@
+terraform {
+  backend "gcs" {
+    # Missing required attribute "bucket"
+    #
+    # Everything else is missing as well, but this
+    # test fixture is intended for use testing the validate command,
+    # which is offline only. So lack of credentials etc is not a problem.
+  }
+}
diff --git a/internal/command/validate.go b/internal/command/validate.go
index f679e2fae8..c3bd859dbc 100644
--- a/internal/command/validate.go
+++ b/internal/command/validate.go
@@ -8,7 +8,10 @@ import (
 	"path/filepath"
 	"strings"
 
+	"github.com/hashicorp/hcl/v2"
+	"github.com/hashicorp/hcl/v2/hcldec"
 	"github.com/hashicorp/terraform/internal/addrs"
+	backendInit "github.com/hashicorp/terraform/internal/backend/init"
 	"github.com/hashicorp/terraform/internal/command/arguments"
 	"github.com/hashicorp/terraform/internal/command/views"
 	"github.com/hashicorp/terraform/internal/configs"
@@ -87,6 +90,13 @@ func (c *ValidateCommand) validate(dir string) tfdiags.Diagnostics {
 
 	diags = diags.Append(c.validateConfig(cfg))
 
+	// Validation of backend block, if present
+	// Backend blocks live outside the Terraform graph so we have to do this separately.
+	backend := cfg.Module.Backend
+	if backend != nil {
+		diags = diags.Append(c.validateBackend(backend))
+	}
+
 	// Unless excluded, we'll also do a quick validation of the Terraform test files. These live
 	// outside the Terraform graph so we have to do this separately.
 	if !c.ParsedArgs.NoTests {
@@ -157,6 +167,48 @@ func (c *ValidateCommand) validateTestFiles(cfg *configs.Config) tfdiags.Diagnos
 	return diags
 }
 
+// We validate the backend in an offline manner, so we use PrepareConfig to validate the configuration (and ENVs present),
+// but we never use the Configure method, as that will interact with third-party systems.
+//
+// The code in this method is very similar to the `backendInitFromConfig` method, expect it doesn't configure the backend.
+func (c *ValidateCommand) validateBackend(cfg *configs.Backend) tfdiags.Diagnostics {
+	var diags tfdiags.Diagnostics
+
+	bf := backendInit.Backend(cfg.Type)
+	if bf == nil {
+		detail := fmt.Sprintf("There is no backend type named %q.", cfg.Type)
+		if msg, removed := backendInit.RemovedBackends[cfg.Type]; removed {
+			detail = msg
+		}
+
+		diags = diags.Append(&hcl.Diagnostic{
+			Severity: hcl.DiagError,
+			Summary:  "Unsupported backend type",
+			Detail:   detail,
+			Subject:  &cfg.TypeRange,
+		})
+		return diags
+	}
+
+	b := bf()
+	backendSchema := b.ConfigSchema()
+
+	decSpec := backendSchema.DecoderSpec()
+	configVal, hclDiags := hcldec.Decode(cfg.Config, decSpec, nil)
+	diags = diags.Append(hclDiags)
+	if hclDiags.HasErrors() {
+		return diags
+	}
+
+	_, validateDiags := b.PrepareConfig(configVal)
+	diags = diags.Append(validateDiags)
+	if validateDiags.HasErrors() {
+		return diags
+	}
+
+	return diags
+}
+
 func (c *ValidateCommand) Synopsis() string {
 	return "Check whether the configuration is valid"
 }
