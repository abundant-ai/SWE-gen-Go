diff --git a/field.go b/field.go
index c8dd335..f40fa7b 100644
--- a/field.go
+++ b/field.go
@@ -25,7 +25,6 @@ import (
 	"math"
 	"time"
 
-	"go.uber.org/zap/internal/stacktrace"
 	"go.uber.org/zap/zapcore"
 )
 
@@ -375,7 +374,7 @@ func StackSkip(key string, skip int) Field {
 	// from expanding the zapcore.Field union struct to include a byte slice. Since
 	// taking a stacktrace is already so expensive (~10us), the extra allocation
 	// is okay.
-	return String(key, stacktrace.Take(skip+1)) // skip StackSkip
+	return String(key, takeStacktrace(skip+1)) // skip StackSkip
 }
 
 // Duration constructs a field with the given key and value. The encoder
diff --git a/field_test.go b/field_test.go
index f87f159..bbb9f79 100644
--- a/field_test.go
+++ b/field_test.go
@@ -29,7 +29,6 @@ import (
 	"time"
 
 	"github.com/stretchr/testify/assert"
-	"go.uber.org/zap/internal/stacktrace"
 	"go.uber.org/zap/zapcore"
 )
 
@@ -270,7 +269,7 @@ func TestStackField(t *testing.T) {
 	assert.Equal(t, "stacktrace", f.Key, "Unexpected field key.")
 	assert.Equal(t, zapcore.StringType, f.Type, "Unexpected field type.")
 	r := regexp.MustCompile(`field_test.go:(\d+)`)
-	assert.Equal(t, r.ReplaceAllString(stacktrace.Take(0), "field_test.go"), r.ReplaceAllString(f.String, "field_test.go"), "Unexpected stack trace")
+	assert.Equal(t, r.ReplaceAllString(takeStacktrace(0), "field_test.go"), r.ReplaceAllString(f.String, "field_test.go"), "Unexpected stack trace")
 	assertCanBeReused(t, f)
 }
 
@@ -279,7 +278,7 @@ func TestStackSkipField(t *testing.T) {
 	assert.Equal(t, "stacktrace", f.Key, "Unexpected field key.")
 	assert.Equal(t, zapcore.StringType, f.Type, "Unexpected field type.")
 	r := regexp.MustCompile(`field_test.go:(\d+)`)
-	assert.Equal(t, r.ReplaceAllString(stacktrace.Take(0), "field_test.go"), r.ReplaceAllString(f.String, "field_test.go"), f.String, "Unexpected stack trace")
+	assert.Equal(t, r.ReplaceAllString(takeStacktrace(0), "field_test.go"), r.ReplaceAllString(f.String, "field_test.go"), f.String, "Unexpected stack trace")
 	assertCanBeReused(t, f)
 }
 
@@ -287,7 +286,7 @@ func TestStackSkipFieldWithSkip(t *testing.T) {
 	f := StackSkip("stacktrace", 1)
 	assert.Equal(t, "stacktrace", f.Key, "Unexpected field key.")
 	assert.Equal(t, zapcore.StringType, f.Type, "Unexpected field type.")
-	assert.Equal(t, stacktrace.Take(1), f.String, "Unexpected stack trace")
+	assert.Equal(t, takeStacktrace(1), f.String, "Unexpected stack trace")
 	assertCanBeReused(t, f)
 }
 
diff --git a/logger.go b/logger.go
index 32d7372..9b45b07 100644
--- a/logger.go
+++ b/logger.go
@@ -27,7 +27,6 @@ import (
 	"strings"
 
 	"go.uber.org/zap/internal/bufferpool"
-	"go.uber.org/zap/internal/stacktrace"
 	"go.uber.org/zap/zapcore"
 )
 
@@ -364,11 +363,11 @@ func (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {
 
 	// Adding the caller or stack trace requires capturing the callers of
 	// this function. We'll share information between these two.
-	stackDepth := stacktrace.First
+	stackDepth := stacktraceFirst
 	if addStack {
-		stackDepth = stacktrace.Full
+		stackDepth = stacktraceFull
 	}
-	stack := stacktrace.Capture(log.callerSkip+callerSkipOffset, stackDepth)
+	stack := captureStacktrace(log.callerSkip+callerSkipOffset, stackDepth)
 	defer stack.Free()
 
 	if stack.Count() == 0 {
@@ -395,7 +394,7 @@ func (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {
 		buffer := bufferpool.Get()
 		defer buffer.Free()
 
-		stackfmt := stacktrace.NewFormatter(buffer)
+		stackfmt := newStackFormatter(buffer)
 
 		// We've already extracted the first frame, so format that
 		// separately and defer to stackfmt for the rest.
diff --git a/internal/stacktrace/stack.go b/stacktrace.go
similarity index 75%
rename from internal/stacktrace/stack.go
rename to stacktrace.go
index 82af755..1f152eb 100644
--- a/internal/stacktrace/stack.go
+++ b/stacktrace.go
@@ -1,4 +1,4 @@
-// Copyright (c) 2023 Uber Technologies, Inc.
+// Copyright (c) 2016 Uber Technologies, Inc.
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to deal
@@ -18,9 +18,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-// Package stacktrace provides support for gathering stack traces
-// efficiently.
-package stacktrace
+package zap
 
 import (
 	"runtime"
@@ -30,14 +28,13 @@ import (
 	"go.uber.org/zap/internal/pool"
 )
 
-var _stackPool = pool.New(func() *Stack {
-	return &Stack{
+var _stacktracePool = pool.New(func() *stacktrace {
+	return &stacktrace{
 		storage: make([]uintptr, 64),
 	}
 })
 
-// Stack is a captured stack trace.
-type Stack struct {
+type stacktrace struct {
 	pcs    []uintptr // program counters; always a subslice of storage
 	frames *runtime.Frames
 
@@ -51,30 +48,30 @@ type Stack struct {
 	storage []uintptr
 }
 
-// Depth specifies how deep of a stack trace should be captured.
-type Depth int
+// stacktraceDepth specifies how deep of a stack trace should be captured.
+type stacktraceDepth int
 
 const (
-	// First captures only the first frame.
-	First Depth = iota
+	// stacktraceFirst captures only the first frame.
+	stacktraceFirst stacktraceDepth = iota
 
-	// Full captures the entire call stack, allocating more
+	// stacktraceFull captures the entire call stack, allocating more
 	// storage for it if needed.
-	Full
+	stacktraceFull
 )
 
-// Capture captures a stack trace of the specified depth, skipping
+// captureStacktrace captures a stack trace of the specified depth, skipping
 // the provided number of frames. skip=0 identifies the caller of
-// Capture.
+// captureStacktrace.
 //
 // The caller must call Free on the returned stacktrace after using it.
-func Capture(skip int, depth Depth) *Stack {
-	stack := _stackPool.Get()
+func captureStacktrace(skip int, depth stacktraceDepth) *stacktrace {
+	stack := _stacktracePool.Get()
 
 	switch depth {
-	case First:
+	case stacktraceFirst:
 		stack.pcs = stack.storage[:1]
-	case Full:
+	case stacktraceFull:
 		stack.pcs = stack.storage
 	}
 
@@ -88,7 +85,7 @@ func Capture(skip int, depth Depth) *Stack {
 	// runtime.Callers truncates the recorded stacktrace if there is no
 	// room in the provided slice. For the full stack trace, keep expanding
 	// storage until there are fewer frames than there is room.
-	if depth == Full {
+	if depth == stacktraceFull {
 		pcs := stack.pcs
 		for numFrames == len(pcs) {
 			pcs = make([]uintptr, len(pcs)*2)
@@ -110,54 +107,50 @@ func Capture(skip int, depth Depth) *Stack {
 
 // Free releases resources associated with this stacktrace
 // and returns it back to the pool.
-func (st *Stack) Free() {
+func (st *stacktrace) Free() {
 	st.frames = nil
 	st.pcs = nil
-	_stackPool.Put(st)
+	_stacktracePool.Put(st)
 }
 
 // Count reports the total number of frames in this stacktrace.
 // Count DOES NOT change as Next is called.
-func (st *Stack) Count() int {
+func (st *stacktrace) Count() int {
 	return len(st.pcs)
 }
 
 // Next returns the next frame in the stack trace,
 // and a boolean indicating whether there are more after it.
-func (st *Stack) Next() (_ runtime.Frame, more bool) {
+func (st *stacktrace) Next() (_ runtime.Frame, more bool) {
 	return st.frames.Next()
 }
 
-// Take returns a string representation of the current stacktrace.
-//
-// skip is the number of frames to skip before recording the stack trace.
-// skip=0 identifies the caller of Take.
-func Take(skip int) string {
-	stack := Capture(skip+1, Full)
+func takeStacktrace(skip int) string {
+	stack := captureStacktrace(skip+1, stacktraceFull)
 	defer stack.Free()
 
 	buffer := bufferpool.Get()
 	defer buffer.Free()
 
-	stackfmt := NewFormatter(buffer)
+	stackfmt := newStackFormatter(buffer)
 	stackfmt.FormatStack(stack)
 	return buffer.String()
 }
 
-// Formatter formats a stack trace into a readable string representation.
-type Formatter struct {
+// stackFormatter formats a stack trace into a readable string representation.
+type stackFormatter struct {
 	b        *buffer.Buffer
 	nonEmpty bool // whehther we've written at least one frame already
 }
 
-// NewFormatter builds a new Formatter.
-func NewFormatter(b *buffer.Buffer) Formatter {
-	return Formatter{b: b}
+// newStackFormatter builds a new stackFormatter.
+func newStackFormatter(b *buffer.Buffer) stackFormatter {
+	return stackFormatter{b: b}
 }
 
 // FormatStack formats all remaining frames in the provided stacktrace -- minus
 // the final runtime.main/runtime.goexit frame.
-func (sf *Formatter) FormatStack(stack *Stack) {
+func (sf *stackFormatter) FormatStack(stack *stacktrace) {
 	// Note: On the last iteration, frames.Next() returns false, with a valid
 	// frame, but we ignore this frame. The last frame is a runtime frame which
 	// adds noise, since it's only either runtime.main or runtime.goexit.
@@ -167,7 +160,7 @@ func (sf *Formatter) FormatStack(stack *Stack) {
 }
 
 // FormatFrame formats the given frame.
-func (sf *Formatter) FormatFrame(frame runtime.Frame) {
+func (sf *stackFormatter) FormatFrame(frame runtime.Frame) {
 	if sf.nonEmpty {
 		sf.b.AppendByte('\n')
 	}
diff --git a/internal/stacktrace/stack_test.go b/stacktrace_test.go
similarity index 82%
rename from internal/stacktrace/stack_test.go
rename to stacktrace_test.go
index 195eeae..82b6af3 100644
--- a/internal/stacktrace/stack_test.go
+++ b/stacktrace_test.go
@@ -1,4 +1,4 @@
-// Copyright (c) 2023 Uber Technologies, Inc.
+// Copyright (c) 2016 Uber Technologies, Inc.
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to deal
@@ -18,7 +18,7 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-package stacktrace
+package zap
 
 import (
 	"bytes"
@@ -29,20 +29,20 @@ import (
 	"github.com/stretchr/testify/require"
 )
 
-func TestTake(t *testing.T) {
-	trace := Take(0)
+func TestTakeStacktrace(t *testing.T) {
+	trace := takeStacktrace(0)
 	lines := strings.Split(trace, "\n")
 	require.NotEmpty(t, lines, "Expected stacktrace to have at least one frame.")
 	assert.Contains(
 		t,
 		lines[0],
-		"go.uber.org/zap/internal/stacktrace.TestTake",
+		"go.uber.org/zap.TestTakeStacktrace",
 		"Expected stacktrace to start with the test.",
 	)
 }
 
-func TestTakeWithSkip(t *testing.T) {
-	trace := Take(1)
+func TestTakeStacktraceWithSkip(t *testing.T) {
+	trace := takeStacktrace(1)
 	lines := strings.Split(trace, "\n")
 	require.NotEmpty(t, lines, "Expected stacktrace to have at least one frame.")
 	assert.Contains(
@@ -53,10 +53,10 @@ func TestTakeWithSkip(t *testing.T) {
 	)
 }
 
-func TestTakeWithSkipInnerFunc(t *testing.T) {
+func TestTakeStacktraceWithSkipInnerFunc(t *testing.T) {
 	var trace string
 	func() {
-		trace = Take(2)
+		trace = takeStacktrace(2)
 	}()
 	lines := strings.Split(trace, "\n")
 	require.NotEmpty(t, lines, "Expected stacktrace to have at least one frame.")
@@ -68,13 +68,13 @@ func TestTakeWithSkipInnerFunc(t *testing.T) {
 	)
 }
 
-func TestTakeDeepStack(t *testing.T) {
+func TestTakeStacktraceDeepStack(t *testing.T) {
 	const (
 		N                  = 500
-		withStackDepthName = "go.uber.org/zap/internal/stacktrace.withStackDepth"
+		withStackDepthName = "go.uber.org/zap.withStackDepth"
 	)
 	withStackDepth(N, func() {
-		trace := Take(0)
+		trace := takeStacktrace(0)
 		for found := 0; found < N; found++ {
 			i := strings.Index(trace, withStackDepthName)
 			if i < 0 {
@@ -86,9 +86,9 @@ func TestTakeDeepStack(t *testing.T) {
 	})
 }
 
-func BenchmarkTake(b *testing.B) {
+func BenchmarkTakeStacktrace(b *testing.B) {
 	for i := 0; i < b.N; i++ {
-		Take(0)
+		takeStacktrace(0)
 	}
 }
 
