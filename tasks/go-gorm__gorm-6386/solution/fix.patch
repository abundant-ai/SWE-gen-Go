diff --git a/migrator/migrator.go b/migrator/migrator.go
index 64a5a4b..d97fbf3 100644
--- a/migrator/migrator.go
+++ b/migrator/migrator.go
@@ -110,15 +110,20 @@ func (m Migrator) FullDataTypeOf(field *schema.Field) (expr clause.Expr) {
 	return
 }
 
+func (m Migrator) GetQueryAndExecTx() (queryTx, execTx *gorm.DB) {
+	queryTx = m.DB.Session(&gorm.Session{})
+	execTx = queryTx
+	if m.DB.DryRun {
+		queryTx.DryRun = false
+		execTx = m.DB.Session(&gorm.Session{Logger: &printSQLLogger{Interface: m.DB.Logger}})
+	}
+	return queryTx, execTx
+}
+
 // AutoMigrate auto migrate values
 func (m Migrator) AutoMigrate(values ...interface{}) error {
 	for _, value := range m.ReorderModels(values, true) {
-		queryTx := m.DB.Session(&gorm.Session{})
-		execTx := queryTx
-		if m.DB.DryRun {
-			queryTx.DryRun = false
-			execTx = m.DB.Session(&gorm.Session{Logger: &printSQLLogger{Interface: m.DB.Logger}})
-		}
+		queryTx, execTx := m.GetQueryAndExecTx()
 		if !queryTx.Migrator().HasTable(value) {
 			if err := execTx.Migrator().CreateTable(value); err != nil {
 				return err
@@ -268,7 +273,7 @@ func (m Migrator) CreateTable(values ...interface{}) error {
 					}
 					if constraint := rel.ParseConstraint(); constraint != nil {
 						if constraint.Schema == stmt.Schema {
-							sql, vars := buildConstraint(constraint)
+							sql, vars := constraint.Build()
 							createTableSQL += sql + ","
 							values = append(values, vars...)
 						}
@@ -276,6 +281,11 @@ func (m Migrator) CreateTable(values ...interface{}) error {
 				}
 			}
 
+			for _, uni := range stmt.Schema.ParseUniqueConstraints() {
+				createTableSQL += "CONSTRAINT ? UNIQUE (?),"
+				values = append(values, clause.Column{Name: uni.Name}, clause.Expr{SQL: stmt.Quote(uni.Field.DBName)})
+			}
+
 			for _, chk := range stmt.Schema.ParseCheckConstraints() {
 				createTableSQL += "CONSTRAINT ? CHECK (?),"
 				values = append(values, clause.Column{Name: chk.Name}, clause.Expr{SQL: chk.Constraint})
@@ -439,6 +449,10 @@ func (m Migrator) RenameColumn(value interface{}, oldName, newName string) error
 
 // MigrateColumn migrate column
 func (m Migrator) MigrateColumn(value interface{}, field *schema.Field, columnType gorm.ColumnType) error {
+	if field.IgnoreMigration {
+		return nil
+	}
+
 	// found, smart migrate
 	fullDataType := strings.TrimSpace(strings.ToLower(m.DB.Migrator().FullDataTypeOf(field).SQL))
 	realDataType := strings.ToLower(columnType.DatabaseTypeName())
@@ -499,7 +513,7 @@ func (m Migrator) MigrateColumn(value interface{}, field *schema.Field, columnTy
 	}
 
 	// check unique
-	if unique, ok := columnType.Unique(); ok && unique != field.Unique {
+	if unique, ok := columnType.Unique(); ok && unique != (field.Unique || field.UniqueIndex != "") {
 		// not primary key
 		if !field.PrimaryKey {
 			alterColumn = true
@@ -630,37 +644,36 @@ func (m Migrator) DropView(name string) error {
 	return m.DB.Exec("DROP VIEW IF EXISTS ?", clause.Table{Name: name}).Error
 }
 
-func buildConstraint(constraint *schema.Constraint) (sql string, results []interface{}) {
-	sql = "CONSTRAINT ? FOREIGN KEY ? REFERENCES ??"
-	if constraint.OnDelete != "" {
-		sql += " ON DELETE " + constraint.OnDelete
-	}
-
-	if constraint.OnUpdate != "" {
-		sql += " ON UPDATE " + constraint.OnUpdate
-	}
-
-	var foreignKeys, references []interface{}
-	for _, field := range constraint.ForeignKeys {
-		foreignKeys = append(foreignKeys, clause.Column{Name: field.DBName})
-	}
-
-	for _, field := range constraint.References {
-		references = append(references, clause.Column{Name: field.DBName})
-	}
-	results = append(results, clause.Table{Name: constraint.Name}, foreignKeys, clause.Table{Name: constraint.ReferenceSchema.Table}, references)
-	return
-}
-
 // GuessConstraintAndTable guess statement's constraint and it's table based on name
-func (m Migrator) GuessConstraintAndTable(stmt *gorm.Statement, name string) (_ *schema.Constraint, _ *schema.Check, table string) {
+//
+// Deprecated: use GuessConstraintInterfaceAndTable instead.
+func (m Migrator) GuessConstraintAndTable(stmt *gorm.Statement, name string) (*schema.Constraint, *schema.CheckConstraint, string) {
+	constraint, table := m.GuessConstraintInterfaceAndTable(stmt, name)
+	switch c := constraint.(type) {
+	case *schema.Constraint:
+		return c, nil, table
+	case *schema.CheckConstraint:
+		return nil, c, table
+	default:
+		return nil, nil, table
+	}
+}
+
+// GuessConstraintInterfaceAndTable guess statement's constraint and it's table based on name
+// nolint:cyclop
+func (m Migrator) GuessConstraintInterfaceAndTable(stmt *gorm.Statement, name string) (_ schema.ConstraintInterface, table string) {
 	if stmt.Schema == nil {
-		return nil, nil, stmt.Table
+		return nil, stmt.Table
 	}
 
 	checkConstraints := stmt.Schema.ParseCheckConstraints()
 	if chk, ok := checkConstraints[name]; ok {
-		return nil, &chk, stmt.Table
+		return &chk, stmt.Table
+	}
+
+	uniqueConstraints := stmt.Schema.ParseUniqueConstraints()
+	if uni, ok := uniqueConstraints[name]; ok {
+		return &uni, stmt.Table
 	}
 
 	getTable := func(rel *schema.Relationship) string {
@@ -675,7 +688,7 @@ func (m Migrator) GuessConstraintAndTable(stmt *gorm.Statement, name string) (_
 
 	for _, rel := range stmt.Schema.Relationships.Relations {
 		if constraint := rel.ParseConstraint(); constraint != nil && constraint.Name == name {
-			return constraint, nil, getTable(rel)
+			return constraint, getTable(rel)
 		}
 	}
 
@@ -683,40 +696,39 @@ func (m Migrator) GuessConstraintAndTable(stmt *gorm.Statement, name string) (_
 		for k := range checkConstraints {
 			if checkConstraints[k].Field == field {
 				v := checkConstraints[k]
-				return nil, &v, stmt.Table
+				return &v, stmt.Table
+			}
+		}
+
+		for k := range uniqueConstraints {
+			if uniqueConstraints[k].Field == field {
+				v := uniqueConstraints[k]
+				return &v, stmt.Table
 			}
 		}
 
 		for _, rel := range stmt.Schema.Relationships.Relations {
 			if constraint := rel.ParseConstraint(); constraint != nil && rel.Field == field {
-				return constraint, nil, getTable(rel)
+				return constraint, getTable(rel)
 			}
 		}
 	}
 
-	return nil, nil, stmt.Schema.Table
+	return nil, stmt.Schema.Table
 }
 
 // CreateConstraint create constraint
 func (m Migrator) CreateConstraint(value interface{}, name string) error {
 	return m.RunWithValue(value, func(stmt *gorm.Statement) error {
-		constraint, chk, table := m.GuessConstraintAndTable(stmt, name)
-		if chk != nil {
-			return m.DB.Exec(
-				"ALTER TABLE ? ADD CONSTRAINT ? CHECK (?)",
-				m.CurrentTable(stmt), clause.Column{Name: chk.Name}, clause.Expr{SQL: chk.Constraint},
-			).Error
-		}
-
+		constraint, table := m.GuessConstraintInterfaceAndTable(stmt, name)
 		if constraint != nil {
 			vars := []interface{}{clause.Table{Name: table}}
 			if stmt.TableExpr != nil {
 				vars[0] = stmt.TableExpr
 			}
-			sql, values := buildConstraint(constraint)
+			sql, values := constraint.Build()
 			return m.DB.Exec("ALTER TABLE ? ADD "+sql, append(vars, values...)...).Error
 		}
-
 		return nil
 	})
 }
@@ -724,11 +736,9 @@ func (m Migrator) CreateConstraint(value interface{}, name string) error {
 // DropConstraint drop constraint
 func (m Migrator) DropConstraint(value interface{}, name string) error {
 	return m.RunWithValue(value, func(stmt *gorm.Statement) error {
-		constraint, chk, table := m.GuessConstraintAndTable(stmt, name)
+		constraint, table := m.GuessConstraintInterfaceAndTable(stmt, name)
 		if constraint != nil {
-			name = constraint.Name
-		} else if chk != nil {
-			name = chk.Name
+			name = constraint.GetName()
 		}
 		return m.DB.Exec("ALTER TABLE ? DROP CONSTRAINT ?", clause.Table{Name: table}, clause.Column{Name: name}).Error
 	})
@@ -739,11 +749,9 @@ func (m Migrator) HasConstraint(value interface{}, name string) bool {
 	var count int64
 	m.RunWithValue(value, func(stmt *gorm.Statement) error {
 		currentDatabase := m.DB.Migrator().CurrentDatabase()
-		constraint, chk, table := m.GuessConstraintAndTable(stmt, name)
+		constraint, table := m.GuessConstraintInterfaceAndTable(stmt, name)
 		if constraint != nil {
-			name = constraint.Name
-		} else if chk != nil {
-			name = chk.Name
+			name = constraint.GetName()
 		}
 
 		return m.DB.Raw(
diff --git a/schema/check.go b/schema/check.go
deleted file mode 100644
index 89e732d..0000000
--- a/schema/check.go
+++ /dev/null
@@ -1,35 +0,0 @@
-package schema
-
-import (
-	"regexp"
-	"strings"
-)
-
-// reg match english letters and midline
-var regEnLetterAndMidline = regexp.MustCompile("^[A-Za-z-_]+$")
-
-type Check struct {
-	Name       string
-	Constraint string // length(phone) >= 10
-	*Field
-}
-
-// ParseCheckConstraints parse schema check constraints
-func (schema *Schema) ParseCheckConstraints() map[string]Check {
-	checks := map[string]Check{}
-	for _, field := range schema.FieldsByDBName {
-		if chk := field.TagSettings["CHECK"]; chk != "" {
-			names := strings.Split(chk, ",")
-			if len(names) > 1 && regEnLetterAndMidline.MatchString(names[0]) {
-				checks[names[0]] = Check{Name: names[0], Constraint: strings.Join(names[1:], ","), Field: field}
-			} else {
-				if names[0] == "" {
-					chk = strings.Join(names[1:], ",")
-				}
-				name := schema.namer.CheckerName(schema.Table, field.DBName)
-				checks[name] = Check{Name: name, Constraint: chk, Field: field}
-			}
-		}
-	}
-	return checks
-}
diff --git a/schema/constraint.go b/schema/constraint.go
new file mode 100644
index 0000000..5f6beb8
--- /dev/null
+++ b/schema/constraint.go
@@ -0,0 +1,66 @@
+package schema
+
+import (
+	"regexp"
+	"strings"
+
+	"gorm.io/gorm/clause"
+)
+
+// reg match english letters and midline
+var regEnLetterAndMidline = regexp.MustCompile("^[A-Za-z-_]+$")
+
+type CheckConstraint struct {
+	Name       string
+	Constraint string // length(phone) >= 10
+	*Field
+}
+
+func (chk *CheckConstraint) GetName() string { return chk.Name }
+
+func (chk *CheckConstraint) Build() (sql string, vars []interface{}) {
+	return "CONSTRAINT ? CHECK (?)", []interface{}{clause.Column{Name: chk.Name}, clause.Expr{SQL: chk.Constraint}}
+}
+
+// ParseCheckConstraints parse schema check constraints
+func (schema *Schema) ParseCheckConstraints() map[string]CheckConstraint {
+	checks := map[string]CheckConstraint{}
+	for _, field := range schema.FieldsByDBName {
+		if chk := field.TagSettings["CHECK"]; chk != "" {
+			names := strings.Split(chk, ",")
+			if len(names) > 1 && regEnLetterAndMidline.MatchString(names[0]) {
+				checks[names[0]] = CheckConstraint{Name: names[0], Constraint: strings.Join(names[1:], ","), Field: field}
+			} else {
+				if names[0] == "" {
+					chk = strings.Join(names[1:], ",")
+				}
+				name := schema.namer.CheckerName(schema.Table, field.DBName)
+				checks[name] = CheckConstraint{Name: name, Constraint: chk, Field: field}
+			}
+		}
+	}
+	return checks
+}
+
+type UniqueConstraint struct {
+	Name  string
+	Field *Field
+}
+
+func (uni *UniqueConstraint) GetName() string { return uni.Name }
+
+func (uni *UniqueConstraint) Build() (sql string, vars []interface{}) {
+	return "CONSTRAINT ? UNIQUE (?)", []interface{}{clause.Column{Name: uni.Name}, clause.Column{Name: uni.Field.DBName}}
+}
+
+// ParseUniqueConstraints parse schema unique constraints
+func (schema *Schema) ParseUniqueConstraints() map[string]UniqueConstraint {
+	uniques := make(map[string]UniqueConstraint)
+	for _, field := range schema.Fields {
+		if field.Unique {
+			name := schema.namer.UniqueName(schema.Table, field.DBName)
+			uniques[name] = UniqueConstraint{Name: name, Field: field}
+		}
+	}
+	return uniques
+}
diff --git a/schema/field.go b/schema/field.go
index 657e0a4..91e4c0a 100644
--- a/schema/field.go
+++ b/schema/field.go
@@ -89,6 +89,12 @@ type Field struct {
 	Set                    func(context.Context, reflect.Value, interface{}) error
 	Serializer             SerializerInterface
 	NewValuePool           FieldNewValuePool
+
+	// In some db (e.g. MySQL), Unique and UniqueIndex are indistinguishable.
+	// When a column has a (not Mul) UniqueIndex, Migrator always reports its gorm.ColumnType is Unique.
+	// It causes field unnecessarily migration.
+	// Therefore, we need to record the UniqueIndex on this column (exclude Mul UniqueIndex) for MigrateColumnUnique.
+	UniqueIndex string
 }
 
 func (field *Field) BindName() string {
diff --git a/schema/index.go b/schema/index.go
index f5ac5dd..f4f3675 100644
--- a/schema/index.go
+++ b/schema/index.go
@@ -13,8 +13,8 @@ type Index struct {
 	Type    string // btree, hash, gist, spgist, gin, and brin
 	Where   string
 	Comment string
-	Option  string // WITH PARSER parser_name
-	Fields  []IndexOption
+	Option  string        // WITH PARSER parser_name
+	Fields  []IndexOption // Note: IndexOption's Field maybe the same
 }
 
 type IndexOption struct {
@@ -67,7 +67,7 @@ func (schema *Schema) ParseIndexes() map[string]Index {
 	}
 	for _, index := range indexes {
 		if index.Class == "UNIQUE" && len(index.Fields) == 1 {
-			index.Fields[0].Field.Unique = true
+			index.Fields[0].Field.UniqueIndex = index.Name
 		}
 	}
 	return indexes
diff --git a/schema/interfaces.go b/schema/interfaces.go
index a75a33c..306d4f4 100644
--- a/schema/interfaces.go
+++ b/schema/interfaces.go
@@ -4,6 +4,12 @@ import (
 	"gorm.io/gorm/clause"
 )
 
+// ConstraintInterface database constraint interface
+type ConstraintInterface interface {
+	GetName() string
+	Build() (sql string, vars []interface{})
+}
+
 // GormDataTypeInterface gorm data type interface
 type GormDataTypeInterface interface {
 	GormDataType() string
diff --git a/schema/relationship.go b/schema/relationship.go
index 5716785..2e94fc2 100644
--- a/schema/relationship.go
+++ b/schema/relationship.go
@@ -605,6 +605,7 @@ func (schema *Schema) guessRelation(relation *Relationship, field *Field, cgl gu
 	}
 }
 
+// Constraint is ForeignKey Constraint
 type Constraint struct {
 	Name            string
 	Field           *Field
@@ -616,6 +617,31 @@ type Constraint struct {
 	OnUpdate        string
 }
 
+func (constraint *Constraint) GetName() string { return constraint.Name }
+
+func (constraint *Constraint) Build() (sql string, vars []interface{}) {
+	sql = "CONSTRAINT ? FOREIGN KEY ? REFERENCES ??"
+	if constraint.OnDelete != "" {
+		sql += " ON DELETE " + constraint.OnDelete
+	}
+
+	if constraint.OnUpdate != "" {
+		sql += " ON UPDATE " + constraint.OnUpdate
+	}
+
+	foreignKeys := make([]interface{}, 0, len(constraint.ForeignKeys))
+	for _, field := range constraint.ForeignKeys {
+		foreignKeys = append(foreignKeys, clause.Column{Name: field.DBName})
+	}
+
+	references := make([]interface{}, 0, len(constraint.References))
+	for _, field := range constraint.References {
+		references = append(references, clause.Column{Name: field.DBName})
+	}
+	vars = append(vars, clause.Table{Name: constraint.Name}, foreignKeys, clause.Table{Name: constraint.ReferenceSchema.Table}, references)
+	return
+}
+
 func (rel *Relationship) ParseConstraint() *Constraint {
 	str := rel.Field.TagSettings["CONSTRAINT"]
 	if str == "-" {
