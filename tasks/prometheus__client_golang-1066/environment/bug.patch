diff --git a/examples/simple/main.go b/examples/simple/main.go
index 935f805..972910c 100644
--- a/examples/simple/main.go
+++ b/examples/simple/main.go
@@ -16,11 +16,10 @@ package main
 
 import (
 	"flag"
+	"github.com/prometheus/client_golang/prometheus/collectors"
 	"log"
 	"net/http"
 
-	"github.com/prometheus/client_golang/prometheus/collectors"
-
 	"github.com/prometheus/client_golang/prometheus"
 	"github.com/prometheus/client_golang/prometheus/promhttp"
 )
diff --git a/prometheus/promhttp/instrument_client.go b/prometheus/promhttp/instrument_client.go
index d3482c4..2108678 100644
--- a/prometheus/promhttp/instrument_client.go
+++ b/prometheus/promhttp/instrument_client.go
@@ -68,17 +68,16 @@ func InstrumentRoundTripperCounter(counter *prometheus.CounterVec, next http.Rou
 		o.apply(rtOpts)
 	}
 
-	// Curry the counter with dynamic labels before checking the remaining labels.
-	code, method := checkLabels(counter.MustCurryWith(rtOpts.emptyDynamicLabels()))
+	code, method := checkLabels(counter)
 
 	return func(r *http.Request) (*http.Response, error) {
 		resp, err := next.RoundTrip(r)
 		if err == nil {
-			l := labels(code, method, r.Method, resp.StatusCode, rtOpts.extraMethods...)
-			for label, resolve := range rtOpts.extraLabelsFromCtx {
-				l[label] = resolve(resp.Request.Context())
-			}
-			addWithExemplar(counter.With(l), 1, rtOpts.getExemplarFn(r.Context()))
+			addWithExemplar(
+				counter.With(labels(code, method, r.Method, resp.StatusCode, rtOpts.extraMethods...)),
+				1,
+				rtOpts.getExemplarFn(r.Context()),
+			)
 		}
 		return resp, err
 	}
@@ -111,18 +110,17 @@ func InstrumentRoundTripperDuration(obs prometheus.ObserverVec, next http.RoundT
 		o.apply(rtOpts)
 	}
 
-	// Curry the observer with dynamic labels before checking the remaining labels.
-	code, method := checkLabels(obs.MustCurryWith(rtOpts.emptyDynamicLabels()))
+	code, method := checkLabels(obs)
 
 	return func(r *http.Request) (*http.Response, error) {
 		start := time.Now()
 		resp, err := next.RoundTrip(r)
 		if err == nil {
-			l := labels(code, method, r.Method, resp.StatusCode, rtOpts.extraMethods...)
-			for label, resolve := range rtOpts.extraLabelsFromCtx {
-				l[label] = resolve(resp.Request.Context())
-			}
-			observeWithExemplar(obs.With(l), time.Since(start).Seconds(), rtOpts.getExemplarFn(r.Context()))
+			observeWithExemplar(
+				obs.With(labels(code, method, r.Method, resp.StatusCode, rtOpts.extraMethods...)),
+				time.Since(start).Seconds(),
+				rtOpts.getExemplarFn(r.Context()),
+			)
 		}
 		return resp, err
 	}
diff --git a/prometheus/promhttp/instrument_server.go b/prometheus/promhttp/instrument_server.go
index 3793036..cca67a7 100644
--- a/prometheus/promhttp/instrument_server.go
+++ b/prometheus/promhttp/instrument_server.go
@@ -87,8 +87,7 @@ func InstrumentHandlerDuration(obs prometheus.ObserverVec, next http.Handler, op
 		o.apply(hOpts)
 	}
 
-	// Curry the observer with dynamic labels before checking the remaining labels.
-	code, method := checkLabels(obs.MustCurryWith(hOpts.emptyDynamicLabels()))
+	code, method := checkLabels(obs)
 
 	if code {
 		return func(w http.ResponseWriter, r *http.Request) {
@@ -96,22 +95,23 @@ func InstrumentHandlerDuration(obs prometheus.ObserverVec, next http.Handler, op
 			d := newDelegator(w, nil)
 			next.ServeHTTP(d, r)
 
-			l := labels(code, method, r.Method, d.Status(), hOpts.extraMethods...)
-			for label, resolve := range hOpts.extraLabelsFromCtx {
-				l[label] = resolve(r.Context())
-			}
-			observeWithExemplar(obs.With(l), time.Since(now).Seconds(), hOpts.getExemplarFn(r.Context()))
+			observeWithExemplar(
+				obs.With(labels(code, method, r.Method, d.Status(), hOpts.extraMethods...)),
+				time.Since(now).Seconds(),
+				hOpts.getExemplarFn(r.Context()),
+			)
 		}
 	}
 
 	return func(w http.ResponseWriter, r *http.Request) {
 		now := time.Now()
 		next.ServeHTTP(w, r)
-		l := labels(code, method, r.Method, 0, hOpts.extraMethods...)
-		for label, resolve := range hOpts.extraLabelsFromCtx {
-			l[label] = resolve(r.Context())
-		}
-		observeWithExemplar(obs.With(l), time.Since(now).Seconds(), hOpts.getExemplarFn(r.Context()))
+
+		observeWithExemplar(
+			obs.With(labels(code, method, r.Method, 0, hOpts.extraMethods...)),
+			time.Since(now).Seconds(),
+			hOpts.getExemplarFn(r.Context()),
+		)
 	}
 }
 
@@ -138,30 +138,28 @@ func InstrumentHandlerCounter(counter *prometheus.CounterVec, next http.Handler,
 		o.apply(hOpts)
 	}
 
-	// Curry the counter with dynamic labels before checking the remaining labels.
-	code, method := checkLabels(counter.MustCurryWith(hOpts.emptyDynamicLabels()))
+	code, method := checkLabels(counter)
 
 	if code {
 		return func(w http.ResponseWriter, r *http.Request) {
 			d := newDelegator(w, nil)
 			next.ServeHTTP(d, r)
 
-			l := labels(code, method, r.Method, d.Status(), hOpts.extraMethods...)
-			for label, resolve := range hOpts.extraLabelsFromCtx {
-				l[label] = resolve(r.Context())
-			}
-			addWithExemplar(counter.With(l), 1, hOpts.getExemplarFn(r.Context()))
+			addWithExemplar(
+				counter.With(labels(code, method, r.Method, d.Status(), hOpts.extraMethods...)),
+				1,
+				hOpts.getExemplarFn(r.Context()),
+			)
 		}
 	}
 
 	return func(w http.ResponseWriter, r *http.Request) {
 		next.ServeHTTP(w, r)
-
-		l := labels(code, method, r.Method, 0, hOpts.extraMethods...)
-		for label, resolve := range hOpts.extraLabelsFromCtx {
-			l[label] = resolve(r.Context())
-		}
-		addWithExemplar(counter.With(l), 1, hOpts.getExemplarFn(r.Context()))
+		addWithExemplar(
+			counter.With(labels(code, method, r.Method, 0, hOpts.extraMethods...)),
+			1,
+			hOpts.getExemplarFn(r.Context()),
+		)
 	}
 }
 
@@ -193,17 +191,16 @@ func InstrumentHandlerTimeToWriteHeader(obs prometheus.ObserverVec, next http.Ha
 		o.apply(hOpts)
 	}
 
-	// Curry the observer with dynamic labels before checking the remaining labels.
-	code, method := checkLabels(obs.MustCurryWith(hOpts.emptyDynamicLabels()))
+	code, method := checkLabels(obs)
 
 	return func(w http.ResponseWriter, r *http.Request) {
 		now := time.Now()
 		d := newDelegator(w, func(status int) {
-			l := labels(code, method, r.Method, status, hOpts.extraMethods...)
-			for label, resolve := range hOpts.extraLabelsFromCtx {
-				l[label] = resolve(r.Context())
-			}
-			observeWithExemplar(obs.With(l), time.Since(now).Seconds(), hOpts.getExemplarFn(r.Context()))
+			observeWithExemplar(
+				obs.With(labels(code, method, r.Method, status, hOpts.extraMethods...)),
+				time.Since(now).Seconds(),
+				hOpts.getExemplarFn(r.Context()),
+			)
 		})
 		next.ServeHTTP(d, r)
 	}
@@ -234,32 +231,28 @@ func InstrumentHandlerRequestSize(obs prometheus.ObserverVec, next http.Handler,
 		o.apply(hOpts)
 	}
 
-	// Curry the observer with dynamic labels before checking the remaining labels.
-	code, method := checkLabels(obs.MustCurryWith(hOpts.emptyDynamicLabels()))
-
+	code, method := checkLabels(obs)
 	if code {
 		return func(w http.ResponseWriter, r *http.Request) {
 			d := newDelegator(w, nil)
 			next.ServeHTTP(d, r)
 			size := computeApproximateRequestSize(r)
-
-			l := labels(code, method, r.Method, d.Status(), hOpts.extraMethods...)
-			for label, resolve := range hOpts.extraLabelsFromCtx {
-				l[label] = resolve(r.Context())
-			}
-			observeWithExemplar(obs.With(l), float64(size), hOpts.getExemplarFn(r.Context()))
+			observeWithExemplar(
+				obs.With(labels(code, method, r.Method, d.Status(), hOpts.extraMethods...)),
+				float64(size),
+				hOpts.getExemplarFn(r.Context()),
+			)
 		}
 	}
 
 	return func(w http.ResponseWriter, r *http.Request) {
 		next.ServeHTTP(w, r)
 		size := computeApproximateRequestSize(r)
-
-		l := labels(code, method, r.Method, 0, hOpts.extraMethods...)
-		for label, resolve := range hOpts.extraLabelsFromCtx {
-			l[label] = resolve(r.Context())
-		}
-		observeWithExemplar(obs.With(l), float64(size), hOpts.getExemplarFn(r.Context()))
+		observeWithExemplar(
+			obs.With(labels(code, method, r.Method, 0, hOpts.extraMethods...)),
+			float64(size),
+			hOpts.getExemplarFn(r.Context()),
+		)
 	}
 }
 
@@ -288,18 +281,16 @@ func InstrumentHandlerResponseSize(obs prometheus.ObserverVec, next http.Handler
 		o.apply(hOpts)
 	}
 
-	// Curry the observer with dynamic labels before checking the remaining labels.
-	code, method := checkLabels(obs.MustCurryWith(hOpts.emptyDynamicLabels()))
+	code, method := checkLabels(obs)
 
 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		d := newDelegator(w, nil)
 		next.ServeHTTP(d, r)
-
-		l := labels(code, method, r.Method, d.Status(), hOpts.extraMethods...)
-		for label, resolve := range hOpts.extraLabelsFromCtx {
-			l[label] = resolve(r.Context())
-		}
-		observeWithExemplar(obs.With(l), float64(d.Written()), hOpts.getExemplarFn(r.Context()))
+		observeWithExemplar(
+			obs.With(labels(code, method, r.Method, d.Status(), hOpts.extraMethods...)),
+			float64(d.Written()),
+			hOpts.getExemplarFn(r.Context()),
+		)
 	})
 }
 
diff --git a/prometheus/promhttp/instrument_server_test.go b/prometheus/promhttp/instrument_server_test.go
index 6c64443..2a2cbf2 100644
--- a/prometheus/promhttp/instrument_server_test.go
+++ b/prometheus/promhttp/instrument_server_test.go
@@ -30,7 +30,6 @@ func TestLabelCheck(t *testing.T) {
 		varLabels     []string
 		constLabels   []string
 		curriedLabels []string
-		dynamicLabels []string
 		ok            bool
 	}{
 		"empty": {
@@ -61,14 +60,12 @@ func TestLabelCheck(t *testing.T) {
 			varLabels:     []string{"code", "method"},
 			constLabels:   []string{"foo", "bar"},
 			curriedLabels: []string{"dings", "bums"},
-			dynamicLabels: []string{"dyn", "amics"},
 			ok:            true,
 		},
 		"all labels used with an invalid const label name": {
 			varLabels:     []string{"code", "method"},
 			constLabels:   []string{"in-valid", "bar"},
 			curriedLabels: []string{"dings", "bums"},
-			dynamicLabels: []string{"dyn", "amics"},
 			ok:            false,
 		},
 		"unsupported var label": {
@@ -101,18 +98,6 @@ func TestLabelCheck(t *testing.T) {
 			curriedLabels: []string{"method"},
 			ok:            true,
 		},
-		"supported label as const and dynamic": {
-			varLabels:     []string{},
-			constLabels:   []string{"code"},
-			dynamicLabels: []string{"method"},
-			ok:            true,
-		},
-		"supported label as curried and dynamic": {
-			varLabels:     []string{},
-			curriedLabels: []string{"code"},
-			dynamicLabels: []string{"method"},
-			ok:            true,
-		},
 		"supported label as const and curry with unsupported as var": {
 			varLabels:     []string{"foo"},
 			constLabels:   []string{"code"},
@@ -131,7 +116,6 @@ func TestLabelCheck(t *testing.T) {
 			varLabels:     []string{"code", "method"},
 			constLabels:   []string{"foo", "bar"},
 			curriedLabels: []string{"dings", "bums"},
-			dynamicLabels: []string{"dyn", "amics"},
 			ok:            false,
 		},
 	}
@@ -146,39 +130,26 @@ func TestLabelCheck(t *testing.T) {
 			for _, l := range sc.constLabels {
 				constLabels[l] = "dummy"
 			}
-			labelNames := append(append(sc.varLabels, sc.curriedLabels...), sc.dynamicLabels...)
-			c := prometheus.V2.NewCounterVec(
-				prometheus.CounterVecOpts{
-					CounterOpts: prometheus.CounterOpts{
-						Name:        metricName,
-						Help:        "c help",
-						ConstLabels: constLabels,
-					},
-					VariableLabels: prometheus.UnconstrainedLabels(labelNames),
+			c := prometheus.NewCounterVec(
+				prometheus.CounterOpts{
+					Name:        metricName,
+					Help:        "c help",
+					ConstLabels: constLabels,
 				},
+				append(sc.varLabels, sc.curriedLabels...),
 			)
-			o := prometheus.ObserverVec(prometheus.V2.NewHistogramVec(
-				prometheus.HistogramVecOpts{
-					HistogramOpts: prometheus.HistogramOpts{
-						Name:        metricName,
-						Help:        "c help",
-						ConstLabels: constLabels,
-					},
-					VariableLabels: prometheus.UnconstrainedLabels(labelNames),
+			o := prometheus.ObserverVec(prometheus.NewHistogramVec(
+				prometheus.HistogramOpts{
+					Name:        metricName,
+					Help:        "c help",
+					ConstLabels: constLabels,
 				},
+				append(sc.varLabels, sc.curriedLabels...),
 			))
 			for _, l := range sc.curriedLabels {
 				c = c.MustCurryWith(prometheus.Labels{l: "dummy"})
 				o = o.MustCurryWith(prometheus.Labels{l: "dummy"})
 			}
-			opts := []Option{}
-			for _, l := range sc.dynamicLabels {
-				opts = append(opts, WithLabelFromCtx(l,
-					func(_ context.Context) string {
-						return "foo"
-					},
-				))
-			}
 
 			func() {
 				defer func() {
@@ -190,7 +161,7 @@ func TestLabelCheck(t *testing.T) {
 						t.Error("expected panic")
 					}
 				}()
-				InstrumentHandlerCounter(c, nil, opts...)
+				InstrumentHandlerCounter(c, nil)
 			}()
 			func() {
 				defer func() {
@@ -202,7 +173,7 @@ func TestLabelCheck(t *testing.T) {
 						t.Error("expected panic")
 					}
 				}()
-				InstrumentHandlerDuration(o, nil, opts...)
+				InstrumentHandlerDuration(o, nil)
 			}()
 			if sc.ok {
 				// Test if wantCode and wantMethod were detected correctly.
@@ -215,11 +186,6 @@ func TestLabelCheck(t *testing.T) {
 						wantMethod = true
 					}
 				}
-				// Curry the dynamic labels since this is done normally behind the scenes for the check
-				for _, l := range sc.dynamicLabels {
-					c = c.MustCurryWith(prometheus.Labels{l: "dummy"})
-					o = o.MustCurryWith(prometheus.Labels{l: "dummy"})
-				}
 				gotCode, gotMethod := checkLabels(c)
 				if gotCode != wantCode {
 					t.Errorf("wanted code=%t for counter, got code=%t", wantCode, gotCode)
diff --git a/prometheus/promhttp/option.go b/prometheus/promhttp/option.go
index af7403d..c590d91 100644
--- a/prometheus/promhttp/option.go
+++ b/prometheus/promhttp/option.go
@@ -24,32 +24,14 @@ type Option interface {
 	apply(*options)
 }
 
-// LabelValueFromCtx are used to compute the label value from request context.
-// Context can be filled with values from request through middleware.
-type LabelValueFromCtx func(ctx context.Context) string
-
 // options store options for both a handler or round tripper.
 type options struct {
-	extraMethods       []string
-	getExemplarFn      func(requestCtx context.Context) prometheus.Labels
-	extraLabelsFromCtx map[string]LabelValueFromCtx
+	extraMethods  []string
+	getExemplarFn func(requestCtx context.Context) prometheus.Labels
 }
 
 func defaultOptions() *options {
-	return &options{
-		getExemplarFn:      func(ctx context.Context) prometheus.Labels { return nil },
-		extraLabelsFromCtx: map[string]LabelValueFromCtx{},
-	}
-}
-
-func (o *options) emptyDynamicLabels() prometheus.Labels {
-	labels := prometheus.Labels{}
-
-	for label := range o.extraLabelsFromCtx {
-		labels[label] = ""
-	}
-
-	return labels
+	return &options{getExemplarFn: func(ctx context.Context) prometheus.Labels { return nil }}
 }
 
 type optionApplyFunc func(*options)
@@ -74,11 +56,3 @@ func WithExemplarFromContext(getExemplarFn func(requestCtx context.Context) prom
 		o.getExemplarFn = getExemplarFn
 	})
 }
-
-// WithLabelFromCtx registers a label for dynamic resolution with access to context.
-// See the example for ExampleInstrumentHandlerWithLabelResolver for example usage
-func WithLabelFromCtx(name string, valueFn LabelValueFromCtx) Option {
-	return optionApplyFunc(func(o *options) {
-		o.extraLabelsFromCtx[name] = valueFn
-	})
-}
diff --git a/prometheus/promhttp/option_test.go b/prometheus/promhttp/option_test.go
index 1582718..5d85655 100644
--- a/prometheus/promhttp/option_test.go
+++ b/prometheus/promhttp/option_test.go
@@ -14,19 +14,12 @@
 package promhttp
 
 import (
-	"context"
 	"log"
 	"net/http"
 
 	"github.com/prometheus/client_golang/prometheus"
 )
 
-type key int
-
-const (
-	CtxResolverKey key = iota
-)
-
 func ExampleInstrumentHandlerWithExtraMethods() {
 	counter := prometheus.NewCounterVec(
 		prometheus.CounterOpts{
@@ -69,60 +62,3 @@ func ExampleInstrumentHandlerWithExtraMethods() {
 		log.Fatal(err)
 	}
 }
-
-func ExampleInstrumentHandlerWithLabelResolver() {
-	counter := prometheus.NewCounterVec(
-		prometheus.CounterOpts{
-			Name: "api_requests_total",
-			Help: "A counter for requests to the wrapped handler.",
-		},
-		[]string{"code", "method", "myheader"},
-	)
-
-	// duration is partitioned by the HTTP method, handler and request header
-	// value. It uses custom buckets based on the expected request duration.
-	// Beware to not have too high cardinality on the values of header. You
-	// always should sanitize external inputs.
-	duration := prometheus.NewHistogramVec(
-		prometheus.HistogramOpts{
-			Name:    "request_duration_seconds",
-			Help:    "A histogram of latencies for requests.",
-			Buckets: []float64{.25, .5, 1, 2.5, 5, 10},
-		},
-		[]string{"handler", "method", "myheader"},
-	)
-
-	// Create the handlers that will be wrapped by the middleware.
-	pullHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte("Pull"))
-	})
-
-	// Specify additional HTTP methods to be added to the label allow list.
-	opts := WithLabelFromCtx("myheader",
-		func(ctx context.Context) string {
-			return ctx.Value(CtxResolverKey).(string)
-		},
-	)
-
-	// Instrument the handlers with all the metrics, injecting the "handler"
-	// label by currying.
-	pullChain := InstrumentHandlerDuration(duration.MustCurryWith(prometheus.Labels{"handler": "pull"}),
-		InstrumentHandlerCounter(counter, pullHandler, opts),
-		opts,
-	)
-
-	middleware := func(next http.HandlerFunc) http.HandlerFunc {
-		return func(w http.ResponseWriter, r *http.Request) {
-			ctx := context.WithValue(r.Context(), CtxResolverKey, r.Header.Get("x-my-header"))
-
-			next(w, r.WithContext(ctx))
-		}
-	}
-
-	http.Handle("/metrics", Handler())
-	http.Handle("/pull", middleware(pullChain))
-
-	if err := http.ListenAndServe(":3000", nil); err != nil {
-		log.Fatal(err)
-	}
-}
