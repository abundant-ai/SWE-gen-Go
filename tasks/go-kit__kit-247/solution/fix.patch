diff --git a/examples/addsvc/client/grpc/factory.go b/examples/addsvc/client/grpc/factory.go
index b898d96..0e59932 100644
--- a/examples/addsvc/client/grpc/factory.go
+++ b/examples/addsvc/client/grpc/factory.go
@@ -3,37 +3,49 @@ package grpc
 import (
 	"io"
 
+	kitot "github.com/go-kit/kit/tracing/opentracing"
+	"github.com/opentracing/opentracing-go"
 	"google.golang.org/grpc"
 
 	"github.com/go-kit/kit/endpoint"
 	"github.com/go-kit/kit/examples/addsvc/pb"
+	"github.com/go-kit/kit/loadbalancer"
+	"github.com/go-kit/kit/log"
 	grpctransport "github.com/go-kit/kit/transport/grpc"
 )
 
-// SumEndpointFactory transforms GRPC host:port strings into Endpoints that call the Sum method on a GRPC server
+// MakeSumEndpointFactory returns a loadbalancer.Factory that transforms GRPC
+// host:port strings into Endpoints that call the Sum method on a GRPC server
 // at that address.
-func SumEndpointFactory(instance string) (endpoint.Endpoint, io.Closer, error) {
-	cc, err := grpc.Dial(instance, grpc.WithInsecure())
-	return grpctransport.NewClient(
-		cc,
-		"Add",
-		"Sum",
-		encodeSumRequest,
-		decodeSumResponse,
-		pb.SumReply{},
-	).Endpoint(), cc, err
+func MakeSumEndpointFactory(tracer opentracing.Tracer, tracingLogger log.Logger) loadbalancer.Factory {
+	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
+		cc, err := grpc.Dial(instance, grpc.WithInsecure())
+		return grpctransport.NewClient(
+			cc,
+			"Add",
+			"Sum",
+			encodeSumRequest,
+			decodeSumResponse,
+			pb.SumReply{},
+			grpctransport.SetClientBefore(kitot.ToGRPCRequest(tracer, tracingLogger)),
+		).Endpoint(), cc, err
+	}
 }
 
-// ConcatEndpointFactory transforms GRPC host:port strings into Endpoints that call the Concat method on a GRPC server
-// at that address.
-func ConcatEndpointFactory(instance string) (endpoint.Endpoint, io.Closer, error) {
-	cc, err := grpc.Dial(instance, grpc.WithInsecure())
-	return grpctransport.NewClient(
-		cc,
-		"Add",
-		"Concat",
-		encodeConcatRequest,
-		decodeConcatResponse,
-		pb.ConcatReply{},
-	).Endpoint(), cc, err
+// MakeConcatEndpointFactory returns a loadbalancer.Factory that transforms
+// GRPC host:port strings into Endpoints that call the Concat method on a GRPC
+// server at that address.
+func MakeConcatEndpointFactory(tracer opentracing.Tracer, tracingLogger log.Logger) loadbalancer.Factory {
+	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
+		cc, err := grpc.Dial(instance, grpc.WithInsecure())
+		return grpctransport.NewClient(
+			cc,
+			"Add",
+			"Concat",
+			encodeConcatRequest,
+			decodeConcatResponse,
+			pb.ConcatReply{},
+			grpctransport.SetClientBefore(kitot.ToGRPCRequest(tracer, tracingLogger)),
+		).Endpoint(), cc, err
+	}
 }
diff --git a/examples/addsvc/client/httpjson/factory.go b/examples/addsvc/client/httpjson/factory.go
index 43f3148..f36ce4e 100644
--- a/examples/addsvc/client/httpjson/factory.go
+++ b/examples/addsvc/client/httpjson/factory.go
@@ -4,47 +4,62 @@ import (
 	"io"
 	"net/url"
 
+	"github.com/opentracing/opentracing-go"
+
 	"github.com/go-kit/kit/endpoint"
 	"github.com/go-kit/kit/examples/addsvc/server"
+	"github.com/go-kit/kit/loadbalancer"
+	"github.com/go-kit/kit/log"
+	kitot "github.com/go-kit/kit/tracing/opentracing"
 	httptransport "github.com/go-kit/kit/transport/http"
 )
 
-// SumEndpointFactory transforms a http url into an Endpoint.
+// MakeSumEndpointFactory generates a Factory that transforms an http url into
+// an Endpoint.
+//
 // The path of the url is reset to /sum.
-func SumEndpointFactory(instance string) (endpoint.Endpoint, io.Closer, error) {
-	sumURL, err := url.Parse(instance)
-	if err != nil {
-		return nil, nil, err
-	}
-	sumURL.Path = "/sum"
+func MakeSumEndpointFactory(tracer opentracing.Tracer, tracingLogger log.Logger) loadbalancer.Factory {
+	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
+		sumURL, err := url.Parse(instance)
+		if err != nil {
+			return nil, nil, err
+		}
+		sumURL.Path = "/sum"
 
-	client := httptransport.NewClient(
-		"GET",
-		sumURL,
-		server.EncodeSumRequest,
-		server.DecodeSumResponse,
-		httptransport.SetClient(nil),
-	)
+		client := httptransport.NewClient(
+			"GET",
+			sumURL,
+			server.EncodeSumRequest,
+			server.DecodeSumResponse,
+			httptransport.SetClient(nil),
+			httptransport.SetClientBefore(kitot.ToHTTPRequest(tracer, tracingLogger)),
+		)
 
-	return client.Endpoint(), nil, nil
+		return client.Endpoint(), nil, nil
+	}
 }
 
-// ConcatEndpointFactory transforms a http url into an Endpoint.
+// MakeConcatEndpointFactory generates a Factory that transforms an http url
+// into an Endpoint.
+//
 // The path of the url is reset to /concat.
-func ConcatEndpointFactory(instance string) (endpoint.Endpoint, io.Closer, error) {
-	concatURL, err := url.Parse(instance)
-	if err != nil {
-		return nil, nil, err
-	}
-	concatURL.Path = "/concat"
+func MakeConcatEndpointFactory(tracer opentracing.Tracer, tracingLogger log.Logger) loadbalancer.Factory {
+	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
+		concatURL, err := url.Parse(instance)
+		if err != nil {
+			return nil, nil, err
+		}
+		concatURL.Path = "/concat"
 
-	client := httptransport.NewClient(
-		"GET",
-		concatURL,
-		server.EncodeConcatRequest,
-		server.DecodeConcatResponse,
-		httptransport.SetClient(nil),
-	)
+		client := httptransport.NewClient(
+			"GET",
+			concatURL,
+			server.EncodeConcatRequest,
+			server.DecodeConcatResponse,
+			httptransport.SetClient(nil),
+			httptransport.SetClientBefore(kitot.ToHTTPRequest(tracer, tracingLogger)),
+		)
 
-	return client.Endpoint(), nil, nil
+		return client.Endpoint(), nil, nil
+	}
 }
diff --git a/examples/addsvc/client/main.go b/examples/addsvc/client/main.go
index 95bb16e..e1307cb 100644
--- a/examples/addsvc/client/main.go
+++ b/examples/addsvc/client/main.go
@@ -9,7 +9,11 @@ import (
 	"strings"
 	"time"
 
+	"github.com/lightstep/lightstep-tracer-go"
+	"github.com/opentracing/opentracing-go"
+	appdashot "github.com/sourcegraph/appdash/opentracing"
 	"golang.org/x/net/context"
+	"sourcegraph.com/sourcegraph/appdash"
 
 	"github.com/go-kit/kit/endpoint"
 	grpcclient "github.com/go-kit/kit/examples/addsvc/client/grpc"
@@ -19,6 +23,7 @@ import (
 	"github.com/go-kit/kit/loadbalancer"
 	"github.com/go-kit/kit/loadbalancer/static"
 	"github.com/go-kit/kit/log"
+	kitot "github.com/go-kit/kit/tracing/opentracing"
 )
 
 func main() {
@@ -31,6 +36,10 @@ func main() {
 		thriftProtocol   = flag.String("thrift.protocol", "binary", "binary, compact, json, simplejson")
 		thriftBufferSize = flag.Int("thrift.buffer.size", 0, "0 for unbuffered")
 		thriftFramed     = flag.Bool("thrift.framed", false, "true to enable framing")
+
+		// Two OpenTracing backends (to demonstrate how they can be interchanged):
+		appdashAddr          = flag.String("appdash.addr", "", "Enable Appdash tracing via an Appdash server host:port")
+		lightstepAccessToken = flag.String("lightstep.token", "", "Enable LightStep tracing via a LightStep access token")
 	)
 	flag.Parse()
 	if len(os.Args) < 4 {
@@ -48,6 +57,25 @@ func main() {
 	logger = log.NewLogfmtLogger(os.Stdout)
 	logger = log.NewContext(logger).With("caller", log.DefaultCaller)
 	logger = log.NewContext(logger).With("transport", *transport)
+	tracingLogger := log.NewContext(logger).With("component", "tracing")
+
+	// Set up OpenTracing
+	var tracer opentracing.Tracer
+	{
+		switch {
+		case *appdashAddr != "" && *lightstepAccessToken == "":
+			tracer = appdashot.NewTracer(appdash.NewRemoteCollector(*appdashAddr))
+		case *appdashAddr == "" && *lightstepAccessToken != "":
+			tracer = lightstep.NewTracer(lightstep.Options{
+				AccessToken: *lightstepAccessToken,
+			})
+			defer lightstep.FlushLightStepTracer(tracer)
+		case *appdashAddr == "" && *lightstepAccessToken == "":
+			tracer = opentracing.GlobalTracer() // no-op
+		default:
+			panic("specify either -appdash.addr or -lightstep.access.token, not both")
+		}
+	}
 
 	var (
 		instances                 []string
@@ -57,8 +85,8 @@ func main() {
 	switch *transport {
 	case "grpc":
 		instances = strings.Split(*grpcAddrs, ",")
-		sumFactory = grpcclient.SumEndpointFactory
-		concatFactory = grpcclient.ConcatEndpointFactory
+		sumFactory = grpcclient.MakeSumEndpointFactory(tracer, tracingLogger)
+		concatFactory = grpcclient.MakeConcatEndpointFactory(tracer, tracingLogger)
 
 	case "httpjson":
 		instances = strings.Split(*httpAddrs, ",")
@@ -67,8 +95,8 @@ func main() {
 				instances[i] = "http://" + rawurl
 			}
 		}
-		sumFactory = httpjsonclient.SumEndpointFactory
-		concatFactory = httpjsonclient.ConcatEndpointFactory
+		sumFactory = httpjsonclient.MakeSumEndpointFactory(tracer, tracingLogger)
+		concatFactory = httpjsonclient.MakeConcatEndpointFactory(tracer, tracingLogger)
 
 	case "netrpc":
 		instances = strings.Split(*netrpcAddrs, ",")
@@ -86,8 +114,8 @@ func main() {
 		os.Exit(1)
 	}
 
-	sum := buildEndpoint(instances, sumFactory, randomSeed, logger)
-	concat := buildEndpoint(instances, concatFactory, randomSeed, logger)
+	sum := buildEndpoint(tracer, "sum", instances, sumFactory, randomSeed, logger)
+	concat := buildEndpoint(tracer, "concat", instances, concatFactory, randomSeed, logger)
 
 	svc := newClient(root, sum, concat, logger)
 
@@ -110,8 +138,9 @@ func main() {
 	}
 }
 
-func buildEndpoint(instances []string, factory loadbalancer.Factory, seed int64, logger log.Logger) endpoint.Endpoint {
+func buildEndpoint(tracer opentracing.Tracer, operationName string, instances []string, factory loadbalancer.Factory, seed int64, logger log.Logger) endpoint.Endpoint {
 	publisher := static.NewPublisher(instances, factory, logger)
 	random := loadbalancer.NewRandom(publisher, seed)
-	return loadbalancer.Retry(10, 10*time.Second, random)
+	endpoint := loadbalancer.Retry(10, 10*time.Second, random)
+	return kitot.TraceClient(tracer, operationName)(endpoint)
 }
diff --git a/examples/addsvc/grpc_binding.go b/examples/addsvc/grpc_binding.go
index 42cd849..101c71f 100644
--- a/examples/addsvc/grpc_binding.go
+++ b/examples/addsvc/grpc_binding.go
@@ -3,9 +3,13 @@ package main
 import (
 	"golang.org/x/net/context"
 
+	"github.com/opentracing/opentracing-go"
+
 	"github.com/go-kit/kit/examples/addsvc/pb"
 	"github.com/go-kit/kit/examples/addsvc/server"
 	servergrpc "github.com/go-kit/kit/examples/addsvc/server/grpc"
+	"github.com/go-kit/kit/log"
+	kitot "github.com/go-kit/kit/tracing/opentracing"
 	"github.com/go-kit/kit/transport/grpc"
 )
 
@@ -13,10 +17,22 @@ type grpcBinding struct {
 	sum, concat grpc.Handler
 }
 
-func newGRPCBinding(ctx context.Context, svc server.AddService) grpcBinding {
+func newGRPCBinding(ctx context.Context, tracer opentracing.Tracer, svc server.AddService, tracingLogger log.Logger) grpcBinding {
 	return grpcBinding{
-		sum:    grpc.NewServer(ctx, makeSumEndpoint(svc), servergrpc.DecodeSumRequest, servergrpc.EncodeSumResponse),
-		concat: grpc.NewServer(ctx, makeConcatEndpoint(svc), servergrpc.DecodeConcatRequest, servergrpc.EncodeConcatResponse),
+		sum: grpc.NewServer(
+			ctx,
+			kitot.TraceServer(tracer, "sum")(makeSumEndpoint(svc)),
+			servergrpc.DecodeSumRequest,
+			servergrpc.EncodeSumResponse,
+			grpc.ServerBefore(kitot.FromGRPCRequest(tracer, "", tracingLogger)),
+		),
+		concat: grpc.NewServer(
+			ctx,
+			kitot.TraceServer(tracer, "concat")(makeConcatEndpoint(svc)),
+			servergrpc.DecodeConcatRequest,
+			servergrpc.EncodeConcatResponse,
+			grpc.ServerBefore(kitot.FromGRPCRequest(tracer, "", tracingLogger)),
+		),
 	}
 }
 
diff --git a/examples/addsvc/main.go b/examples/addsvc/main.go
index d504043..28c4088 100644
--- a/examples/addsvc/main.go
+++ b/examples/addsvc/main.go
@@ -15,9 +15,13 @@ import (
 	"time"
 
 	"github.com/apache/thrift/lib/go/thrift"
+	"github.com/lightstep/lightstep-tracer-go"
+	"github.com/opentracing/opentracing-go"
 	stdprometheus "github.com/prometheus/client_golang/prometheus"
+	appdashot "github.com/sourcegraph/appdash/opentracing"
 	"golang.org/x/net/context"
 	"google.golang.org/grpc"
+	"sourcegraph.com/sourcegraph/appdash"
 
 	"github.com/go-kit/kit/endpoint"
 	"github.com/go-kit/kit/examples/addsvc/pb"
@@ -27,6 +31,7 @@ import (
 	"github.com/go-kit/kit/metrics"
 	"github.com/go-kit/kit/metrics/expvar"
 	"github.com/go-kit/kit/metrics/prometheus"
+	kitot "github.com/go-kit/kit/tracing/opentracing"
 	"github.com/go-kit/kit/tracing/zipkin"
 	httptransport "github.com/go-kit/kit/transport/http"
 )
@@ -36,17 +41,18 @@ func main() {
 	// of glog. So, we define a new flag set, to keep those domains distinct.
 	fs := flag.NewFlagSet("", flag.ExitOnError)
 	var (
-		debugAddr           = fs.String("debug.addr", ":8000", "Address for HTTP debug/instrumentation server")
-		httpAddr            = fs.String("http.addr", ":8001", "Address for HTTP (JSON) server")
-		grpcAddr            = fs.String("grpc.addr", ":8002", "Address for gRPC server")
-		netrpcAddr          = fs.String("netrpc.addr", ":8003", "Address for net/rpc server")
-		thriftAddr          = fs.String("thrift.addr", ":8004", "Address for Thrift server")
-		thriftProtocol      = fs.String("thrift.protocol", "binary", "binary, compact, json, simplejson")
-		thriftBufferSize    = fs.Int("thrift.buffer.size", 0, "0 for unbuffered")
-		thriftFramed        = fs.Bool("thrift.framed", false, "true to enable framing")
-		zipkinHostPort      = fs.String("zipkin.host.port", "my.service.domain:12345", "Zipkin host:port")
-		zipkinServiceName   = fs.String("zipkin.service.name", "addsvc", "Zipkin service name")
-		zipkinCollectorAddr = fs.String("zipkin.collector.addr", "", "Zipkin Kafka collector address (empty will log spans)")
+		debugAddr        = fs.String("debug.addr", ":8000", "Address for HTTP debug/instrumentation server")
+		httpAddr         = fs.String("http.addr", ":8001", "Address for HTTP (JSON) server")
+		grpcAddr         = fs.String("grpc.addr", ":8002", "Address for gRPC server")
+		netrpcAddr       = fs.String("netrpc.addr", ":8003", "Address for net/rpc server")
+		thriftAddr       = fs.String("thrift.addr", ":8004", "Address for Thrift server")
+		thriftProtocol   = fs.String("thrift.protocol", "binary", "binary, compact, json, simplejson")
+		thriftBufferSize = fs.Int("thrift.buffer.size", 0, "0 for unbuffered")
+		thriftFramed     = fs.Bool("thrift.framed", false, "true to enable framing")
+
+		// Supported OpenTracing backends
+		appdashAddr          = fs.String("appdash.addr", "", "Enable Appdash tracing via an Appdash server host:port")
+		lightstepAccessToken = fs.String("lightstep.token", "", "Enable LightStep tracing via a LightStep access token")
 	)
 	flag.Usage = fs.Usage // only show our flags
 	if err := fs.Parse(os.Args[1:]); err != nil {
@@ -78,20 +84,21 @@ func main() {
 		))
 	}
 
-	// package tracing
-	var collector zipkin.Collector
+	// Set up OpenTracing
+	var tracer opentracing.Tracer
 	{
-		zipkinLogger := log.NewContext(logger).With("component", "zipkin")
-		collector = loggingCollector{zipkinLogger} // TODO(pb)
-		if *zipkinCollectorAddr != "" {
-			var err error
-			if collector, err = zipkin.NewKafkaCollector(
-				[]string{*zipkinCollectorAddr},
-				zipkin.KafkaLogger(zipkinLogger),
-			); err != nil {
-				zipkinLogger.Log("err", err)
-				os.Exit(1)
-			}
+		switch {
+		case *appdashAddr != "" && *lightstepAccessToken == "":
+			tracer = appdashot.NewTracer(appdash.NewRemoteCollector(*appdashAddr))
+		case *appdashAddr == "" && *lightstepAccessToken != "":
+			tracer = lightstep.NewTracer(lightstep.Options{
+				AccessToken: *lightstepAccessToken,
+			})
+			defer lightstep.FlushLightStepTracer(tracer)
+		case *appdashAddr == "" && *lightstepAccessToken == "":
+			tracer = opentracing.GlobalTracer() // no-op
+		default:
+			panic("specify either -appdash.addr or -lightstep.access.token, not both")
 		}
 	}
 
@@ -124,34 +131,30 @@ func main() {
 		var (
 			transportLogger = log.NewContext(logger).With("transport", "HTTP/JSON")
 			tracingLogger   = log.NewContext(transportLogger).With("component", "tracing")
-			newSumSpan      = zipkin.MakeNewSpanFunc(*zipkinHostPort, *zipkinServiceName, "sum")
-			newConcatSpan   = zipkin.MakeNewSpanFunc(*zipkinHostPort, *zipkinServiceName, "concat")
-			traceSum        = zipkin.ToContext(newSumSpan, tracingLogger)
-			traceConcat     = zipkin.ToContext(newConcatSpan, tracingLogger)
 			mux             = http.NewServeMux()
 			sum, concat     endpoint.Endpoint
 		)
 
 		sum = makeSumEndpoint(svc)
-		sum = zipkin.AnnotateServer(newSumSpan, collector)(sum)
+		sum = kitot.TraceServer(tracer, "sum")(sum)
 		mux.Handle("/sum", httptransport.NewServer(
 			root,
 			sum,
 			server.DecodeSumRequest,
 			server.EncodeSumResponse,
-			httptransport.ServerBefore(traceSum),
 			httptransport.ServerErrorLogger(transportLogger),
+			httptransport.ServerBefore(kitot.FromHTTPRequest(tracer, "sum", tracingLogger)),
 		))
 
 		concat = makeConcatEndpoint(svc)
-		concat = zipkin.AnnotateServer(newConcatSpan, collector)(concat)
+		concat = kitot.TraceServer(tracer, "concat")(concat)
 		mux.Handle("/concat", httptransport.NewServer(
 			root,
 			concat,
 			server.DecodeConcatRequest,
 			server.EncodeConcatResponse,
-			httptransport.ServerBefore(traceConcat),
 			httptransport.ServerErrorLogger(transportLogger),
+			httptransport.ServerBefore(kitot.FromHTTPRequest(tracer, "concat", tracingLogger)),
 		))
 
 		transportLogger.Log("addr", *httpAddr)
@@ -161,13 +164,14 @@ func main() {
 	// Transport: gRPC
 	go func() {
 		transportLogger := log.NewContext(logger).With("transport", "gRPC")
+		tracingLogger := log.NewContext(transportLogger).With("component", "tracing")
 		ln, err := net.Listen("tcp", *grpcAddr)
 		if err != nil {
 			errc <- err
 			return
 		}
 		s := grpc.NewServer() // uses its own, internal context
-		pb.RegisterAddServer(s, newGRPCBinding(root, svc))
+		pb.RegisterAddServer(s, newGRPCBinding(root, tracer, svc, tracingLogger))
 		transportLogger.Log("addr", *grpcAddr)
 		errc <- s.Serve(ln)
 	}()
diff --git a/examples/apigateway/main.go b/examples/apigateway/main.go
index e6ba593..4506812 100644
--- a/examples/apigateway/main.go
+++ b/examples/apigateway/main.go
@@ -17,6 +17,7 @@ import (
 
 	"github.com/gorilla/mux"
 	"github.com/hashicorp/consul/api"
+	"github.com/opentracing/opentracing-go"
 	"golang.org/x/net/context"
 
 	"github.com/go-kit/kit/endpoint"
@@ -77,8 +78,8 @@ func main() {
 		factory loadbalancer.Factory
 	}{
 		"addsvc": {
-			{path: "/api/addsvc/concat", factory: grpc.ConcatEndpointFactory},
-			{path: "/api/addsvc/sum", factory: grpc.SumEndpointFactory},
+			{path: "/api/addsvc/concat", factory: grpc.MakeConcatEndpointFactory(opentracing.GlobalTracer(), nil)},
+			{path: "/api/addsvc/sum", factory: grpc.MakeSumEndpointFactory(opentracing.GlobalTracer(), nil)},
 		},
 		"stringsvc": {
 			{path: "/api/stringsvc/uppercase", factory: httpFactory(ctx, "GET", "uppercase/")},
diff --git a/tracing/opentracing/endpoint.go b/tracing/opentracing/endpoint.go
new file mode 100644
index 0000000..9f626a7
--- /dev/null
+++ b/tracing/opentracing/endpoint.go
@@ -0,0 +1,50 @@
+package opentracing
+
+import (
+	"github.com/opentracing/opentracing-go"
+	otext "github.com/opentracing/opentracing-go/ext"
+	"golang.org/x/net/context"
+
+	"github.com/go-kit/kit/endpoint"
+)
+
+// TraceServer returns a Middleware that wraps the `next` Endpoint in an
+// OpenTracing Span called `operationName`.
+//
+// If `ctx` already has a Span, it is re-used and the operation name is
+// overwritten. If `ctx` does not yet have a Span, one is created here.
+func TraceServer(tracer opentracing.Tracer, operationName string) endpoint.Middleware {
+	return func(next endpoint.Endpoint) endpoint.Endpoint {
+		return func(ctx context.Context, request interface{}) (interface{}, error) {
+			serverSpan := opentracing.SpanFromContext(ctx)
+			if serverSpan == nil {
+				// All we can do is create a new root span.
+				serverSpan = tracer.StartSpan(operationName)
+			} else {
+				serverSpan.SetOperationName(operationName)
+			}
+			defer serverSpan.Finish()
+			otext.SpanKind.Set(serverSpan, otext.SpanKindRPCServer)
+			ctx = opentracing.ContextWithSpan(ctx, serverSpan)
+			return next(ctx, request)
+		}
+	}
+}
+
+// TraceClient returns a Middleware that wraps the `next` Endpoint in an
+// OpenTracing Span called `operationName`.
+func TraceClient(tracer opentracing.Tracer, operationName string) endpoint.Middleware {
+	return func(next endpoint.Endpoint) endpoint.Endpoint {
+		return func(ctx context.Context, request interface{}) (interface{}, error) {
+			parentSpan := opentracing.SpanFromContext(ctx)
+			clientSpan := tracer.StartSpanWithOptions(opentracing.StartSpanOptions{
+				OperationName: operationName,
+				Parent:        parentSpan, // may be nil
+			})
+			defer clientSpan.Finish()
+			otext.SpanKind.Set(clientSpan, otext.SpanKindRPCClient)
+			ctx = opentracing.ContextWithSpan(ctx, clientSpan)
+			return next(ctx, request)
+		}
+	}
+}
diff --git a/tracing/opentracing/grpc.go b/tracing/opentracing/grpc.go
new file mode 100644
index 0000000..e4fb793
--- /dev/null
+++ b/tracing/opentracing/grpc.go
@@ -0,0 +1,68 @@
+package opentracing
+
+import (
+	"github.com/opentracing/opentracing-go"
+	"golang.org/x/net/context"
+	"google.golang.org/grpc/metadata"
+
+	"github.com/go-kit/kit/log"
+)
+
+// ToGRPCRequest returns a grpc RequestFunc that injects an OpenTracing Span
+// found in `ctx` into the grpc Metadata. If no such Span can be found, the
+// RequestFunc is a noop.
+//
+// The logger is used to report errors and may be nil.
+func ToGRPCRequest(tracer opentracing.Tracer, logger log.Logger) func(ctx context.Context, md *metadata.MD) context.Context {
+	return func(ctx context.Context, md *metadata.MD) context.Context {
+		if span := opentracing.SpanFromContext(ctx); span != nil {
+			// There's nothing we can do with an error here.
+			err := tracer.Inject(span, opentracing.TextMap, metadataReaderWriter{md})
+			if err != nil && logger != nil {
+				logger.Log("msg", "Inject failed", "err", err)
+			}
+		}
+		return ctx
+	}
+}
+
+// FromGRPCRequest returns a grpc RequestFunc that tries to join with an
+// OpenTracing trace found in `req` and starts a new Span called
+// `operationName` accordingly. If no trace could be found in `req`, the Span
+// will be a trace root. The Span is incorporated in the returned Context and
+// can be retrieved with opentracing.SpanFromContext(ctx).
+//
+// The logger is used to report errors and may be nil.
+func FromGRPCRequest(tracer opentracing.Tracer, operationName string, logger log.Logger) func(ctx context.Context, md *metadata.MD) context.Context {
+	return func(ctx context.Context, md *metadata.MD) context.Context {
+		span, err := tracer.Join(operationName, opentracing.TextMap, metadataReaderWriter{md})
+		if err != nil && logger != nil {
+			logger.Log("msg", "Join failed", "err", err)
+		}
+		if span == nil {
+			span = tracer.StartSpan(operationName)
+		}
+		return opentracing.ContextWithSpan(ctx, span)
+	}
+}
+
+// A type that conforms to opentracing.TextMapReader and
+// opentracing.TextMapWriter.
+type metadataReaderWriter struct {
+	*metadata.MD
+}
+
+func (w metadataReaderWriter) Set(key, val string) {
+	(*w.MD)[key] = append((*w.MD)[key], val)
+}
+
+func (w metadataReaderWriter) ForeachKey(handler func(key, val string) error) error {
+	for k, vals := range *w.MD {
+		for _, v := range vals {
+			if err := handler(k, v); err != nil {
+				return err
+			}
+		}
+	}
+	return nil
+}
diff --git a/tracing/opentracing/http.go b/tracing/opentracing/http.go
new file mode 100644
index 0000000..606516d
--- /dev/null
+++ b/tracing/opentracing/http.go
@@ -0,0 +1,75 @@
+package opentracing
+
+import (
+	"net"
+	"net/http"
+	"strconv"
+
+	"github.com/opentracing/opentracing-go"
+	"github.com/opentracing/opentracing-go/ext"
+	"golang.org/x/net/context"
+
+	"github.com/go-kit/kit/log"
+	kithttp "github.com/go-kit/kit/transport/http"
+)
+
+// ToHTTPRequest returns an http RequestFunc that injects an OpenTracing Span
+// found in `ctx` into the http headers. If no such Span can be found, the
+// RequestFunc is a noop.
+//
+// The logger is used to report errors and may be nil.
+func ToHTTPRequest(tracer opentracing.Tracer, logger log.Logger) kithttp.RequestFunc {
+	return func(ctx context.Context, req *http.Request) context.Context {
+		// Try to find a Span in the Context.
+		if span := opentracing.SpanFromContext(ctx); span != nil {
+			// Add standard OpenTracing tags.
+			ext.HTTPMethod.Set(span, req.URL.RequestURI())
+			host, portString, err := net.SplitHostPort(req.URL.Host)
+			if err == nil {
+				ext.PeerHostname.Set(span, host)
+				if port, err := strconv.Atoi(portString); err != nil {
+					ext.PeerPort.Set(span, uint16(port))
+				}
+			} else {
+				ext.PeerHostname.Set(span, req.URL.Host)
+			}
+
+			// There's nothing we can do with any errors here.
+			err = tracer.Inject(
+				span,
+				opentracing.TextMap,
+				opentracing.HTTPHeaderTextMapCarrier(req.Header),
+			)
+			if err != nil && logger != nil {
+				logger.Log("msg", "Join failed", "err", err)
+			}
+		}
+		return ctx
+	}
+}
+
+// FromHTTPRequest returns an http RequestFunc that tries to join with an
+// OpenTracing trace found in `req` and starts a new Span called
+// `operationName` accordingly. If no trace could be found in `req`, the Span
+// will be a trace root. The Span is incorporated in the returned Context and
+// can be retrieved with opentracing.SpanFromContext(ctx).
+//
+// The logger is used to report errors and may be nil.
+func FromHTTPRequest(tracer opentracing.Tracer, operationName string, logger log.Logger) kithttp.RequestFunc {
+	return func(ctx context.Context, req *http.Request) context.Context {
+		// Try to join to a trace propagated in `req`. There's nothing we can
+		// do with any errors here, so we ignore them.
+		span, err := tracer.Join(
+			operationName,
+			opentracing.TextMap,
+			opentracing.HTTPHeaderTextMapCarrier(req.Header),
+		)
+		if err != nil && logger != nil {
+			logger.Log("msg", "Join failed", "err", err)
+		}
+		if span == nil {
+			span = opentracing.StartSpan(operationName)
+		}
+		return opentracing.ContextWithSpan(ctx, span)
+	}
+}
