diff --git a/examples/addsvc/client/grpc/factory.go b/examples/addsvc/client/grpc/factory.go
index 0e59932..b898d96 100644
--- a/examples/addsvc/client/grpc/factory.go
+++ b/examples/addsvc/client/grpc/factory.go
@@ -3,49 +3,37 @@ package grpc
 import (
 	"io"
 
-	kitot "github.com/go-kit/kit/tracing/opentracing"
-	"github.com/opentracing/opentracing-go"
 	"google.golang.org/grpc"
 
 	"github.com/go-kit/kit/endpoint"
 	"github.com/go-kit/kit/examples/addsvc/pb"
-	"github.com/go-kit/kit/loadbalancer"
-	"github.com/go-kit/kit/log"
 	grpctransport "github.com/go-kit/kit/transport/grpc"
 )
 
-// MakeSumEndpointFactory returns a loadbalancer.Factory that transforms GRPC
-// host:port strings into Endpoints that call the Sum method on a GRPC server
+// SumEndpointFactory transforms GRPC host:port strings into Endpoints that call the Sum method on a GRPC server
 // at that address.
-func MakeSumEndpointFactory(tracer opentracing.Tracer, tracingLogger log.Logger) loadbalancer.Factory {
-	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
-		cc, err := grpc.Dial(instance, grpc.WithInsecure())
-		return grpctransport.NewClient(
-			cc,
-			"Add",
-			"Sum",
-			encodeSumRequest,
-			decodeSumResponse,
-			pb.SumReply{},
-			grpctransport.SetClientBefore(kitot.ToGRPCRequest(tracer, tracingLogger)),
-		).Endpoint(), cc, err
-	}
+func SumEndpointFactory(instance string) (endpoint.Endpoint, io.Closer, error) {
+	cc, err := grpc.Dial(instance, grpc.WithInsecure())
+	return grpctransport.NewClient(
+		cc,
+		"Add",
+		"Sum",
+		encodeSumRequest,
+		decodeSumResponse,
+		pb.SumReply{},
+	).Endpoint(), cc, err
 }
 
-// MakeConcatEndpointFactory returns a loadbalancer.Factory that transforms
-// GRPC host:port strings into Endpoints that call the Concat method on a GRPC
-// server at that address.
-func MakeConcatEndpointFactory(tracer opentracing.Tracer, tracingLogger log.Logger) loadbalancer.Factory {
-	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
-		cc, err := grpc.Dial(instance, grpc.WithInsecure())
-		return grpctransport.NewClient(
-			cc,
-			"Add",
-			"Concat",
-			encodeConcatRequest,
-			decodeConcatResponse,
-			pb.ConcatReply{},
-			grpctransport.SetClientBefore(kitot.ToGRPCRequest(tracer, tracingLogger)),
-		).Endpoint(), cc, err
-	}
+// ConcatEndpointFactory transforms GRPC host:port strings into Endpoints that call the Concat method on a GRPC server
+// at that address.
+func ConcatEndpointFactory(instance string) (endpoint.Endpoint, io.Closer, error) {
+	cc, err := grpc.Dial(instance, grpc.WithInsecure())
+	return grpctransport.NewClient(
+		cc,
+		"Add",
+		"Concat",
+		encodeConcatRequest,
+		decodeConcatResponse,
+		pb.ConcatReply{},
+	).Endpoint(), cc, err
 }
diff --git a/examples/addsvc/client/httpjson/factory.go b/examples/addsvc/client/httpjson/factory.go
index f36ce4e..43f3148 100644
--- a/examples/addsvc/client/httpjson/factory.go
+++ b/examples/addsvc/client/httpjson/factory.go
@@ -4,62 +4,47 @@ import (
 	"io"
 	"net/url"
 
-	"github.com/opentracing/opentracing-go"
-
 	"github.com/go-kit/kit/endpoint"
 	"github.com/go-kit/kit/examples/addsvc/server"
-	"github.com/go-kit/kit/loadbalancer"
-	"github.com/go-kit/kit/log"
-	kitot "github.com/go-kit/kit/tracing/opentracing"
 	httptransport "github.com/go-kit/kit/transport/http"
 )
 
-// MakeSumEndpointFactory generates a Factory that transforms an http url into
-// an Endpoint.
-//
+// SumEndpointFactory transforms a http url into an Endpoint.
 // The path of the url is reset to /sum.
-func MakeSumEndpointFactory(tracer opentracing.Tracer, tracingLogger log.Logger) loadbalancer.Factory {
-	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
-		sumURL, err := url.Parse(instance)
-		if err != nil {
-			return nil, nil, err
-		}
-		sumURL.Path = "/sum"
+func SumEndpointFactory(instance string) (endpoint.Endpoint, io.Closer, error) {
+	sumURL, err := url.Parse(instance)
+	if err != nil {
+		return nil, nil, err
+	}
+	sumURL.Path = "/sum"
 
-		client := httptransport.NewClient(
-			"GET",
-			sumURL,
-			server.EncodeSumRequest,
-			server.DecodeSumResponse,
-			httptransport.SetClient(nil),
-			httptransport.SetClientBefore(kitot.ToHTTPRequest(tracer, tracingLogger)),
-		)
+	client := httptransport.NewClient(
+		"GET",
+		sumURL,
+		server.EncodeSumRequest,
+		server.DecodeSumResponse,
+		httptransport.SetClient(nil),
+	)
 
-		return client.Endpoint(), nil, nil
-	}
+	return client.Endpoint(), nil, nil
 }
 
-// MakeConcatEndpointFactory generates a Factory that transforms an http url
-// into an Endpoint.
-//
+// ConcatEndpointFactory transforms a http url into an Endpoint.
 // The path of the url is reset to /concat.
-func MakeConcatEndpointFactory(tracer opentracing.Tracer, tracingLogger log.Logger) loadbalancer.Factory {
-	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
-		concatURL, err := url.Parse(instance)
-		if err != nil {
-			return nil, nil, err
-		}
-		concatURL.Path = "/concat"
+func ConcatEndpointFactory(instance string) (endpoint.Endpoint, io.Closer, error) {
+	concatURL, err := url.Parse(instance)
+	if err != nil {
+		return nil, nil, err
+	}
+	concatURL.Path = "/concat"
 
-		client := httptransport.NewClient(
-			"GET",
-			concatURL,
-			server.EncodeConcatRequest,
-			server.DecodeConcatResponse,
-			httptransport.SetClient(nil),
-			httptransport.SetClientBefore(kitot.ToHTTPRequest(tracer, tracingLogger)),
-		)
+	client := httptransport.NewClient(
+		"GET",
+		concatURL,
+		server.EncodeConcatRequest,
+		server.DecodeConcatResponse,
+		httptransport.SetClient(nil),
+	)
 
-		return client.Endpoint(), nil, nil
-	}
+	return client.Endpoint(), nil, nil
 }
diff --git a/examples/addsvc/client/main.go b/examples/addsvc/client/main.go
index e1307cb..95bb16e 100644
--- a/examples/addsvc/client/main.go
+++ b/examples/addsvc/client/main.go
@@ -9,11 +9,7 @@ import (
 	"strings"
 	"time"
 
-	"github.com/lightstep/lightstep-tracer-go"
-	"github.com/opentracing/opentracing-go"
-	appdashot "github.com/sourcegraph/appdash/opentracing"
 	"golang.org/x/net/context"
-	"sourcegraph.com/sourcegraph/appdash"
 
 	"github.com/go-kit/kit/endpoint"
 	grpcclient "github.com/go-kit/kit/examples/addsvc/client/grpc"
@@ -23,7 +19,6 @@ import (
 	"github.com/go-kit/kit/loadbalancer"
 	"github.com/go-kit/kit/loadbalancer/static"
 	"github.com/go-kit/kit/log"
-	kitot "github.com/go-kit/kit/tracing/opentracing"
 )
 
 func main() {
@@ -36,10 +31,6 @@ func main() {
 		thriftProtocol   = flag.String("thrift.protocol", "binary", "binary, compact, json, simplejson")
 		thriftBufferSize = flag.Int("thrift.buffer.size", 0, "0 for unbuffered")
 		thriftFramed     = flag.Bool("thrift.framed", false, "true to enable framing")
-
-		// Two OpenTracing backends (to demonstrate how they can be interchanged):
-		appdashAddr          = flag.String("appdash.addr", "", "Enable Appdash tracing via an Appdash server host:port")
-		lightstepAccessToken = flag.String("lightstep.token", "", "Enable LightStep tracing via a LightStep access token")
 	)
 	flag.Parse()
 	if len(os.Args) < 4 {
@@ -57,25 +48,6 @@ func main() {
 	logger = log.NewLogfmtLogger(os.Stdout)
 	logger = log.NewContext(logger).With("caller", log.DefaultCaller)
 	logger = log.NewContext(logger).With("transport", *transport)
-	tracingLogger := log.NewContext(logger).With("component", "tracing")
-
-	// Set up OpenTracing
-	var tracer opentracing.Tracer
-	{
-		switch {
-		case *appdashAddr != "" && *lightstepAccessToken == "":
-			tracer = appdashot.NewTracer(appdash.NewRemoteCollector(*appdashAddr))
-		case *appdashAddr == "" && *lightstepAccessToken != "":
-			tracer = lightstep.NewTracer(lightstep.Options{
-				AccessToken: *lightstepAccessToken,
-			})
-			defer lightstep.FlushLightStepTracer(tracer)
-		case *appdashAddr == "" && *lightstepAccessToken == "":
-			tracer = opentracing.GlobalTracer() // no-op
-		default:
-			panic("specify either -appdash.addr or -lightstep.access.token, not both")
-		}
-	}
 
 	var (
 		instances                 []string
@@ -85,8 +57,8 @@ func main() {
 	switch *transport {
 	case "grpc":
 		instances = strings.Split(*grpcAddrs, ",")
-		sumFactory = grpcclient.MakeSumEndpointFactory(tracer, tracingLogger)
-		concatFactory = grpcclient.MakeConcatEndpointFactory(tracer, tracingLogger)
+		sumFactory = grpcclient.SumEndpointFactory
+		concatFactory = grpcclient.ConcatEndpointFactory
 
 	case "httpjson":
 		instances = strings.Split(*httpAddrs, ",")
@@ -95,8 +67,8 @@ func main() {
 				instances[i] = "http://" + rawurl
 			}
 		}
-		sumFactory = httpjsonclient.MakeSumEndpointFactory(tracer, tracingLogger)
-		concatFactory = httpjsonclient.MakeConcatEndpointFactory(tracer, tracingLogger)
+		sumFactory = httpjsonclient.SumEndpointFactory
+		concatFactory = httpjsonclient.ConcatEndpointFactory
 
 	case "netrpc":
 		instances = strings.Split(*netrpcAddrs, ",")
@@ -114,8 +86,8 @@ func main() {
 		os.Exit(1)
 	}
 
-	sum := buildEndpoint(tracer, "sum", instances, sumFactory, randomSeed, logger)
-	concat := buildEndpoint(tracer, "concat", instances, concatFactory, randomSeed, logger)
+	sum := buildEndpoint(instances, sumFactory, randomSeed, logger)
+	concat := buildEndpoint(instances, concatFactory, randomSeed, logger)
 
 	svc := newClient(root, sum, concat, logger)
 
@@ -138,9 +110,8 @@ func main() {
 	}
 }
 
-func buildEndpoint(tracer opentracing.Tracer, operationName string, instances []string, factory loadbalancer.Factory, seed int64, logger log.Logger) endpoint.Endpoint {
+func buildEndpoint(instances []string, factory loadbalancer.Factory, seed int64, logger log.Logger) endpoint.Endpoint {
 	publisher := static.NewPublisher(instances, factory, logger)
 	random := loadbalancer.NewRandom(publisher, seed)
-	endpoint := loadbalancer.Retry(10, 10*time.Second, random)
-	return kitot.TraceClient(tracer, operationName)(endpoint)
+	return loadbalancer.Retry(10, 10*time.Second, random)
 }
diff --git a/examples/addsvc/grpc_binding.go b/examples/addsvc/grpc_binding.go
index 101c71f..42cd849 100644
--- a/examples/addsvc/grpc_binding.go
+++ b/examples/addsvc/grpc_binding.go
@@ -3,13 +3,9 @@ package main
 import (
 	"golang.org/x/net/context"
 
-	"github.com/opentracing/opentracing-go"
-
 	"github.com/go-kit/kit/examples/addsvc/pb"
 	"github.com/go-kit/kit/examples/addsvc/server"
 	servergrpc "github.com/go-kit/kit/examples/addsvc/server/grpc"
-	"github.com/go-kit/kit/log"
-	kitot "github.com/go-kit/kit/tracing/opentracing"
 	"github.com/go-kit/kit/transport/grpc"
 )
 
@@ -17,22 +13,10 @@ type grpcBinding struct {
 	sum, concat grpc.Handler
 }
 
-func newGRPCBinding(ctx context.Context, tracer opentracing.Tracer, svc server.AddService, tracingLogger log.Logger) grpcBinding {
+func newGRPCBinding(ctx context.Context, svc server.AddService) grpcBinding {
 	return grpcBinding{
-		sum: grpc.NewServer(
-			ctx,
-			kitot.TraceServer(tracer, "sum")(makeSumEndpoint(svc)),
-			servergrpc.DecodeSumRequest,
-			servergrpc.EncodeSumResponse,
-			grpc.ServerBefore(kitot.FromGRPCRequest(tracer, "", tracingLogger)),
-		),
-		concat: grpc.NewServer(
-			ctx,
-			kitot.TraceServer(tracer, "concat")(makeConcatEndpoint(svc)),
-			servergrpc.DecodeConcatRequest,
-			servergrpc.EncodeConcatResponse,
-			grpc.ServerBefore(kitot.FromGRPCRequest(tracer, "", tracingLogger)),
-		),
+		sum:    grpc.NewServer(ctx, makeSumEndpoint(svc), servergrpc.DecodeSumRequest, servergrpc.EncodeSumResponse),
+		concat: grpc.NewServer(ctx, makeConcatEndpoint(svc), servergrpc.DecodeConcatRequest, servergrpc.EncodeConcatResponse),
 	}
 }
 
diff --git a/examples/addsvc/main.go b/examples/addsvc/main.go
index 28c4088..d504043 100644
--- a/examples/addsvc/main.go
+++ b/examples/addsvc/main.go
@@ -15,13 +15,9 @@ import (
 	"time"
 
 	"github.com/apache/thrift/lib/go/thrift"
-	"github.com/lightstep/lightstep-tracer-go"
-	"github.com/opentracing/opentracing-go"
 	stdprometheus "github.com/prometheus/client_golang/prometheus"
-	appdashot "github.com/sourcegraph/appdash/opentracing"
 	"golang.org/x/net/context"
 	"google.golang.org/grpc"
-	"sourcegraph.com/sourcegraph/appdash"
 
 	"github.com/go-kit/kit/endpoint"
 	"github.com/go-kit/kit/examples/addsvc/pb"
@@ -31,7 +27,6 @@ import (
 	"github.com/go-kit/kit/metrics"
 	"github.com/go-kit/kit/metrics/expvar"
 	"github.com/go-kit/kit/metrics/prometheus"
-	kitot "github.com/go-kit/kit/tracing/opentracing"
 	"github.com/go-kit/kit/tracing/zipkin"
 	httptransport "github.com/go-kit/kit/transport/http"
 )
@@ -41,18 +36,17 @@ func main() {
 	// of glog. So, we define a new flag set, to keep those domains distinct.
 	fs := flag.NewFlagSet("", flag.ExitOnError)
 	var (
-		debugAddr        = fs.String("debug.addr", ":8000", "Address for HTTP debug/instrumentation server")
-		httpAddr         = fs.String("http.addr", ":8001", "Address for HTTP (JSON) server")
-		grpcAddr         = fs.String("grpc.addr", ":8002", "Address for gRPC server")
-		netrpcAddr       = fs.String("netrpc.addr", ":8003", "Address for net/rpc server")
-		thriftAddr       = fs.String("thrift.addr", ":8004", "Address for Thrift server")
-		thriftProtocol   = fs.String("thrift.protocol", "binary", "binary, compact, json, simplejson")
-		thriftBufferSize = fs.Int("thrift.buffer.size", 0, "0 for unbuffered")
-		thriftFramed     = fs.Bool("thrift.framed", false, "true to enable framing")
-
-		// Supported OpenTracing backends
-		appdashAddr          = fs.String("appdash.addr", "", "Enable Appdash tracing via an Appdash server host:port")
-		lightstepAccessToken = fs.String("lightstep.token", "", "Enable LightStep tracing via a LightStep access token")
+		debugAddr           = fs.String("debug.addr", ":8000", "Address for HTTP debug/instrumentation server")
+		httpAddr            = fs.String("http.addr", ":8001", "Address for HTTP (JSON) server")
+		grpcAddr            = fs.String("grpc.addr", ":8002", "Address for gRPC server")
+		netrpcAddr          = fs.String("netrpc.addr", ":8003", "Address for net/rpc server")
+		thriftAddr          = fs.String("thrift.addr", ":8004", "Address for Thrift server")
+		thriftProtocol      = fs.String("thrift.protocol", "binary", "binary, compact, json, simplejson")
+		thriftBufferSize    = fs.Int("thrift.buffer.size", 0, "0 for unbuffered")
+		thriftFramed        = fs.Bool("thrift.framed", false, "true to enable framing")
+		zipkinHostPort      = fs.String("zipkin.host.port", "my.service.domain:12345", "Zipkin host:port")
+		zipkinServiceName   = fs.String("zipkin.service.name", "addsvc", "Zipkin service name")
+		zipkinCollectorAddr = fs.String("zipkin.collector.addr", "", "Zipkin Kafka collector address (empty will log spans)")
 	)
 	flag.Usage = fs.Usage // only show our flags
 	if err := fs.Parse(os.Args[1:]); err != nil {
@@ -84,21 +78,20 @@ func main() {
 		))
 	}
 
-	// Set up OpenTracing
-	var tracer opentracing.Tracer
+	// package tracing
+	var collector zipkin.Collector
 	{
-		switch {
-		case *appdashAddr != "" && *lightstepAccessToken == "":
-			tracer = appdashot.NewTracer(appdash.NewRemoteCollector(*appdashAddr))
-		case *appdashAddr == "" && *lightstepAccessToken != "":
-			tracer = lightstep.NewTracer(lightstep.Options{
-				AccessToken: *lightstepAccessToken,
-			})
-			defer lightstep.FlushLightStepTracer(tracer)
-		case *appdashAddr == "" && *lightstepAccessToken == "":
-			tracer = opentracing.GlobalTracer() // no-op
-		default:
-			panic("specify either -appdash.addr or -lightstep.access.token, not both")
+		zipkinLogger := log.NewContext(logger).With("component", "zipkin")
+		collector = loggingCollector{zipkinLogger} // TODO(pb)
+		if *zipkinCollectorAddr != "" {
+			var err error
+			if collector, err = zipkin.NewKafkaCollector(
+				[]string{*zipkinCollectorAddr},
+				zipkin.KafkaLogger(zipkinLogger),
+			); err != nil {
+				zipkinLogger.Log("err", err)
+				os.Exit(1)
+			}
 		}
 	}
 
@@ -131,30 +124,34 @@ func main() {
 		var (
 			transportLogger = log.NewContext(logger).With("transport", "HTTP/JSON")
 			tracingLogger   = log.NewContext(transportLogger).With("component", "tracing")
+			newSumSpan      = zipkin.MakeNewSpanFunc(*zipkinHostPort, *zipkinServiceName, "sum")
+			newConcatSpan   = zipkin.MakeNewSpanFunc(*zipkinHostPort, *zipkinServiceName, "concat")
+			traceSum        = zipkin.ToContext(newSumSpan, tracingLogger)
+			traceConcat     = zipkin.ToContext(newConcatSpan, tracingLogger)
 			mux             = http.NewServeMux()
 			sum, concat     endpoint.Endpoint
 		)
 
 		sum = makeSumEndpoint(svc)
-		sum = kitot.TraceServer(tracer, "sum")(sum)
+		sum = zipkin.AnnotateServer(newSumSpan, collector)(sum)
 		mux.Handle("/sum", httptransport.NewServer(
 			root,
 			sum,
 			server.DecodeSumRequest,
 			server.EncodeSumResponse,
+			httptransport.ServerBefore(traceSum),
 			httptransport.ServerErrorLogger(transportLogger),
-			httptransport.ServerBefore(kitot.FromHTTPRequest(tracer, "sum", tracingLogger)),
 		))
 
 		concat = makeConcatEndpoint(svc)
-		concat = kitot.TraceServer(tracer, "concat")(concat)
+		concat = zipkin.AnnotateServer(newConcatSpan, collector)(concat)
 		mux.Handle("/concat", httptransport.NewServer(
 			root,
 			concat,
 			server.DecodeConcatRequest,
 			server.EncodeConcatResponse,
+			httptransport.ServerBefore(traceConcat),
 			httptransport.ServerErrorLogger(transportLogger),
-			httptransport.ServerBefore(kitot.FromHTTPRequest(tracer, "concat", tracingLogger)),
 		))
 
 		transportLogger.Log("addr", *httpAddr)
@@ -164,14 +161,13 @@ func main() {
 	// Transport: gRPC
 	go func() {
 		transportLogger := log.NewContext(logger).With("transport", "gRPC")
-		tracingLogger := log.NewContext(transportLogger).With("component", "tracing")
 		ln, err := net.Listen("tcp", *grpcAddr)
 		if err != nil {
 			errc <- err
 			return
 		}
 		s := grpc.NewServer() // uses its own, internal context
-		pb.RegisterAddServer(s, newGRPCBinding(root, tracer, svc, tracingLogger))
+		pb.RegisterAddServer(s, newGRPCBinding(root, svc))
 		transportLogger.Log("addr", *grpcAddr)
 		errc <- s.Serve(ln)
 	}()
diff --git a/examples/apigateway/main.go b/examples/apigateway/main.go
index 4506812..e6ba593 100644
--- a/examples/apigateway/main.go
+++ b/examples/apigateway/main.go
@@ -17,7 +17,6 @@ import (
 
 	"github.com/gorilla/mux"
 	"github.com/hashicorp/consul/api"
-	"github.com/opentracing/opentracing-go"
 	"golang.org/x/net/context"
 
 	"github.com/go-kit/kit/endpoint"
@@ -78,8 +77,8 @@ func main() {
 		factory loadbalancer.Factory
 	}{
 		"addsvc": {
-			{path: "/api/addsvc/concat", factory: grpc.MakeConcatEndpointFactory(opentracing.GlobalTracer(), nil)},
-			{path: "/api/addsvc/sum", factory: grpc.MakeSumEndpointFactory(opentracing.GlobalTracer(), nil)},
+			{path: "/api/addsvc/concat", factory: grpc.ConcatEndpointFactory},
+			{path: "/api/addsvc/sum", factory: grpc.SumEndpointFactory},
 		},
 		"stringsvc": {
 			{path: "/api/stringsvc/uppercase", factory: httpFactory(ctx, "GET", "uppercase/")},
diff --git a/tracing/opentracing/endpoint.go b/tracing/opentracing/endpoint.go
deleted file mode 100644
index 9f626a7..0000000
--- a/tracing/opentracing/endpoint.go
+++ /dev/null
@@ -1,50 +0,0 @@
-package opentracing
-
-import (
-	"github.com/opentracing/opentracing-go"
-	otext "github.com/opentracing/opentracing-go/ext"
-	"golang.org/x/net/context"
-
-	"github.com/go-kit/kit/endpoint"
-)
-
-// TraceServer returns a Middleware that wraps the `next` Endpoint in an
-// OpenTracing Span called `operationName`.
-//
-// If `ctx` already has a Span, it is re-used and the operation name is
-// overwritten. If `ctx` does not yet have a Span, one is created here.
-func TraceServer(tracer opentracing.Tracer, operationName string) endpoint.Middleware {
-	return func(next endpoint.Endpoint) endpoint.Endpoint {
-		return func(ctx context.Context, request interface{}) (interface{}, error) {
-			serverSpan := opentracing.SpanFromContext(ctx)
-			if serverSpan == nil {
-				// All we can do is create a new root span.
-				serverSpan = tracer.StartSpan(operationName)
-			} else {
-				serverSpan.SetOperationName(operationName)
-			}
-			defer serverSpan.Finish()
-			otext.SpanKind.Set(serverSpan, otext.SpanKindRPCServer)
-			ctx = opentracing.ContextWithSpan(ctx, serverSpan)
-			return next(ctx, request)
-		}
-	}
-}
-
-// TraceClient returns a Middleware that wraps the `next` Endpoint in an
-// OpenTracing Span called `operationName`.
-func TraceClient(tracer opentracing.Tracer, operationName string) endpoint.Middleware {
-	return func(next endpoint.Endpoint) endpoint.Endpoint {
-		return func(ctx context.Context, request interface{}) (interface{}, error) {
-			parentSpan := opentracing.SpanFromContext(ctx)
-			clientSpan := tracer.StartSpanWithOptions(opentracing.StartSpanOptions{
-				OperationName: operationName,
-				Parent:        parentSpan, // may be nil
-			})
-			defer clientSpan.Finish()
-			otext.SpanKind.Set(clientSpan, otext.SpanKindRPCClient)
-			ctx = opentracing.ContextWithSpan(ctx, clientSpan)
-			return next(ctx, request)
-		}
-	}
-}
diff --git a/tracing/opentracing/endpoint_test.go b/tracing/opentracing/endpoint_test.go
deleted file mode 100644
index 02da72e..0000000
--- a/tracing/opentracing/endpoint_test.go
+++ /dev/null
@@ -1,96 +0,0 @@
-package opentracing_test
-
-import (
-	"testing"
-
-	"github.com/opentracing/opentracing-go"
-	"github.com/opentracing/opentracing-go/mocktracer"
-	"golang.org/x/net/context"
-
-	"github.com/go-kit/kit/endpoint"
-	kitot "github.com/go-kit/kit/tracing/opentracing"
-)
-
-func TestTraceServer(t *testing.T) {
-	tracer := mocktracer.New()
-
-	// Initialize the ctx with a nameless Span.
-	contextSpan := tracer.StartSpan("").(*mocktracer.MockSpan)
-	ctx := opentracing.ContextWithSpan(context.Background(), contextSpan)
-
-	var innerEndpoint endpoint.Endpoint
-	innerEndpoint = func(context.Context, interface{}) (interface{}, error) {
-		return struct{}{}, nil
-	}
-	tracedEndpoint := kitot.TraceServer(tracer, "testOp")(innerEndpoint)
-	if _, err := tracedEndpoint(ctx, struct{}{}); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := 1, len(tracer.FinishedSpans); want != have {
-		t.Fatalf("Want %v span(s), found %v", want, have)
-	}
-
-	endpointSpan := tracer.FinishedSpans[0]
-	// Test that the op name is updated
-	if want, have := "testOp", endpointSpan.OperationName; want != have {
-		t.Fatalf("Want %q, have %q", want, have)
-	}
-	// ... and that the ID is unmodified.
-	if want, have := contextSpan.SpanID, endpointSpan.SpanID; want != have {
-		t.Errorf("Want SpanID %q, have %q", want, have)
-	}
-}
-
-func TestTraceServerNoContextSpan(t *testing.T) {
-	tracer := mocktracer.New()
-
-	var innerEndpoint endpoint.Endpoint
-	innerEndpoint = func(context.Context, interface{}) (interface{}, error) {
-		return struct{}{}, nil
-	}
-	tracedEndpoint := kitot.TraceServer(tracer, "testOp")(innerEndpoint)
-	// Empty/background context:
-	if _, err := tracedEndpoint(context.Background(), struct{}{}); err != nil {
-		t.Fatal(err)
-	}
-	// tracedEndpoint created a new Span:
-	if want, have := 1, len(tracer.FinishedSpans); want != have {
-		t.Fatalf("Want %v span(s), found %v", want, have)
-	}
-
-	endpointSpan := tracer.FinishedSpans[0]
-	if want, have := "testOp", endpointSpan.OperationName; want != have {
-		t.Fatalf("Want %q, have %q", want, have)
-	}
-}
-
-func TestTraceClient(t *testing.T) {
-	tracer := mocktracer.New()
-
-	// Initialize the ctx with a parent Span.
-	parentSpan := tracer.StartSpan("parent").(*mocktracer.MockSpan)
-	defer parentSpan.Finish()
-	ctx := opentracing.ContextWithSpan(context.Background(), parentSpan)
-
-	var innerEndpoint endpoint.Endpoint
-	innerEndpoint = func(context.Context, interface{}) (interface{}, error) {
-		return struct{}{}, nil
-	}
-	tracedEndpoint := kitot.TraceClient(tracer, "testOp")(innerEndpoint)
-	if _, err := tracedEndpoint(ctx, struct{}{}); err != nil {
-		t.Fatal(err)
-	}
-	// tracedEndpoint created a new Span:
-	if want, have := 1, len(tracer.FinishedSpans); want != have {
-		t.Fatalf("Want %v span(s), found %v", want, have)
-	}
-
-	endpointSpan := tracer.FinishedSpans[0]
-	if want, have := "testOp", endpointSpan.OperationName; want != have {
-		t.Fatalf("Want %q, have %q", want, have)
-	}
-	// ... and that the parent ID is set appropriately.
-	if want, have := parentSpan.SpanID, endpointSpan.ParentID; want != have {
-		t.Errorf("Want ParentID %q, have %q", want, have)
-	}
-}
diff --git a/tracing/opentracing/grpc.go b/tracing/opentracing/grpc.go
deleted file mode 100644
index e4fb793..0000000
--- a/tracing/opentracing/grpc.go
+++ /dev/null
@@ -1,68 +0,0 @@
-package opentracing
-
-import (
-	"github.com/opentracing/opentracing-go"
-	"golang.org/x/net/context"
-	"google.golang.org/grpc/metadata"
-
-	"github.com/go-kit/kit/log"
-)
-
-// ToGRPCRequest returns a grpc RequestFunc that injects an OpenTracing Span
-// found in `ctx` into the grpc Metadata. If no such Span can be found, the
-// RequestFunc is a noop.
-//
-// The logger is used to report errors and may be nil.
-func ToGRPCRequest(tracer opentracing.Tracer, logger log.Logger) func(ctx context.Context, md *metadata.MD) context.Context {
-	return func(ctx context.Context, md *metadata.MD) context.Context {
-		if span := opentracing.SpanFromContext(ctx); span != nil {
-			// There's nothing we can do with an error here.
-			err := tracer.Inject(span, opentracing.TextMap, metadataReaderWriter{md})
-			if err != nil && logger != nil {
-				logger.Log("msg", "Inject failed", "err", err)
-			}
-		}
-		return ctx
-	}
-}
-
-// FromGRPCRequest returns a grpc RequestFunc that tries to join with an
-// OpenTracing trace found in `req` and starts a new Span called
-// `operationName` accordingly. If no trace could be found in `req`, the Span
-// will be a trace root. The Span is incorporated in the returned Context and
-// can be retrieved with opentracing.SpanFromContext(ctx).
-//
-// The logger is used to report errors and may be nil.
-func FromGRPCRequest(tracer opentracing.Tracer, operationName string, logger log.Logger) func(ctx context.Context, md *metadata.MD) context.Context {
-	return func(ctx context.Context, md *metadata.MD) context.Context {
-		span, err := tracer.Join(operationName, opentracing.TextMap, metadataReaderWriter{md})
-		if err != nil && logger != nil {
-			logger.Log("msg", "Join failed", "err", err)
-		}
-		if span == nil {
-			span = tracer.StartSpan(operationName)
-		}
-		return opentracing.ContextWithSpan(ctx, span)
-	}
-}
-
-// A type that conforms to opentracing.TextMapReader and
-// opentracing.TextMapWriter.
-type metadataReaderWriter struct {
-	*metadata.MD
-}
-
-func (w metadataReaderWriter) Set(key, val string) {
-	(*w.MD)[key] = append((*w.MD)[key], val)
-}
-
-func (w metadataReaderWriter) ForeachKey(handler func(key, val string) error) error {
-	for k, vals := range *w.MD {
-		for _, v := range vals {
-			if err := handler(k, v); err != nil {
-				return err
-			}
-		}
-	}
-	return nil
-}
diff --git a/tracing/opentracing/grpc_test.go b/tracing/opentracing/grpc_test.go
deleted file mode 100644
index d9de49b..0000000
--- a/tracing/opentracing/grpc_test.go
+++ /dev/null
@@ -1,59 +0,0 @@
-package opentracing_test
-
-import (
-	"testing"
-
-	"github.com/opentracing/opentracing-go"
-	"github.com/opentracing/opentracing-go/mocktracer"
-	"golang.org/x/net/context"
-	"google.golang.org/grpc/metadata"
-
-	kitot "github.com/go-kit/kit/tracing/opentracing"
-	"github.com/go-kit/kit/transport/grpc"
-)
-
-func TestTraceGRPCRequestRoundtrip(t *testing.T) {
-	tracer := mocktracer.New()
-
-	// Initialize the ctx with a Span to inject.
-	beforeSpan := tracer.StartSpan("to_inject").(*mocktracer.MockSpan)
-	defer beforeSpan.Finish()
-	beforeSpan.SetBaggageItem("baggage", "check")
-	beforeCtx := opentracing.ContextWithSpan(context.Background(), beforeSpan)
-
-	var toGRPCFunc grpc.RequestFunc = kitot.ToGRPCRequest(tracer, nil)
-	md := metadata.Pairs()
-	// Call the RequestFunc.
-	afterCtx := toGRPCFunc(beforeCtx, &md)
-
-	// The Span should not have changed.
-	afterSpan := opentracing.SpanFromContext(afterCtx)
-	if beforeSpan != afterSpan {
-		t.Errorf("Should not swap in a new span")
-	}
-
-	// No spans should have finished yet.
-	if want, have := 0, len(tracer.FinishedSpans); want != have {
-		t.Errorf("Want %v span(s), found %v", want, have)
-	}
-
-	// Use FromGRPCRequest to verify that we can join with the trace given MD.
-	var fromGRPCFunc grpc.RequestFunc = kitot.FromGRPCRequest(tracer, "joined", nil)
-	joinCtx := fromGRPCFunc(afterCtx, &md)
-	joinedSpan := opentracing.SpanFromContext(joinCtx).(*mocktracer.MockSpan)
-
-	if joinedSpan.SpanID == beforeSpan.SpanID {
-		t.Error("SpanID should have changed", joinedSpan.SpanID, beforeSpan.SpanID)
-	}
-
-	// Check that the parent/child relationship is as expected for the joined span.
-	if want, have := beforeSpan.SpanID, joinedSpan.ParentID; want != have {
-		t.Errorf("Want ParentID %q, have %q", want, have)
-	}
-	if want, have := "joined", joinedSpan.OperationName; want != have {
-		t.Errorf("Want %q, have %q", want, have)
-	}
-	if want, have := "check", joinedSpan.BaggageItem("baggage"); want != have {
-		t.Errorf("Want %q, have %q", want, have)
-	}
-}
diff --git a/tracing/opentracing/http.go b/tracing/opentracing/http.go
deleted file mode 100644
index 606516d..0000000
--- a/tracing/opentracing/http.go
+++ /dev/null
@@ -1,75 +0,0 @@
-package opentracing
-
-import (
-	"net"
-	"net/http"
-	"strconv"
-
-	"github.com/opentracing/opentracing-go"
-	"github.com/opentracing/opentracing-go/ext"
-	"golang.org/x/net/context"
-
-	"github.com/go-kit/kit/log"
-	kithttp "github.com/go-kit/kit/transport/http"
-)
-
-// ToHTTPRequest returns an http RequestFunc that injects an OpenTracing Span
-// found in `ctx` into the http headers. If no such Span can be found, the
-// RequestFunc is a noop.
-//
-// The logger is used to report errors and may be nil.
-func ToHTTPRequest(tracer opentracing.Tracer, logger log.Logger) kithttp.RequestFunc {
-	return func(ctx context.Context, req *http.Request) context.Context {
-		// Try to find a Span in the Context.
-		if span := opentracing.SpanFromContext(ctx); span != nil {
-			// Add standard OpenTracing tags.
-			ext.HTTPMethod.Set(span, req.URL.RequestURI())
-			host, portString, err := net.SplitHostPort(req.URL.Host)
-			if err == nil {
-				ext.PeerHostname.Set(span, host)
-				if port, err := strconv.Atoi(portString); err != nil {
-					ext.PeerPort.Set(span, uint16(port))
-				}
-			} else {
-				ext.PeerHostname.Set(span, req.URL.Host)
-			}
-
-			// There's nothing we can do with any errors here.
-			err = tracer.Inject(
-				span,
-				opentracing.TextMap,
-				opentracing.HTTPHeaderTextMapCarrier(req.Header),
-			)
-			if err != nil && logger != nil {
-				logger.Log("msg", "Join failed", "err", err)
-			}
-		}
-		return ctx
-	}
-}
-
-// FromHTTPRequest returns an http RequestFunc that tries to join with an
-// OpenTracing trace found in `req` and starts a new Span called
-// `operationName` accordingly. If no trace could be found in `req`, the Span
-// will be a trace root. The Span is incorporated in the returned Context and
-// can be retrieved with opentracing.SpanFromContext(ctx).
-//
-// The logger is used to report errors and may be nil.
-func FromHTTPRequest(tracer opentracing.Tracer, operationName string, logger log.Logger) kithttp.RequestFunc {
-	return func(ctx context.Context, req *http.Request) context.Context {
-		// Try to join to a trace propagated in `req`. There's nothing we can
-		// do with any errors here, so we ignore them.
-		span, err := tracer.Join(
-			operationName,
-			opentracing.TextMap,
-			opentracing.HTTPHeaderTextMapCarrier(req.Header),
-		)
-		if err != nil && logger != nil {
-			logger.Log("msg", "Join failed", "err", err)
-		}
-		if span == nil {
-			span = opentracing.StartSpan(operationName)
-		}
-		return opentracing.ContextWithSpan(ctx, span)
-	}
-}
diff --git a/tracing/opentracing/http_test.go b/tracing/opentracing/http_test.go
deleted file mode 100644
index d49acbf..0000000
--- a/tracing/opentracing/http_test.go
+++ /dev/null
@@ -1,59 +0,0 @@
-package opentracing_test
-
-import (
-	"net/http"
-	"testing"
-
-	"github.com/opentracing/opentracing-go"
-	"github.com/opentracing/opentracing-go/mocktracer"
-	"golang.org/x/net/context"
-
-	kitot "github.com/go-kit/kit/tracing/opentracing"
-	kithttp "github.com/go-kit/kit/transport/http"
-)
-
-func TestTraceHTTPRequestRoundtrip(t *testing.T) {
-	tracer := mocktracer.New()
-
-	// Initialize the ctx with a Span to inject.
-	beforeSpan := tracer.StartSpan("to_inject").(*mocktracer.MockSpan)
-	defer beforeSpan.Finish()
-	beforeSpan.SetBaggageItem("baggage", "check")
-	beforeCtx := opentracing.ContextWithSpan(context.Background(), beforeSpan)
-
-	var toHTTPFunc kithttp.RequestFunc = kitot.ToHTTPRequest(tracer, nil)
-	req, _ := http.NewRequest("GET", "http://test.biz/url", nil)
-	// Call the RequestFunc.
-	afterCtx := toHTTPFunc(beforeCtx, req)
-
-	// The Span should not have changed.
-	afterSpan := opentracing.SpanFromContext(afterCtx)
-	if beforeSpan != afterSpan {
-		t.Errorf("Should not swap in a new span")
-	}
-
-	// No spans should have finished yet.
-	if want, have := 0, len(tracer.FinishedSpans); want != have {
-		t.Errorf("Want %v span(s), found %v", want, have)
-	}
-
-	// Use FromHTTPRequest to verify that we can join with the trace given a req.
-	var fromHTTPFunc kithttp.RequestFunc = kitot.FromHTTPRequest(tracer, "joined", nil)
-	joinCtx := fromHTTPFunc(afterCtx, req)
-	joinedSpan := opentracing.SpanFromContext(joinCtx).(*mocktracer.MockSpan)
-
-	if joinedSpan.SpanID == beforeSpan.SpanID {
-		t.Error("SpanID should have changed", joinedSpan.SpanID, beforeSpan.SpanID)
-	}
-
-	// Check that the parent/child relationship is as expected for the joined span.
-	if want, have := beforeSpan.SpanID, joinedSpan.ParentID; want != have {
-		t.Errorf("Want ParentID %q, have %q", want, have)
-	}
-	if want, have := "joined", joinedSpan.OperationName; want != have {
-		t.Errorf("Want %q, have %q", want, have)
-	}
-	if want, have := "check", joinedSpan.BaggageItem("baggage"); want != have {
-		t.Errorf("Want %q, have %q", want, have)
-	}
-}
