diff --git a/exp/README.md b/exp/README.md
deleted file mode 100644
index 7a509ad..0000000
--- a/exp/README.md
+++ /dev/null
@@ -1,62 +0,0 @@
-# client_golang experimental module
-
-Contains experimental utilities and APIs for Prometheus.
-The module may be contain breaking changes or be removed in the future.
-
-Packages within this module are listed below.
-
-## Remote
-
-Implements bindings from Prometheus remote APIs (remote write v1 and v2 for now).
-
-Contains flexible method for building API clients, that can send remote write protocol messages.
-
-```go
-    import (
-        "github.com/prometheus/client_golang/exp/api/remote"
-    )
-    ...
-
-	remoteAPI, err := remote.NewAPI(
-		"https://your-remote-endpoint",
-		remote.WithAPIHTTPClient(httpClient),
-		remote.WithAPILogger(logger.With("component", "remote_write_api")),
-	)
-    ...
-
-    stats, err := remoteAPI.Write(ctx, remote.WriteV2MessageType, protoWriteReq)
-```
-
-Also contains handler methods for applications that would like to handle and store remote write requests.
-
-```go
-    import (
-        "net/http"
-        "log"
-
-        "github.com/prometheus/client_golang/exp/api/remote"
-    )
-    ...
-    
-    type db {}
-
-    func NewStorage() *db {}
-
-    func (d *db) Store(ctx context.Context, msgType remote.WriteMessageType, req *http.Request) (*remote.WriteResponse, error) {}
-    ...
-
-	mux := http.NewServeMux()
-
-	remoteWriteHandler := remote.NewHandler(storage, remote.WithHandlerLogger(logger.With("component", "remote_write_handler")))
-	mux.Handle("/api/v1/write", remoteWriteHandler)
-
-	server := &http.Server{
-		Addr:    ":8080",
-		Handler: mux,
-	}
-	if err := server.ListenAndServe(); err != nil {
-		log.Fatal(err)
-	}
-```
-
-For more details, see [go doc](https://pkg.go.dev/github.com/prometheus/client_golang/exp/api/remote).
\ No newline at end of file
diff --git a/exp/api/remote/remote_api.go b/exp/api/remote/remote_api.go
index d64e5cb..0ac4f98 100644
--- a/exp/api/remote/remote_api.go
+++ b/exp/api/remote/remote_api.go
@@ -26,7 +26,6 @@ import (
 	"path"
 	"strconv"
 	"strings"
-	"sync"
 	"time"
 
 	"github.com/klauspost/compress/snappy"
@@ -40,9 +39,11 @@ import (
 // read protocols to be implemented if there will be a demand.
 type API struct {
 	baseURL *url.URL
+	client  *http.Client
 
-	opts    apiOpts
-	bufPool sync.Pool
+	opts apiOpts
+
+	reqBuf, comprBuf []byte
 }
 
 // APIOption represents a remote API option.
@@ -51,7 +52,6 @@ type APIOption func(o *apiOpts) error
 // TODO(bwplotka): Add "too old sample" handling one day.
 type apiOpts struct {
 	logger           *slog.Logger
-	client           *http.Client
 	backoff          backoff.Config
 	compression      Compression
 	path             string
@@ -64,7 +64,6 @@ var defaultAPIOpts = &apiOpts{
 		Max:        10 * time.Second,
 		MaxRetries: 10,
 	},
-	client: http.DefaultClient,
 	// Hardcoded for now.
 	retryOnRateLimit: true,
 	compression:      SnappyBlockCompression,
@@ -80,14 +79,6 @@ func WithAPILogger(logger *slog.Logger) APIOption {
 	}
 }
 
-// WithAPIHTTPClient returns APIOption that allows providing http client.
-func WithAPIHTTPClient(client *http.Client) APIOption {
-	return func(o *apiOpts) error {
-		o.client = client
-		return nil
-	}
-}
-
 // WithAPIPath returns APIOption that allows providing path to send remote write requests to.
 func WithAPIPath(path string) APIOption {
 	return func(o *apiOpts) error {
@@ -120,7 +111,10 @@ func (n nopSlogHandler) WithAttrs([]slog.Attr) slog.Handler        { return n }
 func (n nopSlogHandler) WithGroup(string) slog.Handler             { return n }
 
 // NewAPI returns a new API for the clients of Remote Write Protocol.
-func NewAPI(baseURL string, opts ...APIOption) (*API, error) {
+//
+// It is not safe to use the returned API from multiple goroutines, create a
+// separate *API for each goroutine.
+func NewAPI(client *http.Client, baseURL string, opts ...APIOption) (*API, error) {
 	parsedURL, err := url.Parse(baseURL)
 	if err != nil {
 		return nil, fmt.Errorf("invalid base URL: %w", err)
@@ -137,19 +131,17 @@ func NewAPI(baseURL string, opts ...APIOption) (*API, error) {
 		o.logger = slog.New(nopSlogHandler{})
 	}
 
+	if client == nil {
+		client = http.DefaultClient
+	}
+
 	parsedURL.Path = path.Join(parsedURL.Path, o.path)
 
-	api := &API{
+	return &API{
 		opts:    o,
+		client:  client,
 		baseURL: parsedURL,
-		bufPool: sync.Pool{
-			New: func() any {
-				b := make([]byte, 0, 1024*16) // Initial capacity of 16KB.
-				return &b
-			},
-		},
-	}
-	return api, nil
+	}, nil
 }
 
 type retryableError struct {
@@ -171,6 +163,13 @@ type gogoProtoEnabled interface {
 	MarshalToSizedBuffer(dAtA []byte) (n int, err error)
 }
 
+// Sort of a hack to identify v2 requests.
+// Under any marshaling scheme, v2 requests have a `Symbols` field of type []string.
+// So would always have a `GetSymbols()` method which doesn't rely on any other types.
+type v2Request interface {
+	GetSymbols() []string
+}
+
 // Write writes given, non-empty, protobuf message to a remote storage.
 //
 // Depending on serialization methods,
@@ -180,10 +179,17 @@ type gogoProtoEnabled interface {
 //     will be used
 //   - If neither is supported, it will marshaled using generic google.golang.org/protobuf methods and
 //     error out on unknown scheme.
-func (r *API) Write(ctx context.Context, msgType WriteMessageType, msg any) (_ WriteResponseStats, err error) {
-	buf := r.bufPool.Get().(*[]byte)
+func (r *API) Write(ctx context.Context, msg any) (_ WriteResponseStats, err error) {
+	// Reset the buffer.
+	r.reqBuf = r.reqBuf[:0]
+
+	// Detect content-type.
+	cType := WriteProtoFullNameV1
+	if _, ok := msg.(v2Request); ok {
+		cType = WriteProtoFullNameV2
+	}
 
-	if err := msgType.Validate(); err != nil {
+	if err := cType.Validate(); err != nil {
 		return WriteResponseStats{}, err
 	}
 
@@ -192,30 +198,24 @@ func (r *API) Write(ctx context.Context, msgType WriteMessageType, msg any) (_ W
 	case vtProtoEnabled:
 		// Use optimized vtprotobuf if supported.
 		size := m.SizeVT()
-		if cap(*buf) < size {
-			*buf = make([]byte, size)
-		} else {
-			*buf = (*buf)[:size]
+		if len(r.reqBuf) < size {
+			r.reqBuf = make([]byte, size)
 		}
-
-		if _, err := m.MarshalToSizedBufferVT(*buf); err != nil {
+		if _, err := m.MarshalToSizedBufferVT(r.reqBuf[:size]); err != nil {
 			return WriteResponseStats{}, fmt.Errorf("encoding request %w", err)
 		}
 	case gogoProtoEnabled:
 		// Gogo proto if supported.
 		size := m.Size()
-		if cap(*buf) < size {
-			*buf = make([]byte, size)
-		} else {
-			*buf = (*buf)[:size]
+		if len(r.reqBuf) < size {
+			r.reqBuf = make([]byte, size)
 		}
-
-		if _, err := m.MarshalToSizedBuffer(*buf); err != nil {
+		if _, err := m.MarshalToSizedBuffer(r.reqBuf[:size]); err != nil {
 			return WriteResponseStats{}, fmt.Errorf("encoding request %w", err)
 		}
 	case proto.Message:
 		// Generic proto.
-		*buf, err = (proto.MarshalOptions{}).MarshalAppend(*buf, m)
+		r.reqBuf, err = (proto.MarshalOptions{}).MarshalAppend(r.reqBuf, m)
 		if err != nil {
 			return WriteResponseStats{}, fmt.Errorf("encoding request %w", err)
 		}
@@ -223,13 +223,10 @@ func (r *API) Write(ctx context.Context, msgType WriteMessageType, msg any) (_ W
 		return WriteResponseStats{}, fmt.Errorf("unknown message type %T", m)
 	}
 
-	comprBuf := r.bufPool.Get().(*[]byte)
-	payload, err := compressPayload(comprBuf, r.opts.compression, *buf)
+	payload, err := compressPayload(&r.comprBuf, r.opts.compression, r.reqBuf)
 	if err != nil {
 		return WriteResponseStats{}, fmt.Errorf("compressing %w", err)
 	}
-	r.bufPool.Put(buf)
-	r.bufPool.Put(comprBuf)
 
 	// Since we retry writes we need to track the total amount of accepted data
 	// across the various attempts.
@@ -237,12 +234,12 @@ func (r *API) Write(ctx context.Context, msgType WriteMessageType, msg any) (_ W
 
 	b := backoff.New(ctx, r.opts.backoff)
 	for {
-		rs, err := r.attemptWrite(ctx, r.opts.compression, msgType, payload, b.NumRetries())
-		accumulatedStats.Add(rs)
+		rs, err := r.attemptWrite(ctx, r.opts.compression, cType, payload, b.NumRetries())
+		accumulatedStats = accumulatedStats.Add(rs)
 		if err == nil {
 			// Check the case mentioned in PRW 2.0.
 			// https://prometheus.io/docs/specs/remote_write_spec_2_0/#required-written-response-headers.
-			if msgType == WriteV2MessageType && !accumulatedStats.confirmed && accumulatedStats.NoDataWritten() {
+			if cType == WriteProtoFullNameV2 && !accumulatedStats.Confirmed && accumulatedStats.NoDataWritten() {
 				// TODO(bwplotka): Allow users to disable this check or provide their stats for us to know if it's empty.
 				return accumulatedStats, fmt.Errorf("sent v2 request; "+
 					"got 2xx, but PRW 2.0 response header statistics indicate %v samples, %v histograms "+
@@ -282,20 +279,18 @@ func (r *API) Write(ctx context.Context, msgType WriteMessageType, msg any) (_ W
 func compressPayload(tmpbuf *[]byte, enc Compression, inp []byte) (compressed []byte, _ error) {
 	switch enc {
 	case SnappyBlockCompression:
-		if cap(*tmpbuf) < snappy.MaxEncodedLen(len(inp)) {
-			*tmpbuf = make([]byte, snappy.MaxEncodedLen(len(inp)))
-		} else {
-			*tmpbuf = (*tmpbuf)[:snappy.MaxEncodedLen(len(inp))]
-		}
-
 		compressed = snappy.Encode(*tmpbuf, inp)
+		if n := snappy.MaxEncodedLen(len(inp)); n > len(*tmpbuf) {
+			// grow the buffer for the next time.
+			*tmpbuf = make([]byte, n)
+		}
 		return compressed, nil
 	default:
 		return compressed, fmt.Errorf("unknown compression scheme [%v]", enc)
 	}
 }
 
-func (r *API) attemptWrite(ctx context.Context, compr Compression, msgType WriteMessageType, payload []byte, attempt int) (WriteResponseStats, error) {
+func (r *API) attemptWrite(ctx context.Context, compr Compression, proto WriteProtoFullName, payload []byte, attempt int) (WriteResponseStats, error) {
 	req, err := http.NewRequest(http.MethodPost, r.baseURL.String(), bytes.NewReader(payload))
 	if err != nil {
 		// Errors from NewRequest are from unparsable URLs, so are not
@@ -304,8 +299,8 @@ func (r *API) attemptWrite(ctx context.Context, compr Compression, msgType Write
 	}
 
 	req.Header.Add("Content-Encoding", string(compr))
-	req.Header.Set("Content-Type", contentTypeHeader(msgType))
-	if msgType == WriteV1MessageType {
+	req.Header.Set("Content-Type", contentTypeHeader(proto))
+	if proto == WriteProtoFullNameV1 {
 		// Compatibility mode for 1.0.
 		req.Header.Set(versionHeader, version1HeaderValue)
 	} else {
@@ -316,7 +311,7 @@ func (r *API) attemptWrite(ctx context.Context, compr Compression, msgType Write
 		req.Header.Set("Retry-Attempt", strconv.Itoa(attempt))
 	}
 
-	resp, err := r.opts.client.Do(req.WithContext(ctx))
+	resp, err := r.client.Do(req.WithContext(ctx))
 	if err != nil {
 		// Errors from Client.Do are likely network errors, so recoverable.
 		return WriteResponseStats{}, retryableError{err, 0}
@@ -329,7 +324,7 @@ func (r *API) attemptWrite(ctx context.Context, compr Compression, msgType Write
 	}
 
 	rs := WriteResponseStats{}
-	if msgType == WriteV2MessageType {
+	if proto == WriteProtoFullNameV2 {
 		rs, err = parseWriteResponseStats(resp)
 		if err != nil {
 			r.opts.logger.Warn("parsing rw write statistics failed; partial or no stats", "err", err)
@@ -366,14 +361,7 @@ func retryAfterDuration(t string) time.Duration {
 // writeStorage represents the storage for RemoteWriteHandler.
 // This interface is intentionally private due its experimental state.
 type writeStorage interface {
-	// Store stores remote write metrics encoded in the given WriteContentType.
-	// Provided http.Request contains the encoded bytes in the req.Body with all the HTTP information,
-	// except "Content-Type" header which is provided in a separate, validated ctype.
-	//
-	// Other headers might be trimmed, depending on the configured middlewares
-	// e.g. a default SnappyMiddleware trims "Content-Encoding" and ensures that
-	// encoded body bytes are already decompressed.
-	Store(ctx context.Context, msgType WriteMessageType, req *http.Request) (_ *WriteResponse, _ error)
+	Store(ctx context.Context, proto WriteProtoFullName, serializedRequest []byte) (_ WriteResponseStats, code int, _ error)
 }
 
 type handler struct {
@@ -411,12 +399,6 @@ func WithHandlerMiddlewares(middlewares ...func(http.Handler) http.Handler) Hand
 // If the request body is not snappy-encoded, it returns an error.
 // Used by default in NewRemoteWriteHandler.
 func SnappyDecompressorMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
-	bufPool := sync.Pool{
-		New: func() any {
-			return bytes.NewBuffer(nil)
-		},
-	}
-
 	return func(next http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 			enc := r.Header.Get("Content-Encoding")
@@ -427,10 +409,8 @@ func SnappyDecompressorMiddleware(logger *slog.Logger) func(http.Handler) http.H
 				return
 			}
 
-			buf := bufPool.Get().(*bytes.Buffer)
-			defer bufPool.Put(buf)
-
-			bodyBytes, err := io.ReadAll(io.TeeReader(r.Body, buf))
+			// Read the request body.
+			bodyBytes, err := io.ReadAll(r.Body)
 			if err != nil {
 				logger.Error("Error reading request body", "err", err)
 				http.Error(w, err.Error(), http.StatusBadRequest)
@@ -445,17 +425,16 @@ func SnappyDecompressorMiddleware(logger *slog.Logger) func(http.Handler) http.H
 				return
 			}
 
-			// Replace the body with decompressed data and remove Content-Encoding header.
+			// Replace the body with decompressed data
 			r.Body = io.NopCloser(bytes.NewReader(decompressed))
-			r.Header.Del("Content-Encoding")
 			next.ServeHTTP(w, r)
 		})
 	}
 }
 
-// NewHandler returns HTTP handler that receives Remote Write 2.0
+// NewRemoteWriteHandler returns HTTP handler that receives Remote Write 2.0
 // protocol https://prometheus.io/docs/specs/remote_write_spec_2_0/.
-func NewHandler(store writeStorage, opts ...HandlerOption) http.Handler {
+func NewRemoteWriteHandler(store writeStorage, opts ...HandlerOption) http.Handler {
 	o := handlerOpts{
 		logger:      slog.New(nopSlogHandler{}),
 		middlewares: []func(http.Handler) http.Handler{SnappyDecompressorMiddleware(slog.New(nopSlogHandler{}))},
@@ -481,7 +460,7 @@ func NewHandler(store writeStorage, opts ...HandlerOption) http.Handler {
 //   - `application/x-protobuf` which will be treated as RW1.0 request.
 //
 // If the content-type is not of the above forms, it will return an error.
-func ParseProtoMsg(contentType string) (WriteMessageType, error) {
+func ParseProtoMsg(contentType string) (WriteProtoFullName, error) {
 	contentType = strings.TrimSpace(contentType)
 
 	parts := strings.Split(contentType, ";")
@@ -495,7 +474,7 @@ func ParseProtoMsg(contentType string) (WriteMessageType, error) {
 			return "", fmt.Errorf("as per https://www.rfc-editor.org/rfc/rfc9110#parameter expected parameters to be key-values, got %v in %v content-type", p, contentType)
 		}
 		if pair[0] == "proto" {
-			ret := WriteMessageType(pair[1])
+			ret := WriteProtoFullName(pair[1])
 			if err := ret.Validate(); err != nil {
 				return "", fmt.Errorf("got %v content type; %w", contentType, err)
 			}
@@ -503,7 +482,7 @@ func ParseProtoMsg(contentType string) (WriteMessageType, error) {
 		}
 	}
 	// No "proto=" parameter, assuming v1.
-	return WriteV1MessageType, nil
+	return WriteProtoFullNameV1, nil
 }
 
 func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
@@ -524,19 +503,27 @@ func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
-	writeResponse, storeErr := h.store.Store(r.Context(), msgType, r)
+	// Read the already decompressed body
+	body, err := io.ReadAll(r.Body)
+	if err != nil {
+		h.opts.logger.Error("Error reading request body", "err", err.Error())
+		http.Error(w, err.Error(), http.StatusBadRequest)
+		return
+	}
+
+	stats, code, storeErr := h.store.Store(r.Context(), msgType, body)
 
-	// Set required X-Prometheus-Remote-Write-Written-* response headers, in all cases, alongwith any user-defined headers.
-	writeResponse.SetHeaders(w)
+	// Set required X-Prometheus-Remote-Write-Written-* response headers, in all cases.
+	stats.SetHeaders(w)
 
 	if storeErr != nil {
-		if writeResponse.StatusCode() == 0 {
-			writeResponse.SetStatusCode(http.StatusInternalServerError)
+		if code == 0 {
+			code = http.StatusInternalServerError
 		}
-		if writeResponse.StatusCode()/100 == 5 { // 5xx
+		if code/100 == 5 { // 5xx
 			h.opts.logger.Error("Error while storing the remote write request", "err", storeErr.Error())
 		}
-		http.Error(w, storeErr.Error(), writeResponse.StatusCode())
+		http.Error(w, storeErr.Error(), code)
 		return
 	}
 	w.WriteHeader(http.StatusNoContent)
diff --git a/exp/api/remote/remote_api_test.go b/exp/api/remote/remote_api_test.go
index 1054f23..a7a3af8 100644
--- a/exp/api/remote/remote_api_test.go
+++ b/exp/api/remote/remote_api_test.go
@@ -16,7 +16,6 @@ package remote
 import (
 	"context"
 	"errors"
-	"io"
 	"log/slog"
 	"net/http"
 	"net/http/httptest"
@@ -25,7 +24,6 @@ import (
 	"time"
 
 	"github.com/google/go-cmp/cmp"
-	"github.com/google/go-cmp/cmp/cmpopts"
 	"github.com/prometheus/common/model"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/testing/protocmp"
@@ -65,42 +63,25 @@ func TestRetryAfterDuration(t *testing.T) {
 
 type mockStorage struct {
 	v2Reqs []*writev2.Request
-	protos []WriteMessageType
+	protos []WriteProtoFullName
 
 	mockCode *int
 	mockErr  error
 }
 
-func (m *mockStorage) Store(_ context.Context, msgType WriteMessageType, req *http.Request) (*WriteResponse, error) {
-	w := &WriteResponse{}
+func (m *mockStorage) Store(_ context.Context, msgFullName WriteProtoFullName, serializedRequest []byte) (w WriteResponseStats, code int, _ error) {
 	if m.mockErr != nil {
-		if m.mockCode != nil {
-			w.SetStatusCode(*m.mockCode)
-		}
-		return w, m.mockErr
-	}
-
-	// Read the request body
-	serializedRequest, err := io.ReadAll(req.Body)
-	if err != nil {
-		w.SetStatusCode(http.StatusBadRequest)
-		return w, err
+		return w, *m.mockCode, m.mockErr
 	}
 
-	// This test expects v2 only
+	// This test expects v2 only.
 	r := &writev2.Request{}
 	if err := proto.Unmarshal(serializedRequest, r); err != nil {
-		w.SetStatusCode(http.StatusInternalServerError)
-		return w, err
+		return WriteResponseStats{}, http.StatusInternalServerError, err
 	}
 	m.v2Reqs = append(m.v2Reqs, r)
-	m.protos = append(m.protos, msgType)
-
-	// Set stats in response headers
-	w.Add(stats(r))
-	w.SetStatusCode(http.StatusNoContent)
-
-	return w, nil
+	m.protos = append(m.protos, msgFullName)
+	return stats(r), http.StatusOK, nil
 }
 
 func testV2() *writev2.Request {
@@ -134,7 +115,7 @@ func testV2() *writev2.Request {
 }
 
 func stats(req *writev2.Request) (s WriteResponseStats) {
-	s.confirmed = true
+	s.Confirmed = true
 	for _, ts := range req.Timeseries {
 		s.Samples += len(ts.Samples)
 		s.Histograms += len(ts.Histograms)
@@ -147,24 +128,20 @@ func TestRemoteAPI_Write_WithHandler(t *testing.T) {
 	t.Run("success", func(t *testing.T) {
 		tLogger := slog.Default()
 		mStore := &mockStorage{}
-		srv := httptest.NewServer(NewHandler(mStore, WithHandlerLogger(tLogger)))
+		srv := httptest.NewServer(NewRemoteWriteHandler(mStore, WithHandlerLogger(tLogger)))
 		t.Cleanup(srv.Close)
 
-		client, err := NewAPI(srv.URL,
-			WithAPIHTTPClient(srv.Client()),
-			WithAPILogger(tLogger),
-			WithAPIPath("api/v1/write"),
-		)
+		client, err := NewAPI(srv.Client(), srv.URL, WithAPILogger(tLogger), WithAPIPath("api/v1/write"))
 		if err != nil {
 			t.Fatal(err)
 		}
 
 		req := testV2()
-		s, err := client.Write(context.Background(), WriteV2MessageType, req)
+		s, err := client.Write(context.Background(), req)
 		if err != nil {
 			t.Fatal(err)
 		}
-		if diff := cmp.Diff(stats(req), s, cmpopts.IgnoreUnexported(WriteResponseStats{})); diff != "" {
+		if diff := cmp.Diff(stats(req), s); diff != "" {
 			t.Fatal("unexpected stats", diff)
 		}
 		if len(mStore.v2Reqs) != 1 {
@@ -182,25 +159,20 @@ func TestRemoteAPI_Write_WithHandler(t *testing.T) {
 			mockErr:  errors.New("storage error"),
 			mockCode: &mockCode,
 		}
-		srv := httptest.NewServer(NewHandler(mStore, WithHandlerLogger(tLogger)))
+		srv := httptest.NewServer(NewRemoteWriteHandler(mStore, WithHandlerLogger(tLogger)))
 		t.Cleanup(srv.Close)
 
-		client, err := NewAPI(srv.URL,
-			WithAPIHTTPClient(srv.Client()),
-			WithAPILogger(tLogger),
-			WithAPIPath("api/v1/write"),
-			WithAPIBackoff(backoff.Config{
-				Min:        1 * time.Second,
-				Max:        1 * time.Second,
-				MaxRetries: 2,
-			}),
-		)
+		client, err := NewAPI(srv.Client(), srv.URL, WithAPILogger(tLogger), WithAPIPath("api/v1/write"), WithAPIBackoff(backoff.Config{
+			Min:        1 * time.Second,
+			Max:        1 * time.Second,
+			MaxRetries: 2,
+		}))
 		if err != nil {
 			t.Fatal(err)
 		}
 
 		req := testV2()
-		_, err = client.Write(context.Background(), WriteV2MessageType, req)
+		_, err = client.Write(context.Background(), req)
 		if err == nil {
 			t.Fatal("expected error, got nil")
 		}
diff --git a/exp/api/remote/remote_headers.go b/exp/api/remote/remote_headers.go
index df38920..d8b6de9 100644
--- a/exp/api/remote/remote_headers.go
+++ b/exp/api/remote/remote_headers.go
@@ -38,34 +38,34 @@ const (
 	SnappyBlockCompression Compression = "snappy"
 )
 
-// WriteMessageType represents the fully qualified name of the protobuf message
+// WriteProtoFullName represents the fully qualified name of the protobuf message
 // to use in Remote write 1.0 and 2.0 protocols.
 // See https://prometheus.io/docs/specs/remote_write_spec_2_0/#protocol.
-type WriteMessageType string
+type WriteProtoFullName string
 
 const (
-	// WriteV1MessageType represents the `prometheus.WriteRequest` protobuf
+	// WriteProtoFullNameV1 represents the `prometheus.WriteRequest` protobuf
 	// message introduced in the https://prometheus.io/docs/specs/remote_write_spec/.
-	// DEPRECATED: Use WriteV2MessageType instead.
-	WriteV1MessageType WriteMessageType = "prometheus.WriteRequest"
-	// WriteV2MessageType represents the `io.prometheus.write.v2.Request` protobuf
+	// DEPRECATED: Use WriteProtoFullNameV2 instead.
+	WriteProtoFullNameV1 WriteProtoFullName = "prometheus.WriteRequest"
+	// WriteProtoFullNameV2 represents the `io.prometheus.write.v2.Request` protobuf
 	// message introduced in https://prometheus.io/docs/specs/remote_write_spec_2_0/
-	WriteV2MessageType WriteMessageType = "io.prometheus.write.v2.Request"
+	WriteProtoFullNameV2 WriteProtoFullName = "io.prometheus.write.v2.Request"
 )
 
 // Validate returns error if the given reference for the protobuf message is not supported.
-func (n WriteMessageType) Validate() error {
+func (n WriteProtoFullName) Validate() error {
 	switch n {
-	case WriteV1MessageType, WriteV2MessageType:
+	case WriteProtoFullNameV1, WriteProtoFullNameV2:
 		return nil
 	default:
-		return fmt.Errorf("unknown type for remote write protobuf message %v, supported: %v", n, messageTypes{WriteV1MessageType, WriteV2MessageType}.String())
+		return fmt.Errorf("unknown remote write protobuf message %v, supported: %v", n, protoMsgs{WriteProtoFullNameV1, WriteProtoFullNameV2}.String())
 	}
 }
 
-type messageTypes []WriteMessageType
+type protoMsgs []WriteProtoFullName
 
-func (m messageTypes) Strings() []string {
+func (m protoMsgs) Strings() []string {
 	ret := make([]string, 0, len(m))
 	for _, typ := range m {
 		ret = append(ret, string(typ))
@@ -73,18 +73,18 @@ func (m messageTypes) Strings() []string {
 	return ret
 }
 
-func (m messageTypes) String() string {
+func (m protoMsgs) String() string {
 	return strings.Join(m.Strings(), ", ")
 }
 
-var contentTypeHeaders = map[WriteMessageType]string{
-	WriteV1MessageType: appProtoContentType, // Also application/x-protobuf;proto=prometheus.WriteRequest but simplified for compatibility with 1.x spec.
-	WriteV2MessageType: appProtoContentType + ";proto=io.prometheus.write.v2.Request",
+var contentTypeHeaders = map[WriteProtoFullName]string{
+	WriteProtoFullNameV1: appProtoContentType, // Also application/x-protobuf;proto=prometheus.WriteRequest but simplified for compatibility with 1.x spec.
+	WriteProtoFullNameV2: appProtoContentType + ";proto=io.prometheus.write.v2.Request",
 }
 
 // ContentTypeHeader returns content type header value for the given proto message
 // or empty string for unknown proto message.
-func contentTypeHeader(m WriteMessageType) string {
+func contentTypeHeader(m WriteProtoFullName) string {
 	return contentTypeHeaders[m]
 }
 
@@ -94,61 +94,6 @@ const (
 	writtenExemplarsHeader  = "X-Prometheus-Remote-Write-Exemplars-Written"
 )
 
-// WriteResponse represents the response from the remote storage upon receiving a remote write request.
-type WriteResponse struct {
-	WriteResponseStats
-	statusCode   int
-	extraHeaders http.Header
-}
-
-// NewWriteResponse creates a new WriteResponse with empty stats and status code http.StatusNoContent.
-func NewWriteResponse() *WriteResponse {
-	return &WriteResponse{
-		WriteResponseStats: WriteResponseStats{},
-		statusCode:         http.StatusNoContent,
-		extraHeaders:       make(http.Header),
-	}
-}
-
-// Stats returns the current statistics.
-func (w *WriteResponse) Stats() WriteResponseStats {
-	return w.WriteResponseStats
-}
-
-// SetStatusCode sets the HTTP status code for the response. http.StatusNoContent is the default unless 5xx is set.
-func (w *WriteResponse) SetStatusCode(code int) {
-	w.statusCode = code
-}
-
-// StatusCode returns the current HTTP status code.
-func (w *WriteResponse) StatusCode() int {
-	return w.statusCode
-}
-
-// SetExtraHeader adds additional headers to be set in the response (apart from stats headers)
-func (w *WriteResponse) SetExtraHeader(key, value string) {
-	w.extraHeaders.Set(key, value)
-}
-
-// ExtraHeaders returns all additional headers to be set in the response (apart from stats headers).
-func (w *WriteResponse) ExtraHeaders() http.Header {
-	return w.extraHeaders
-}
-
-// SetHeaders sets response headers in a given response writer.
-// Make sure to use it before http.ResponseWriter.WriteHeader and .Write.
-func (r *WriteResponse) SetHeaders(w http.ResponseWriter) {
-	h := w.Header()
-	h.Set(writtenSamplesHeader, strconv.Itoa(r.Samples))
-	h.Set(writtenHistogramsHeader, strconv.Itoa(r.Histograms))
-	h.Set(writtenExemplarsHeader, strconv.Itoa(r.Exemplars))
-	for k, v := range r.ExtraHeaders() {
-		for _, vv := range v {
-			h.Add(k, vv)
-		}
-	}
-}
-
 // WriteResponseStats represents the response, remote write statistics.
 type WriteResponseStats struct {
 	// Samples represents X-Prometheus-Remote-Write-Written-Samples
@@ -162,7 +107,7 @@ type WriteResponseStats struct {
 	// of the PRW 2.0 spec. When parsed from headers, it means we got at least one
 	// response header from the Receiver to confirm those numbers, meaning it must
 	// be at least 2.0 Receiver. See ParseWriteResponseStats for details.
-	confirmed bool
+	Confirmed bool
 }
 
 // NoDataWritten returns true if statistics indicate no data was written.
@@ -175,13 +120,22 @@ func (s WriteResponseStats) AllSamples() int {
 	return s.Samples + s.Histograms
 }
 
-// Add adds the given WriteResponseStats to this WriteResponseStats.
-// If this WriteResponseStats is empty, it will be replaced by the given WriteResponseStats.
-func (s *WriteResponseStats) Add(rs WriteResponseStats) {
-	s.confirmed = rs.confirmed
+// Add returns the sum of this WriteResponseStats plus the given WriteResponseStats.
+func (s WriteResponseStats) Add(rs WriteResponseStats) WriteResponseStats {
+	s.Confirmed = rs.Confirmed
 	s.Samples += rs.Samples
 	s.Histograms += rs.Histograms
 	s.Exemplars += rs.Exemplars
+	return s
+}
+
+// SetHeaders sets response headers in a given response writer.
+// Make sure to use it before http.ResponseWriter.WriteHeader and .Write.
+func (s WriteResponseStats) SetHeaders(w http.ResponseWriter) {
+	h := w.Header()
+	h.Set(writtenSamplesHeader, strconv.Itoa(s.Samples))
+	h.Set(writtenHistogramsHeader, strconv.Itoa(s.Histograms))
+	h.Set(writtenExemplarsHeader, strconv.Itoa(s.Exemplars))
 }
 
 // parseWriteResponseStats returns WriteResponseStats parsed from the response headers.
@@ -198,21 +152,21 @@ func parseWriteResponseStats(r *http.Response) (s WriteResponseStats, err error)
 		h    = r.Header
 	)
 	if v := h.Get(writtenSamplesHeader); v != "" { // Empty means zero.
-		s.confirmed = true
+		s.Confirmed = true
 		if s.Samples, err = strconv.Atoi(v); err != nil {
 			s.Samples = 0
 			errs = append(errs, err)
 		}
 	}
 	if v := h.Get(writtenHistogramsHeader); v != "" { // Empty means zero.
-		s.confirmed = true
+		s.Confirmed = true
 		if s.Histograms, err = strconv.Atoi(v); err != nil {
 			s.Histograms = 0
 			errs = append(errs, err)
 		}
 	}
 	if v := h.Get(writtenExemplarsHeader); v != "" { // Empty means zero.
-		s.confirmed = true
+		s.Confirmed = true
 		if s.Exemplars, err = strconv.Atoi(v); err != nil {
 			s.Exemplars = 0
 			errs = append(errs, err)
diff --git a/exp/api/remote/remote_headers_test.go b/exp/api/remote/remote_headers_test.go
deleted file mode 100644
index 7327490..0000000
--- a/exp/api/remote/remote_headers_test.go
+++ /dev/null
@@ -1,100 +0,0 @@
-// Copyright 2024 The Prometheus Authors
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package remote
-
-import (
-	"net/http"
-	"net/http/httptest"
-	"testing"
-
-	"github.com/google/go-cmp/cmp"
-	"github.com/google/go-cmp/cmp/cmpopts"
-)
-
-func TestWriteResponse(t *testing.T) {
-	t.Run("new response has empty headers", func(t *testing.T) {
-		resp := NewWriteResponse()
-		if len(resp.ExtraHeaders()) != 0 {
-			t.Errorf("expected empty headers, got %v", resp.ExtraHeaders())
-		}
-	})
-
-	t.Run("setters and getters", func(t *testing.T) {
-		resp := NewWriteResponse()
-
-		resp.SetStatusCode(http.StatusOK)
-		if got := resp.StatusCode(); got != http.StatusOK {
-			t.Errorf("expected status code %d, got %d", http.StatusOK, got)
-		}
-
-		stats := WriteResponseStats{
-			Samples:    10,
-			Histograms: 5,
-			Exemplars:  2,
-			confirmed:  true,
-		}
-		resp.Add(stats)
-		if diff := cmp.Diff(stats, resp.Stats(), cmpopts.IgnoreUnexported(WriteResponseStats{})); diff != "" {
-			t.Errorf("stats mismatch (-want +got):\n%s", diff)
-		}
-
-		toAdd := WriteResponseStats{
-			Samples:    10,
-			Histograms: 5,
-			Exemplars:  2,
-			confirmed:  true,
-		}
-		resp.Add(toAdd)
-		if diff := cmp.Diff(WriteResponseStats{
-			Samples:    20,
-			Histograms: 10,
-			Exemplars:  4,
-			confirmed:  true,
-		}, resp.Stats(), cmpopts.IgnoreUnexported(WriteResponseStats{})); diff != "" {
-			t.Errorf("stats mismatch (-want +got):\n%s", diff)
-		}
-
-		resp.SetExtraHeader("Test-Header", "test-value")
-		if got := resp.ExtraHeaders().Get("Test-Header"); got != "test-value" {
-			t.Errorf("expected header value %q, got %q", "test-value", got)
-		}
-	})
-
-	t.Run("set headers on response writer", func(t *testing.T) {
-		resp := NewWriteResponse()
-		resp.Add(WriteResponseStats{
-			Samples:    10,
-			Histograms: 5,
-			Exemplars:  2,
-			confirmed:  true,
-		})
-		resp.SetExtraHeader("Custom-Header", "custom-value")
-
-		w := httptest.NewRecorder()
-		resp.SetHeaders(w)
-
-		expectedHeaders := map[string]string{
-			"Custom-Header": "custom-value",
-			"X-Prometheus-Remote-Write-Samples-Written":    "10",
-			"X-Prometheus-Remote-Write-Histograms-Written": "5",
-			"X-Prometheus-Remote-Write-Exemplars-Written":  "2",
-		}
-
-		for k, want := range expectedHeaders {
-			if got := w.Header().Get(k); got != want {
-				t.Errorf("header %q: want %q, got %q", k, want, got)
-			}
-		}
-	})
-}
diff --git a/exp/go.mod b/exp/go.mod
index 0c341cc..35449e9 100644
--- a/exp/go.mod
+++ b/exp/go.mod
@@ -4,9 +4,9 @@ go 1.21
 
 require (
 	github.com/google/go-cmp v0.6.0
-	github.com/klauspost/compress v1.17.11
-	github.com/prometheus/common v0.62.0
-	google.golang.org/protobuf v1.36.4
+	github.com/klauspost/compress v1.17.10
+	github.com/prometheus/common v0.59.1
+	google.golang.org/protobuf v1.34.2
 )
 
 require github.com/prometheus/client_model v0.6.1 // indirect
diff --git a/exp/go.sum b/exp/go.sum
index 263ed1d..0acdfd8 100644
--- a/exp/go.sum
+++ b/exp/go.sum
@@ -1,10 +1,6 @@
-github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
 github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
-github.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=
-github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
+github.com/klauspost/compress v1.17.10 h1:oXAz+Vh0PMUvJczoi+flxpnBEPxoER1IaAnU/NMPtT0=
 github.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=
-github.com/prometheus/common v0.62.0 h1:xasJaQlnWAeyHdUBeGjXmutelfJHWMRr+Fg4QszZ2Io=
-github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
-google.golang.org/protobuf v1.36.4 h1:6A3ZDJHn/eNqc1i+IdefRzy/9PokBTPvcqMySR7NNIM=
-gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
+github.com/prometheus/common v0.59.1 h1:LXb1quJHWm1P6wq/U824uxYi4Sg0oGvNeUm1z5dJoX0=
+google.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=
diff --git a/go.work.sum b/go.work.sum
index 6210b5d..9cb5d3f 100644
--- a/go.work.sum
+++ b/go.work.sum
@@ -17,15 +17,12 @@ github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/
 github.com/google/gofuzz v1.0.0 h1:A8PeW59pxE9IoFRqBp37U+mSNaQoZ46F1f0f863XSXw=
 github.com/julienschmidt/httprouter v1.3.0 h1:U0609e9tgbseu3rBINet9P48AI/D3oJs4dN7jwJOQ1U=
 github.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=
-github.com/klauspost/compress v1.17.10/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=
 github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
 github.com/kr/pty v1.1.1 h1:VkoXIwSboBpnk99O/KFauAEILuNHv5DVFKZMBN/gUgw=
 github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
 github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
 github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e h1:aoZm08cpOy4WuID//EZDgcC4zIxODThtZNPirFr42+A=
 github.com/prometheus/client_golang v1.20.0/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=
-github.com/prometheus/client_golang v1.20.4/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=
-github.com/prometheus/common v0.59.1/go.mod h1:GpWM7dewqmVYcd7SmRaiWVe9SSqjf0UrwnYnpEZNuT0=
 github.com/stretchr/objx v0.1.0 h1:4G4v2dO3VZwixGIRoQ5Lfboy6nUhCyYzaqnIAPPhYs4=
 github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
 github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
@@ -34,20 +31,13 @@ github.com/xhit/go-str2duration/v2 v2.1.0 h1:lxklc02Drh6ynqX+DdPyp5pCKLUQpRT8bp8
 github.com/xhit/go-str2duration/v2 v2.1.0/go.mod h1:ohY8p+0f07DiV6Em5LKB0s2YpLtXVyJfNt1+BlmyAsU=
 golang.org/x/crypto v0.26.0 h1:RrRspgV4mU+YwB4FYnuBoKsUapNIL5cohGAmSH3azsw=
 golang.org/x/crypto v0.26.0/go.mod h1:GY7jblb9wI+FOo5y8/S2oY4zWP07AkOJ4+jxCqdqn54=
-golang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=
-golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
 golang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=
 golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
 golang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=
 golang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
-golang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=
-golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
 golang.org/x/sys v0.23.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
-golang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
 golang.org/x/term v0.23.0 h1:F6D4vR+EHoL9/sWAWgAR1H2DcHr4PareCbAaCo1RpuU=
 golang.org/x/term v0.23.0/go.mod h1:DgV24QBUrK6jhZXl+20l6UWznPlwAHm1Q1mGHtydmSk=
-golang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=
-golang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=
 golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=
 golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
@@ -56,6 +46,4 @@ google.golang.org/appengine v1.6.7 h1:FZR1q0exgwxzPzp/aF+VccGrSfxfPpkBqjIIEq3ru6
 google.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
 google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
 google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
-google.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=
-google.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=
 gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
