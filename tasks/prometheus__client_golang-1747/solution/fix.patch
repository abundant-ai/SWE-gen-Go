diff --git a/exp/README.md b/exp/README.md
new file mode 100644
index 0000000..7a509ad
--- /dev/null
+++ b/exp/README.md
@@ -0,0 +1,62 @@
+# client_golang experimental module
+
+Contains experimental utilities and APIs for Prometheus.
+The module may be contain breaking changes or be removed in the future.
+
+Packages within this module are listed below.
+
+## Remote
+
+Implements bindings from Prometheus remote APIs (remote write v1 and v2 for now).
+
+Contains flexible method for building API clients, that can send remote write protocol messages.
+
+```go
+    import (
+        "github.com/prometheus/client_golang/exp/api/remote"
+    )
+    ...
+
+	remoteAPI, err := remote.NewAPI(
+		"https://your-remote-endpoint",
+		remote.WithAPIHTTPClient(httpClient),
+		remote.WithAPILogger(logger.With("component", "remote_write_api")),
+	)
+    ...
+
+    stats, err := remoteAPI.Write(ctx, remote.WriteV2MessageType, protoWriteReq)
+```
+
+Also contains handler methods for applications that would like to handle and store remote write requests.
+
+```go
+    import (
+        "net/http"
+        "log"
+
+        "github.com/prometheus/client_golang/exp/api/remote"
+    )
+    ...
+    
+    type db {}
+
+    func NewStorage() *db {}
+
+    func (d *db) Store(ctx context.Context, msgType remote.WriteMessageType, req *http.Request) (*remote.WriteResponse, error) {}
+    ...
+
+	mux := http.NewServeMux()
+
+	remoteWriteHandler := remote.NewHandler(storage, remote.WithHandlerLogger(logger.With("component", "remote_write_handler")))
+	mux.Handle("/api/v1/write", remoteWriteHandler)
+
+	server := &http.Server{
+		Addr:    ":8080",
+		Handler: mux,
+	}
+	if err := server.ListenAndServe(); err != nil {
+		log.Fatal(err)
+	}
+```
+
+For more details, see [go doc](https://pkg.go.dev/github.com/prometheus/client_golang/exp/api/remote).
\ No newline at end of file
diff --git a/exp/api/remote/remote_api.go b/exp/api/remote/remote_api.go
index 0ac4f98..d64e5cb 100644
--- a/exp/api/remote/remote_api.go
+++ b/exp/api/remote/remote_api.go
@@ -26,6 +26,7 @@ import (
 	"path"
 	"strconv"
 	"strings"
+	"sync"
 	"time"
 
 	"github.com/klauspost/compress/snappy"
@@ -39,11 +40,9 @@ import (
 // read protocols to be implemented if there will be a demand.
 type API struct {
 	baseURL *url.URL
-	client  *http.Client
 
-	opts apiOpts
-
-	reqBuf, comprBuf []byte
+	opts    apiOpts
+	bufPool sync.Pool
 }
 
 // APIOption represents a remote API option.
@@ -52,6 +51,7 @@ type APIOption func(o *apiOpts) error
 // TODO(bwplotka): Add "too old sample" handling one day.
 type apiOpts struct {
 	logger           *slog.Logger
+	client           *http.Client
 	backoff          backoff.Config
 	compression      Compression
 	path             string
@@ -64,6 +64,7 @@ var defaultAPIOpts = &apiOpts{
 		Max:        10 * time.Second,
 		MaxRetries: 10,
 	},
+	client: http.DefaultClient,
 	// Hardcoded for now.
 	retryOnRateLimit: true,
 	compression:      SnappyBlockCompression,
@@ -79,6 +80,14 @@ func WithAPILogger(logger *slog.Logger) APIOption {
 	}
 }
 
+// WithAPIHTTPClient returns APIOption that allows providing http client.
+func WithAPIHTTPClient(client *http.Client) APIOption {
+	return func(o *apiOpts) error {
+		o.client = client
+		return nil
+	}
+}
+
 // WithAPIPath returns APIOption that allows providing path to send remote write requests to.
 func WithAPIPath(path string) APIOption {
 	return func(o *apiOpts) error {
@@ -111,10 +120,7 @@ func (n nopSlogHandler) WithAttrs([]slog.Attr) slog.Handler        { return n }
 func (n nopSlogHandler) WithGroup(string) slog.Handler             { return n }
 
 // NewAPI returns a new API for the clients of Remote Write Protocol.
-//
-// It is not safe to use the returned API from multiple goroutines, create a
-// separate *API for each goroutine.
-func NewAPI(client *http.Client, baseURL string, opts ...APIOption) (*API, error) {
+func NewAPI(baseURL string, opts ...APIOption) (*API, error) {
 	parsedURL, err := url.Parse(baseURL)
 	if err != nil {
 		return nil, fmt.Errorf("invalid base URL: %w", err)
@@ -131,17 +137,19 @@ func NewAPI(client *http.Client, baseURL string, opts ...APIOption) (*API, error
 		o.logger = slog.New(nopSlogHandler{})
 	}
 
-	if client == nil {
-		client = http.DefaultClient
-	}
-
 	parsedURL.Path = path.Join(parsedURL.Path, o.path)
 
-	return &API{
+	api := &API{
 		opts:    o,
-		client:  client,
 		baseURL: parsedURL,
-	}, nil
+		bufPool: sync.Pool{
+			New: func() any {
+				b := make([]byte, 0, 1024*16) // Initial capacity of 16KB.
+				return &b
+			},
+		},
+	}
+	return api, nil
 }
 
 type retryableError struct {
@@ -163,13 +171,6 @@ type gogoProtoEnabled interface {
 	MarshalToSizedBuffer(dAtA []byte) (n int, err error)
 }
 
-// Sort of a hack to identify v2 requests.
-// Under any marshaling scheme, v2 requests have a `Symbols` field of type []string.
-// So would always have a `GetSymbols()` method which doesn't rely on any other types.
-type v2Request interface {
-	GetSymbols() []string
-}
-
 // Write writes given, non-empty, protobuf message to a remote storage.
 //
 // Depending on serialization methods,
@@ -179,17 +180,10 @@ type v2Request interface {
 //     will be used
 //   - If neither is supported, it will marshaled using generic google.golang.org/protobuf methods and
 //     error out on unknown scheme.
-func (r *API) Write(ctx context.Context, msg any) (_ WriteResponseStats, err error) {
-	// Reset the buffer.
-	r.reqBuf = r.reqBuf[:0]
-
-	// Detect content-type.
-	cType := WriteProtoFullNameV1
-	if _, ok := msg.(v2Request); ok {
-		cType = WriteProtoFullNameV2
-	}
+func (r *API) Write(ctx context.Context, msgType WriteMessageType, msg any) (_ WriteResponseStats, err error) {
+	buf := r.bufPool.Get().(*[]byte)
 
-	if err := cType.Validate(); err != nil {
+	if err := msgType.Validate(); err != nil {
 		return WriteResponseStats{}, err
 	}
 
@@ -198,24 +192,30 @@ func (r *API) Write(ctx context.Context, msg any) (_ WriteResponseStats, err err
 	case vtProtoEnabled:
 		// Use optimized vtprotobuf if supported.
 		size := m.SizeVT()
-		if len(r.reqBuf) < size {
-			r.reqBuf = make([]byte, size)
+		if cap(*buf) < size {
+			*buf = make([]byte, size)
+		} else {
+			*buf = (*buf)[:size]
 		}
-		if _, err := m.MarshalToSizedBufferVT(r.reqBuf[:size]); err != nil {
+
+		if _, err := m.MarshalToSizedBufferVT(*buf); err != nil {
 			return WriteResponseStats{}, fmt.Errorf("encoding request %w", err)
 		}
 	case gogoProtoEnabled:
 		// Gogo proto if supported.
 		size := m.Size()
-		if len(r.reqBuf) < size {
-			r.reqBuf = make([]byte, size)
+		if cap(*buf) < size {
+			*buf = make([]byte, size)
+		} else {
+			*buf = (*buf)[:size]
 		}
-		if _, err := m.MarshalToSizedBuffer(r.reqBuf[:size]); err != nil {
+
+		if _, err := m.MarshalToSizedBuffer(*buf); err != nil {
 			return WriteResponseStats{}, fmt.Errorf("encoding request %w", err)
 		}
 	case proto.Message:
 		// Generic proto.
-		r.reqBuf, err = (proto.MarshalOptions{}).MarshalAppend(r.reqBuf, m)
+		*buf, err = (proto.MarshalOptions{}).MarshalAppend(*buf, m)
 		if err != nil {
 			return WriteResponseStats{}, fmt.Errorf("encoding request %w", err)
 		}
@@ -223,10 +223,13 @@ func (r *API) Write(ctx context.Context, msg any) (_ WriteResponseStats, err err
 		return WriteResponseStats{}, fmt.Errorf("unknown message type %T", m)
 	}
 
-	payload, err := compressPayload(&r.comprBuf, r.opts.compression, r.reqBuf)
+	comprBuf := r.bufPool.Get().(*[]byte)
+	payload, err := compressPayload(comprBuf, r.opts.compression, *buf)
 	if err != nil {
 		return WriteResponseStats{}, fmt.Errorf("compressing %w", err)
 	}
+	r.bufPool.Put(buf)
+	r.bufPool.Put(comprBuf)
 
 	// Since we retry writes we need to track the total amount of accepted data
 	// across the various attempts.
@@ -234,12 +237,12 @@ func (r *API) Write(ctx context.Context, msg any) (_ WriteResponseStats, err err
 
 	b := backoff.New(ctx, r.opts.backoff)
 	for {
-		rs, err := r.attemptWrite(ctx, r.opts.compression, cType, payload, b.NumRetries())
-		accumulatedStats = accumulatedStats.Add(rs)
+		rs, err := r.attemptWrite(ctx, r.opts.compression, msgType, payload, b.NumRetries())
+		accumulatedStats.Add(rs)
 		if err == nil {
 			// Check the case mentioned in PRW 2.0.
 			// https://prometheus.io/docs/specs/remote_write_spec_2_0/#required-written-response-headers.
-			if cType == WriteProtoFullNameV2 && !accumulatedStats.Confirmed && accumulatedStats.NoDataWritten() {
+			if msgType == WriteV2MessageType && !accumulatedStats.confirmed && accumulatedStats.NoDataWritten() {
 				// TODO(bwplotka): Allow users to disable this check or provide their stats for us to know if it's empty.
 				return accumulatedStats, fmt.Errorf("sent v2 request; "+
 					"got 2xx, but PRW 2.0 response header statistics indicate %v samples, %v histograms "+
@@ -279,18 +282,20 @@ func (r *API) Write(ctx context.Context, msg any) (_ WriteResponseStats, err err
 func compressPayload(tmpbuf *[]byte, enc Compression, inp []byte) (compressed []byte, _ error) {
 	switch enc {
 	case SnappyBlockCompression:
-		compressed = snappy.Encode(*tmpbuf, inp)
-		if n := snappy.MaxEncodedLen(len(inp)); n > len(*tmpbuf) {
-			// grow the buffer for the next time.
-			*tmpbuf = make([]byte, n)
+		if cap(*tmpbuf) < snappy.MaxEncodedLen(len(inp)) {
+			*tmpbuf = make([]byte, snappy.MaxEncodedLen(len(inp)))
+		} else {
+			*tmpbuf = (*tmpbuf)[:snappy.MaxEncodedLen(len(inp))]
 		}
+
+		compressed = snappy.Encode(*tmpbuf, inp)
 		return compressed, nil
 	default:
 		return compressed, fmt.Errorf("unknown compression scheme [%v]", enc)
 	}
 }
 
-func (r *API) attemptWrite(ctx context.Context, compr Compression, proto WriteProtoFullName, payload []byte, attempt int) (WriteResponseStats, error) {
+func (r *API) attemptWrite(ctx context.Context, compr Compression, msgType WriteMessageType, payload []byte, attempt int) (WriteResponseStats, error) {
 	req, err := http.NewRequest(http.MethodPost, r.baseURL.String(), bytes.NewReader(payload))
 	if err != nil {
 		// Errors from NewRequest are from unparsable URLs, so are not
@@ -299,8 +304,8 @@ func (r *API) attemptWrite(ctx context.Context, compr Compression, proto WritePr
 	}
 
 	req.Header.Add("Content-Encoding", string(compr))
-	req.Header.Set("Content-Type", contentTypeHeader(proto))
-	if proto == WriteProtoFullNameV1 {
+	req.Header.Set("Content-Type", contentTypeHeader(msgType))
+	if msgType == WriteV1MessageType {
 		// Compatibility mode for 1.0.
 		req.Header.Set(versionHeader, version1HeaderValue)
 	} else {
@@ -311,7 +316,7 @@ func (r *API) attemptWrite(ctx context.Context, compr Compression, proto WritePr
 		req.Header.Set("Retry-Attempt", strconv.Itoa(attempt))
 	}
 
-	resp, err := r.client.Do(req.WithContext(ctx))
+	resp, err := r.opts.client.Do(req.WithContext(ctx))
 	if err != nil {
 		// Errors from Client.Do are likely network errors, so recoverable.
 		return WriteResponseStats{}, retryableError{err, 0}
@@ -324,7 +329,7 @@ func (r *API) attemptWrite(ctx context.Context, compr Compression, proto WritePr
 	}
 
 	rs := WriteResponseStats{}
-	if proto == WriteProtoFullNameV2 {
+	if msgType == WriteV2MessageType {
 		rs, err = parseWriteResponseStats(resp)
 		if err != nil {
 			r.opts.logger.Warn("parsing rw write statistics failed; partial or no stats", "err", err)
@@ -361,7 +366,14 @@ func retryAfterDuration(t string) time.Duration {
 // writeStorage represents the storage for RemoteWriteHandler.
 // This interface is intentionally private due its experimental state.
 type writeStorage interface {
-	Store(ctx context.Context, proto WriteProtoFullName, serializedRequest []byte) (_ WriteResponseStats, code int, _ error)
+	// Store stores remote write metrics encoded in the given WriteContentType.
+	// Provided http.Request contains the encoded bytes in the req.Body with all the HTTP information,
+	// except "Content-Type" header which is provided in a separate, validated ctype.
+	//
+	// Other headers might be trimmed, depending on the configured middlewares
+	// e.g. a default SnappyMiddleware trims "Content-Encoding" and ensures that
+	// encoded body bytes are already decompressed.
+	Store(ctx context.Context, msgType WriteMessageType, req *http.Request) (_ *WriteResponse, _ error)
 }
 
 type handler struct {
@@ -399,6 +411,12 @@ func WithHandlerMiddlewares(middlewares ...func(http.Handler) http.Handler) Hand
 // If the request body is not snappy-encoded, it returns an error.
 // Used by default in NewRemoteWriteHandler.
 func SnappyDecompressorMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
+	bufPool := sync.Pool{
+		New: func() any {
+			return bytes.NewBuffer(nil)
+		},
+	}
+
 	return func(next http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 			enc := r.Header.Get("Content-Encoding")
@@ -409,8 +427,10 @@ func SnappyDecompressorMiddleware(logger *slog.Logger) func(http.Handler) http.H
 				return
 			}
 
-			// Read the request body.
-			bodyBytes, err := io.ReadAll(r.Body)
+			buf := bufPool.Get().(*bytes.Buffer)
+			defer bufPool.Put(buf)
+
+			bodyBytes, err := io.ReadAll(io.TeeReader(r.Body, buf))
 			if err != nil {
 				logger.Error("Error reading request body", "err", err)
 				http.Error(w, err.Error(), http.StatusBadRequest)
@@ -425,16 +445,17 @@ func SnappyDecompressorMiddleware(logger *slog.Logger) func(http.Handler) http.H
 				return
 			}
 
-			// Replace the body with decompressed data
+			// Replace the body with decompressed data and remove Content-Encoding header.
 			r.Body = io.NopCloser(bytes.NewReader(decompressed))
+			r.Header.Del("Content-Encoding")
 			next.ServeHTTP(w, r)
 		})
 	}
 }
 
-// NewRemoteWriteHandler returns HTTP handler that receives Remote Write 2.0
+// NewHandler returns HTTP handler that receives Remote Write 2.0
 // protocol https://prometheus.io/docs/specs/remote_write_spec_2_0/.
-func NewRemoteWriteHandler(store writeStorage, opts ...HandlerOption) http.Handler {
+func NewHandler(store writeStorage, opts ...HandlerOption) http.Handler {
 	o := handlerOpts{
 		logger:      slog.New(nopSlogHandler{}),
 		middlewares: []func(http.Handler) http.Handler{SnappyDecompressorMiddleware(slog.New(nopSlogHandler{}))},
@@ -460,7 +481,7 @@ func NewRemoteWriteHandler(store writeStorage, opts ...HandlerOption) http.Handl
 //   - `application/x-protobuf` which will be treated as RW1.0 request.
 //
 // If the content-type is not of the above forms, it will return an error.
-func ParseProtoMsg(contentType string) (WriteProtoFullName, error) {
+func ParseProtoMsg(contentType string) (WriteMessageType, error) {
 	contentType = strings.TrimSpace(contentType)
 
 	parts := strings.Split(contentType, ";")
@@ -474,7 +495,7 @@ func ParseProtoMsg(contentType string) (WriteProtoFullName, error) {
 			return "", fmt.Errorf("as per https://www.rfc-editor.org/rfc/rfc9110#parameter expected parameters to be key-values, got %v in %v content-type", p, contentType)
 		}
 		if pair[0] == "proto" {
-			ret := WriteProtoFullName(pair[1])
+			ret := WriteMessageType(pair[1])
 			if err := ret.Validate(); err != nil {
 				return "", fmt.Errorf("got %v content type; %w", contentType, err)
 			}
@@ -482,7 +503,7 @@ func ParseProtoMsg(contentType string) (WriteProtoFullName, error) {
 		}
 	}
 	// No "proto=" parameter, assuming v1.
-	return WriteProtoFullNameV1, nil
+	return WriteV1MessageType, nil
 }
 
 func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
@@ -503,27 +524,19 @@ func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
-	// Read the already decompressed body
-	body, err := io.ReadAll(r.Body)
-	if err != nil {
-		h.opts.logger.Error("Error reading request body", "err", err.Error())
-		http.Error(w, err.Error(), http.StatusBadRequest)
-		return
-	}
-
-	stats, code, storeErr := h.store.Store(r.Context(), msgType, body)
+	writeResponse, storeErr := h.store.Store(r.Context(), msgType, r)
 
-	// Set required X-Prometheus-Remote-Write-Written-* response headers, in all cases.
-	stats.SetHeaders(w)
+	// Set required X-Prometheus-Remote-Write-Written-* response headers, in all cases, alongwith any user-defined headers.
+	writeResponse.SetHeaders(w)
 
 	if storeErr != nil {
-		if code == 0 {
-			code = http.StatusInternalServerError
+		if writeResponse.StatusCode() == 0 {
+			writeResponse.SetStatusCode(http.StatusInternalServerError)
 		}
-		if code/100 == 5 { // 5xx
+		if writeResponse.StatusCode()/100 == 5 { // 5xx
 			h.opts.logger.Error("Error while storing the remote write request", "err", storeErr.Error())
 		}
-		http.Error(w, storeErr.Error(), code)
+		http.Error(w, storeErr.Error(), writeResponse.StatusCode())
 		return
 	}
 	w.WriteHeader(http.StatusNoContent)
diff --git a/exp/api/remote/remote_headers.go b/exp/api/remote/remote_headers.go
index d8b6de9..df38920 100644
--- a/exp/api/remote/remote_headers.go
+++ b/exp/api/remote/remote_headers.go
@@ -38,34 +38,34 @@ const (
 	SnappyBlockCompression Compression = "snappy"
 )
 
-// WriteProtoFullName represents the fully qualified name of the protobuf message
+// WriteMessageType represents the fully qualified name of the protobuf message
 // to use in Remote write 1.0 and 2.0 protocols.
 // See https://prometheus.io/docs/specs/remote_write_spec_2_0/#protocol.
-type WriteProtoFullName string
+type WriteMessageType string
 
 const (
-	// WriteProtoFullNameV1 represents the `prometheus.WriteRequest` protobuf
+	// WriteV1MessageType represents the `prometheus.WriteRequest` protobuf
 	// message introduced in the https://prometheus.io/docs/specs/remote_write_spec/.
-	// DEPRECATED: Use WriteProtoFullNameV2 instead.
-	WriteProtoFullNameV1 WriteProtoFullName = "prometheus.WriteRequest"
-	// WriteProtoFullNameV2 represents the `io.prometheus.write.v2.Request` protobuf
+	// DEPRECATED: Use WriteV2MessageType instead.
+	WriteV1MessageType WriteMessageType = "prometheus.WriteRequest"
+	// WriteV2MessageType represents the `io.prometheus.write.v2.Request` protobuf
 	// message introduced in https://prometheus.io/docs/specs/remote_write_spec_2_0/
-	WriteProtoFullNameV2 WriteProtoFullName = "io.prometheus.write.v2.Request"
+	WriteV2MessageType WriteMessageType = "io.prometheus.write.v2.Request"
 )
 
 // Validate returns error if the given reference for the protobuf message is not supported.
-func (n WriteProtoFullName) Validate() error {
+func (n WriteMessageType) Validate() error {
 	switch n {
-	case WriteProtoFullNameV1, WriteProtoFullNameV2:
+	case WriteV1MessageType, WriteV2MessageType:
 		return nil
 	default:
-		return fmt.Errorf("unknown remote write protobuf message %v, supported: %v", n, protoMsgs{WriteProtoFullNameV1, WriteProtoFullNameV2}.String())
+		return fmt.Errorf("unknown type for remote write protobuf message %v, supported: %v", n, messageTypes{WriteV1MessageType, WriteV2MessageType}.String())
 	}
 }
 
-type protoMsgs []WriteProtoFullName
+type messageTypes []WriteMessageType
 
-func (m protoMsgs) Strings() []string {
+func (m messageTypes) Strings() []string {
 	ret := make([]string, 0, len(m))
 	for _, typ := range m {
 		ret = append(ret, string(typ))
@@ -73,18 +73,18 @@ func (m protoMsgs) Strings() []string {
 	return ret
 }
 
-func (m protoMsgs) String() string {
+func (m messageTypes) String() string {
 	return strings.Join(m.Strings(), ", ")
 }
 
-var contentTypeHeaders = map[WriteProtoFullName]string{
-	WriteProtoFullNameV1: appProtoContentType, // Also application/x-protobuf;proto=prometheus.WriteRequest but simplified for compatibility with 1.x spec.
-	WriteProtoFullNameV2: appProtoContentType + ";proto=io.prometheus.write.v2.Request",
+var contentTypeHeaders = map[WriteMessageType]string{
+	WriteV1MessageType: appProtoContentType, // Also application/x-protobuf;proto=prometheus.WriteRequest but simplified for compatibility with 1.x spec.
+	WriteV2MessageType: appProtoContentType + ";proto=io.prometheus.write.v2.Request",
 }
 
 // ContentTypeHeader returns content type header value for the given proto message
 // or empty string for unknown proto message.
-func contentTypeHeader(m WriteProtoFullName) string {
+func contentTypeHeader(m WriteMessageType) string {
 	return contentTypeHeaders[m]
 }
 
@@ -94,6 +94,61 @@ const (
 	writtenExemplarsHeader  = "X-Prometheus-Remote-Write-Exemplars-Written"
 )
 
+// WriteResponse represents the response from the remote storage upon receiving a remote write request.
+type WriteResponse struct {
+	WriteResponseStats
+	statusCode   int
+	extraHeaders http.Header
+}
+
+// NewWriteResponse creates a new WriteResponse with empty stats and status code http.StatusNoContent.
+func NewWriteResponse() *WriteResponse {
+	return &WriteResponse{
+		WriteResponseStats: WriteResponseStats{},
+		statusCode:         http.StatusNoContent,
+		extraHeaders:       make(http.Header),
+	}
+}
+
+// Stats returns the current statistics.
+func (w *WriteResponse) Stats() WriteResponseStats {
+	return w.WriteResponseStats
+}
+
+// SetStatusCode sets the HTTP status code for the response. http.StatusNoContent is the default unless 5xx is set.
+func (w *WriteResponse) SetStatusCode(code int) {
+	w.statusCode = code
+}
+
+// StatusCode returns the current HTTP status code.
+func (w *WriteResponse) StatusCode() int {
+	return w.statusCode
+}
+
+// SetExtraHeader adds additional headers to be set in the response (apart from stats headers)
+func (w *WriteResponse) SetExtraHeader(key, value string) {
+	w.extraHeaders.Set(key, value)
+}
+
+// ExtraHeaders returns all additional headers to be set in the response (apart from stats headers).
+func (w *WriteResponse) ExtraHeaders() http.Header {
+	return w.extraHeaders
+}
+
+// SetHeaders sets response headers in a given response writer.
+// Make sure to use it before http.ResponseWriter.WriteHeader and .Write.
+func (r *WriteResponse) SetHeaders(w http.ResponseWriter) {
+	h := w.Header()
+	h.Set(writtenSamplesHeader, strconv.Itoa(r.Samples))
+	h.Set(writtenHistogramsHeader, strconv.Itoa(r.Histograms))
+	h.Set(writtenExemplarsHeader, strconv.Itoa(r.Exemplars))
+	for k, v := range r.ExtraHeaders() {
+		for _, vv := range v {
+			h.Add(k, vv)
+		}
+	}
+}
+
 // WriteResponseStats represents the response, remote write statistics.
 type WriteResponseStats struct {
 	// Samples represents X-Prometheus-Remote-Write-Written-Samples
@@ -107,7 +162,7 @@ type WriteResponseStats struct {
 	// of the PRW 2.0 spec. When parsed from headers, it means we got at least one
 	// response header from the Receiver to confirm those numbers, meaning it must
 	// be at least 2.0 Receiver. See ParseWriteResponseStats for details.
-	Confirmed bool
+	confirmed bool
 }
 
 // NoDataWritten returns true if statistics indicate no data was written.
@@ -120,22 +175,13 @@ func (s WriteResponseStats) AllSamples() int {
 	return s.Samples + s.Histograms
 }
 
-// Add returns the sum of this WriteResponseStats plus the given WriteResponseStats.
-func (s WriteResponseStats) Add(rs WriteResponseStats) WriteResponseStats {
-	s.Confirmed = rs.Confirmed
+// Add adds the given WriteResponseStats to this WriteResponseStats.
+// If this WriteResponseStats is empty, it will be replaced by the given WriteResponseStats.
+func (s *WriteResponseStats) Add(rs WriteResponseStats) {
+	s.confirmed = rs.confirmed
 	s.Samples += rs.Samples
 	s.Histograms += rs.Histograms
 	s.Exemplars += rs.Exemplars
-	return s
-}
-
-// SetHeaders sets response headers in a given response writer.
-// Make sure to use it before http.ResponseWriter.WriteHeader and .Write.
-func (s WriteResponseStats) SetHeaders(w http.ResponseWriter) {
-	h := w.Header()
-	h.Set(writtenSamplesHeader, strconv.Itoa(s.Samples))
-	h.Set(writtenHistogramsHeader, strconv.Itoa(s.Histograms))
-	h.Set(writtenExemplarsHeader, strconv.Itoa(s.Exemplars))
 }
 
 // parseWriteResponseStats returns WriteResponseStats parsed from the response headers.
@@ -152,21 +198,21 @@ func parseWriteResponseStats(r *http.Response) (s WriteResponseStats, err error)
 		h    = r.Header
 	)
 	if v := h.Get(writtenSamplesHeader); v != "" { // Empty means zero.
-		s.Confirmed = true
+		s.confirmed = true
 		if s.Samples, err = strconv.Atoi(v); err != nil {
 			s.Samples = 0
 			errs = append(errs, err)
 		}
 	}
 	if v := h.Get(writtenHistogramsHeader); v != "" { // Empty means zero.
-		s.Confirmed = true
+		s.confirmed = true
 		if s.Histograms, err = strconv.Atoi(v); err != nil {
 			s.Histograms = 0
 			errs = append(errs, err)
 		}
 	}
 	if v := h.Get(writtenExemplarsHeader); v != "" { // Empty means zero.
-		s.Confirmed = true
+		s.confirmed = true
 		if s.Exemplars, err = strconv.Atoi(v); err != nil {
 			s.Exemplars = 0
 			errs = append(errs, err)
diff --git a/exp/go.mod b/exp/go.mod
index 35449e9..0c341cc 100644
--- a/exp/go.mod
+++ b/exp/go.mod
@@ -4,9 +4,9 @@ go 1.21
 
 require (
 	github.com/google/go-cmp v0.6.0
-	github.com/klauspost/compress v1.17.10
-	github.com/prometheus/common v0.59.1
-	google.golang.org/protobuf v1.34.2
+	github.com/klauspost/compress v1.17.11
+	github.com/prometheus/common v0.62.0
+	google.golang.org/protobuf v1.36.4
 )
 
 require github.com/prometheus/client_model v0.6.1 // indirect
diff --git a/exp/go.sum b/exp/go.sum
index 0acdfd8..263ed1d 100644
--- a/exp/go.sum
+++ b/exp/go.sum
@@ -1,6 +1,10 @@
+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
 github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
-github.com/klauspost/compress v1.17.10 h1:oXAz+Vh0PMUvJczoi+flxpnBEPxoER1IaAnU/NMPtT0=
+github.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=
+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=
-github.com/prometheus/common v0.59.1 h1:LXb1quJHWm1P6wq/U824uxYi4Sg0oGvNeUm1z5dJoX0=
-google.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=
+github.com/prometheus/common v0.62.0 h1:xasJaQlnWAeyHdUBeGjXmutelfJHWMRr+Fg4QszZ2Io=
+github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
+google.golang.org/protobuf v1.36.4 h1:6A3ZDJHn/eNqc1i+IdefRzy/9PokBTPvcqMySR7NNIM=
+gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
diff --git a/go.work.sum b/go.work.sum
index 9cb5d3f..6210b5d 100644
--- a/go.work.sum
+++ b/go.work.sum
@@ -17,12 +17,15 @@ github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/
 github.com/google/gofuzz v1.0.0 h1:A8PeW59pxE9IoFRqBp37U+mSNaQoZ46F1f0f863XSXw=
 github.com/julienschmidt/httprouter v1.3.0 h1:U0609e9tgbseu3rBINet9P48AI/D3oJs4dN7jwJOQ1U=
 github.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=
+github.com/klauspost/compress v1.17.10/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=
 github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
 github.com/kr/pty v1.1.1 h1:VkoXIwSboBpnk99O/KFauAEILuNHv5DVFKZMBN/gUgw=
 github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
 github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
 github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e h1:aoZm08cpOy4WuID//EZDgcC4zIxODThtZNPirFr42+A=
 github.com/prometheus/client_golang v1.20.0/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=
+github.com/prometheus/client_golang v1.20.4/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=
+github.com/prometheus/common v0.59.1/go.mod h1:GpWM7dewqmVYcd7SmRaiWVe9SSqjf0UrwnYnpEZNuT0=
 github.com/stretchr/objx v0.1.0 h1:4G4v2dO3VZwixGIRoQ5Lfboy6nUhCyYzaqnIAPPhYs4=
 github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
 github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
@@ -31,13 +34,20 @@ github.com/xhit/go-str2duration/v2 v2.1.0 h1:lxklc02Drh6ynqX+DdPyp5pCKLUQpRT8bp8
 github.com/xhit/go-str2duration/v2 v2.1.0/go.mod h1:ohY8p+0f07DiV6Em5LKB0s2YpLtXVyJfNt1+BlmyAsU=
 golang.org/x/crypto v0.26.0 h1:RrRspgV4mU+YwB4FYnuBoKsUapNIL5cohGAmSH3azsw=
 golang.org/x/crypto v0.26.0/go.mod h1:GY7jblb9wI+FOo5y8/S2oY4zWP07AkOJ4+jxCqdqn54=
+golang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=
+golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
 golang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=
 golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
 golang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=
 golang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
+golang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=
+golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
 golang.org/x/sys v0.23.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
+golang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
 golang.org/x/term v0.23.0 h1:F6D4vR+EHoL9/sWAWgAR1H2DcHr4PareCbAaCo1RpuU=
 golang.org/x/term v0.23.0/go.mod h1:DgV24QBUrK6jhZXl+20l6UWznPlwAHm1Q1mGHtydmSk=
+golang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=
+golang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=
 golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=
 golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
@@ -46,4 +56,6 @@ google.golang.org/appengine v1.6.7 h1:FZR1q0exgwxzPzp/aF+VccGrSfxfPpkBqjIIEq3ru6
 google.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
 google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
 google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
+google.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=
+google.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=
 gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
