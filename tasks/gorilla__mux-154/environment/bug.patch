diff --git a/.travis.yml b/.travis.yml
index f4084bd..4dcdacb 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -10,6 +10,9 @@ matrix:
     - go: 1.6
     - go: tip
 
+install:
+  - go get golang.org/x/tools/cmd/vet
+
 script:
   - go get -t -v ./...
   - diff -u <(echo -n) <(gofmt -d .)
diff --git a/mux.go b/mux.go
index 94f5ddd..fbb7f19 100644
--- a/mux.go
+++ b/mux.go
@@ -48,8 +48,6 @@ type Router struct {
 	namedRoutes map[string]*Route
 	// See Router.StrictSlash(). This defines the flag for new routes.
 	strictSlash bool
-	// See Router.SkipClean(). This defines the flag for new routes.
-	skipClean bool
 	// If true, do not clear the request context after handling the request
 	KeepContext bool
 }
@@ -75,21 +73,19 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 // When there is a match, the route variables can be retrieved calling
 // mux.Vars(request).
 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
-	if !r.skipClean {
-		// Clean path to canonical form and redirect.
-		if p := cleanPath(req.URL.Path); p != req.URL.Path {
-
-			// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
-			// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
-			// http://code.google.com/p/go/issues/detail?id=5252
-			url := *req.URL
-			url.Path = p
-			p = url.String()
-
-			w.Header().Set("Location", p)
-			w.WriteHeader(http.StatusMovedPermanently)
-			return
-		}
+	// Clean path to canonical form and redirect.
+	if p := cleanPath(req.URL.Path); p != req.URL.Path {
+
+		// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
+		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
+		// http://code.google.com/p/go/issues/detail?id=5252
+		url := *req.URL
+		url.Path = p
+		p = url.String()
+
+		w.Header().Set("Location", p)
+		w.WriteHeader(http.StatusMovedPermanently)
+		return
 	}
 	var match RouteMatch
 	var handler http.Handler
@@ -137,19 +133,6 @@ func (r *Router) StrictSlash(value bool) *Router {
 	return r
 }
 
-// SkipClean defines the path cleaning behaviour for new routes. The initial
-// value is false. Users should be careful about which routes are not cleaned
-//
-// When true, if the route path is "/path//to", it will remain with the double
-// slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/
-//
-// When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will
-// become /fetch/http/xkcd.com/534
-func (r *Router) SkipClean(value bool) *Router {
-	r.skipClean = value
-	return r
-}
-
 // ----------------------------------------------------------------------------
 // parentRoute
 // ----------------------------------------------------------------------------
@@ -187,7 +170,7 @@ func (r *Router) buildVars(m map[string]string) map[string]string {
 
 // NewRoute registers an empty route.
 func (r *Router) NewRoute() *Route {
-	route := &Route{parent: r, strictSlash: r.strictSlash, skipClean: r.skipClean}
+	route := &Route{parent: r, strictSlash: r.strictSlash}
 	r.routes = append(r.routes, route)
 	return route
 }
@@ -374,7 +357,6 @@ func cleanPath(p string) string {
 	if p[len(p)-1] == '/' && np != "/" {
 		np += "/"
 	}
-
 	return np
 }
 
diff --git a/mux_test.go b/mux_test.go
index f147bb6..8912d09 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -1376,24 +1376,6 @@ func Test301Redirect(t *testing.T) {
 	}
 }
 
-func TestSkipClean(t *testing.T) {
-	func1 := func(w http.ResponseWriter, r *http.Request) {}
-	func2 := func(w http.ResponseWriter, r *http.Request) {}
-
-	r := NewRouter()
-	r.SkipClean(true)
-	r.HandleFunc("/api/", func2).Name("func2")
-	r.HandleFunc("/", func1).Name("func1")
-
-	req, _ := http.NewRequest("GET", "http://localhost//api/?abc=def", nil)
-	res := NewRecorder()
-	r.ServeHTTP(res, req)
-
-	if len(res.HeaderMap["Location"]) != 0 {
-		t.Errorf("Shouldn't redirect since skip clean is disabled")
-	}
-}
-
 // https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
 func TestSubrouterHeader(t *testing.T) {
 	expected := "func1 response"
diff --git a/route.go b/route.go
index 6c53f9f..bf92af2 100644
--- a/route.go
+++ b/route.go
@@ -26,9 +26,6 @@ type Route struct {
 	// If true, when the path pattern is "/path/", accessing "/path" will
 	// redirect to the former and vice versa.
 	strictSlash bool
-	// If true, when the path pattern is "/path//to", accessing "/path//to"
-	// will not redirect
-	skipClean bool
 	// If true, this route never matches: it is only used to build URLs.
 	buildOnly bool
 	// The name used to build URLs.
@@ -39,10 +36,6 @@ type Route struct {
 	buildVarsFunc BuildVarsFunc
 }
 
-func (r *Route) SkipClean() bool {
-	return r.skipClean
-}
-
 // Match matches the route against the request.
 func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if r.buildOnly || r.err != nil {
