diff --git a/cluster.go b/cluster.go
index 9077e8a5..872baad4 100644
--- a/cluster.go
+++ b/cluster.go
@@ -838,7 +838,7 @@ type ClusterClient struct {
 	state         *clusterStateHolder
 	cmdsInfoCache *cmdsInfoCache
 	cmdable
-	hooksMixin
+	hooks
 }
 
 // NewClusterClient returns a Redis Cluster client as described in
@@ -855,12 +855,9 @@ func NewClusterClient(opt *ClusterOptions) *ClusterClient {
 	c.cmdsInfoCache = newCmdsInfoCache(c.cmdsInfo)
 	c.cmdable = c.Process
 
-	c.initHooks(hooks{
-		dial:       nil,
-		process:    c.process,
-		pipeline:   c.processPipeline,
-		txPipeline: c.processTxPipeline,
-	})
+	c.hooks.setProcess(c.process)
+	c.hooks.setProcessPipeline(c.processPipeline)
+	c.hooks.setProcessTxPipeline(c.processTxPipeline)
 
 	return c
 }
@@ -892,7 +889,7 @@ func (c *ClusterClient) Do(ctx context.Context, args ...interface{}) *Cmd {
 }
 
 func (c *ClusterClient) Process(ctx context.Context, cmd Cmder) error {
-	err := c.processHook(ctx, cmd)
+	err := c.hooks.process(ctx, cmd)
 	cmd.SetErr(err)
 	return err
 }
@@ -1190,7 +1187,7 @@ func (c *ClusterClient) loadState(ctx context.Context) (*clusterState, error) {
 
 func (c *ClusterClient) Pipeline() Pipeliner {
 	pipe := Pipeline{
-		exec: pipelineExecer(c.processPipelineHook),
+		exec: pipelineExecer(c.hooks.processPipeline),
 	}
 	pipe.init()
 	return &pipe
@@ -1279,7 +1276,7 @@ func (c *ClusterClient) cmdsAreReadOnly(ctx context.Context, cmds []Cmder) bool
 func (c *ClusterClient) processPipelineNode(
 	ctx context.Context, node *clusterNode, cmds []Cmder, failedCmds *cmdsMap,
 ) {
-	_ = node.Client.withProcessPipelineHook(ctx, cmds, func(ctx context.Context, cmds []Cmder) error {
+	_ = node.Client.hooks.withProcessPipelineHook(ctx, cmds, func(ctx context.Context, cmds []Cmder) error {
 		cn, err := node.Client.getConn(ctx)
 		if err != nil {
 			_ = c.mapCmdsByNode(ctx, failedCmds, cmds)
@@ -1383,7 +1380,7 @@ func (c *ClusterClient) TxPipeline() Pipeliner {
 	pipe := Pipeline{
 		exec: func(ctx context.Context, cmds []Cmder) error {
 			cmds = wrapMultiExec(ctx, cmds)
-			return c.processTxPipelineHook(ctx, cmds)
+			return c.hooks.processTxPipeline(ctx, cmds)
 		},
 	}
 	pipe.init()
@@ -1456,7 +1453,7 @@ func (c *ClusterClient) processTxPipelineNode(
 	ctx context.Context, node *clusterNode, cmds []Cmder, failedCmds *cmdsMap,
 ) {
 	cmds = wrapMultiExec(ctx, cmds)
-	_ = node.Client.withProcessPipelineHook(ctx, cmds, func(ctx context.Context, cmds []Cmder) error {
+	_ = node.Client.hooks.withProcessPipelineHook(ctx, cmds, func(ctx context.Context, cmds []Cmder) error {
 		cn, err := node.Client.getConn(ctx)
 		if err != nil {
 			_ = c.mapCmdsByNode(ctx, failedCmds, cmds)
diff --git a/cluster_commands.go b/cluster_commands.go
index b13f8e7e..fc0a9cd4 100644
--- a/cluster_commands.go
+++ b/cluster_commands.go
@@ -8,7 +8,7 @@ import (
 
 func (c *ClusterClient) DBSize(ctx context.Context) *IntCmd {
 	cmd := NewIntCmd(ctx, "dbsize")
-	_ = c.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {
+	_ = c.hooks.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {
 		var size int64
 		err := c.ForEachMaster(ctx, func(ctx context.Context, master *Client) error {
 			n, err := master.DBSize(ctx).Result()
@@ -30,8 +30,8 @@ func (c *ClusterClient) DBSize(ctx context.Context) *IntCmd {
 
 func (c *ClusterClient) ScriptLoad(ctx context.Context, script string) *StringCmd {
 	cmd := NewStringCmd(ctx, "script", "load", script)
-	_ = c.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {
-		var mu sync.Mutex
+	_ = c.hooks.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {
+		mu := &sync.Mutex{}
 		err := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {
 			val, err := shard.ScriptLoad(ctx, script).Result()
 			if err != nil {
@@ -56,7 +56,7 @@ func (c *ClusterClient) ScriptLoad(ctx context.Context, script string) *StringCm
 
 func (c *ClusterClient) ScriptFlush(ctx context.Context) *StatusCmd {
 	cmd := NewStatusCmd(ctx, "script", "flush")
-	_ = c.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {
+	_ = c.hooks.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {
 		err := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {
 			return shard.ScriptFlush(ctx).Err()
 		})
@@ -82,7 +82,7 @@ func (c *ClusterClient) ScriptExists(ctx context.Context, hashes ...string) *Boo
 		result[i] = true
 	}
 
-	_ = c.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {
+	_ = c.hooks.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {
 		var mu sync.Mutex
 		err := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {
 			val, err := shard.ScriptExists(ctx, hashes...).Result()
diff --git a/redis.go b/redis.go
index 1fe48a90..9fe0cd1a 100644
--- a/redis.go
+++ b/redis.go
@@ -40,42 +40,18 @@ type (
 	ProcessPipelineHook func(ctx context.Context, cmds []Cmder) error
 )
 
-type hooksMixin struct {
-	slice   []Hook
-	initial hooks
-	current hooks
-}
-
-func (hs *hooksMixin) initHooks(hooks hooks) {
-	hs.initial = hooks
-	hs.chain()
-}
-
 type hooks struct {
-	dial       DialHook
-	process    ProcessHook
-	pipeline   ProcessPipelineHook
-	txPipeline ProcessPipelineHook
-}
-
-func (h *hooks) setDefaults() {
-	if h.dial == nil {
-		h.dial = func(ctx context.Context, network, addr string) (net.Conn, error) { return nil, nil }
-	}
-	if h.process == nil {
-		h.process = func(ctx context.Context, cmd Cmder) error { return nil }
-	}
-	if h.pipeline == nil {
-		h.pipeline = func(ctx context.Context, cmds []Cmder) error { return nil }
-	}
-	if h.txPipeline == nil {
-		h.txPipeline = func(ctx context.Context, cmds []Cmder) error { return nil }
-	}
+	slice                 []Hook
+	dialHook              DialHook
+	processHook           ProcessHook
+	processPipelineHook   ProcessPipelineHook
+	processTxPipelineHook ProcessPipelineHook
 }
 
 // AddHook is to add a hook to the queue.
 // Hook is a function executed during network connection, command execution, and pipeline,
-// it is a first-in-first-out stack queue (FIFO).
+// it is a first-in-last-out stack queue (FILO).
+// The first to be added to the queue is the execution function of the redis command (the last to be executed).
 // You need to execute the next hook in each hook, unless you want to terminate the execution of the command.
 // For example, you added hook-1, hook-2:
 //
@@ -105,80 +81,95 @@ func (h *hooks) setDefaults() {
 //
 // The execution sequence is:
 //
-//	hook-1 start -> hook-2 start -> exec redis cmd -> hook-2 end -> hook-1 end
+//	hook-2 start -> hook-1 start -> exec redis cmd -> hook-1 end -> hook-2 end
 //
 // Please note: "next(ctx, cmd)" is very important, it will call the next hook,
-// if "next(ctx, cmd)" is not executed, the redis command will not be executed.
-func (hs *hooksMixin) AddHook(hook Hook) {
+// if "next(ctx, cmd)" is not executed in hook-1, the redis command will not be executed.
+func (hs *hooks) AddHook(hook Hook) {
 	hs.slice = append(hs.slice, hook)
-	hs.chain()
+	hs.dialHook = hook.DialHook(hs.dialHook)
+	hs.processHook = hook.ProcessHook(hs.processHook)
+	hs.processPipelineHook = hook.ProcessPipelineHook(hs.processPipelineHook)
+	hs.processTxPipelineHook = hook.ProcessPipelineHook(hs.processTxPipelineHook)
 }
 
-func (hs *hooksMixin) chain() {
-	hs.initial.setDefaults()
-
-	hs.current.dial = hs.initial.dial
-	hs.current.process = hs.initial.process
-	hs.current.pipeline = hs.initial.pipeline
-	hs.current.txPipeline = hs.initial.txPipeline
+func (hs *hooks) clone() hooks {
+	clone := *hs
+	l := len(clone.slice)
+	clone.slice = clone.slice[:l:l]
+	return clone
+}
 
-	for i := len(hs.slice) - 1; i >= 0; i-- {
-		if wrapped := hs.slice[i].DialHook(hs.current.dial); wrapped != nil {
-			hs.current.dial = wrapped
+func (hs *hooks) setDial(dial DialHook) {
+	hs.dialHook = dial
+	for _, h := range hs.slice {
+		if wrapped := h.DialHook(hs.dialHook); wrapped != nil {
+			hs.dialHook = wrapped
 		}
-		if wrapped := hs.slice[i].ProcessHook(hs.current.process); wrapped != nil {
-			hs.current.process = wrapped
-		}
-		if wrapped := hs.slice[i].ProcessPipelineHook(hs.current.pipeline); wrapped != nil {
-			hs.current.pipeline = wrapped
+	}
+}
+
+func (hs *hooks) setProcess(process ProcessHook) {
+	hs.processHook = process
+	for _, h := range hs.slice {
+		if wrapped := h.ProcessHook(hs.processHook); wrapped != nil {
+			hs.processHook = wrapped
 		}
-		if wrapped := hs.slice[i].ProcessPipelineHook(hs.current.txPipeline); wrapped != nil {
-			hs.current.txPipeline = wrapped
+	}
+}
+
+func (hs *hooks) setProcessPipeline(processPipeline ProcessPipelineHook) {
+	hs.processPipelineHook = processPipeline
+	for _, h := range hs.slice {
+		if wrapped := h.ProcessPipelineHook(hs.processPipelineHook); wrapped != nil {
+			hs.processPipelineHook = wrapped
 		}
 	}
 }
 
-func (hs *hooksMixin) clone() hooksMixin {
-	clone := *hs
-	l := len(clone.slice)
-	clone.slice = clone.slice[:l:l]
-	return clone
+func (hs *hooks) setProcessTxPipeline(processTxPipeline ProcessPipelineHook) {
+	hs.processTxPipelineHook = processTxPipeline
+	for _, h := range hs.slice {
+		if wrapped := h.ProcessPipelineHook(hs.processTxPipelineHook); wrapped != nil {
+			hs.processTxPipelineHook = wrapped
+		}
+	}
 }
 
-func (hs *hooksMixin) withProcessHook(ctx context.Context, cmd Cmder, hook ProcessHook) error {
-	for i := len(hs.slice) - 1; i >= 0; i-- {
-		if wrapped := hs.slice[i].ProcessHook(hook); wrapped != nil {
+func (hs *hooks) withProcessHook(ctx context.Context, cmd Cmder, hook ProcessHook) error {
+	for _, h := range hs.slice {
+		if wrapped := h.ProcessHook(hook); wrapped != nil {
 			hook = wrapped
 		}
 	}
 	return hook(ctx, cmd)
 }
 
-func (hs *hooksMixin) withProcessPipelineHook(
+func (hs *hooks) withProcessPipelineHook(
 	ctx context.Context, cmds []Cmder, hook ProcessPipelineHook,
 ) error {
-	for i := len(hs.slice) - 1; i >= 0; i-- {
-		if wrapped := hs.slice[i].ProcessPipelineHook(hook); wrapped != nil {
+	for _, h := range hs.slice {
+		if wrapped := h.ProcessPipelineHook(hook); wrapped != nil {
 			hook = wrapped
 		}
 	}
 	return hook(ctx, cmds)
 }
 
-func (hs *hooksMixin) dialHook(ctx context.Context, network, addr string) (net.Conn, error) {
-	return hs.current.dial(ctx, network, addr)
+func (hs *hooks) dial(ctx context.Context, network, addr string) (net.Conn, error) {
+	return hs.dialHook(ctx, network, addr)
 }
 
-func (hs *hooksMixin) processHook(ctx context.Context, cmd Cmder) error {
-	return hs.current.process(ctx, cmd)
+func (hs *hooks) process(ctx context.Context, cmd Cmder) error {
+	return hs.processHook(ctx, cmd)
 }
 
-func (hs *hooksMixin) processPipelineHook(ctx context.Context, cmds []Cmder) error {
-	return hs.current.pipeline(ctx, cmds)
+func (hs *hooks) processPipeline(ctx context.Context, cmds []Cmder) error {
+	return hs.processPipelineHook(ctx, cmds)
 }
 
-func (hs *hooksMixin) processTxPipelineHook(ctx context.Context, cmds []Cmder) error {
-	return hs.current.txPipeline(ctx, cmds)
+func (hs *hooks) processTxPipeline(ctx context.Context, cmds []Cmder) error {
+	return hs.processTxPipelineHook(ctx, cmds)
 }
 
 //------------------------------------------------------------------------------
@@ -584,7 +575,7 @@ func (c *baseClient) context(ctx context.Context) context.Context {
 type Client struct {
 	*baseClient
 	cmdable
-	hooksMixin
+	hooks
 }
 
 // NewClient returns a client to the Redis Server specified by Options.
@@ -597,19 +588,17 @@ func NewClient(opt *Options) *Client {
 		},
 	}
 	c.init()
-	c.connPool = newConnPool(opt, c.dialHook)
+	c.connPool = newConnPool(opt, c.hooks.dial)
 
 	return &c
 }
 
 func (c *Client) init() {
 	c.cmdable = c.Process
-	c.initHooks(hooks{
-		dial:       c.baseClient.dial,
-		process:    c.baseClient.process,
-		pipeline:   c.baseClient.processPipeline,
-		txPipeline: c.baseClient.processTxPipeline,
-	})
+	c.hooks.setDial(c.baseClient.dial)
+	c.hooks.setProcess(c.baseClient.process)
+	c.hooks.setProcessPipeline(c.baseClient.processPipeline)
+	c.hooks.setProcessTxPipeline(c.baseClient.processTxPipeline)
 }
 
 func (c *Client) WithTimeout(timeout time.Duration) *Client {
@@ -631,7 +620,7 @@ func (c *Client) Do(ctx context.Context, args ...interface{}) *Cmd {
 }
 
 func (c *Client) Process(ctx context.Context, cmd Cmder) error {
-	err := c.processHook(ctx, cmd)
+	err := c.hooks.process(ctx, cmd)
 	cmd.SetErr(err)
 	return err
 }
@@ -655,7 +644,7 @@ func (c *Client) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmd
 
 func (c *Client) Pipeline() Pipeliner {
 	pipe := Pipeline{
-		exec: pipelineExecer(c.processPipelineHook),
+		exec: pipelineExecer(c.hooks.processPipeline),
 	}
 	pipe.init()
 	return &pipe
@@ -670,7 +659,7 @@ func (c *Client) TxPipeline() Pipeliner {
 	pipe := Pipeline{
 		exec: func(ctx context.Context, cmds []Cmder) error {
 			cmds = wrapMultiExec(ctx, cmds)
-			return c.processTxPipelineHook(ctx, cmds)
+			return c.hooks.processTxPipeline(ctx, cmds)
 		},
 	}
 	pipe.init()
@@ -753,7 +742,7 @@ type Conn struct {
 	baseClient
 	cmdable
 	statefulCmdable
-	hooksMixin
+	hooks
 }
 
 func newConn(opt *Options, connPool pool.Pooler) *Conn {
@@ -766,18 +755,17 @@ func newConn(opt *Options, connPool pool.Pooler) *Conn {
 
 	c.cmdable = c.Process
 	c.statefulCmdable = c.Process
-	c.initHooks(hooks{
-		dial:       c.baseClient.dial,
-		process:    c.baseClient.process,
-		pipeline:   c.baseClient.processPipeline,
-		txPipeline: c.baseClient.processTxPipeline,
-	})
+
+	c.hooks.setDial(c.baseClient.dial)
+	c.hooks.setProcess(c.baseClient.process)
+	c.hooks.setProcessPipeline(c.baseClient.processPipeline)
+	c.hooks.setProcessTxPipeline(c.baseClient.processTxPipeline)
 
 	return &c
 }
 
 func (c *Conn) Process(ctx context.Context, cmd Cmder) error {
-	err := c.processHook(ctx, cmd)
+	err := c.hooks.process(ctx, cmd)
 	cmd.SetErr(err)
 	return err
 }
@@ -788,7 +776,7 @@ func (c *Conn) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder
 
 func (c *Conn) Pipeline() Pipeliner {
 	pipe := Pipeline{
-		exec: c.processPipelineHook,
+		exec: c.hooks.processPipeline,
 	}
 	pipe.init()
 	return &pipe
@@ -803,7 +791,7 @@ func (c *Conn) TxPipeline() Pipeliner {
 	pipe := Pipeline{
 		exec: func(ctx context.Context, cmds []Cmder) error {
 			cmds = wrapMultiExec(ctx, cmds)
-			return c.processTxPipelineHook(ctx, cmds)
+			return c.hooks.processTxPipeline(ctx, cmds)
 		},
 	}
 	pipe.init()
diff --git a/redis_test.go b/redis_test.go
index ec7ba7e7..4cbc3899 100644
--- a/redis_test.go
+++ b/redis_test.go
@@ -483,51 +483,3 @@ var _ = Describe("Conn", func() {
 		Expect(err).NotTo(HaveOccurred())
 	})
 })
-
-var _ = Describe("Hook", func() {
-	var client *redis.Client
-
-	BeforeEach(func() {
-		client = redis.NewClient(redisOptions())
-		Expect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())
-	})
-
-	AfterEach(func() {
-		err := client.Close()
-		Expect(err).NotTo(HaveOccurred())
-	})
-
-	It("fifo", func() {
-		var res []string
-		client.AddHook(&hook{
-			processHook: func(hook redis.ProcessHook) redis.ProcessHook {
-				return func(ctx context.Context, cmd redis.Cmder) error {
-					res = append(res, "hook-1-process-start")
-					err := hook(ctx, cmd)
-					res = append(res, "hook-1-process-end")
-					return err
-				}
-			},
-		})
-		client.AddHook(&hook{
-			processHook: func(hook redis.ProcessHook) redis.ProcessHook {
-				return func(ctx context.Context, cmd redis.Cmder) error {
-					res = append(res, "hook-2-process-start")
-					err := hook(ctx, cmd)
-					res = append(res, "hook-2-process-end")
-					return err
-				}
-			},
-		})
-
-		err := client.Ping(ctx).Err()
-		Expect(err).NotTo(HaveOccurred())
-
-		Expect(res).To(Equal([]string{
-			"hook-1-process-start",
-			"hook-2-process-start",
-			"hook-2-process-end",
-			"hook-1-process-end",
-		}))
-	})
-})
diff --git a/ring.go b/ring.go
index 9fd5f442..bc299da0 100644
--- a/ring.go
+++ b/ring.go
@@ -487,7 +487,7 @@ func (c *ringSharding) Close() error {
 // Otherwise you should use Redis Cluster.
 type Ring struct {
 	cmdable
-	hooksMixin
+	hooks
 
 	opt               *RingOptions
 	sharding          *ringSharding
@@ -509,14 +509,12 @@ func NewRing(opt *RingOptions) *Ring {
 	ring.cmdsInfoCache = newCmdsInfoCache(ring.cmdsInfo)
 	ring.cmdable = ring.Process
 
-	ring.initHooks(hooks{
-		process: ring.process,
-		pipeline: func(ctx context.Context, cmds []Cmder) error {
-			return ring.generalProcessPipeline(ctx, cmds, false)
-		},
-		txPipeline: func(ctx context.Context, cmds []Cmder) error {
-			return ring.generalProcessPipeline(ctx, cmds, true)
-		},
+	ring.hooks.setProcess(ring.process)
+	ring.hooks.setProcessPipeline(func(ctx context.Context, cmds []Cmder) error {
+		return ring.generalProcessPipeline(ctx, cmds, false)
+	})
+	ring.hooks.setProcessTxPipeline(func(ctx context.Context, cmds []Cmder) error {
+		return ring.generalProcessPipeline(ctx, cmds, true)
 	})
 
 	go ring.sharding.Heartbeat(hbCtx, opt.HeartbeatFrequency)
@@ -536,7 +534,7 @@ func (c *Ring) Do(ctx context.Context, args ...interface{}) *Cmd {
 }
 
 func (c *Ring) Process(ctx context.Context, cmd Cmder) error {
-	err := c.processHook(ctx, cmd)
+	err := c.hooks.process(ctx, cmd)
 	cmd.SetErr(err)
 	return err
 }
@@ -719,7 +717,7 @@ func (c *Ring) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder
 
 func (c *Ring) Pipeline() Pipeliner {
 	pipe := Pipeline{
-		exec: pipelineExecer(c.processPipelineHook),
+		exec: pipelineExecer(c.hooks.processPipeline),
 	}
 	pipe.init()
 	return &pipe
@@ -733,7 +731,7 @@ func (c *Ring) TxPipeline() Pipeliner {
 	pipe := Pipeline{
 		exec: func(ctx context.Context, cmds []Cmder) error {
 			cmds = wrapMultiExec(ctx, cmds)
-			return c.processTxPipelineHook(ctx, cmds)
+			return c.hooks.processTxPipeline(ctx, cmds)
 		},
 	}
 	pipe.init()
@@ -774,9 +772,9 @@ func (c *Ring) generalProcessPipeline(
 
 			if tx {
 				cmds = wrapMultiExec(ctx, cmds)
-				_ = shard.Client.processTxPipelineHook(ctx, cmds)
+				_ = shard.Client.hooks.processTxPipeline(ctx, cmds)
 			} else {
-				_ = shard.Client.processPipelineHook(ctx, cmds)
+				_ = shard.Client.hooks.processPipeline(ctx, cmds)
 			}
 		}(hash, cmds)
 	}
diff --git a/sentinel.go b/sentinel.go
index a3834896..1feeb039 100644
--- a/sentinel.go
+++ b/sentinel.go
@@ -214,7 +214,7 @@ func NewFailoverClient(failoverOpt *FailoverOptions) *Client {
 	}
 	rdb.init()
 
-	connPool = newConnPool(opt, rdb.dialHook)
+	connPool = newConnPool(opt, rdb.hooks.dial)
 	rdb.connPool = connPool
 	rdb.onClose = failover.Close
 
@@ -267,7 +267,7 @@ func masterReplicaDialer(
 // SentinelClient is a client for a Redis Sentinel.
 type SentinelClient struct {
 	*baseClient
-	hooksMixin
+	hooks
 }
 
 func NewSentinelClient(opt *Options) *SentinelClient {
@@ -278,17 +278,15 @@ func NewSentinelClient(opt *Options) *SentinelClient {
 		},
 	}
 
-	c.initHooks(hooks{
-		dial:    c.baseClient.dial,
-		process: c.baseClient.process,
-	})
-	c.connPool = newConnPool(opt, c.dialHook)
+	c.hooks.setDial(c.baseClient.dial)
+	c.hooks.setProcess(c.baseClient.process)
+	c.connPool = newConnPool(opt, c.hooks.dial)
 
 	return c
 }
 
 func (c *SentinelClient) Process(ctx context.Context, cmd Cmder) error {
-	err := c.processHook(ctx, cmd)
+	err := c.hooks.process(ctx, cmd)
 	cmd.SetErr(err)
 	return err
 }
diff --git a/tx.go b/tx.go
index a772e9e2..e720e687 100644
--- a/tx.go
+++ b/tx.go
@@ -19,7 +19,7 @@ type Tx struct {
 	baseClient
 	cmdable
 	statefulCmdable
-	hooksMixin
+	hooks
 }
 
 func (c *Client) newTx() *Tx {
@@ -28,7 +28,7 @@ func (c *Client) newTx() *Tx {
 			opt:      c.opt,
 			connPool: pool.NewStickyConnPool(c.connPool),
 		},
-		hooksMixin: c.hooksMixin.clone(),
+		hooks: c.hooks.clone(),
 	}
 	tx.init()
 	return &tx
@@ -38,16 +38,14 @@ func (c *Tx) init() {
 	c.cmdable = c.Process
 	c.statefulCmdable = c.Process
 
-	c.initHooks(hooks{
-		dial:       c.baseClient.dial,
-		process:    c.baseClient.process,
-		pipeline:   c.baseClient.processPipeline,
-		txPipeline: c.baseClient.processTxPipeline,
-	})
+	c.hooks.setDial(c.baseClient.dial)
+	c.hooks.setProcess(c.baseClient.process)
+	c.hooks.setProcessPipeline(c.baseClient.processPipeline)
+	c.hooks.setProcessTxPipeline(c.baseClient.processTxPipeline)
 }
 
 func (c *Tx) Process(ctx context.Context, cmd Cmder) error {
-	err := c.processHook(ctx, cmd)
+	err := c.hooks.process(ctx, cmd)
 	cmd.SetErr(err)
 	return err
 }
@@ -102,7 +100,7 @@ func (c *Tx) Unwatch(ctx context.Context, keys ...string) *StatusCmd {
 func (c *Tx) Pipeline() Pipeliner {
 	pipe := Pipeline{
 		exec: func(ctx context.Context, cmds []Cmder) error {
-			return c.processPipelineHook(ctx, cmds)
+			return c.hooks.processPipeline(ctx, cmds)
 		},
 	}
 	pipe.init()
@@ -132,7 +130,7 @@ func (c *Tx) TxPipeline() Pipeliner {
 	pipe := Pipeline{
 		exec: func(ctx context.Context, cmds []Cmder) error {
 			cmds = wrapMultiExec(ctx, cmds)
-			return c.processTxPipelineHook(ctx, cmds)
+			return c.hooks.processTxPipeline(ctx, cmds)
 		},
 	}
 	pipe.init()
