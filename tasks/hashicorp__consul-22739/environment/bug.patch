diff --git a/.changelog/22739.txt b/.changelog/22739.txt
deleted file mode 100644
index 09782959b5..0000000000
--- a/.changelog/22739.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-```release-note:security
-security: Configure HTTP server timeouts to prevent Slowloris denial-of-service attacks on agent HTTP endpoints and pprof endpoints
-```
diff --git a/agent/agent.go b/agent/agent.go
index 0c2d0bce4e..fcc7b510bb 100644
--- a/agent/agent.go
+++ b/agent/agent.go
@@ -1153,14 +1153,10 @@ func (a *Agent) listenHTTP() ([]apiServer, error) {
 			a.configReloaders = append(a.configReloaders, srv.ReloadConfig)
 			a.httpHandlers = srv
 			httpServer := &http.Server{
-				Addr:              l.Addr().String(),
-				TLSConfig:         tlscfg,
-				Handler:           srv.handler(),
-				MaxHeaderBytes:    a.config.HTTPMaxHeaderBytes,
-				ReadHeaderTimeout: a.config.HTTPReadHeaderTimeout,
-				ReadTimeout:       a.config.HTTPReadTimeout,
-				WriteTimeout:      a.config.HTTPWriteTimeout,
-				IdleTimeout:       a.config.HTTPIdleTimeout,
+				Addr:           l.Addr().String(),
+				TLSConfig:      tlscfg,
+				Handler:        srv.handler(),
+				MaxHeaderBytes: a.config.HTTPMaxHeaderBytes,
 			}
 
 			// Load the connlimit helper into the server
diff --git a/agent/agent_test.go b/agent/agent_test.go
index 9d4e172c1c..62963b94a7 100644
--- a/agent/agent_test.go
+++ b/agent/agent_test.go
@@ -6501,41 +6501,6 @@ func assertDeepEqual(t *testing.T, x, y interface{}, opts ...cmp.Option) {
 	}
 }
 
-func TestAgent_HTTPServerTimeouts(t *testing.T) {
-	t.Parallel()
-
-	// Test with custom timeout configuration
-	a := NewTestAgent(t, `
-		http_config = {
-			read_timeout = "5s"
-			read_header_timeout = "2s"
-			write_timeout = "5s"
-			idle_timeout = "60s"
-		}
-	`)
-	defer a.Shutdown()
-
-	// Verify timeout values are configured correctly
-	require.Equal(t, 5*time.Second, a.config.HTTPReadTimeout)
-	require.Equal(t, 2*time.Second, a.config.HTTPReadHeaderTimeout)
-	require.Equal(t, 5*time.Second, a.config.HTTPWriteTimeout)
-	require.Equal(t, 60*time.Second, a.config.HTTPIdleTimeout)
-}
-
-func TestAgent_HTTPServerDefaultTimeouts(t *testing.T) {
-	t.Parallel()
-
-	// Test with default timeout configuration (no explicit timeouts set)
-	a := NewTestAgent(t, "")
-	defer a.Shutdown()
-
-	// Verify default timeout values are applied
-	require.Equal(t, 30*time.Second, a.config.HTTPReadTimeout)
-	require.Equal(t, 10*time.Second, a.config.HTTPReadHeaderTimeout)
-	require.Equal(t, 30*time.Second, a.config.HTTPWriteTimeout)
-	require.Equal(t, 120*time.Second, a.config.HTTPIdleTimeout)
-}
-
 func TestAgent_ServiceRegistration(t *testing.T) {
 	// Since we accept both `port` and `ports` for service registration, we need to ensure that catalog stores it as it gets it
 
diff --git a/agent/config/builder.go b/agent/config/builder.go
index 37a6781f7e..4fb3e013bc 100644
--- a/agent/config/builder.go
+++ b/agent/config/builder.go
@@ -934,19 +934,15 @@ func (b *builder) build() (rt RuntimeConfig, err error) {
 		DNSCacheMaxAge:        b.durationVal("dns_config.cache_max_age", c.DNS.CacheMaxAge),
 
 		// HTTP
-		HTTPPort:              httpPort,
-		HTTPSPort:             httpsPort,
-		HTTPAddrs:             httpAddrs,
-		HTTPSAddrs:            httpsAddrs,
-		HTTPBlockEndpoints:    c.HTTPConfig.BlockEndpoints,
-		HTTPMaxHeaderBytes:    intVal(c.HTTPConfig.MaxHeaderBytes),
-		HTTPResponseHeaders:   c.HTTPConfig.ResponseHeaders,
-		AllowWriteHTTPFrom:    b.cidrsVal("allow_write_http_from", c.HTTPConfig.AllowWriteHTTPFrom),
-		HTTPUseCache:          boolValWithDefault(c.HTTPConfig.UseCache, true),
-		HTTPReadTimeout:       b.durationValWithDefaultMin("http_config.read_timeout", c.HTTPConfig.ReadTimeout, 30*time.Second, 1*time.Second),
-		HTTPReadHeaderTimeout: b.durationValWithDefaultMin("http_config.read_header_timeout", c.HTTPConfig.ReadHeaderTimeout, 10*time.Second, 1*time.Second),
-		HTTPWriteTimeout:      b.durationValWithDefaultMin("http_config.write_timeout", c.HTTPConfig.WriteTimeout, 30*time.Second, 1*time.Second),
-		HTTPIdleTimeout:       b.durationValWithDefaultMin("http_config.idle_timeout", c.HTTPConfig.IdleTimeout, 120*time.Second, 10*time.Second),
+		HTTPPort:            httpPort,
+		HTTPSPort:           httpsPort,
+		HTTPAddrs:           httpAddrs,
+		HTTPSAddrs:          httpsAddrs,
+		HTTPBlockEndpoints:  c.HTTPConfig.BlockEndpoints,
+		HTTPMaxHeaderBytes:  intVal(c.HTTPConfig.MaxHeaderBytes),
+		HTTPResponseHeaders: c.HTTPConfig.ResponseHeaders,
+		AllowWriteHTTPFrom:  b.cidrsVal("allow_write_http_from", c.HTTPConfig.AllowWriteHTTPFrom),
+		HTTPUseCache:        boolValWithDefault(c.HTTPConfig.UseCache, true),
 
 		// Telemetry
 		Telemetry: lib.TelemetryConfig{
diff --git a/agent/config/builder_test.go b/agent/config/builder_test.go
index ddbcd09b2c..bf558138df 100644
--- a/agent/config/builder_test.go
+++ b/agent/config/builder_test.go
@@ -345,246 +345,6 @@ func TestBuilder_ServiceVal_MultiError(t *testing.T) {
 	require.Contains(t, b.err.Error(), "cannot have both socket path")
 }
 
-func TestBuilder_DurationVal_EdgeCases(t *testing.T) {
-	testCases := []struct {
-		name        string
-		input       string
-		expectError bool
-		errorMsg    string
-	}{
-		{
-			name:        "negative duration",
-			input:       "-5s",
-			expectError: false, // time.ParseDuration allows negative durations
-		},
-		{
-			name:        "zero duration",
-			input:       "0s",
-			expectError: false,
-		},
-		{
-			name:        "unparseable string - no unit",
-			input:       "123",
-			expectError: true,
-			errorMsg:    "time: missing unit in duration",
-		},
-		{
-			name:        "unparseable string - invalid unit",
-			input:       "5x",
-			expectError: true,
-			errorMsg:    "unknown unit",
-		},
-		{
-			name:        "unparseable string - empty",
-			input:       "",
-			expectError: true,
-			errorMsg:    "invalid duration",
-		},
-		{
-			name:        "unparseable string - just letters",
-			input:       "abc",
-			expectError: true,
-			errorMsg:    "invalid duration",
-		},
-		{
-			name:        "unparseable string - mixed invalid",
-			input:       "5s10x",
-			expectError: true,
-			errorMsg:    "unknown unit",
-		},
-		{
-			name:        "very large duration",
-			input:       "8760h", // 1 year in hours
-			expectError: false,
-		},
-		{
-			name:        "fractional seconds",
-			input:       "1.5s",
-			expectError: false,
-		},
-		{
-			name:        "complex valid duration",
-			input:       "1h30m45s",
-			expectError: false,
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			b := builder{}
-			result := b.durationVal("test_field", &tc.input)
-
-			if tc.expectError {
-				require.Error(t, b.err)
-				require.Contains(t, b.err.Error(), tc.errorMsg)
-				require.Equal(t, time.Duration(0), result)
-			} else {
-				require.NoError(t, b.err)
-				switch tc.input {
-				case "-5s":
-					require.Equal(t, -5*time.Second, result)
-				case "0s":
-					require.Equal(t, time.Duration(0), result)
-				case "8760h":
-					require.Equal(t, 8760*time.Hour, result)
-				case "1.5s":
-					require.Equal(t, 1500*time.Millisecond, result)
-				case "1h30m45s":
-					expected := time.Hour + 30*time.Minute + 45*time.Second
-					require.Equal(t, expected, result)
-				}
-			}
-		})
-	}
-}
-
-func TestBuilder_DurationValWithDefaultMin_EdgeCases(t *testing.T) {
-	testCases := []struct {
-		name        string
-		input       *string
-		defaultVal  time.Duration
-		minVal      time.Duration
-		expectError bool
-		errorMsg    string
-	}{
-		{
-			name:        "nil input uses default",
-			input:       nil,
-			defaultVal:  10 * time.Second,
-			minVal:      5 * time.Second,
-			expectError: false,
-		},
-		{
-			name:        "negative duration below minimum",
-			input:       strPtr("-10s"),
-			defaultVal:  10 * time.Second,
-			minVal:      0,
-			expectError: true,
-			errorMsg:    "cannot be less than",
-		},
-		{
-			name:        "zero duration below minimum",
-			input:       strPtr("0s"),
-			defaultVal:  10 * time.Second,
-			minVal:      5 * time.Second,
-			expectError: true,
-			errorMsg:    "cannot be less than",
-		},
-		{
-			name:        "valid duration above minimum",
-			input:       strPtr("30s"),
-			defaultVal:  10 * time.Second,
-			minVal:      5 * time.Second,
-			expectError: false,
-		},
-		{
-			name:        "duration exactly at minimum",
-			input:       strPtr("5s"),
-			defaultVal:  10 * time.Second,
-			minVal:      5 * time.Second,
-			expectError: false,
-		},
-		{
-			name:        "unparseable duration with minimum check",
-			input:       strPtr("invalid"),
-			defaultVal:  10 * time.Second,
-			minVal:      5 * time.Second,
-			expectError: true,
-			errorMsg:    "invalid duration",
-		},
-		{
-			name:        "very small duration below microsecond minimum",
-			input:       strPtr("1ns"),
-			defaultVal:  0,
-			minVal:      time.Microsecond,
-			expectError: true,
-			errorMsg:    "cannot be less than",
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			b := builder{}
-			result := b.durationValWithDefaultMin("test_field", tc.input, tc.defaultVal, tc.minVal)
-
-			if tc.expectError {
-				require.Error(t, b.err)
-				require.Contains(t, b.err.Error(), tc.errorMsg)
-			} else {
-				require.NoError(t, b.err)
-				if tc.input == nil {
-					require.Equal(t, tc.defaultVal, result)
-				} else if *tc.input == "30s" {
-					require.Equal(t, 30*time.Second, result)
-				} else if *tc.input == "5s" {
-					require.Equal(t, 5*time.Second, result)
-				}
-			}
-		})
-	}
-}
-
-func TestBuilder_DurationValWithDefault_EdgeCases(t *testing.T) {
-	testCases := []struct {
-		name        string
-		input       *string
-		defaultVal  time.Duration
-		expectError bool
-		expected    time.Duration
-	}{
-		{
-			name:        "nil input returns default",
-			input:       nil,
-			defaultVal:  15 * time.Minute,
-			expectError: false,
-			expected:    15 * time.Minute,
-		},
-		{
-			name:        "empty string input",
-			input:       strPtr(""),
-			defaultVal:  15 * time.Minute,
-			expectError: true,
-			expected:    time.Duration(0),
-		},
-		{
-			name:        "negative duration with default",
-			input:       strPtr("-1h"),
-			defaultVal:  15 * time.Minute,
-			expectError: false,
-			expected:    -time.Hour,
-		},
-		{
-			name:        "zero duration overrides default",
-			input:       strPtr("0s"),
-			defaultVal:  15 * time.Minute,
-			expectError: false,
-			expected:    time.Duration(0),
-		},
-		{
-			name:        "valid duration overrides default",
-			input:       strPtr("2h30m"),
-			defaultVal:  15 * time.Minute,
-			expectError: false,
-			expected:    2*time.Hour + 30*time.Minute,
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			b := builder{}
-			result := b.durationValWithDefault("test_field", tc.input, tc.defaultVal)
-
-			if tc.expectError {
-				require.Error(t, b.err)
-				require.Equal(t, time.Duration(0), result)
-			} else {
-				require.NoError(t, b.err)
-				require.Equal(t, tc.expected, result)
-			}
-		})
-	}
-}
-
 func TestBuilder_ServiceVal_with_Check(t *testing.T) {
 	b := builder{}
 	svc := b.serviceVal(&ServiceDefinition{
diff --git a/agent/config/config.go b/agent/config/config.go
index ccf15758df..c2d9131860 100644
--- a/agent/config/config.go
+++ b/agent/config/config.go
@@ -686,10 +686,6 @@ type HTTPConfig struct {
 	ResponseHeaders    map[string]string `mapstructure:"response_headers"`
 	UseCache           *bool             `mapstructure:"use_cache"`
 	MaxHeaderBytes     *int              `mapstructure:"max_header_bytes"`
-	ReadTimeout        *string           `mapstructure:"read_timeout"`
-	ReadHeaderTimeout  *string           `mapstructure:"read_header_timeout"`
-	WriteTimeout       *string           `mapstructure:"write_timeout"`
-	IdleTimeout        *string           `mapstructure:"idle_timeout"`
 }
 
 type Performance struct {
diff --git a/agent/config/runtime.go b/agent/config/runtime.go
index b583f2eb2b..69512c3227 100644
--- a/agent/config/runtime.go
+++ b/agent/config/runtime.go
@@ -805,38 +805,6 @@ type RuntimeConfig struct {
 	// If zero, or negative, http.DefaultMaxHeaderBytes is used.
 	HTTPMaxHeaderBytes int
 
-	// HTTPReadTimeout is the maximum duration for reading the entire request,
-	// including the body. This timeout prevents slow request body attacks.
-	// A zero or negative value means there will be no timeout.
-	//
-	// Default: 30s, Minimum: 1s
-	// hcl: http_config { read_timeout = "30s" }
-	HTTPReadTimeout time.Duration
-
-	// HTTPReadHeaderTimeout is the amount of time allowed to read request headers.
-	// The connection's read deadline is reset after reading the headers and the
-	// Handler can decide what is considered too slow for the body.
-	// This timeout prevents slowloris attacks on header parsing.
-	//
-	// Default: 10s, Minimum: 1s
-	// hcl: http_config { read_header_timeout = "10s" }
-	HTTPReadHeaderTimeout time.Duration
-
-	// HTTPWriteTimeout is the maximum duration before timing out writes of the response.
-	// This timeout prevents slow response drain attacks.
-	// A zero or negative value means there will be no timeout.
-	//
-	// Default: 30s, Minimum: 1s
-	// hcl: http_config { write_timeout = "30s" }
-	HTTPWriteTimeout time.Duration
-
-	// HTTPIdleTimeout is the maximum amount of time to wait for the next request
-	// when keep-alives are enabled. This timeout prevents connection exhaustion attacks.
-	//
-	// Default: 120s, Minimum: 10s
-	// hcl: http_config { idle_timeout = "120s" }
-	HTTPIdleTimeout time.Duration
-
 	// HTTPSHandshakeTimeout is the time allowed for HTTPS client to complete the
 	// TLS handshake and send first bytes of the request.
 	//
diff --git a/agent/config/runtime_test.go b/agent/config/runtime_test.go
index b903fb82f0..d6139af0f1 100644
--- a/agent/config/runtime_test.go
+++ b/agent/config/runtime_test.go
@@ -6662,10 +6662,6 @@ func TestLoad_FullConfig(t *testing.T) {
 		HTTPSAddrs:            []net.Addr{tcpAddr("95.17.17.19:15127")},
 		HTTPMaxConnsPerClient: 100,
 		HTTPMaxHeaderBytes:    10,
-		HTTPReadTimeout:       30 * time.Second,
-		HTTPReadHeaderTimeout: 10 * time.Second,
-		HTTPWriteTimeout:      30 * time.Second,
-		HTTPIdleTimeout:       120 * time.Second,
 		HTTPSHandshakeTimeout: 2391 * time.Millisecond,
 		HTTPSPort:             15127,
 		HTTPUseCache:          false,
@@ -7493,11 +7489,7 @@ func TestRuntimeConfig_Sanitize(t *testing.T) {
 			*parseCIDR(t, "192.168.1.0/24"),
 			*parseCIDR(t, "127.0.0.0/8"),
 		},
-		TxnMaxReqLen:          5678000000000000,
-		HTTPReadTimeout:       0,
-		HTTPReadHeaderTimeout: 0,
-		HTTPWriteTimeout:      0,
-		HTTPIdleTimeout:       0,
+		TxnMaxReqLen: 5678000000000000,
 		UIConfig: UIConfig{
 			MetricsProxy: UIMetricsProxy{
 				AddHeaders: []UIMetricsProxyAddHeader{
diff --git a/agent/config/testdata/TestRuntimeConfig_Sanitize.golden b/agent/config/testdata/TestRuntimeConfig_Sanitize.golden
index 8f87777d3e..ef58c0af83 100644
--- a/agent/config/testdata/TestRuntimeConfig_Sanitize.golden
+++ b/agent/config/testdata/TestRuntimeConfig_Sanitize.golden
@@ -222,18 +222,14 @@
         "unix:///var/run/foo"
     ],
     "HTTPBlockEndpoints": [],
-    "HTTPIdleTimeout": "0s",
     "HTTPMaxConnsPerClient": 0,
     "HTTPMaxHeaderBytes": 0,
     "HTTPPort": 0,
-    "HTTPReadHeaderTimeout": "0s",
-    "HTTPReadTimeout": "0s",
     "HTTPResponseHeaders": {},
     "HTTPSAddrs": [],
     "HTTPSHandshakeTimeout": "0s",
     "HTTPSPort": 0,
     "HTTPUseCache": false,
-    "HTTPWriteTimeout": "0s",
     "KVMaxValueSize": 1234567800000000,
     "LeaveDrainTime": "0s",
     "LeaveOnTerm": false,
diff --git a/agent/http_test.go b/agent/http_test.go
index 53c5208a85..30f9a8b475 100644
--- a/agent/http_test.go
+++ b/agent/http_test.go
@@ -113,11 +113,7 @@ func TestHTTPServer_UnixSocket_FileExists(t *testing.T) {
 		t.SkipNow()
 	}
 
-	tempDir, err := os.MkdirTemp("", "consul_sock_test_")
-	if err != nil {
-		t.Fatalf("Failed to create temp dir: %v", err)
-	}
-	defer os.RemoveAll(tempDir)
+	tempDir := testutil.TempDir(t, "consul")
 	socket := filepath.Join(tempDir, "test.sock")
 
 	// Create a regular file at the socket path
@@ -1214,149 +1210,6 @@ func TestHTTPServer_PProfHandlers_DisableDebugNoACLs(t *testing.T) {
 	require.Equal(t, http.StatusNotFound, resp.Code)
 }
 
-func TestHTTPServer_PProfHandlers_LongRunningProfile(t *testing.T) {
-	if testing.Short() {
-		t.Skip("too slow for testing.Short")
-	}
-
-	// Test that pprof profiling works with durations longer than default WriteTimeout
-	// This test verifies that:
-	// 1. pprof.Profile is synchronous and blocks until profiling completes
-	// 2. WriteTimeout must be configured appropriately for long profiling sessions
-	// 3. Response is only written after profiling finishes
-
-	testCases := []struct {
-		name           string
-		profileSeconds int
-		writeTimeout   string
-		expectSuccess  bool
-		expectMinBytes int
-		description    string
-	}{
-		{
-			name:           "Short profile with default timeout",
-			profileSeconds: 2,
-			writeTimeout:   "30s", // default
-			expectSuccess:  true,
-			expectMinBytes: 100,
-			description:    "2-second profile should complete within 30s timeout",
-		},
-		{
-			name:           "Long profile with extended timeout",
-			profileSeconds: 35,
-			writeTimeout:   "120s", // 2 minutes
-			expectSuccess:  true,
-			expectMinBytes: 100,
-			description:    "35-second profile requires >30s timeout to avoid timeout error",
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			// Create agent with configured write timeout
-			config := fmt.Sprintf(`
-				enable_debug = true
-				http_config = {
-					write_timeout = "%s"
-				}
-			`, tc.writeTimeout)
-
-			a := NewTestAgent(t, config)
-			defer a.Shutdown()
-
-			// Create request for CPU profile
-			url := fmt.Sprintf("/debug/pprof/profile?seconds=%d", tc.profileSeconds)
-			req, _ := http.NewRequest("GET", url, nil)
-			resp := httptest.NewRecorder()
-
-			// Record start time to verify synchronous behavior
-			startTime := time.Now()
-
-			// Execute the pprof handler
-			a.enableDebug.Store(true)
-			httpServer := &HTTPHandlers{agent: a.Agent}
-			httpServer.handler().ServeHTTP(resp, req)
-
-			// Record completion time
-			duration := time.Since(startTime)
-
-			// Verify the handler blocked for approximately the profiling duration
-			// Allow some overhead (up to 3 seconds) for processing
-			minExpectedDuration := time.Duration(tc.profileSeconds) * time.Second
-			maxExpectedDuration := minExpectedDuration + 3*time.Second
-
-			require.GreaterOrEqual(t, duration, minExpectedDuration,
-				"Handler should block for at least %v, but returned in %v", minExpectedDuration, duration)
-			require.LessOrEqual(t, duration, maxExpectedDuration,
-				"Handler took too long: %v (expected max %v)", duration, maxExpectedDuration)
-
-			if tc.expectSuccess {
-				// Verify successful response
-				require.Equal(t, http.StatusOK, resp.Code,
-					"%s: Expected status 200, got %d", tc.description, resp.Code)
-
-				// Verify response contains profile data
-				body := resp.Body.Bytes()
-				require.Greater(t, len(body), tc.expectMinBytes,
-					"%s: Expected at least %d bytes of profile data, got %d",
-					tc.description, tc.expectMinBytes, len(body))
-
-				t.Logf("✓ %s: Profile completed in %v with %d bytes of data",
-					tc.description, duration, len(body))
-			} else {
-				// Verify timeout or error
-				require.NotEqual(t, http.StatusOK, resp.Code,
-					"%s: Expected non-OK status due to timeout", tc.description)
-				t.Logf("✓ %s: Correctly failed with status %d",
-					tc.description, resp.Code)
-			}
-		})
-	}
-}
-
-func TestHTTPServer_PProfHandlers_TraceWithTimeout(t *testing.T) {
-	if testing.Short() {
-		t.Skip("too slow for testing.Short")
-	}
-
-	// Test that trace endpoint also respects WriteTimeout since it's synchronous
-	t.Parallel()
-
-	config := `
-		enable_debug = true
-		http_config = {
-			write_timeout = "60s"
-		}
-	`
-
-	a := NewTestAgent(t, config)
-	defer a.Shutdown()
-
-	// Request 30-second trace
-	req, _ := http.NewRequest("GET", "/debug/pprof/trace?seconds=30", nil)
-	resp := httptest.NewRecorder()
-
-	startTime := time.Now()
-
-	a.enableDebug.Store(true)
-	httpServer := &HTTPHandlers{agent: a.Agent}
-	httpServer.handler().ServeHTTP(resp, req)
-
-	duration := time.Since(startTime)
-
-	// Verify trace blocked for approximately 30 seconds
-	require.GreaterOrEqual(t, duration, 30*time.Second,
-		"Trace handler should block for at least 30s")
-	require.LessOrEqual(t, duration, 33*time.Second,
-		"Trace handler took too long")
-
-	require.Equal(t, http.StatusOK, resp.Code)
-	require.Greater(t, len(resp.Body.Bytes()), 100,
-		"Expected trace data in response")
-
-	t.Logf("✓ Trace completed synchronously in %v", duration)
-}
-
 func TestHTTPServer_PProfHandlers_ACLs(t *testing.T) {
 	if testing.Short() {
 		t.Skip("too slow for testing.Short")
@@ -1965,10 +1818,7 @@ func TestHTTPServer_HandshakeTimeout(t *testing.T) {
 		buf := make([]byte, 10)
 		_, err = conn.Read(buf)
 		require.Error(r, err)
-
-		// After adding timeouts to prevent slowloris attacks, the connection
-		// times out with "i/o timeout" instead of "EOF"
-		require.Contains(r, err.Error(), "i/o timeout")
+		require.Contains(r, err.Error(), "EOF")
 	})
 }
 
diff --git a/command/connect/proxy/proxy.go b/command/connect/proxy/proxy.go
index 06ac6e5f83..203925ee6f 100644
--- a/command/connect/proxy/proxy.go
+++ b/command/connect/proxy/proxy.go
@@ -14,16 +14,14 @@ import (
 	"sort"
 	"strconv"
 	"strings"
-	"time"
-
-	"github.com/mitchellh/cli"
-
-	"github.com/hashicorp/go-hclog"
 
 	"github.com/hashicorp/consul/api"
 	"github.com/hashicorp/consul/command/flags"
 	proxyImpl "github.com/hashicorp/consul/connect/proxy"
+	"github.com/hashicorp/go-hclog"
+
 	"github.com/hashicorp/consul/logging"
+	"github.com/mitchellh/cli"
 )
 
 func New(ui cli.Ui, shutdownCh <-chan struct{}) *cmd {
@@ -50,19 +48,18 @@ type cmd struct {
 	logger hclog.Logger
 
 	// flags
-	logLevel     string
-	logJSON      bool
-	cfgFile      string
-	proxyID      string
-	sidecarFor   string
-	pprofAddr    string
-	pprofTimeout time.Duration
-	service      string
-	serviceAddr  string
-	upstreams    map[string]proxyImpl.UpstreamConfig
-	listen       string
-	register     bool
-	registerId   string
+	logLevel    string
+	logJSON     bool
+	cfgFile     string
+	proxyID     string
+	sidecarFor  string
+	pprofAddr   string
+	service     string
+	serviceAddr string
+	upstreams   map[string]proxyImpl.UpstreamConfig
+	listen      string
+	register    bool
+	registerId  string
 
 	// test flags
 	testNoStart bool // don't start the proxy, just exit 0
@@ -90,10 +87,6 @@ func (c *cmd) init() {
 		"Enable debugging via pprof. Providing a host:port (or just ':port') "+
 			"enables profiling HTTP endpoints on that address.")
 
-	c.flags.DurationVar(&c.pprofTimeout, "pprof-timeout", 30*time.Second,
-		"Timeout for pprof HTTP server operations. This includes read, write, "+
-			"and idle timeouts to prevent slowloris attacks.")
-
 	c.flags.StringVar(&c.service, "service", "",
 		"Name of the service this proxy is representing.")
 
@@ -160,23 +153,8 @@ func (c *cmd) Run(args []string) int {
 	if c.pprofAddr != "" {
 		go func() {
 			c.UI.Output(fmt.Sprintf("Starting pprof HTTP endpoints on "+
-				"http://%s/debug/pprof (timeout: %v)", c.pprofAddr, c.pprofTimeout))
-
-			// Use minimum timeout values for security while respecting user configuration
-			readTimeout := c.pprofTimeout
-			if readTimeout < 1*time.Second {
-				readTimeout = 1 * time.Second
-			}
-
-			server := &http.Server{
-				Addr:              c.pprofAddr,
-				Handler:           nil,
-				ReadHeaderTimeout: readTimeout / 3, // Use 1/3 of total timeout for headers
-				ReadTimeout:       readTimeout,
-				WriteTimeout:      readTimeout,
-				IdleTimeout:       readTimeout * 4, // Idle can be longer
-			}
-			log.Fatal(server.ListenAndServe())
+				"http://%s/debug/pprof", c.pprofAddr))
+			log.Fatal(http.ListenAndServe(c.pprofAddr, nil))
 		}()
 	}
 
diff --git a/command/connect/proxy/proxy_test.go b/command/connect/proxy/proxy_test.go
index 06f05d3c76..f17b04f5f8 100644
--- a/command/connect/proxy/proxy_test.go
+++ b/command/connect/proxy/proxy_test.go
@@ -8,11 +8,10 @@ import (
 	"testing"
 	"time"
 
-	"github.com/mitchellh/cli"
-	"github.com/stretchr/testify/require"
-
 	"github.com/hashicorp/consul/agent"
 	"github.com/hashicorp/consul/connect/proxy"
+	"github.com/mitchellh/cli"
+	"github.com/stretchr/testify/require"
 )
 
 func TestCommandConfigWatcher(t *testing.T) {
@@ -204,64 +203,6 @@ func testConfig(t *testing.T, cw proxy.ConfigWatcher) *proxy.Config {
 	}
 }
 
-func TestFlagUpstreams_ConnectTimeout(t *testing.T) {
-	testCases := []struct {
-		name           string
-		upstreamFlag   string
-		configOverride map[string]interface{}
-		expectedMs     int
-	}{
-		{
-			name:         "default timeout",
-			upstreamFlag: "db:8080",
-			expectedMs:   10000, // 10s default
-		},
-		{
-			name:         "custom timeout via config",
-			upstreamFlag: "db:8080",
-			configOverride: map[string]interface{}{
-				"connect_timeout_ms": 5000,
-			},
-			expectedMs: 5000,
-		},
-		{
-			name:         "zero timeout",
-			upstreamFlag: "cache:6379",
-			configOverride: map[string]interface{}{
-				"connect_timeout_ms": 0,
-			},
-			expectedMs: 0,
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			// Parse the upstream flag
-			var upstreams FlagUpstreams
-			err := upstreams.Set(tc.upstreamFlag)
-			require.NoError(t, err)
-
-			// Get the parsed upstream
-			var upstream *proxy.UpstreamConfig
-			for _, u := range upstreams {
-				upstream = &u
-				break
-			}
-			require.NotNil(t, upstream)
-
-			// Override config if provided
-			if tc.configOverride != nil {
-				upstream.Config = tc.configOverride
-			}
-
-			// Test the timeout
-			timeout := upstream.ConnectTimeout()
-			expectedDuration := time.Duration(tc.expectedMs) * time.Millisecond
-			require.Equal(t, expectedDuration, timeout)
-		})
-	}
-}
-
 func TestCatalogCommand_noTabs(t *testing.T) {
 	t.Parallel()
 	if strings.ContainsRune(New(nil, nil).Help(), '\t') {
diff --git a/connect/proxy/proxy_test.go b/connect/proxy/proxy_test.go
index dee8ec191c..73d65b82c6 100644
--- a/connect/proxy/proxy_test.go
+++ b/connect/proxy/proxy_test.go
@@ -129,164 +129,3 @@ func TestProxy_public(t *testing.T) {
 		require.NoFileExists(t, unixSocket)
 	})
 }
-
-func TestPublicListenerConfig_Defaults(t *testing.T) {
-	testCases := []struct {
-		name     string
-		config   PublicListenerConfig
-		expected PublicListenerConfig
-	}{
-		{
-			name:   "empty config gets defaults",
-			config: PublicListenerConfig{},
-			expected: PublicListenerConfig{
-				LocalConnectTimeoutMs: 1000,
-				HandshakeTimeoutMs:    10000,
-				BindAddress:           "0.0.0.0",
-			},
-		},
-		{
-			name: "partial config preserves values",
-			config: PublicListenerConfig{
-				LocalConnectTimeoutMs: 5000,
-				BindAddress:           "127.0.0.1",
-			},
-			expected: PublicListenerConfig{
-				LocalConnectTimeoutMs: 5000,
-				HandshakeTimeoutMs:    10000,
-				BindAddress:           "127.0.0.1",
-			},
-		},
-		{
-			name: "full config unchanged",
-			config: PublicListenerConfig{
-				LocalConnectTimeoutMs: 2000,
-				HandshakeTimeoutMs:    15000,
-				BindAddress:           "192.168.1.100",
-			},
-			expected: PublicListenerConfig{
-				LocalConnectTimeoutMs: 2000,
-				HandshakeTimeoutMs:    15000,
-				BindAddress:           "192.168.1.100",
-			},
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			tc.config.applyDefaults()
-			require.Equal(t, tc.expected, tc.config)
-		})
-	}
-}
-
-func TestUpstreamConfig_ConnectTimeout(t *testing.T) {
-	testCases := []struct {
-		name     string
-		config   map[string]interface{}
-		expected time.Duration
-	}{
-		{
-			name:     "no config uses default",
-			config:   map[string]interface{}{},
-			expected: 10000 * time.Millisecond, // 10s default
-		},
-		{
-			name:     "nil config uses default",
-			config:   nil,
-			expected: 10000 * time.Millisecond,
-		},
-		{
-			name: "custom timeout",
-			config: map[string]interface{}{
-				"connect_timeout_ms": 5000,
-			},
-			expected: 5000 * time.Millisecond,
-		},
-		{
-			name: "zero timeout",
-			config: map[string]interface{}{
-				"connect_timeout_ms": 0,
-			},
-			expected: 0,
-		},
-		{
-			name: "very large timeout",
-			config: map[string]interface{}{
-				"connect_timeout_ms": 300000, // 5 minutes
-			},
-			expected: 300000 * time.Millisecond,
-		},
-		{
-			name: "invalid type falls back to default",
-			config: map[string]interface{}{
-				"connect_timeout_ms": "invalid",
-			},
-			expected: 10000 * time.Millisecond,
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			upstream := &UpstreamConfig{
-				Config: tc.config,
-			}
-			result := upstream.ConnectTimeout()
-			require.Equal(t, tc.expected, result)
-		})
-	}
-}
-
-func TestUpstreamConfig_Defaults(t *testing.T) {
-	testCases := []struct {
-		name     string
-		config   UpstreamConfig
-		expected UpstreamConfig
-	}{
-		{
-			name:   "empty config gets defaults",
-			config: UpstreamConfig{},
-			expected: UpstreamConfig{
-				DestinationType:      "service",
-				DestinationNamespace: "default",
-				DestinationPartition: "default",
-				LocalBindAddress:     "127.0.0.1",
-			},
-		},
-		{
-			name: "partial config preserves values",
-			config: UpstreamConfig{
-				DestinationName:      "web",
-				DestinationNamespace: "prod",
-				LocalBindPort:        8080,
-			},
-			expected: UpstreamConfig{
-				DestinationName:      "web",
-				DestinationType:      "service",
-				DestinationNamespace: "prod",
-				DestinationPartition: "default",
-				LocalBindAddress:     "127.0.0.1",
-				LocalBindPort:        8080,
-			},
-		},
-		{
-			name: "socket path overrides bind address default",
-			config: UpstreamConfig{
-				LocalBindSocketPath: "/var/run/socket.sock",
-			},
-			expected: UpstreamConfig{
-				DestinationType:      "service",
-				DestinationNamespace: "default",
-				DestinationPartition: "default",
-				LocalBindSocketPath:  "/var/run/socket.sock",
-			},
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			tc.config.applyDefaults()
-			require.Equal(t, tc.expected, tc.config)
-		})
-	}
-}
diff --git a/website/content/docs/reference/agent/configuration-file/index.mdx b/website/content/docs/reference/agent/configuration-file/index.mdx
index 47a6e6a78d..2d41ef22bb 100644
--- a/website/content/docs/reference/agent/configuration-file/index.mdx
+++ b/website/content/docs/reference/agent/configuration-file/index.mdx
@@ -92,27 +92,6 @@ Examples:
 
 Refer to the [formatting specification](https://golang.org/pkg/time/#ParseDuration) for additional information.
 
-#### Duration formatting validation
-
-When you configure timeout and duration values, Consul validates the formatting and enforces minimum values where applicable. When you use invalid duration strings, the agent will fail to start and the output will include a descriptive error message.
-
-**Examples of valid duration formatting**:
-
-- `"10s"` - 10 seconds
-- `"1.5m"` - 1.5 minutes, equivalent to 90 seconds (`90s`)
-- `"2h30m45s"` - Complex duration with hours, minutes, and seconds
-- `"0s"` - Zero duration, although not all fields support this value.
-
-**Examples of invalid formatting that produce errors**:
-
-- `"10"` - Missing unit specification
-- `"10x"` - Invalid unit, as `x` is not a recognized duration
-- `""` - Empty string
-- `"abc"` - Non-numeric string
-- `"-5s"` - Negative durations are not accepted for timeout configurations
-
-Some timeout configurations enforce minimum values to prevent connection issues or security vulnerabilities. For example, handshake timeouts typically require a minimum of 1 second. When a configured value is below the minimum, Consul reports a validation error during startup.
-
 ## Examples
 
 The following configuration examples demonstrate scenarios for server and client agent configuration files.
