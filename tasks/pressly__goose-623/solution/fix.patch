diff --git a/database/dialect.go b/database/dialect.go
new file mode 100644
index 0000000..d4b3529
--- /dev/null
+++ b/database/dialect.go
@@ -0,0 +1,131 @@
+package database
+
+import (
+	"context"
+	"errors"
+	"fmt"
+
+	"github.com/pressly/goose/v3/internal/dialect/dialectquery"
+)
+
+// Dialect is the type of database dialect.
+type Dialect string
+
+const (
+	DialectClickHouse Dialect = "clickhouse"
+	DialectMSSQL      Dialect = "mssql"
+	DialectMySQL      Dialect = "mysql"
+	DialectPostgres   Dialect = "postgres"
+	DialectRedshift   Dialect = "redshift"
+	DialectSQLite3    Dialect = "sqlite3"
+	DialectTiDB       Dialect = "tidb"
+	DialectVertica    Dialect = "vertica"
+	DialectYdB        Dialect = "ydb"
+
+	// DialectCustom is a special dialect that allows users to provide their own [Store]
+	// implementation when constructing a [goose.Provider].
+	DialectCustom Dialect = "custom"
+)
+
+// NewStore returns a new [Store] backed by the given dialect.
+func NewStore(dialect Dialect, tablename string) (Store, error) {
+	if tablename == "" {
+		return nil, errors.New("tablename must not be empty")
+	}
+	if dialect == "" {
+		return nil, errors.New("dialect must not be empty")
+	}
+	if dialect == DialectCustom {
+		return nil, errors.New("dialect must not be custom")
+	}
+	lookup := map[Dialect]dialectquery.Querier{
+		DialectClickHouse: &dialectquery.Clickhouse{},
+		DialectMSSQL:      &dialectquery.Sqlserver{},
+		DialectMySQL:      &dialectquery.Mysql{},
+		DialectPostgres:   &dialectquery.Postgres{},
+		DialectRedshift:   &dialectquery.Redshift{},
+		DialectSQLite3:    &dialectquery.Sqlite3{},
+		DialectTiDB:       &dialectquery.Tidb{},
+		DialectVertica:    &dialectquery.Vertica{},
+		DialectYdB:        &dialectquery.Ydb{},
+	}
+	querier, ok := lookup[dialect]
+	if !ok {
+		return nil, fmt.Errorf("unknown dialect: %q", dialect)
+	}
+	return &store{
+		tablename: tablename,
+		querier:   querier,
+	}, nil
+}
+
+type store struct {
+	tablename string
+	querier   dialectquery.Querier
+}
+
+var _ Store = (*store)(nil)
+
+func (s *store) CreateVersionTable(ctx context.Context, db DBTxConn) error {
+	q := s.querier.CreateTable(s.tablename)
+	if _, err := db.ExecContext(ctx, q); err != nil {
+		return fmt.Errorf("failed to create version table %q: %w", s.tablename, err)
+	}
+	return nil
+}
+
+func (s *store) InsertOrDelete(ctx context.Context, db DBTxConn, direction bool, version int64) error {
+	if direction {
+		q := s.querier.InsertVersion(s.tablename)
+		if _, err := db.ExecContext(ctx, q, version, true); err != nil {
+			return fmt.Errorf("failed to insert version %d: %w", version, err)
+		}
+		return nil
+	}
+	q := s.querier.DeleteVersion(s.tablename)
+	if _, err := db.ExecContext(ctx, q, version); err != nil {
+		return fmt.Errorf("failed to delete version %d: %w", version, err)
+	}
+	return nil
+}
+
+func (s *store) GetMigration(
+	ctx context.Context,
+	db DBTxConn,
+	version int64,
+) (*GetMigrationResult, error) {
+	q := s.querier.GetMigrationByVersion(s.tablename)
+	var result GetMigrationResult
+	if err := db.QueryRowContext(ctx, q, version).Scan(
+		&result.Timestamp,
+		&result.IsApplied,
+	); err != nil {
+		return nil, fmt.Errorf("failed to get migration %d: %w", version, err)
+	}
+	return &result, nil
+}
+
+func (s *store) ListMigrations(
+	ctx context.Context,
+	db DBTxConn,
+) ([]*ListMigrationsResult, error) {
+	q := s.querier.ListMigrations(s.tablename)
+	rows, err := db.QueryContext(ctx, q)
+	if err != nil {
+		return nil, fmt.Errorf("failed to list migrations: %w", err)
+	}
+	defer rows.Close()
+
+	var migrations []*ListMigrationsResult
+	for rows.Next() {
+		var result ListMigrationsResult
+		if err := rows.Scan(&result.Version, &result.IsApplied); err != nil {
+			return nil, fmt.Errorf("failed to scan list migrations result: %w", err)
+		}
+		migrations = append(migrations, &result)
+	}
+	if err := rows.Err(); err != nil {
+		return nil, err
+	}
+	return migrations, nil
+}
diff --git a/database/doc.go b/database/doc.go
new file mode 100644
index 0000000..4748c72
--- /dev/null
+++ b/database/doc.go
@@ -0,0 +1,14 @@
+// Package database defines a generic [Store] interface for goose to use when interacting with the
+// database. It is meant to be generic and not tied to any specific database technology.
+//
+// At a high level, a [Store] is responsible for:
+//   - Creating a version table
+//   - Inserting and deleting a version
+//   - Getting a specific version
+//   - Listing all applied versions
+//
+// Use the [NewStore] function to create a [Store] for one of the supported dialects.
+//
+// For more advanced use cases, it's possible to implement a custom [Store] for a database that
+// goose does not support.
+package database
diff --git a/database/sql_extended.go b/database/sql_extended.go
new file mode 100644
index 0000000..8eaa939
--- /dev/null
+++ b/database/sql_extended.go
@@ -0,0 +1,23 @@
+package database
+
+import (
+	"context"
+	"database/sql"
+)
+
+// DBTxConn is a thin interface for common methods that is satisfied by *sql.DB, *sql.Tx and
+// *sql.Conn.
+//
+// There is a long outstanding issue to formalize a std lib interface, but alas. See:
+// https://github.com/golang/go/issues/14468
+type DBTxConn interface {
+	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
+	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
+	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
+}
+
+var (
+	_ DBTxConn = (*sql.DB)(nil)
+	_ DBTxConn = (*sql.Tx)(nil)
+	_ DBTxConn = (*sql.Conn)(nil)
+)
diff --git a/database/store.go b/database/store.go
new file mode 100644
index 0000000..4e2ff0c
--- /dev/null
+++ b/database/store.go
@@ -0,0 +1,39 @@
+package database
+
+import (
+	"context"
+	"time"
+)
+
+// Store is an interface that defines methods for managing database migrations and versioning. By
+// defining a Store interface, we can support multiple databases with consistent functionality.
+//
+// Each database dialect requires a specific implementation of this interface. A dialect represents
+// a set of SQL statements specific to a particular database system.
+type Store interface {
+	// CreateVersionTable creates the version table. This table is used to record applied
+	// migrations.
+	CreateVersionTable(ctx context.Context, db DBTxConn) error
+
+	// InsertOrDelete inserts or deletes a version id from the version table. If direction is true,
+	// insert the version id. If direction is false, delete the version id.
+	InsertOrDelete(ctx context.Context, db DBTxConn, direction bool, version int64) error
+
+	// GetMigration retrieves a single migration by version id. This method may return the raw sql
+	// error if the query fails so the caller can assert for errors such as [sql.ErrNoRows].
+	GetMigration(ctx context.Context, db DBTxConn, version int64) (*GetMigrationResult, error)
+
+	// ListMigrations retrieves all migrations sorted in descending order by id or timestamp. If
+	// there are no migrations, return empty slice with no error.
+	ListMigrations(ctx context.Context, db DBTxConn) ([]*ListMigrationsResult, error)
+}
+
+type GetMigrationResult struct {
+	Timestamp time.Time
+	IsApplied bool
+}
+
+type ListMigrationsResult struct {
+	Version   int64
+	IsApplied bool
+}
diff --git a/internal/provider/migration.go b/internal/provider/migration.go
index 05faf01..2ace5f9 100644
--- a/internal/provider/migration.go
+++ b/internal/provider/migration.go
@@ -6,7 +6,7 @@ import (
 	"fmt"
 	"path/filepath"
 
-	"github.com/pressly/goose/v3/internal/sqlextended"
+	"github.com/pressly/goose/v3/database"
 )
 
 type migration struct {
@@ -170,7 +170,7 @@ func (s *sqlMigration) IsEmpty(direction bool) bool {
 	return len(s.DownStatements) == 0
 }
 
-func (s *sqlMigration) run(ctx context.Context, db sqlextended.DBTxConn, direction bool) error {
+func (s *sqlMigration) run(ctx context.Context, db database.DBTxConn, direction bool) error {
 	var statements []string
 	if direction {
 		statements = s.UpStatements
diff --git a/internal/provider/provider.go b/internal/provider/provider.go
index 2dd3350..c2e081c 100644
--- a/internal/provider/provider.go
+++ b/internal/provider/provider.go
@@ -9,7 +9,7 @@ import (
 	"math"
 	"sync"
 
-	"github.com/pressly/goose/v3/internal/sqladapter"
+	"github.com/pressly/goose/v3/database"
 )
 
 // NewProvider returns a new goose Provider.
@@ -28,13 +28,10 @@ import (
 // Unless otherwise specified, all methods on Provider are safe for concurrent use.
 //
 // Experimental: This API is experimental and may change in the future.
-func NewProvider(dialect Dialect, db *sql.DB, fsys fs.FS, opts ...ProviderOption) (*Provider, error) {
+func NewProvider(dialect database.Dialect, db *sql.DB, fsys fs.FS, opts ...ProviderOption) (*Provider, error) {
 	if db == nil {
 		return nil, errors.New("db must not be nil")
 	}
-	if dialect == "" {
-		return nil, errors.New("dialect must not be empty")
-	}
 	if fsys == nil {
 		fsys = noopFS{}
 	}
@@ -51,7 +48,7 @@ func NewProvider(dialect Dialect, db *sql.DB, fsys fs.FS, opts ...ProviderOption
 	if cfg.tableName == "" {
 		cfg.tableName = DefaultTablename
 	}
-	store, err := sqladapter.NewStore(string(dialect), cfg.tableName)
+	store, err := database.NewStore(dialect, cfg.tableName)
 	if err != nil {
 		return nil, err
 	}
@@ -138,7 +135,7 @@ type Provider struct {
 	db    *sql.DB
 	fsys  fs.FS
 	cfg   config
-	store sqladapter.Store
+	store database.Store
 
 	// migrations are ordered by version in ascending order.
 	migrations []*migration
diff --git a/internal/provider/run.go b/internal/provider/run.go
index 6dc6001..17edff9 100644
--- a/internal/provider/run.go
+++ b/internal/provider/run.go
@@ -10,7 +10,7 @@ import (
 	"strings"
 	"time"
 
-	"github.com/pressly/goose/v3/internal/sqladapter"
+	"github.com/pressly/goose/v3/database"
 	"github.com/pressly/goose/v3/internal/sqlparser"
 	"go.uber.org/multierr"
 )
@@ -63,7 +63,7 @@ func (p *Provider) up(ctx context.Context, upByOne bool, version int64) (_ []*Mi
 }
 
 func (p *Provider) resolveUpMigrations(
-	dbVersions []*sqladapter.ListMigrationsResult,
+	dbVersions []*database.ListMigrationsResult,
 	version int64,
 ) ([]*migration, error) {
 	var apply []*migration
@@ -379,7 +379,7 @@ type missingMigration struct {
 // findMissingMigrations returns a list of migrations that are missing from the database. A missing
 // migration is one that has a version less than the max version in the database.
 func findMissingMigrations(
-	dbMigrations []*sqladapter.ListMigrationsResult,
+	dbMigrations []*database.ListMigrationsResult,
 	fsMigrations []*migration,
 ) []missingMigration {
 	existing := make(map[int64]bool)
diff --git a/internal/sqladapter/sqladapter.go b/internal/sqladapter/sqladapter.go
deleted file mode 100644
index f6c975d..0000000
--- a/internal/sqladapter/sqladapter.go
+++ /dev/null
@@ -1,49 +0,0 @@
-// Package sqladapter provides an interface for interacting with a SQL database.
-//
-// All supported database dialects must implement the Store interface.
-package sqladapter
-
-import (
-	"context"
-	"time"
-
-	"github.com/pressly/goose/v3/internal/sqlextended"
-)
-
-// Store is the interface that wraps the basic methods for a database dialect.
-//
-// A dialect is a set of SQL statements that are specific to a database.
-//
-// By defining a store interface, we can support multiple databases with a single codebase.
-//
-// The underlying implementation does not modify the error. It is the callers responsibility to
-// assert for the correct error, such as [sql.ErrNoRows].
-type Store interface {
-	// CreateVersionTable creates the version table within a transaction. This table is used to
-	// record applied migrations.
-	CreateVersionTable(ctx context.Context, db sqlextended.DBTxConn) error
-
-	// InsertOrDelete inserts or deletes a version id from the version table.
-	InsertOrDelete(ctx context.Context, db sqlextended.DBTxConn, direction bool, version int64) error
-
-	// GetMigration retrieves a single migration by version id.
-	//
-	// Returns the raw sql error if the query fails. It is the callers responsibility to assert for
-	// the correct error, such as [sql.ErrNoRows].
-	GetMigration(ctx context.Context, db sqlextended.DBTxConn, version int64) (*GetMigrationResult, error)
-
-	// ListMigrations retrieves all migrations sorted in descending order by id.
-	//
-	// If there are no migrations, an empty slice is returned with no error.
-	ListMigrations(ctx context.Context, db sqlextended.DBTxConn) ([]*ListMigrationsResult, error)
-}
-
-type GetMigrationResult struct {
-	IsApplied bool
-	Timestamp time.Time
-}
-
-type ListMigrationsResult struct {
-	Version   int64
-	IsApplied bool
-}
