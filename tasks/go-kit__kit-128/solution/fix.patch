diff --git a/examples/stringsvc3/proxying.go b/examples/stringsvc3/proxying.go
index 6427b06..6de5e1d 100644
--- a/examples/stringsvc3/proxying.go
+++ b/examples/stringsvc3/proxying.go
@@ -3,6 +3,7 @@ package main
 import (
 	"errors"
 	"fmt"
+	"io"
 	"net/url"
 	"strings"
 	"time"
@@ -64,12 +65,12 @@ func (mw proxymw) Uppercase(s string) (string, error) {
 }
 
 func factory(ctx context.Context, qps int) loadbalancer.Factory {
-	return func(instance string) (endpoint.Endpoint, error) {
+	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
 		var e endpoint.Endpoint
 		e = makeUppercaseProxy(ctx, instance)
 		e = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{}))(e)
 		e = kitratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(float64(qps), int64(qps)))(e)
-		return e, nil
+		return e, nil, nil
 	}
 }
 
diff --git a/loadbalancer/dnssrv/publisher.go b/loadbalancer/dnssrv/publisher.go
index 0f9fe9f..8a81afa 100644
--- a/loadbalancer/dnssrv/publisher.go
+++ b/loadbalancer/dnssrv/publisher.go
@@ -1,10 +1,8 @@
 package dnssrv
 
 import (
-	"crypto/md5"
 	"fmt"
 	"net"
-	"sort"
 	"time"
 
 	"github.com/go-kit/kit/endpoint"
@@ -15,12 +13,11 @@ import (
 // Publisher yields endpoints taken from the named DNS SRV record. The name is
 // resolved on a fixed schedule. Priorities and weights are ignored.
 type Publisher struct {
-	name      string
-	ttl       time.Duration
-	factory   loadbalancer.Factory
-	logger    log.Logger
-	endpoints chan []endpoint.Endpoint
-	quit      chan struct{}
+	name   string
+	ttl    time.Duration
+	cache  *loadbalancer.EndpointCache
+	logger log.Logger
+	quit   chan struct{}
 }
 
 // NewPublisher returns a DNS SRV publisher. The name is resolved
@@ -28,22 +25,25 @@ type Publisher struct {
 // constructor will return an error. The factory is used to convert a
 // host:port to a usable endpoint. The logger is used to report DNS and
 // factory errors.
-func NewPublisher(name string, ttl time.Duration, f loadbalancer.Factory, logger log.Logger) (*Publisher, error) {
-	logger = log.NewContext(logger).With("component", "DNS SRV Publisher")
-	addrs, md5, err := resolve(name)
-	if err != nil {
-		return nil, err
-	}
+func NewPublisher(name string, ttl time.Duration, factory loadbalancer.Factory, logger log.Logger) *Publisher {
 	p := &Publisher{
-		name:      name,
-		ttl:       ttl,
-		factory:   f,
-		logger:    logger,
-		endpoints: make(chan []endpoint.Endpoint),
-		quit:      make(chan struct{}),
+		name:   name,
+		ttl:    ttl,
+		cache:  loadbalancer.NewEndpointCache(factory, logger),
+		logger: logger,
+		quit:   make(chan struct{}),
+	}
+
+	instances, err := p.resolve()
+	if err != nil {
+		logger.Log(name, len(instances))
+	} else {
+		logger.Log(name, err)
 	}
-	go p.loop(makeEndpoints(addrs, f, logger), md5)
-	return p, nil
+	p.cache.Replace(instances)
+
+	go p.loop()
+	return p
 }
 
 // Stop terminates the publisher.
@@ -51,25 +51,18 @@ func (p *Publisher) Stop() {
 	close(p.quit)
 }
 
-func (p *Publisher) loop(endpoints []endpoint.Endpoint, md5 string) {
+func (p *Publisher) loop() {
 	t := newTicker(p.ttl)
 	defer t.Stop()
 	for {
 		select {
-		case p.endpoints <- endpoints:
-
 		case <-t.C:
-			// TODO should we do this out-of-band?
-			addrs, newmd5, err := resolve(p.name)
+			instances, err := p.resolve()
 			if err != nil {
-				p.logger.Log("name", p.name, "err", err)
-				continue // don't replace good endpoints with bad ones
-			}
-			if newmd5 == md5 {
-				continue // no change
+				p.logger.Log(p.name, err)
+				continue // don't replace potentially-good with bad
 			}
-			endpoints = makeEndpoints(addrs, p.factory, p.logger)
-			md5 = newmd5
+			p.cache.Replace(instances)
 
 		case <-p.quit:
 			return
@@ -79,12 +72,7 @@ func (p *Publisher) loop(endpoints []endpoint.Endpoint, md5 string) {
 
 // Endpoints implements the Publisher interface.
 func (p *Publisher) Endpoints() ([]endpoint.Endpoint, error) {
-	select {
-	case endpoints := <-p.endpoints:
-		return endpoints, nil
-	case <-p.quit:
-		return nil, loadbalancer.ErrPublisherStopped
-	}
+	return p.cache.Endpoints(), nil
 }
 
 var (
@@ -92,36 +80,14 @@ var (
 	newTicker = time.NewTicker
 )
 
-func resolve(name string) (addrs []*net.SRV, md5sum string, err error) {
-	_, addrs, err = lookupSRV("", "", name)
+func (p *Publisher) resolve() ([]string, error) {
+	_, addrs, err := lookupSRV("", "", p.name)
 	if err != nil {
-		return addrs, "", err
+		return []string{}, err
 	}
-	hostports := make([]string, len(addrs))
+	instances := make([]string, len(addrs))
 	for i, addr := range addrs {
-		hostports[i] = fmt.Sprintf("%s:%d", addr.Target, addr.Port)
-	}
-	sort.Sort(sort.StringSlice(hostports))
-	h := md5.New()
-	for _, hostport := range hostports {
-		fmt.Fprintf(h, hostport)
-	}
-	return addrs, fmt.Sprintf("%x", h.Sum(nil)), nil
-}
-
-func makeEndpoints(addrs []*net.SRV, f loadbalancer.Factory, logger log.Logger) []endpoint.Endpoint {
-	endpoints := make([]endpoint.Endpoint, 0, len(addrs))
-	for _, addr := range addrs {
-		endpoint, err := f(addr2instance(addr))
-		if err != nil {
-			logger.Log("instance", addr2instance(addr), "err", err)
-			continue
-		}
-		endpoints = append(endpoints, endpoint)
+		instances[i] = net.JoinHostPort(addr.Target, fmt.Sprint(addr.Port))
 	}
-	return endpoints
-}
-
-func addr2instance(addr *net.SRV) string {
-	return net.JoinHostPort(addr.Target, fmt.Sprint(addr.Port))
+	return instances, nil
 }
diff --git a/loadbalancer/endpoint_cache.go b/loadbalancer/endpoint_cache.go
new file mode 100644
index 0000000..f4b8bc9
--- /dev/null
+++ b/loadbalancer/endpoint_cache.go
@@ -0,0 +1,90 @@
+package loadbalancer
+
+import (
+	"io"
+	"sync"
+
+	"github.com/go-kit/kit/endpoint"
+	"github.com/go-kit/kit/log"
+)
+
+// EndpointCache caches endpoints that need to be deallocated when they're no
+// longer useful. Clients update the cache by providing a current set of
+// instance strings. The cache converts each instance string to an endpoint
+// and a closer via the factory function.
+//
+// Instance strings are assumed to be unique and are used as keys. Endpoints
+// that were in the previous set of instances and are not in the current set
+// are considered invalid and closed.
+//
+// EndpointCache is designed to be used in your publisher implementation.
+type EndpointCache struct {
+	mtx    sync.RWMutex
+	f      Factory
+	m      map[string]endpointCloser
+	logger log.Logger
+}
+
+// NewEndpointCache produces a new EndpointCache, ready for use. Instance
+// strings will be converted to endpoints via the provided factory function.
+// The logger is used to log errors.
+func NewEndpointCache(f Factory, logger log.Logger) *EndpointCache {
+	return &EndpointCache{
+		f:      f,
+		m:      map[string]endpointCloser{},
+		logger: log.NewContext(logger).With("component", "Endpoint Cache"),
+	}
+}
+
+type endpointCloser struct {
+	endpoint.Endpoint
+	io.Closer
+}
+
+// Replace replaces the current set of endpoints with endpoints manufactured
+// by the passed instances. If the same instance exists in both the existing
+// and new sets, it's left untouched.
+func (t *EndpointCache) Replace(instances []string) {
+	t.mtx.Lock()
+	defer t.mtx.Unlock()
+
+	// Produce the current set of endpoints.
+	m := make(map[string]endpointCloser, len(instances))
+	for _, instance := range instances {
+		// If it already exists, just copy it over.
+		if ec, ok := t.m[instance]; ok {
+			m[instance] = ec
+			delete(t.m, instance)
+			continue
+		}
+
+		// If it doesn't exist, create it.
+		endpoint, closer, err := t.f(instance)
+		if err != nil {
+			t.logger.Log("instance", instance, "err", err)
+			continue
+		}
+		m[instance] = endpointCloser{endpoint, closer}
+	}
+
+	// Close any leftover endpoints.
+	for _, ec := range t.m {
+		if ec.Closer != nil {
+			ec.Closer.Close()
+		}
+	}
+
+	// Swap and GC.
+	t.m = m
+}
+
+// Endpoints returns the current set of endpoints in undefined order.
+func (t *EndpointCache) Endpoints() []endpoint.Endpoint {
+	t.mtx.RLock()
+	defer t.mtx.RUnlock()
+	a := make([]endpoint.Endpoint, 0, len(t.m))
+	for _, ec := range t.m {
+		a = append(a, ec.Endpoint)
+	}
+	return a
+}
diff --git a/loadbalancer/etcd/client.go b/loadbalancer/etcd/client.go
index 27d9284..c19101d 100644
--- a/loadbalancer/etcd/client.go
+++ b/loadbalancer/etcd/client.go
@@ -7,7 +7,7 @@ import (
 	"github.com/coreos/go-etcd/etcd"
 )
 
-// Client is a wrapper arround the etcd client
+// Client is a wrapper arround the etcd client.
 type Client interface {
 	// GetEntries will query the given prefix in etcd and returns a set of entries.
 	GetEntries(prefix string) ([]string, error)
@@ -43,7 +43,7 @@ func NewClient(machines []string, cert, key, caCert string) (Client, error) {
 	return &client{c}, nil
 }
 
-// GetEntries implements the EtcdClient interface.
+// GetEntries implements the etcd Client interface.
 func (c *client) GetEntries(key string) ([]string, error) {
 	resp, err := c.Get(key, false, true)
 	if err != nil {
@@ -57,7 +57,7 @@ func (c *client) GetEntries(key string) ([]string, error) {
 	return entries, nil
 }
 
-// WatchPrefix implements the EtcdClient interface.
+// WatchPrefix implements the etcd Client interface.
 func (c *client) WatchPrefix(prefix string, responseChan chan *etcd.Response) {
 	c.Watch(prefix, 0, true, responseChan, nil)
 }
diff --git a/loadbalancer/etcd/publisher.go b/loadbalancer/etcd/publisher.go
index 27e9912..dbafd65 100644
--- a/loadbalancer/etcd/publisher.go
+++ b/loadbalancer/etcd/publisher.go
@@ -9,53 +9,50 @@ import (
 )
 
 // Publisher yield endpoints stored in a certain etcd keyspace. Any kind of
-// change in that keyspace is watched and wil update the Publisher endpoints.
+// change in that keyspace is watched and will update the Publisher endpoints.
 type Publisher struct {
-	client    Client
-	prefix    string
-	factory   loadbalancer.Factory
-	logger    log.Logger
-	endpoints chan []endpoint.Endpoint
-	quit      chan struct{}
+	client Client
+	prefix string
+	cache  *loadbalancer.EndpointCache
+	logger log.Logger
+	quit   chan struct{}
 }
 
 // NewPublisher returs a etcd publisher. Etcd will start watching the given
 // prefix for changes and update the Publisher endpoints.
 func NewPublisher(c Client, prefix string, f loadbalancer.Factory, logger log.Logger) (*Publisher, error) {
-	logger = log.NewContext(logger).With("component", "Etcd Publisher")
-
 	p := &Publisher{
-		client:    c,
-		prefix:    prefix,
-		factory:   f,
-		logger:    logger,
-		endpoints: make(chan []endpoint.Endpoint),
-		quit:      make(chan struct{}),
+		client: c,
+		prefix: prefix,
+		cache:  loadbalancer.NewEndpointCache(f, logger),
+		logger: logger,
+		quit:   make(chan struct{}),
 	}
 
-	entries, err := p.client.GetEntries(prefix)
-	if err != nil {
-		return nil, err
+	instances, err := p.client.GetEntries(p.prefix)
+	if err == nil {
+		logger.Log(p.prefix, len(instances))
+	} else {
+		logger.Log("msg", "failed to retrieve entries", "err", err)
 	}
-	go p.loop(makeEndpoints(entries, f, logger))
+	p.cache.Replace(instances)
+
+	go p.loop()
 	return p, nil
 }
 
-func (p *Publisher) loop(endpoints []endpoint.Endpoint) {
+func (p *Publisher) loop() {
 	responseChan := make(chan *etcd.Response)
 	go p.client.WatchPrefix(p.prefix, responseChan)
-
 	for {
 		select {
-		case p.endpoints <- endpoints:
-
 		case <-responseChan:
-			entries, err := p.client.GetEntries(p.prefix)
+			instances, err := p.client.GetEntries(p.prefix)
 			if err != nil {
 				p.logger.Log("msg", "failed to retrieve entries", "err", err)
 				continue
 			}
-			endpoints = makeEndpoints(entries, p.factory, p.logger)
+			p.cache.Replace(instances)
 
 		case <-p.quit:
 			return
@@ -65,29 +62,10 @@ func (p *Publisher) loop(endpoints []endpoint.Endpoint) {
 
 // Endpoints implements the Publisher interface.
 func (p *Publisher) Endpoints() ([]endpoint.Endpoint, error) {
-	select {
-	case endpoints := <-p.endpoints:
-		return endpoints, nil
-	case <-p.quit:
-		return nil, loadbalancer.ErrPublisherStopped
-	}
+	return p.cache.Endpoints(), nil
 }
 
-// Stop terminates the publisher.
+// Stop terminates the Publisher.
 func (p *Publisher) Stop() {
 	close(p.quit)
 }
-
-func makeEndpoints(addrs []string, f loadbalancer.Factory, logger log.Logger) []endpoint.Endpoint {
-	endpoints := make([]endpoint.Endpoint, 0, len(addrs))
-
-	for _, addr := range addrs {
-		endpoint, err := f(addr)
-		if err != nil {
-			logger.Log("instance", addr, "err", err)
-			continue
-		}
-		endpoints = append(endpoints, endpoint)
-	}
-	return endpoints
-}
diff --git a/loadbalancer/factory.go b/loadbalancer/factory.go
index 2974033..71a7be5 100644
--- a/loadbalancer/factory.go
+++ b/loadbalancer/factory.go
@@ -1,6 +1,10 @@
 package loadbalancer
 
-import "github.com/go-kit/kit/endpoint"
+import (
+	"io"
+
+	"github.com/go-kit/kit/endpoint"
+)
 
 // Factory is a function that converts an instance string, e.g. a host:port,
 // to a usable endpoint. Factories are used by load balancers to convert
@@ -8,4 +12,4 @@ import "github.com/go-kit/kit/endpoint"
 // endpoints. Users are expected to provide their own factory functions that
 // assume specific transports, or can deduce transports by parsing the
 // instance string.
-type Factory func(instance string) (endpoint.Endpoint, error)
+type Factory func(instance string) (endpoint.Endpoint, io.Closer, error)
diff --git a/loadbalancer/publisher.go b/loadbalancer/publisher.go
index d175da8..ec17d7e 100644
--- a/loadbalancer/publisher.go
+++ b/loadbalancer/publisher.go
@@ -1,10 +1,6 @@
 package loadbalancer
 
-import (
-	"errors"
-
-	"github.com/go-kit/kit/endpoint"
-)
+import "github.com/go-kit/kit/endpoint"
 
 // Publisher describes something that provides a set of identical endpoints.
 // Different publisher implementations exist for different kinds of service
@@ -12,7 +8,3 @@ import (
 type Publisher interface {
 	Endpoints() ([]endpoint.Endpoint, error)
 }
-
-// ErrPublisherStopped is returned by publishers when the underlying
-// implementation has been terminated and can no longer serve requests.
-var ErrPublisherStopped = errors.New("publisher stopped")
diff --git a/loadbalancer/static/publisher.go b/loadbalancer/static/publisher.go
index d92948a..88b0f26 100644
--- a/loadbalancer/static/publisher.go
+++ b/loadbalancer/static/publisher.go
@@ -8,19 +8,24 @@ import (
 )
 
 // Publisher yields a set of static endpoints as produced by the passed factory.
-type Publisher struct{ *fixed.Publisher }
+type Publisher struct{ publisher *fixed.Publisher }
 
 // NewPublisher returns a static endpoint Publisher.
 func NewPublisher(instances []string, factory loadbalancer.Factory, logger log.Logger) Publisher {
-	logger = log.NewContext(logger).With("component", "Fixed Publisher")
+	logger = log.NewContext(logger).With("component", "Static Publisher")
 	endpoints := []endpoint.Endpoint{}
 	for _, instance := range instances {
-		e, err := factory(instance)
+		e, _, err := factory(instance) // never close
 		if err != nil {
 			_ = logger.Log("instance", instance, "err", err)
 			continue
 		}
 		endpoints = append(endpoints, e)
 	}
-	return Publisher{fixed.NewPublisher(endpoints)}
+	return Publisher{publisher: fixed.NewPublisher(endpoints)}
+}
+
+// Endpoints implements Publisher.
+func (p Publisher) Endpoints() ([]endpoint.Endpoint, error) {
+	return p.publisher.Endpoints()
 }
