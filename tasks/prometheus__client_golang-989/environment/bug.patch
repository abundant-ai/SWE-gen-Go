diff --git a/prometheus/desc.go b/prometheus/desc.go
index ee81107..4bb816a 100644
--- a/prometheus/desc.go
+++ b/prometheus/desc.go
@@ -20,8 +20,6 @@ import (
 	"strings"
 
 	"github.com/cespare/xxhash/v2"
-	"github.com/prometheus/client_golang/prometheus/internal"
-
 	//nolint:staticcheck // Ignore SA1019. Need to keep deprecated package for compatibility.
 	"github.com/golang/protobuf/proto"
 	"github.com/prometheus/common/model"
@@ -156,7 +154,7 @@ func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *
 			Value: proto.String(v),
 		})
 	}
-	sort.Sort(internal.LabelPairSorter(d.constLabelPairs))
+	sort.Sort(labelPairSorter(d.constLabelPairs))
 	return d
 }
 
diff --git a/prometheus/internal/metric.go b/prometheus/internal/metric.go
index 6515c11..351c26e 100644
--- a/prometheus/internal/metric.go
+++ b/prometheus/internal/metric.go
@@ -19,34 +19,18 @@ import (
 	dto "github.com/prometheus/client_model/go"
 )
 
-// LabelPairSorter implements sort.Interface. It is used to sort a slice of
-// dto.LabelPair pointers.
-type LabelPairSorter []*dto.LabelPair
+// metricSorter is a sortable slice of *dto.Metric.
+type metricSorter []*dto.Metric
 
-func (s LabelPairSorter) Len() int {
+func (s metricSorter) Len() int {
 	return len(s)
 }
 
-func (s LabelPairSorter) Swap(i, j int) {
+func (s metricSorter) Swap(i, j int) {
 	s[i], s[j] = s[j], s[i]
 }
 
-func (s LabelPairSorter) Less(i, j int) bool {
-	return s[i].GetName() < s[j].GetName()
-}
-
-// MetricSorter is a sortable slice of *dto.Metric.
-type MetricSorter []*dto.Metric
-
-func (s MetricSorter) Len() int {
-	return len(s)
-}
-
-func (s MetricSorter) Swap(i, j int) {
-	s[i], s[j] = s[j], s[i]
-}
-
-func (s MetricSorter) Less(i, j int) bool {
+func (s metricSorter) Less(i, j int) bool {
 	if len(s[i].Label) != len(s[j].Label) {
 		// This should not happen. The metrics are
 		// inconsistent. However, we have to deal with the fact, as
@@ -84,7 +68,7 @@ func (s MetricSorter) Less(i, j int) bool {
 // the slice, with the contained Metrics sorted within each MetricFamily.
 func NormalizeMetricFamilies(metricFamiliesByName map[string]*dto.MetricFamily) []*dto.MetricFamily {
 	for _, mf := range metricFamiliesByName {
-		sort.Sort(MetricSorter(mf.Metric))
+		sort.Sort(metricSorter(mf.Metric))
 	}
 	names := make([]string, 0, len(metricFamiliesByName))
 	for name, mf := range metricFamiliesByName {
diff --git a/prometheus/metric.go b/prometheus/metric.go
index 118a54e..dc12191 100644
--- a/prometheus/metric.go
+++ b/prometheus/metric.go
@@ -115,6 +115,22 @@ func BuildFQName(namespace, subsystem, name string) string {
 	return name
 }
 
+// labelPairSorter implements sort.Interface. It is used to sort a slice of
+// dto.LabelPair pointers.
+type labelPairSorter []*dto.LabelPair
+
+func (s labelPairSorter) Len() int {
+	return len(s)
+}
+
+func (s labelPairSorter) Swap(i, j int) {
+	s[i], s[j] = s[j], s[i]
+}
+
+func (s labelPairSorter) Less(i, j int) bool {
+	return s[i].GetName() < s[j].GetName()
+}
+
 type invalidMetric struct {
 	desc *Desc
 	err  error
diff --git a/prometheus/promhttp/http.go b/prometheus/promhttp/http.go
index a6e4f85..d86d0cf 100644
--- a/prometheus/promhttp/http.go
+++ b/prometheus/promhttp/http.go
@@ -84,13 +84,6 @@ func Handler() http.Handler {
 // instrumentation. Use the InstrumentMetricHandler function to apply the same
 // kind of instrumentation as it is used by the Handler function.
 func HandlerFor(reg prometheus.Gatherer, opts HandlerOpts) http.Handler {
-	return HandlerForTransactional(prometheus.ToTransactionalGatherer(reg), opts)
-}
-
-// HandlerForTransactional is like HandlerFor, but it uses transactional gather, which
-// can safely change in-place returned *dto.MetricFamily before call to `Gather` and after
-// call to `done` of that `Gather`.
-func HandlerForTransactional(reg prometheus.TransactionalGatherer, opts HandlerOpts) http.Handler {
 	var (
 		inFlightSem chan struct{}
 		errCnt      = prometheus.NewCounterVec(
@@ -130,8 +123,7 @@ func HandlerForTransactional(reg prometheus.TransactionalGatherer, opts HandlerO
 				return
 			}
 		}
-		mfs, done, err := reg.Gather()
-		defer done()
+		mfs, err := reg.Gather()
 		if err != nil {
 			if opts.ErrorLog != nil {
 				opts.ErrorLog.Println("error gathering metrics:", err)
diff --git a/prometheus/promhttp/http_test.go b/prometheus/promhttp/http_test.go
index 53204c5..781ea8f 100644
--- a/prometheus/promhttp/http_test.go
+++ b/prometheus/promhttp/http_test.go
@@ -16,7 +16,6 @@ package promhttp
 import (
 	"bytes"
 	"errors"
-	"fmt"
 	"log"
 	"net/http"
 	"net/http/httptest"
@@ -25,7 +24,6 @@ import (
 	"time"
 
 	"github.com/prometheus/client_golang/prometheus"
-	dto "github.com/prometheus/client_model/go"
 )
 
 type errorCollector struct{}
@@ -58,19 +56,8 @@ func (b blockingCollector) Collect(ch chan<- prometheus.Metric) {
 	<-b.Block
 }
 
-type mockTransactionGatherer struct {
-	g             prometheus.Gatherer
-	gatherInvoked int
-	doneInvoked   int
-}
-
-func (g *mockTransactionGatherer) Gather() (_ []*dto.MetricFamily, done func(), err error) {
-	g.gatherInvoked++
-	mfs, err := g.g.Gather()
-	return mfs, func() { g.doneInvoked++ }, err
-}
-
 func TestHandlerErrorHandling(t *testing.T) {
+
 	// Create a registry that collects a MetricFamily with two elements,
 	// another with one, and reports an error. Further down, we'll use the
 	// same registry in the HandlerOpts.
@@ -103,30 +90,21 @@ func TestHandlerErrorHandling(t *testing.T) {
 	request, _ := http.NewRequest("GET", "/", nil)
 	request.Header.Add("Accept", "test/plain")
 
-	mReg := &mockTransactionGatherer{g: reg}
-	errorHandler := HandlerForTransactional(mReg, HandlerOpts{
+	errorHandler := HandlerFor(reg, HandlerOpts{
 		ErrorLog:      logger,
 		ErrorHandling: HTTPErrorOnError,
 		Registry:      reg,
 	})
-	continueHandler := HandlerForTransactional(mReg, HandlerOpts{
+	continueHandler := HandlerFor(reg, HandlerOpts{
 		ErrorLog:      logger,
 		ErrorHandling: ContinueOnError,
 		Registry:      reg,
 	})
-	panicHandler := HandlerForTransactional(mReg, HandlerOpts{
+	panicHandler := HandlerFor(reg, HandlerOpts{
 		ErrorLog:      logger,
 		ErrorHandling: PanicOnError,
 		Registry:      reg,
 	})
-	// Expect gatherer not touched.
-	if got := mReg.gatherInvoked; got != 0 {
-		t.Fatalf("unexpected number of gather invokes, want 0, got %d", got)
-	}
-	if got := mReg.doneInvoked; got != 0 {
-		t.Fatalf("unexpected number of done invokes, want 0, got %d", got)
-	}
-
 	wantMsg := `error gathering metrics: error collecting metric Desc{fqName: "invalid_metric", help: "not helpful", constLabels: {}, variableLabels: []}: collect error
 `
 	wantErrorBody := `An error has occurred while serving metrics:
@@ -162,39 +140,25 @@ the_count 0
 `
 
 	errorHandler.ServeHTTP(writer, request)
-	if got := mReg.gatherInvoked; got != 1 {
-		t.Fatalf("unexpected number of gather invokes, want 1, got %d", got)
-	}
-	if got := mReg.doneInvoked; got != 1 {
-		t.Fatalf("unexpected number of done invokes, want 1, got %d", got)
-	}
 	if got, want := writer.Code, http.StatusInternalServerError; got != want {
 		t.Errorf("got HTTP status code %d, want %d", got, want)
 	}
-	if got, want := logBuf.String(), wantMsg; got != want {
-		t.Errorf("got log buf %q, want %q", got, want)
+	if got := logBuf.String(); got != wantMsg {
+		t.Errorf("got log message:\n%s\nwant log message:\n%s\n", got, wantMsg)
 	}
-	if got, want := writer.Body.String(), wantErrorBody; got != want {
-		t.Errorf("got body %q, want %q", got, want)
+	if got := writer.Body.String(); got != wantErrorBody {
+		t.Errorf("got body:\n%s\nwant body:\n%s\n", got, wantErrorBody)
 	}
-
 	logBuf.Reset()
 	writer.Body.Reset()
 	writer.Code = http.StatusOK
 
 	continueHandler.ServeHTTP(writer, request)
-
-	if got := mReg.gatherInvoked; got != 2 {
-		t.Fatalf("unexpected number of gather invokes, want 2, got %d", got)
-	}
-	if got := mReg.doneInvoked; got != 2 {
-		t.Fatalf("unexpected number of done invokes, want 2, got %d", got)
-	}
 	if got, want := writer.Code, http.StatusOK; got != want {
 		t.Errorf("got HTTP status code %d, want %d", got, want)
 	}
-	if got, want := logBuf.String(), wantMsg; got != want {
-		t.Errorf("got log buf %q, want %q", got, want)
+	if got := logBuf.String(); got != wantMsg {
+		t.Errorf("got log message %q, want %q", got, wantMsg)
 	}
 	if got := writer.Body.String(); got != wantOKBody1 && got != wantOKBody2 {
 		t.Errorf("got body %q, want either %q or %q", got, wantOKBody1, wantOKBody2)
@@ -204,34 +168,20 @@ the_count 0
 		if err := recover(); err == nil {
 			t.Error("expected panic from panicHandler")
 		}
-		if got := mReg.gatherInvoked; got != 3 {
-			t.Fatalf("unexpected number of gather invokes, want 3, got %d", got)
-		}
-		if got := mReg.doneInvoked; got != 3 {
-			t.Fatalf("unexpected number of done invokes, want 3, got %d", got)
-		}
 	}()
 	panicHandler.ServeHTTP(writer, request)
 }
 
 func TestInstrumentMetricHandler(t *testing.T) {
 	reg := prometheus.NewRegistry()
-	mReg := &mockTransactionGatherer{g: reg}
-	handler := InstrumentMetricHandler(reg, HandlerForTransactional(mReg, HandlerOpts{}))
+	handler := InstrumentMetricHandler(reg, HandlerFor(reg, HandlerOpts{}))
 	// Do it again to test idempotency.
-	InstrumentMetricHandler(reg, HandlerForTransactional(mReg, HandlerOpts{}))
+	InstrumentMetricHandler(reg, HandlerFor(reg, HandlerOpts{}))
 	writer := httptest.NewRecorder()
 	request, _ := http.NewRequest("GET", "/", nil)
 	request.Header.Add("Accept", "test/plain")
 
 	handler.ServeHTTP(writer, request)
-	if got := mReg.gatherInvoked; got != 1 {
-		t.Fatalf("unexpected number of gather invokes, want 1, got %d", got)
-	}
-	if got := mReg.doneInvoked; got != 1 {
-		t.Fatalf("unexpected number of done invokes, want 1, got %d", got)
-	}
-
 	if got, want := writer.Code, http.StatusOK; got != want {
 		t.Errorf("got HTTP status code %d, want %d", got, want)
 	}
@@ -245,28 +195,19 @@ func TestInstrumentMetricHandler(t *testing.T) {
 		t.Errorf("got body %q, does not contain %q", got, want)
 	}
 
-	for i := 0; i < 100; i++ {
-		writer.Body.Reset()
-		handler.ServeHTTP(writer, request)
-
-		if got, want := mReg.gatherInvoked, i+2; got != want {
-			t.Fatalf("unexpected number of gather invokes, want %d, got %d", want, got)
-		}
-		if got, want := mReg.doneInvoked, i+2; got != want {
-			t.Fatalf("unexpected number of done invokes, want %d, got %d", want, got)
-		}
-		if got, want := writer.Code, http.StatusOK; got != want {
-			t.Errorf("got HTTP status code %d, want %d", got, want)
-		}
+	writer.Body.Reset()
+	handler.ServeHTTP(writer, request)
+	if got, want := writer.Code, http.StatusOK; got != want {
+		t.Errorf("got HTTP status code %d, want %d", got, want)
+	}
 
-		want := "promhttp_metric_handler_requests_in_flight 1\n"
-		if got := writer.Body.String(); !strings.Contains(got, want) {
-			t.Errorf("got body %q, does not contain %q", got, want)
-		}
-		want = fmt.Sprintf("promhttp_metric_handler_requests_total{code=\"200\"} %d\n", i+1)
-		if got := writer.Body.String(); !strings.Contains(got, want) {
-			t.Errorf("got body %q, does not contain %q", got, want)
-		}
+	want = "promhttp_metric_handler_requests_in_flight 1\n"
+	if got := writer.Body.String(); !strings.Contains(got, want) {
+		t.Errorf("got body %q, does not contain %q", got, want)
+	}
+	want = "promhttp_metric_handler_requests_total{code=\"200\"} 1\n"
+	if got := writer.Body.String(); !strings.Contains(got, want) {
+		t.Errorf("got body %q, does not contain %q", got, want)
 	}
 }
 
diff --git a/prometheus/registry.go b/prometheus/registry.go
index 5046f7e..383a7f5 100644
--- a/prometheus/registry.go
+++ b/prometheus/registry.go
@@ -407,14 +407,6 @@ func (r *Registry) MustRegister(cs ...Collector) {
 
 // Gather implements Gatherer.
 func (r *Registry) Gather() ([]*dto.MetricFamily, error) {
-	r.mtx.RLock()
-
-	if len(r.collectorsByID) == 0 && len(r.uncheckedCollectors) == 0 {
-		// Fast path.
-		r.mtx.RUnlock()
-		return nil, nil
-	}
-
 	var (
 		checkedMetricChan   = make(chan Metric, capMetricChan)
 		uncheckedMetricChan = make(chan Metric, capMetricChan)
@@ -424,6 +416,7 @@ func (r *Registry) Gather() ([]*dto.MetricFamily, error) {
 		registeredDescIDs   map[uint64]struct{} // Only used for pedantic checks
 	)
 
+	r.mtx.RLock()
 	goroutineBudget := len(r.collectorsByID) + len(r.uncheckedCollectors)
 	metricFamiliesByName := make(map[string]*dto.MetricFamily, len(r.dimHashesByName))
 	checkedCollectors := make(chan Collector, len(r.collectorsByID))
@@ -891,11 +884,11 @@ func checkMetricConsistency(
 	h.Write(separatorByteSlice)
 	// Make sure label pairs are sorted. We depend on it for the consistency
 	// check.
-	if !sort.IsSorted(internal.LabelPairSorter(dtoMetric.Label)) {
+	if !sort.IsSorted(labelPairSorter(dtoMetric.Label)) {
 		// We cannot sort dtoMetric.Label in place as it is immutable by contract.
 		copiedLabels := make([]*dto.LabelPair, len(dtoMetric.Label))
 		copy(copiedLabels, dtoMetric.Label)
-		sort.Sort(internal.LabelPairSorter(copiedLabels))
+		sort.Sort(labelPairSorter(copiedLabels))
 		dtoMetric.Label = copiedLabels
 	}
 	for _, lp := range dtoMetric.Label {
@@ -942,7 +935,7 @@ func checkDescConsistency(
 			metricFamily.GetName(), dtoMetric, desc,
 		)
 	}
-	sort.Sort(internal.LabelPairSorter(lpsFromDesc))
+	sort.Sort(labelPairSorter(lpsFromDesc))
 	for i, lpFromDesc := range lpsFromDesc {
 		lpFromMetric := dtoMetric.Label[i]
 		if lpFromDesc.GetName() != lpFromMetric.GetName() ||
@@ -955,89 +948,3 @@ func checkDescConsistency(
 	}
 	return nil
 }
-
-var _ TransactionalGatherer = &MultiTRegistry{}
-
-// MultiTRegistry is a TransactionalGatherer that joins gathered metrics from multiple
-// transactional gatherers.
-//
-// It is caller responsibility to ensure two registries have mutually exclusive metric families,
-// no deduplication will happen.
-type MultiTRegistry struct {
-	tGatherers []TransactionalGatherer
-}
-
-// NewMultiTRegistry creates MultiTRegistry.
-func NewMultiTRegistry(tGatherers ...TransactionalGatherer) *MultiTRegistry {
-	return &MultiTRegistry{
-		tGatherers: tGatherers,
-	}
-}
-
-// Gather implements TransactionalGatherer interface.
-func (r *MultiTRegistry) Gather() (mfs []*dto.MetricFamily, done func(), err error) {
-	errs := MultiError{}
-
-	dFns := make([]func(), 0, len(r.tGatherers))
-	// TODO(bwplotka): Implement concurrency for those?
-	for _, g := range r.tGatherers {
-		// TODO(bwplotka): Check for duplicates?
-		m, d, err := g.Gather()
-		errs.Append(err)
-
-		mfs = append(mfs, m...)
-		dFns = append(dFns, d)
-	}
-
-	// TODO(bwplotka): Consider sort in place, given metric family in gather is sorted already.
-	sort.Slice(mfs, func(i, j int) bool {
-		return *mfs[i].Name < *mfs[j].Name
-	})
-	return mfs, func() {
-		for _, d := range dFns {
-			d()
-		}
-	}, errs.MaybeUnwrap()
-}
-
-// TransactionalGatherer represents transactional gatherer that can be triggered to notify gatherer that memory
-// used by metric family is no longer used by a caller. This allows implementations with cache.
-type TransactionalGatherer interface {
-	// Gather returns metrics in a lexicographically sorted slice
-	// of uniquely named MetricFamily protobufs. Gather ensures that the
-	// returned slice is valid and self-consistent so that it can be used
-	// for valid exposition. As an exception to the strict consistency
-	// requirements described for metric.Desc, Gather will tolerate
-	// different sets of label names for metrics of the same metric family.
-	//
-	// Even if an error occurs, Gather attempts to gather as many metrics as
-	// possible. Hence, if a non-nil error is returned, the returned
-	// MetricFamily slice could be nil (in case of a fatal error that
-	// prevented any meaningful metric collection) or contain a number of
-	// MetricFamily protobufs, some of which might be incomplete, and some
-	// might be missing altogether. The returned error (which might be a
-	// MultiError) explains the details. Note that this is mostly useful for
-	// debugging purposes. If the gathered protobufs are to be used for
-	// exposition in actual monitoring, it is almost always better to not
-	// expose an incomplete result and instead disregard the returned
-	// MetricFamily protobufs in case the returned error is non-nil.
-	//
-	// Important: done is expected to be triggered (even if the error occurs!)
-	// once caller does not need returned slice of dto.MetricFamily.
-	Gather() (_ []*dto.MetricFamily, done func(), err error)
-}
-
-// ToTransactionalGatherer transforms Gatherer to transactional one with noop as done function.
-func ToTransactionalGatherer(g Gatherer) TransactionalGatherer {
-	return &noTransactionGatherer{g: g}
-}
-
-type noTransactionGatherer struct {
-	g Gatherer
-}
-
-// Gather implements TransactionalGatherer interface.
-func (g *noTransactionGatherer) Gather() (_ []*dto.MetricFamily, done func(), err error) {
-	mfs, err := g.g.Gather()
-	return mfs, func() {}, err
-}
diff --git a/prometheus/registry_test.go b/prometheus/registry_test.go
index 7a959da..0ff7a64 100644
--- a/prometheus/registry_test.go
+++ b/prometheus/registry_test.go
@@ -21,7 +21,6 @@ package prometheus_test
 
 import (
 	"bytes"
-	"errors"
 	"fmt"
 	"io/ioutil"
 	"math/rand"
@@ -1176,82 +1175,3 @@ func TestAlreadyRegisteredCollision(t *testing.T) {
 		}
 	}
 }
-
-type tGatherer struct {
-	done bool
-	err  error
-}
-
-func (g *tGatherer) Gather() (_ []*dto.MetricFamily, done func(), err error) {
-	name := "g1"
-	val := 1.0
-	return []*dto.MetricFamily{
-		{Name: &name, Metric: []*dto.Metric{{Gauge: &dto.Gauge{Value: &val}}}},
-	}, func() { g.done = true }, g.err
-}
-
-func TestNewMultiTRegistry(t *testing.T) {
-	treg := &tGatherer{}
-
-	t.Run("one registry", func(t *testing.T) {
-		m := prometheus.NewMultiTRegistry(treg)
-		ret, done, err := m.Gather()
-		if err != nil {
-			t.Error("gather failed:", err)
-		}
-		done()
-		if len(ret) != 1 {
-			t.Error("unexpected number of metric families, expected 1, got", ret)
-		}
-		if !treg.done {
-			t.Error("inner transactional registry not marked as done")
-		}
-	})
-
-	reg := prometheus.NewRegistry()
-	if err := reg.Register(prometheus.NewCounter(prometheus.CounterOpts{Name: "c1", Help: "help c1"})); err != nil {
-		t.Error("registration failed:", err)
-	}
-
-	// Note on purpose two registries will have exactly same metric family name (but with different string).
-	// This behaviour is undefined at the moment.
-	if err := reg.Register(prometheus.NewGauge(prometheus.GaugeOpts{Name: "g1", Help: "help g1"})); err != nil {
-		t.Error("registration failed:", err)
-	}
-	treg.done = false
-
-	t.Run("two registries", func(t *testing.T) {
-		m := prometheus.NewMultiTRegistry(prometheus.ToTransactionalGatherer(reg), treg)
-		ret, done, err := m.Gather()
-		if err != nil {
-			t.Error("gather failed:", err)
-		}
-		done()
-		if len(ret) != 3 {
-			t.Error("unexpected number of metric families, expected 3, got", ret)
-		}
-		if !treg.done {
-			t.Error("inner transactional registry not marked as done")
-		}
-	})
-
-	treg.done = false
-	// Inject error.
-	treg.err = errors.New("test err")
-
-	t.Run("two registries, one with error", func(t *testing.T) {
-		m := prometheus.NewMultiTRegistry(prometheus.ToTransactionalGatherer(reg), treg)
-		ret, done, err := m.Gather()
-		if err != treg.err {
-			t.Error("unexpected error:", err)
-		}
-		done()
-		if len(ret) != 3 {
-			t.Error("unexpected number of metric families, expected 3, got", ret)
-		}
-		// Still on error, we expect done to be triggered.
-		if !treg.done {
-			t.Error("inner transactional registry not marked as done")
-		}
-	})
-}
diff --git a/prometheus/testutil/testutil.go b/prometheus/testutil/testutil.go
index bf95bea..9af60ce 100644
--- a/prometheus/testutil/testutil.go
+++ b/prometheus/testutil/testutil.go
@@ -167,16 +167,7 @@ func CollectAndCompare(c prometheus.Collector, expected io.Reader, metricNames .
 // exposition format. If any metricNames are provided, only metrics with those
 // names are compared.
 func GatherAndCompare(g prometheus.Gatherer, expected io.Reader, metricNames ...string) error {
-	return TransactionalGatherAndCompare(prometheus.ToTransactionalGatherer(g), expected, metricNames...)
-}
-
-// TransactionalGatherAndCompare gathers all metrics from the provided Gatherer and compares
-// it to an expected output read from the provided Reader in the Prometheus text
-// exposition format. If any metricNames are provided, only metrics with those
-// names are compared.
-func TransactionalGatherAndCompare(g prometheus.TransactionalGatherer, expected io.Reader, metricNames ...string) error {
-	got, done, err := g.Gather()
-	defer done()
+	got, err := g.Gather()
 	if err != nil {
 		return fmt.Errorf("gathering metrics failed: %s", err)
 	}
diff --git a/prometheus/value.go b/prometheus/value.go
index 9f10695..b4e0ae1 100644
--- a/prometheus/value.go
+++ b/prometheus/value.go
@@ -21,7 +21,6 @@ import (
 
 	//nolint:staticcheck // Ignore SA1019. Need to keep deprecated package for compatibility.
 	"github.com/golang/protobuf/proto"
-	"github.com/prometheus/client_golang/prometheus/internal"
 	"google.golang.org/protobuf/types/known/timestamppb"
 
 	dto "github.com/prometheus/client_model/go"
@@ -39,23 +38,6 @@ const (
 	UntypedValue
 )
 
-var (
-	CounterMetricTypePtr = func() *dto.MetricType { d := dto.MetricType_COUNTER; return &d }()
-	GaugeMetricTypePtr   = func() *dto.MetricType { d := dto.MetricType_GAUGE; return &d }()
-	UntypedMetricTypePtr = func() *dto.MetricType { d := dto.MetricType_UNTYPED; return &d }()
-)
-
-func (v ValueType) ToDTO() *dto.MetricType {
-	switch v {
-	case CounterValue:
-		return CounterMetricTypePtr
-	case GaugeValue:
-		return GaugeMetricTypePtr
-	default:
-		return UntypedMetricTypePtr
-	}
-}
-
 // valueFunc is a generic metric for simple values retrieved on collect time
 // from a function. It implements Metric and Collector. Its effective type is
 // determined by ValueType. This is a low-level building block used by the
@@ -109,15 +91,11 @@ func NewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues
 	if err := validateLabelValues(labelValues, len(desc.variableLabels)); err != nil {
 		return nil, err
 	}
-
-	metric := &dto.Metric{}
-	if err := populateMetric(valueType, value, MakeLabelPairs(desc, labelValues), nil, metric); err != nil {
-		return nil, err
-	}
-
 	return &constMetric{
-		desc:   desc,
-		metric: metric,
+		desc:       desc,
+		valType:    valueType,
+		val:        value,
+		labelPairs: MakeLabelPairs(desc, labelValues),
 	}, nil
 }
 
@@ -132,8 +110,10 @@ func MustNewConstMetric(desc *Desc, valueType ValueType, value float64, labelVal
 }
 
 type constMetric struct {
-	desc   *Desc
-	metric *dto.Metric
+	desc       *Desc
+	valType    ValueType
+	val        float64
+	labelPairs []*dto.LabelPair
 }
 
 func (m *constMetric) Desc() *Desc {
@@ -141,11 +121,7 @@ func (m *constMetric) Desc() *Desc {
 }
 
 func (m *constMetric) Write(out *dto.Metric) error {
-	out.Label = m.metric.Label
-	out.Counter = m.metric.Counter
-	out.Gauge = m.metric.Gauge
-	out.Untyped = m.metric.Untyped
-	return nil
+	return populateMetric(m.valType, m.val, m.labelPairs, nil, out)
 }
 
 func populateMetric(
@@ -194,7 +170,7 @@ func MakeLabelPairs(desc *Desc, labelValues []string) []*dto.LabelPair {
 		})
 	}
 	labelPairs = append(labelPairs, desc.constLabelPairs...)
-	sort.Sort(internal.LabelPairSorter(labelPairs))
+	sort.Sort(labelPairSorter(labelPairs))
 	return labelPairs
 }
 
diff --git a/prometheus/wrap.go b/prometheus/wrap.go
index c29f94b..74ee932 100644
--- a/prometheus/wrap.go
+++ b/prometheus/wrap.go
@@ -20,7 +20,6 @@ import (
 	//nolint:staticcheck // Ignore SA1019. Need to keep deprecated package for compatibility.
 	"github.com/golang/protobuf/proto"
 
-	"github.com/prometheus/client_golang/prometheus/internal"
 	dto "github.com/prometheus/client_model/go"
 )
 
@@ -183,7 +182,7 @@ func (m *wrappingMetric) Write(out *dto.Metric) error {
 			Value: proto.String(lv),
 		})
 	}
-	sort.Sort(internal.LabelPairSorter(out.Label))
+	sort.Sort(labelPairSorter(out.Label))
 	return nil
 }
 
