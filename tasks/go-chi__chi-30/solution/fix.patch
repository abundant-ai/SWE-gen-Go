diff --git a/.travis.yml b/.travis.yml
index 0e98fda..228a3d2 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,7 +3,7 @@ language: go
 go:
   - 1.4
   - 1.5
-  - tip
+  - 1.6
 
 install:
   - go get -u golang.org/x/tools/cmd/goimports
diff --git a/LICENSE b/LICENSE
index 88d5ed9..b1e7c84 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,4 +1,4 @@
-Copyright (c) 2015 Peter Kieltyka (https://twitter.com/peterk)
+Copyright (c) 2015-2016 Peter Kieltyka (https://twitter.com/peterk)
 
 MIT License
 
diff --git a/README.md b/README.md
index fd39dfb..6bb1e87 100644
--- a/README.md
+++ b/README.md
@@ -305,18 +305,16 @@ to reusing URLParams from a pool.
   * Trailing slash?
   * Case insensitive paths?
   * GET for HEAD requests (auto fallback)?
-* Register not found handler
-* Register error handler (500's)
+* Register error handler (500's), ServerError() handler?
 * HTTP2 example
   * both http 1.1 and http2 automatically.. just turn it on :)
-* Websocket example
 * Regexp support in router "/:id([0-9]+)" or "#id^[0-9]+$" or ..
 
 We'll be more than happy to see [your contributions](./CONTRIBUTING.md)!
 
 ## License
 
-Copyright (c) 2015 [Peter Kieltyka](https://github.com/pkieltyka)
+Copyright (c) 2015-2016 [Peter Kieltyka](https://github.com/pkieltyka)
 
 Licensed under [MIT License](./LICENSE)
 
diff --git a/chi.go b/chi.go
index 6364c11..f0adad7 100644
--- a/chi.go
+++ b/chi.go
@@ -20,6 +20,8 @@ type Router interface {
 	Mount(pattern string, handlers ...interface{})
 
 	Handle(pattern string, handlers ...interface{})
+	NotFound(h HandlerFunc)
+
 	Connect(pattern string, handlers ...interface{})
 	Head(pattern string, handlers ...interface{})
 	Get(pattern string, handlers ...interface{})
diff --git a/mux.go b/mux.go
index c49354a..733ff51 100644
--- a/mux.go
+++ b/mux.go
@@ -3,7 +3,6 @@ package chi
 import (
 	"fmt"
 	"net/http"
-	"strings"
 
 	"golang.org/x/net/context"
 )
@@ -16,7 +15,7 @@ type Mux struct {
 	middlewares []interface{}
 
 	// The radix trie router with URL parameter matching
-	router treeRouter
+	router *treeRouter
 
 	// The mux handler, chained middleware stack and tree router
 	handler Handler
@@ -24,9 +23,6 @@ type Mux struct {
 	// Controls the behaviour of middleware chain generation when a mux
 	// is registered as an inline group inside another mux.
 	inline bool
-
-	// can add rules here for how the mux should work..
-	// ie. slashes, case insensitive, notfound handler etc.. like httprouter
 }
 
 type methodTyp int
@@ -116,6 +112,11 @@ func (mx *Mux) Options(pattern string, handlers ...interface{}) {
 	mx.handle(mOPTIONS, pattern, handlers...)
 }
 
+// NotFound sets a custom handler for the case when no routes match
+func (mx *Mux) NotFound(h HandlerFunc) {
+	mx.router.notFoundHandler = &h
+}
+
 func (mx *Mux) handle(method methodTyp, pattern string, handlers ...interface{}) {
 	if len(pattern) == 0 || pattern[0] != '/' {
 		panic(fmt.Sprintf("pattern must begin with '/' in '%s'", pattern))
@@ -143,7 +144,7 @@ func (mx *Mux) handle(method methodTyp, pattern string, handlers ...interface{})
 	for _, mt := range methodMap {
 		m := method & mt
 		if m > 0 {
-			mx.router[m].Insert(pattern, endpoint)
+			mx.router.routes[m].Insert(pattern, endpoint)
 		}
 	}
 }
@@ -176,19 +177,28 @@ func (mx *Mux) Mount(path string, handlers ...interface{}) {
 	// Build chain with any inline middlewares and endpoint handler for the subrouter
 	h := chain([]interface{}{}, handlers...)
 
-	// Route the subroutes through a wildcard url param
-	subRouter := HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
+	// Assign sub-Router's with the parent not found handler if not specified.
+	for _, hh := range handlers {
+		if sr, ok := hh.(*Mux); ok {
+			if sr.router.notFoundHandler == nil && mx.router.notFoundHandler != nil {
+				sr.NotFound(*mx.router.notFoundHandler)
+			}
+		}
+	}
+
+	// Wrap the sub-router in a handlerFunc to scope the request path for routing.
+	subHandler := HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {
 		path := URLParams(ctx)["*"]
 		ctx = context.WithValue(ctx, SubRouterCtxKey, "/"+path)
 		h.ServeHTTPC(ctx, w, r)
 	})
 
 	if path == "" || path[len(path)-1] != '/' {
-		mx.Handle(path, subRouter)
-		mx.Handle(path+"/", http.NotFound) // TODO: which not-found handler..?
+		mx.Handle(path, subHandler)
+		mx.Handle(path+"/", mx.router.notFoundHandler)
 		path += "/"
 	}
-	mx.Handle(path+"*", subRouter)
+	mx.Handle(path+"*", subHandler)
 }
 
 func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
@@ -199,14 +209,23 @@ func (mx *Mux) ServeHTTPC(ctx context.Context, w http.ResponseWriter, r *http.Re
 	mx.handler.ServeHTTPC(ctx, w, r)
 }
 
-type treeRouter map[methodTyp]*tree
+type treeRouter struct {
+	// Routing tree by method type
+	routes map[methodTyp]*tree
+
+	// Custom route not found handler
+	notFoundHandler *HandlerFunc
+}
 
-func newTreeRouter() treeRouter {
-	tr := make(map[methodTyp]*tree, len(methodMap))
+func newTreeRouter() *treeRouter {
+	tr := &treeRouter{
+		routes:          make(map[methodTyp]*tree, len(methodMap)),
+		notFoundHandler: nil,
+	}
 	for _, v := range methodMap {
-		tr[v] = &tree{root: &node{}}
+		tr.routes[v] = &tree{root: &node{}}
 	}
-	return treeRouter(tr)
+	return tr
 }
 
 func (tr treeRouter) ServeHTTPC(ctx context.Context, w http.ResponseWriter, r *http.Request) {
@@ -228,34 +247,21 @@ func (tr treeRouter) ServeHTTPC(ctx context.Context, w http.ResponseWriter, r *h
 	// Check if method is supported by chi
 	method, ok := methodMap[r.Method]
 	if !ok {
-		writeMethodNotAllowed(w)
+		methodNotAllowedHandler(ctx, w, r)
 		return
 	}
 
 	// Find the handler in the router
-	cxh := tr[method].Find(routePath, params)
+	cxh := tr.routes[method].Find(routePath, params)
 	if cxh == nil {
-		w.WriteHeader(404)
-		w.Write([]byte(http.StatusText(404)))
+		if tr.notFoundHandler == nil {
+			http.NotFound(w, r)
+		} else {
+			tr.notFoundHandler.ServeHTTPC(ctx, w, r)
+		}
 		return
 	}
 
 	// Serve it
 	cxh.ServeHTTPC(ctx, w, r)
 }
-
-// Respond with just the allowed methods, as required by RFC2616 for
-// 405 Method not allowed.
-func writeMethodNotAllowed(w http.ResponseWriter) {
-	methods := make([]string, len(methodMap))
-	i := 0
-	for m := range methodMap {
-		methods[i] = m // still faster than append to array with capacity
-		i++
-	}
-
-	w.Header().Add("Allow", strings.Join(methods, ","))
-	w.WriteHeader(405)
-
-	w.Write([]byte(http.StatusText(405)))
-}
diff --git a/util.go b/util.go
index 068f7d7..5e6eb3f 100644
--- a/util.go
+++ b/util.go
@@ -3,6 +3,7 @@ package chi
 import (
 	"fmt"
 	"net/http"
+	"strings"
 
 	"golang.org/x/net/context"
 )
@@ -85,3 +86,18 @@ func assertMiddleware(middleware interface{}) interface{} {
 	}
 	return middleware
 }
+
+// Respond with just the allowed methods, as required by RFC2616 for
+// 405 Method not allowed.
+func methodNotAllowedHandler(ctx context.Context, w http.ResponseWriter, r *http.Request) {
+	methods := make([]string, len(methodMap))
+	i := 0
+	for m := range methodMap {
+		methods[i] = m // still faster than append to array with capacity
+		i++
+	}
+
+	w.Header().Add("Allow", strings.Join(methods, ","))
+	w.WriteHeader(405)
+	w.Write([]byte(http.StatusText(405)))
+}
