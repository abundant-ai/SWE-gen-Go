Under Go 1.7+ (notably observed on Go 1.11), using a gin.Context as a parent for standard-library context cancellation (e.g., via context.WithCancel, context.WithTimeout, or context.WithDeadline) can cause a runtime panic under concurrent load: `panic: context: internal error: missing cancel error`.

This happens because Gin reuses *gin.Context objects via a sync.Pool: after a request finishes, the same *gin.Context may be returned to the pool and quickly reused for a different request while a goroutine created by the standard library is still monitoring the original parent context’s Done channel to propagate cancellation to its children. When the old parent’s Done is observed as closed, the standard library cancels the child using parent.Err(). If the *gin.Context has already been reset/reused for a new request, its Err() can become nil or otherwise inconsistent with the Done signal, triggering the panic shown above.

Gin’s Context should not expose a request-scoped cancellation/deadline that is unsafe once the Context is returned to the pool. In particular, for Go 1.7+ behavior, gin.Context must not “inherit” cancellation/deadlines from http.Request.Context() in a way that allows gin.Context to be used as a long-lived parent context beyond the lifetime of the handler.

Fix gin.Context so that using it as a parent for context.WithCancel / context.WithTimeout / context.WithDeadline does not panic even when requests are handled concurrently and gin.Context instances are pooled and reused. The intended behavior is that gin.Context behaves like `context.Background()` plus `Value()` support for request-scoped key/value lookups, without participating in cancellation propagation from the underlying http.Request context.

After the change, normal handler operations must still work (including rendering helpers like calling `c.PureJSON(status, obj)` and getting the expected JSON body and Content-Type), but gin.Context must no longer cause cancellation-related panics when used with the standard library context package.