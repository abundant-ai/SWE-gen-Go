diff --git a/README.md b/README.md
index 8595397..6fd4958 100644
--- a/README.md
+++ b/README.md
@@ -15,7 +15,7 @@ The name mux stands for "HTTP request multiplexer". Like the standard `http.Serv
 
 * It implements the `http.Handler` interface so it is compatible with the standard `http.ServeMux`.
 * Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers.
-* URL hosts, paths and query values can have variables with an optional regular expression.
+* URL hosts and paths can have variables with an optional regular expression.
 * Registered URLs can be built, or "reversed", which helps maintaining references to resources.
 * Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching.
 
@@ -268,21 +268,19 @@ url, err := r.Get("article").URL("category", "technology", "id", "42")
 "/articles/technology/42"
 ```
 
-This also works for host and query value variables:
+This also works for host variables:
 
 ```go
 r := mux.NewRouter()
 r.Host("{subdomain}.domain.com").
   Path("/articles/{category}/{id:[0-9]+}").
-  Queries("filter", "{filter}")
   HandlerFunc(ArticleHandler).
   Name("article")
 
-// url.String() will be "http://news.domain.com/articles/technology/42?filter=gorilla"
+// url.String() will be "http://news.domain.com/articles/technology/42"
 url, err := r.Get("article").URL("subdomain", "news",
                                  "category", "technology",
-                                 "id", "42",
-                                 "filter", "gorilla")
+                                 "id", "42")
 ```
 
 All variables defined in the route are required, and their values must conform to the corresponding patterns. These requirements guarantee that a generated URL will always match a registered route -- the only exception is for explicitly defined "build-only" routes which never match.
diff --git a/doc.go b/doc.go
index cce30b2..00daf4a 100644
--- a/doc.go
+++ b/doc.go
@@ -12,8 +12,8 @@ or other conditions. The main features are:
 
 	* Requests can be matched based on URL host, path, path prefix, schemes,
 	  header and query values, HTTP methods or using custom matchers.
-	* URL hosts, paths and query values can have variables with an optional
-	  regular expression.
+	* URL hosts and paths can have variables with an optional regular
+	  expression.
 	* Registered URLs can be built, or "reversed", which helps maintaining
 	  references to resources.
 	* Routes can be used as subrouters: nested routes are only tested if the
@@ -188,20 +188,18 @@ key/value pairs for the route variables. For the previous route, we would do:
 
 	"/articles/technology/42"
 
-This also works for host and query value variables:
+This also works for host variables:
 
 	r := mux.NewRouter()
 	r.Host("{subdomain}.domain.com").
 	  Path("/articles/{category}/{id:[0-9]+}").
-	  Queries("filter", "{filter}").
 	  HandlerFunc(ArticleHandler).
 	  Name("article")
 
-	// url.String() will be "http://news.domain.com/articles/technology/42?filter=gorilla"
+	// url.String() will be "http://news.domain.com/articles/technology/42"
 	url, err := r.Get("article").URL("subdomain", "news",
 	                                 "category", "technology",
-	                                 "id", "42",
-	                                 "filter", "gorilla")
+	                                 "id", "42")
 
 All variables defined in the route are required, and their values must
 conform to the corresponding patterns. These requirements guarantee that a
diff --git a/mux_test.go b/mux_test.go
index 4340c50..dd7836b 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -36,7 +36,6 @@ type routeTest struct {
 	scheme         string            // the expected scheme of the built URL
 	host           string            // the expected host of the built URL
 	path           string            // the expected path of the built URL
-	query          string            // the expected query string of the built URL
 	pathTemplate   string            // the expected path template of the route
 	hostTemplate   string            // the expected host template of the route
 	methods        []string          // the expected route methods
@@ -745,7 +744,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{},
 			host:        "",
 			path:        "",
-			query:       "foo=bar&baz=ding",
 			shouldMatch: true,
 		},
 		{
@@ -755,7 +753,6 @@ func TestQueries(t *testing.T) {
 			vars:         map[string]string{},
 			host:         "",
 			path:         "",
-			query:        "foo=bar&baz=ding",
 			pathTemplate: `/api`,
 			hostTemplate: `www.example.com`,
 			shouldMatch:  true,
@@ -767,7 +764,6 @@ func TestQueries(t *testing.T) {
 			vars:         map[string]string{},
 			host:         "",
 			path:         "",
-			query:        "foo=bar&baz=ding",
 			pathTemplate: `/api`,
 			hostTemplate: `www.example.com`,
 			shouldMatch:  true,
@@ -788,7 +784,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v1": "bar"},
 			host:        "",
 			path:        "",
-			query:       "foo=bar",
 			shouldMatch: true,
 		},
 		{
@@ -798,7 +793,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v1": "bar", "v2": "ding"},
 			host:        "",
 			path:        "",
-			query:       "foo=bar&baz=ding",
 			shouldMatch: true,
 		},
 		{
@@ -808,7 +802,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v1": "10"},
 			host:        "",
 			path:        "",
-			query:       "foo=10",
 			shouldMatch: true,
 		},
 		{
@@ -827,7 +820,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v1": "1"},
 			host:        "",
 			path:        "",
-			query:       "foo=1",
 			shouldMatch: true,
 		},
 		{
@@ -837,7 +829,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v1": "1"},
 			host:        "",
 			path:        "",
-			query:       "foo=1",
 			shouldMatch: true,
 		},
 		{
@@ -856,7 +847,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v1": "1a"},
 			host:        "",
 			path:        "",
-			query:       "foo=1a",
 			shouldMatch: true,
 		},
 		{
@@ -875,7 +865,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v-1": "bar"},
 			host:        "",
 			path:        "",
-			query:       "foo=bar",
 			shouldMatch: true,
 		},
 		{
@@ -885,7 +874,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v-1": "bar", "v-2": "ding"},
 			host:        "",
 			path:        "",
-			query:       "foo=bar&baz=ding",
 			shouldMatch: true,
 		},
 		{
@@ -895,7 +883,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v-1": "10"},
 			host:        "",
 			path:        "",
-			query:       "foo=10",
 			shouldMatch: true,
 		},
 		{
@@ -905,7 +892,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"v-1": "1a"},
 			host:        "",
 			path:        "",
-			query:       "foo=1a",
 			shouldMatch: true,
 		},
 		{
@@ -915,7 +901,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{},
 			host:        "",
 			path:        "",
-			query:       "foo=",
 			shouldMatch: true,
 		},
 		{
@@ -934,7 +919,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{},
 			host:        "",
 			path:        "",
-			query:       "foo=",
 			shouldMatch: true,
 		},
 		{
@@ -962,7 +946,6 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{"foo": ""},
 			host:        "",
 			path:        "",
-			query:       "foo=",
 			shouldMatch: true,
 		},
 		{
@@ -974,16 +957,6 @@ func TestQueries(t *testing.T) {
 			path:        "",
 			shouldMatch: false,
 		},
-		{
-			title:       "Queries route with pattern, match, escaped value",
-			route:       new(Route).Queries("foo", "{v1}"),
-			request:     newRequest("GET", "http://localhost?foo=%25bar%26%20%2F%3D%3F"),
-			vars:        map[string]string{"v1": "%bar& /=?"},
-			host:        "",
-			path:        "",
-			query:       "foo=%25bar%26+%2F%3D%3F",
-			shouldMatch: true,
-		},
 	}
 
 	for _, test := range tests {
@@ -1564,7 +1537,6 @@ func testRoute(t *testing.T, test routeTest) {
 	route := test.route
 	vars := test.vars
 	shouldMatch := test.shouldMatch
-	query := test.query
 	shouldRedirect := test.shouldRedirect
 	uri := url.URL{
 		Scheme: test.scheme,
@@ -1634,13 +1606,6 @@ func testRoute(t *testing.T, test routeTest) {
 				return
 			}
 		}
-		if query != "" {
-			u, _ := route.URL(mapToPairs(match.Vars)...)
-			if query != u.RawQuery {
-				t.Errorf("(%v) URL query not equal: expected %v, got %v", test.title, query, u.RawQuery)
-				return
-			}
-		}
 		if shouldRedirect && match.Handler == nil {
 			t.Errorf("(%v) Did not redirect", test.title)
 			return
diff --git a/regexp.go b/regexp.go
index 80d1f78..0189ad3 100644
--- a/regexp.go
+++ b/regexp.go
@@ -35,7 +35,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash,
 	// Now let's parse it.
 	defaultPattern := "[^/]+"
 	if matchQuery {
-		defaultPattern = ".*"
+		defaultPattern = "[^?&]*"
 	} else if matchHost {
 		defaultPattern = "[^.]+"
 		matchPrefix = false
@@ -178,9 +178,6 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 		if !ok {
 			return "", fmt.Errorf("mux: missing route variable %q", v)
 		}
-		if r.matchQuery {
-			value = url.QueryEscape(value)
-		}
 		urlValues[k] = value
 	}
 	rv := fmt.Sprintf(r.reverse, urlValues...)
diff --git a/route.go b/route.go
index 916de74..56dcbbd 100644
--- a/route.go
+++ b/route.go
@@ -482,7 +482,6 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 		return nil, err
 	}
 	var scheme, host, path string
-	queries := make([]string, 0, len(r.regexp.queries))
 	if r.regexp.host != nil {
 		if host, err = r.regexp.host.url(values); err != nil {
 			return nil, err
@@ -497,18 +496,10 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 			return nil, err
 		}
 	}
-	for _, q := range r.regexp.queries {
-		var query string
-		if query, err = q.url(values); err != nil {
-			return nil, err
-		}
-		queries = append(queries, query)
-	}
 	return &url.URL{
-		Scheme:   scheme,
-		Host:     host,
-		Path:     path,
-		RawQuery: strings.Join(queries, "&"),
+		Scheme: scheme,
+		Host:   host,
+		Path:   path,
 	}, nil
 }
 
