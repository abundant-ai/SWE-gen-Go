diff --git a/sd/etcdv3/client.go b/sd/etcdv3/client.go
new file mode 100644
index 0000000..57d1638
--- /dev/null
+++ b/sd/etcdv3/client.go
@@ -0,0 +1,233 @@
+package etcdv3
+
+import (
+	"context"
+	"crypto/tls"
+	"errors"
+	"time"
+
+	"github.com/coreos/etcd/clientv3"
+	"github.com/coreos/etcd/pkg/transport"
+)
+
+var (
+	// ErrNoKey indicates a client method needs a key but receives none.
+	ErrNoKey = errors.New("no key provided")
+
+	// ErrNoValue indicates a client method needs a value but receives none.
+	ErrNoValue = errors.New("no value provided")
+)
+
+// Client is a wrapper around the etcd client.
+type Client interface {
+	// GetEntries queries the given prefix in etcd and returns a slice
+	// containing the values of all keys found, recursively, underneath that
+	// prefix.
+	GetEntries(prefix string) ([]string, error)
+
+	// WatchPrefix watches the given prefix in etcd for changes. When a change
+	// is detected, it will signal on the passed channel. Clients are expected
+	// to call GetEntries to update themselves with the latest set of complete
+	// values. WatchPrefix will always send an initial sentinel value on the
+	// channel after establishing the watch, to ensure that clients always
+	// receive the latest set of values. WatchPrefix will block until the
+	// context passed to the NewClient constructor is terminated.
+	WatchPrefix(prefix string, ch chan struct{})
+
+	// Register a service with etcd.
+	Register(s Service) error
+
+	// Deregister a service with etcd.
+	Deregister(s Service) error
+
+	// LeaseID returns the lease id created for this service instance
+	LeaseID() int64
+}
+
+type client struct {
+	cli *clientv3.Client
+	ctx context.Context
+
+	kv clientv3.KV
+
+	// Watcher interface instance, used to leverage Watcher.Close()
+	watcher clientv3.Watcher
+	// watcher context
+	wctx context.Context
+	// watcher cancel func
+	wcf context.CancelFunc
+
+	// leaseID will be 0 (clientv3.NoLease) if a lease was not created
+	leaseID clientv3.LeaseID
+
+	hbch <-chan *clientv3.LeaseKeepAliveResponse
+	// Lease interface instance, used to leverage Lease.Close()
+	leaser clientv3.Lease
+}
+
+// ClientOptions defines options for the etcd client. All values are optional.
+// If any duration is not specified, a default of 3 seconds will be used.
+type ClientOptions struct {
+	Cert          string
+	Key           string
+	CACert        string
+	DialTimeout   time.Duration
+	DialKeepAlive time.Duration
+	Username      string
+	Password      string
+}
+
+// NewClient returns Client with a connection to the named machines. It will
+// return an error if a connection to the cluster cannot be made.
+func NewClient(ctx context.Context, machines []string, options ClientOptions) (Client, error) {
+	if options.DialTimeout == 0 {
+		options.DialTimeout = 3 * time.Second
+	}
+	if options.DialKeepAlive == 0 {
+		options.DialKeepAlive = 3 * time.Second
+	}
+
+	var err error
+	var tlscfg *tls.Config
+
+	if options.Cert != "" && options.Key != "" {
+		tlsInfo := transport.TLSInfo{
+			CertFile:      options.Cert,
+			KeyFile:       options.Key,
+			TrustedCAFile: options.CACert,
+		}
+		tlscfg, err = tlsInfo.ClientConfig()
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	cli, err := clientv3.New(clientv3.Config{
+		Context:           ctx,
+		Endpoints:         machines,
+		DialTimeout:       options.DialTimeout,
+		DialKeepAliveTime: options.DialKeepAlive,
+		TLS:               tlscfg,
+		Username:          options.Username,
+		Password:          options.Password,
+	})
+	if err != nil {
+		return nil, err
+	}
+
+	return &client{
+		cli: cli,
+		ctx: ctx,
+		kv:  clientv3.NewKV(cli),
+	}, nil
+}
+
+func (c *client) LeaseID() int64 { return int64(c.leaseID) }
+
+// GetEntries implements the etcd Client interface.
+func (c *client) GetEntries(key string) ([]string, error) {
+	resp, err := c.kv.Get(c.ctx, key, clientv3.WithPrefix())
+	if err != nil {
+		return nil, err
+	}
+
+	entries := make([]string, len(resp.Kvs))
+	for i, kv := range resp.Kvs {
+		entries[i] = string(kv.Value)
+	}
+
+	return entries, nil
+}
+
+// WatchPrefix implements the etcd Client interface.
+func (c *client) WatchPrefix(prefix string, ch chan struct{}) {
+	c.wctx, c.wcf = context.WithCancel(c.ctx)
+	c.watcher = clientv3.NewWatcher(c.cli)
+
+	wch := c.watcher.Watch(c.wctx, prefix, clientv3.WithPrefix(), clientv3.WithRev(0))
+	ch <- struct{}{}
+	for wr := range wch {
+		if wr.Canceled {
+			return
+		}
+		ch <- struct{}{}
+	}
+}
+
+func (c *client) Register(s Service) error {
+	var err error
+
+	if s.Key == "" {
+		return ErrNoKey
+	}
+	if s.Value == "" {
+		return ErrNoValue
+	}
+
+	if c.leaser != nil {
+		c.leaser.Close()
+	}
+	c.leaser = clientv3.NewLease(c.cli)
+
+	if c.watcher != nil {
+		c.watcher.Close()
+	}
+	c.watcher = clientv3.NewWatcher(c.cli)
+	if c.kv == nil {
+		c.kv = clientv3.NewKV(c.cli)
+	}
+
+	if s.TTL == nil {
+		s.TTL = NewTTLOption(time.Second*3, time.Second*10)
+	}
+
+	grantResp, err := c.leaser.Grant(c.ctx, int64(s.TTL.ttl.Seconds()))
+	if err != nil {
+		return err
+	}
+	c.leaseID = grantResp.ID
+
+	_, err = c.kv.Put(
+		c.ctx,
+		s.Key,
+		s.Value,
+		clientv3.WithLease(c.leaseID),
+	)
+	if err != nil {
+		return err
+	}
+
+	// this will keep the key alive 'forever' or until we revoke it or
+	// the context is canceled
+	c.hbch, err = c.leaser.KeepAlive(c.ctx, c.leaseID)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func (c *client) Deregister(s Service) error {
+	defer c.close()
+
+	if s.Key == "" {
+		return ErrNoKey
+	}
+	if _, err := c.cli.Delete(c.ctx, s.Key, clientv3.WithIgnoreLease()); err != nil {
+		return err
+	}
+
+	return nil
+}
+
+// close will close any open clients and call
+// the watcher cancel func
+func (c *client) close() {
+	if c.leaser != nil {
+		c.leaser.Close()
+	}
+	if c.watcher != nil {
+		c.watcher.Close()
+		c.wcf()
+	}
+}
diff --git a/sd/etcdv3/doc.go b/sd/etcdv3/doc.go
new file mode 100644
index 0000000..e2aa0dd
--- /dev/null
+++ b/sd/etcdv3/doc.go
@@ -0,0 +1,4 @@
+// Package etcdv3 provides an Instancer and Registrar implementation for etcd v3. If
+// you use etcd v3 as your service discovery system, this package will help you
+// implement the registration and client-side load balancing patterns.
+package etcdv3
diff --git a/sd/etcdv3/instancer.go b/sd/etcdv3/instancer.go
new file mode 100644
index 0000000..17442b1
--- /dev/null
+++ b/sd/etcdv3/instancer.go
@@ -0,0 +1,76 @@
+package etcdv3
+
+import (
+	"github.com/go-kit/kit/log"
+	"github.com/go-kit/kit/sd"
+	"github.com/go-kit/kit/sd/internal/instance"
+)
+
+// Instancer yields instances stored in a certain etcd keyspace. Any kind of
+// change in that keyspace is watched and will update the Instancer's Instancers.
+type Instancer struct {
+	cache  *instance.Cache
+	client Client
+	prefix string
+	logger log.Logger
+	quitc  chan struct{}
+}
+
+// NewInstancer returns an etcd instancer. It will start watching the given
+// prefix for changes, and update the subscribers.
+func NewInstancer(c Client, prefix string, logger log.Logger) (*Instancer, error) {
+	s := &Instancer{
+		client: c,
+		prefix: prefix,
+		cache:  instance.NewCache(),
+		logger: logger,
+		quitc:  make(chan struct{}),
+	}
+
+	instances, err := s.client.GetEntries(s.prefix)
+	if err == nil {
+		logger.Log("prefix", s.prefix, "instances", len(instances))
+	} else {
+		logger.Log("prefix", s.prefix, "err", err)
+	}
+	s.cache.Update(sd.Event{Instances: instances, Err: err})
+
+	go s.loop()
+	return s, nil
+}
+
+func (s *Instancer) loop() {
+	ch := make(chan struct{})
+	go s.client.WatchPrefix(s.prefix, ch)
+
+	for {
+		select {
+		case <-ch:
+			instances, err := s.client.GetEntries(s.prefix)
+			if err != nil {
+				s.logger.Log("msg", "failed to retrieve entries", "err", err)
+				s.cache.Update(sd.Event{Err: err})
+				continue
+			}
+			s.cache.Update(sd.Event{Instances: instances})
+
+		case <-s.quitc:
+			return
+		}
+	}
+}
+
+// Stop terminates the Instancer.
+func (s *Instancer) Stop() {
+	close(s.quitc)
+}
+
+// Register implements Instancer.
+func (s *Instancer) Register(ch chan<- sd.Event) {
+	s.cache.Register(ch)
+}
+
+// Deregister implements Instancer.
+func (s *Instancer) Deregister(ch chan<- sd.Event) {
+	s.cache.Deregister(ch)
+}
diff --git a/sd/etcdv3/registrar.go b/sd/etcdv3/registrar.go
new file mode 100644
index 0000000..27f7a6b
--- /dev/null
+++ b/sd/etcdv3/registrar.go
@@ -0,0 +1,96 @@
+package etcdv3
+
+import (
+	"sync"
+	"time"
+
+	"github.com/go-kit/kit/log"
+)
+
+const minHeartBeatTime = 500 * time.Millisecond
+
+// Registrar registers service instance liveness information to etcd.
+type Registrar struct {
+	client  Client
+	service Service
+	logger  log.Logger
+
+	quitmtx sync.Mutex
+	quit    chan struct{}
+}
+
+// Service holds the instance identifying data you want to publish to etcd. Key
+// must be unique, and value is the string returned to subscribers, typically
+// called the "instance" string in other parts of package sd.
+type Service struct {
+	Key   string // unique key, e.g. "/service/foobar/1.2.3.4:8080"
+	Value string // returned to subscribers, e.g. "http://1.2.3.4:8080"
+	TTL   *TTLOption
+}
+
+// TTLOption allow setting a key with a TTL. This option will be used by a loop
+// goroutine which regularly refreshes the lease of the key.
+type TTLOption struct {
+	heartbeat time.Duration // e.g. time.Second * 3
+	ttl       time.Duration // e.g. time.Second * 10
+}
+
+// NewTTLOption returns a TTLOption that contains proper TTL settings. Heartbeat
+// is used to refresh the lease of the key periodically; its value should be at
+// least 500ms. TTL defines the lease of the key; its value should be
+// significantly greater than heartbeat.
+//
+// Good default values might be 3s heartbeat, 10s TTL.
+func NewTTLOption(heartbeat, ttl time.Duration) *TTLOption {
+	if heartbeat <= minHeartBeatTime {
+		heartbeat = minHeartBeatTime
+	}
+	if ttl <= heartbeat {
+		ttl = 3 * heartbeat
+	}
+	return &TTLOption{
+		heartbeat: heartbeat,
+		ttl:       ttl,
+	}
+}
+
+// NewRegistrar returns a etcd Registrar acting on the provided catalog
+// registration (service).
+func NewRegistrar(client Client, service Service, logger log.Logger) *Registrar {
+	return &Registrar{
+		client:  client,
+		service: service,
+		logger:  log.With(logger, "key", service.Key, "value", service.Value),
+	}
+}
+
+// Register implements the sd.Registrar interface. Call it when you want your
+// service to be registered in etcd, typically at startup.
+func (r *Registrar) Register() {
+	if err := r.client.Register(r.service); err != nil {
+		r.logger.Log("err", err)
+		return
+	}
+	if r.service.TTL != nil {
+		r.logger.Log("action", "register", "lease", r.client.LeaseID())
+	} else {
+		r.logger.Log("action", "register")
+	}
+}
+
+// Deregister implements the sd.Registrar interface. Call it when you want your
+// service to be deregistered from etcd, typically just prior to shutdown.
+func (r *Registrar) Deregister() {
+	if err := r.client.Deregister(r.service); err != nil {
+		r.logger.Log("err", err)
+	} else {
+		r.logger.Log("action", "deregister")
+	}
+
+	r.quitmtx.Lock()
+	defer r.quitmtx.Unlock()
+	if r.quit != nil {
+		close(r.quit)
+		r.quit = nil
+	}
+}
