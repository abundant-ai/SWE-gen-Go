diff --git a/_examples/graceful/main.go b/_examples/graceful/main.go
deleted file mode 100644
index f7daf96..0000000
--- a/_examples/graceful/main.go
+++ /dev/null
@@ -1,111 +0,0 @@
-package main
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"time"
-
-	"github.com/goware/valve"
-	"github.com/pressly/chi"
-	"github.com/pressly/chi/middleware"
-	"github.com/tylerb/graceful"
-)
-
-func main() {
-
-	// Our graceful valve shut-off package to manage code preemption and
-	// shutdown signaling.
-	valv := valve.New()
-	baseCtx := valv.ContextLever()
-
-	// Example of a long running background worker thing..
-	go func(ctx context.Context) {
-		for {
-			<-time.After(1 * time.Second)
-
-			func() {
-				valve.Context(ctx).Open()
-				defer valve.Context(ctx).Close()
-
-				// actual code doing stuff..
-				fmt.Println("tick..")
-				time.Sleep(2 * time.Second)
-				// end-logic
-
-				// signal control..
-				select {
-				case <-valve.Context(ctx).Stop():
-					fmt.Println("valve is closed")
-					return
-
-				case <-ctx.Done():
-					fmt.Println("context is cancelled, go home.")
-					return
-				default:
-				}
-			}()
-
-		}
-	}(baseCtx)
-
-	// HTTP service running in this program as well. The valve context is set
-	// as a base context on the server listener at the point where we instantiate
-	// the server - look lower.
-	r := chi.NewRouter()
-	r.Use(middleware.RequestID)
-	r.Use(middleware.Logger)
-
-	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte("sup"))
-	})
-
-	r.Get("/slow", func(w http.ResponseWriter, r *http.Request) {
-
-		valve.Context(r.Context()).Open()
-		defer valve.Context(r.Context()).Close()
-
-		select {
-		case <-valve.Context(r.Context()).Stop():
-			fmt.Println("valve is closed. finish up..")
-
-		case <-time.After(5 * time.Second):
-			// The above channel simulates some hard work.
-			// We want this handler to complete successfully during a shutdown signal,
-			// so consider the work here as some background routine to fetch a long running
-			// search query to find as many results as possible, but, instead we cut it short
-			// and respond with what we have so far. How a shutdown is handled is entirely
-			// up to the developer, as some code blocks are preemptable, and others are not.
-			time.Sleep(5 * time.Second)
-		}
-
-		w.Write([]byte(fmt.Sprintf("all done.\n")))
-	})
-
-	// c := make(chan os.Signal, 1)
-	// signal.Notify(c, os.Interrupt)
-	// go func() {
-	// 	for sig := range c {
-	// 		// sig is a ^C, handle it
-	// 		valv.Shutdown()
-	// 		os.Exit(1)
-	// 	}
-	// }()
-	// http.ListenAndServe(":3333", chi.ServerBaseContext(r, baseCtx))
-
-	srv := &graceful.Server{
-		Timeout: 20 * time.Second,
-		Server:  &http.Server{Addr: ":3333", Handler: chi.ServerBaseContext(r, baseCtx)},
-	}
-	srv.BeforeShutdown = func() bool {
-		fmt.Println("shutting down..")
-		err := valv.Shutdown(srv.Timeout)
-		if err != nil {
-			fmt.Println("Shutdown error -", err)
-		}
-		// the app code has stopped here now, and so this would be a good place
-		// to close up any db and other service connections, etc.
-		return true
-	}
-	srv.ListenAndServe()
-}
diff --git a/context.go b/context.go
index 198dc20..a74aa3c 100644
--- a/context.go
+++ b/context.go
@@ -2,7 +2,6 @@ package chi
 
 import (
 	"context"
-	"net"
 	"net/http"
 )
 
@@ -106,25 +105,6 @@ func (ps *params) Del(key string) string {
 	return ""
 }
 
-// ServerBaseContext wraps an http.Handler to set the request context to the
-// `baseCtx`.
-func ServerBaseContext(h http.Handler, baseCtx context.Context) http.Handler {
-	fn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		ctx := r.Context()
-
-		// Copy over default net/http server context keys
-		if v, ok := ctx.Value(http.ServerContextKey).(*http.Server); ok {
-			baseCtx = context.WithValue(baseCtx, http.ServerContextKey, v)
-		}
-		if v, ok := ctx.Value(http.LocalAddrContextKey).(net.Addr); ok {
-			baseCtx = context.WithValue(baseCtx, http.LocalAddrContextKey, v)
-		}
-
-		h.ServeHTTP(w, r.WithContext(baseCtx))
-	})
-	return fn
-}
-
 // contextKey is a value for use with context.WithValue. It's used as
 // a pointer so it fits in an interface{} without allocation. This technique
 // for defining context keys was copied from Go 1.7's new use of context in net/http.
diff --git a/mux_test.go b/mux_test.go
index 45ddf68..ef28517 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -7,7 +7,6 @@ import (
 	"fmt"
 	"io"
 	"io/ioutil"
-	"net"
 	"net/http"
 	"net/http/httptest"
 	"os"
@@ -1168,29 +1167,6 @@ func TestMuxFileServer(t *testing.T) {
 	// }
 }
 
-func TestServerBaseContext(t *testing.T) {
-	r := NewRouter()
-	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
-		baseYes := r.Context().Value("base").(string)
-		if _, ok := r.Context().Value(http.ServerContextKey).(*http.Server); !ok {
-			panic("missing server context")
-		}
-		if _, ok := r.Context().Value(http.LocalAddrContextKey).(net.Addr); !ok {
-			panic("missing local addr context")
-		}
-		w.Write([]byte(baseYes))
-	})
-
-	// Setup http Server with a base context
-	ctx := context.WithValue(context.Background(), "base", "yes")
-	ts := httptest.NewServer(ServerBaseContext(r, ctx))
-	defer ts.Close()
-
-	if _, body := testRequest(t, ts, "GET", "/", nil); body != "yes" {
-		t.Fatalf(body)
-	}
-}
-
 func urlParams(rctx *Context) map[string]string {
 	m := make(map[string]string, 0)
 	for _, p := range rctx.URLParams {
