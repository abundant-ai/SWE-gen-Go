diff --git a/Dockerfile.local b/Dockerfile.local
deleted file mode 100644
index 1c66de7..0000000
--- a/Dockerfile.local
+++ /dev/null
@@ -1,8 +0,0 @@
-FROM golang:1.17-buster@sha256:3e663ba6af8281b04975b0a34a14d538cdd7d284213f83f05aaf596b80a8c725 as builder
-
-COPY . /src
-WORKDIR /src
-RUN CGO_ENABLED=0 make dist
-
-FROM scratch AS exporter
-COPY --from=builder /src/bin/ /
\ No newline at end of file
diff --git a/goose.go b/goose.go
index e952041..daf0593 100644
--- a/goose.go
+++ b/goose.go
@@ -8,7 +8,7 @@ import (
 	"strconv"
 )
 
-// Deprecated: VERSION will no longer be supported in v4.
+// Deprecated: VERSION will no longer be supported in the next major release.
 const VERSION = "v3.2.0"
 
 var (
diff --git a/internal/provider/collect.go b/internal/provider/collect.go
index a4a73c0..345da0d 100644
--- a/internal/provider/collect.go
+++ b/internal/provider/collect.go
@@ -7,17 +7,10 @@ import (
 	"os"
 	"path/filepath"
 	"sort"
-	"strconv"
 	"strings"
-)
 
-func NewSource(t MigrationType, fullpath string, version int64) Source {
-	return Source{
-		Type:    t,
-		Path:    fullpath,
-		Version: version,
-	}
-}
+	"github.com/pressly/goose/v3"
+)
 
 // fileSources represents a collection of migration files on the filesystem.
 type fileSources struct {
@@ -44,16 +37,16 @@ func (s *fileSources) lookup(t MigrationType, version int64) *Source {
 	return nil
 }
 
-// collectFileSources scans the file system for migration files that have a numeric prefix (greater
-// than one) followed by an underscore and a file extension of either .go or .sql. fsys may be nil,
-// in which case an empty fileSources is returned.
+// collectFilesystemSources scans the file system for migration files that have a numeric prefix
+// (greater than one) followed by an underscore and a file extension of either .go or .sql. fsys may
+// be nil, in which case an empty fileSources is returned.
 //
 // If strict is true, then any error parsing the numeric component of the filename will result in an
 // error. The file is skipped otherwise.
 //
 // This function DOES NOT parse SQL migrations or merge registered Go migrations. It only collects
 // migration sources from the filesystem.
-func collectFileSources(fsys fs.FS, strict bool, excludes map[string]bool) (*fileSources, error) {
+func collectFilesystemSources(fsys fs.FS, strict bool, excludes map[string]bool) (*fileSources, error) {
 	if fsys == nil {
 		return new(fileSources), nil
 	}
@@ -78,7 +71,7 @@ func collectFileSources(fsys fs.FS, strict bool, excludes map[string]bool) (*fil
 			// filenames, but still have versioned migrations within the same directory. For
 			// example, a user could have a helpers.go file which contains unexported helper
 			// functions for migrations.
-			version, err := NumericComponent(base)
+			version, err := goose.NumericComponent(base)
 			if err != nil {
 				if strict {
 					return nil, fmt.Errorf("failed to parse numeric component from %q: %w", base, err)
@@ -95,9 +88,17 @@ func collectFileSources(fsys fs.FS, strict bool, excludes map[string]bool) (*fil
 			}
 			switch filepath.Ext(base) {
 			case ".sql":
-				sources.sqlSources = append(sources.sqlSources, NewSource(TypeSQL, fullpath, version))
+				sources.sqlSources = append(sources.sqlSources, Source{
+					Type:    TypeSQL,
+					Path:    fullpath,
+					Version: version,
+				})
 			case ".go":
-				sources.goSources = append(sources.goSources, NewSource(TypeGo, fullpath, version))
+				sources.goSources = append(sources.goSources, Source{
+					Type:    TypeGo,
+					Path:    fullpath,
+					Version: version,
+				})
 			default:
 				// Should never happen since we already filtered out all other file types.
 				return nil, fmt.Errorf("unknown migration type: %s", base)
@@ -165,9 +166,12 @@ func merge(sources *fileSources, registerd map[int64]*goMigration) ([]*migration
 			)
 		}
 		m := &migration{
-			// Note, the fullpath may be empty if the migration was registered manually.
-			Source: NewSource(TypeGo, fullpath, version),
-			Go:     r,
+			Source: Source{
+				Type:    TypeGo,
+				Path:    fullpath, // May be empty if migration was registered manually.
+				Version: version,
+			},
+			Go: r,
 		}
 		migrations = append(migrations, m)
 		migrationLookup[version] = m
@@ -207,26 +211,3 @@ var _ fs.FS = noopFS{}
 func (f noopFS) Open(name string) (fs.File, error) {
 	return nil, os.ErrNotExist
 }
-
-// NumericComponent parses the version from the migration file name.
-//
-// XXX_descriptivename.ext where XXX specifies the version number and ext specifies the type of
-// migration, either .sql or .go.
-func NumericComponent(filename string) (int64, error) {
-	base := filepath.Base(filename)
-	if ext := filepath.Ext(base); ext != ".go" && ext != ".sql" {
-		return 0, errors.New("migration file does not have .sql or .go file extension")
-	}
-	idx := strings.Index(base, "_")
-	if idx < 0 {
-		return 0, errors.New("no filename separator '_' found")
-	}
-	n, err := strconv.ParseInt(base[:idx], 10, 64)
-	if err != nil {
-		return 0, err
-	}
-	if n < 1 {
-		return 0, errors.New("migration version must be greater than zero")
-	}
-	return n, nil
-}
diff --git a/internal/provider/migration.go b/internal/provider/migration.go
index 2ace5f9..07508ff 100644
--- a/internal/provider/migration.go
+++ b/internal/provider/migration.go
@@ -44,7 +44,7 @@ func (m *migration) useTx(direction bool) bool {
 func (m *migration) isEmpty(direction bool) bool {
 	switch m.Source.Type {
 	case TypeSQL:
-		return m.SQL == nil || m.SQL.IsEmpty(direction)
+		return m.SQL == nil || m.SQL.isEmpty(direction)
 	case TypeGo:
 		return m.Go == nil || m.Go.isEmpty(direction)
 	}
@@ -102,7 +102,7 @@ func (m *migration) runConn(ctx context.Context, conn *sql.Conn, direction bool)
 
 type goMigration struct {
 	fullpath string
-	up, down *GoMigration
+	up, down *GoMigrationFunc
 }
 
 func (g *goMigration) isEmpty(direction bool) bool {
@@ -115,7 +115,7 @@ func (g *goMigration) isEmpty(direction bool) bool {
 	return g.down == nil
 }
 
-func newGoMigration(fullpath string, up, down *GoMigration) *goMigration {
+func newGoMigration(fullpath string, up, down *GoMigrationFunc) *goMigration {
 	return &goMigration{
 		fullpath: fullpath,
 		up:       up,
@@ -163,7 +163,7 @@ type sqlMigration struct {
 	DownStatements []string
 }
 
-func (s *sqlMigration) IsEmpty(direction bool) bool {
+func (s *sqlMigration) isEmpty(direction bool) bool {
 	if direction {
 		return len(s.UpStatements) == 0
 	}
diff --git a/internal/provider/misc.go b/internal/provider/misc.go
index 717edff..e20fbad 100644
--- a/internal/provider/misc.go
+++ b/internal/provider/misc.go
@@ -5,9 +5,11 @@ import (
 	"database/sql"
 	"errors"
 	"fmt"
+
+	"github.com/pressly/goose/v3"
 )
 
-type Migration struct {
+type MigrationCopy struct {
 	Version                            int64
 	Source                             string // path to .sql script or go file
 	Registered                         bool
@@ -15,13 +17,13 @@ type Migration struct {
 	UpFnNoTxContext, DownFnNoTxContext func(context.Context, *sql.DB) error
 }
 
-var registeredGoMigrations = make(map[int64]*Migration)
+var registeredGoMigrations = make(map[int64]*MigrationCopy)
 
 // SetGlobalGoMigrations registers the given go migrations globally. It returns an error if any of
 // the migrations are nil or if a migration with the same version has already been registered.
 //
 // Not safe for concurrent use.
-func SetGlobalGoMigrations(migrations []*Migration) error {
+func SetGlobalGoMigrations(migrations []*MigrationCopy) error {
 	for _, m := range migrations {
 		if m == nil {
 			return errors.New("cannot register nil go migration")
@@ -35,7 +37,7 @@ func SetGlobalGoMigrations(migrations []*Migration) error {
 		if m.Source != "" {
 			// If the source is set, expect it to be a file path with a numeric component that
 			// matches the version.
-			version, err := NumericComponent(m.Source)
+			version, err := goose.NumericComponent(m.Source)
 			if err != nil {
 				return err
 			}
@@ -62,5 +64,5 @@ func SetGlobalGoMigrations(migrations []*Migration) error {
 //
 // Not safe for concurrent use.
 func ResetGlobalGoMigrations() {
-	registeredGoMigrations = make(map[int64]*Migration)
+	registeredGoMigrations = make(map[int64]*MigrationCopy)
 }
diff --git a/internal/provider/provider.go b/internal/provider/provider.go
index 89c7444..bd68e2f 100644
--- a/internal/provider/provider.go
+++ b/internal/provider/provider.go
@@ -12,6 +12,21 @@ import (
 	"github.com/pressly/goose/v3/database"
 )
 
+// Provider is a goose migration provider.
+type Provider struct {
+	// mu protects all accesses to the provider and must be held when calling operations on the
+	// database.
+	mu sync.Mutex
+
+	db    *sql.DB
+	fsys  fs.FS
+	cfg   config
+	store database.Store
+
+	// migrations are ordered by version in ascending order.
+	migrations []*migration
+}
+
 // NewProvider returns a new goose Provider.
 //
 // The caller is responsible for matching the database dialect with the database/sql driver. For
@@ -46,11 +61,13 @@ func NewProvider(dialect database.Dialect, db *sql.DB, fsys fs.FS, opts ...Provi
 			return nil, err
 		}
 	}
+	// Allow users to specify a custom store implementation, but only if they don't specify a
+	// dialect. If they specify a dialect, we'll use the default store implementation.
 	if dialect == "" && cfg.store == nil {
 		return nil, errors.New("dialect must not be empty")
 	}
 	if dialect != "" && cfg.store != nil {
-		return nil, errors.New("cannot set both dialect and store")
+		return nil, errors.New("cannot set both dialect and custom store")
 	}
 	var store database.Store
 	if dialect != "" {
@@ -65,6 +82,16 @@ func NewProvider(dialect database.Dialect, db *sql.DB, fsys fs.FS, opts ...Provi
 	if store.Tablename() == "" {
 		return nil, errors.New("invalid store implementation: table name must not be empty")
 	}
+	return newProvider(db, store, fsys, cfg, registeredGoMigrations /* global */)
+}
+
+func newProvider(
+	db *sql.DB,
+	store database.Store,
+	fsys fs.FS,
+	cfg config,
+	global map[int64]*MigrationCopy,
+) (*Provider, error) {
 	// Collect migrations from the filesystem and merge with registered migrations.
 	//
 	// Note, neither of these functions parse SQL migrations by default. SQL migrations are parsed
@@ -73,13 +100,10 @@ func NewProvider(dialect database.Dialect, db *sql.DB, fsys fs.FS, opts ...Provi
 	// TODO(mf): we should expose a way to parse SQL migrations eagerly. This would allow us to
 	// return an error if there are any SQL parsing errors. This adds a bit overhead to startup
 	// though, so we should make it optional.
-	sources, err := collectFileSources(fsys, false, cfg.excludes)
+	filesystemSources, err := collectFilesystemSources(fsys, false, cfg.excludes)
 	if err != nil {
 		return nil, err
 	}
-	//
-	// TODO(mf): move the merging of Go migrations into a separate function.
-	//
 	registered := make(map[int64]*goMigration)
 	// Add user-registered Go migrations.
 	for version, m := range cfg.registered {
@@ -87,7 +111,7 @@ func NewProvider(dialect database.Dialect, db *sql.DB, fsys fs.FS, opts ...Provi
 	}
 	// Add init() functions. This is a bit ugly because we need to convert from the old Migration
 	// struct to the new goMigration struct.
-	for version, m := range registeredGoMigrations {
+	for version, m := range global {
 		if _, ok := registered[version]; ok {
 			return nil, fmt.Errorf("go migration with version %d already registered", version)
 		}
@@ -103,27 +127,27 @@ func NewProvider(dialect database.Dialect, db *sql.DB, fsys fs.FS, opts ...Provi
 		}
 		// Up
 		if m.UpFnContext != nil {
-			g.up = &GoMigration{
+			g.up = &GoMigrationFunc{
 				Run: m.UpFnContext,
 			}
 		} else if m.UpFnNoTxContext != nil {
-			g.up = &GoMigration{
+			g.up = &GoMigrationFunc{
 				RunNoTx: m.UpFnNoTxContext,
 			}
 		}
 		// Down
 		if m.DownFnContext != nil {
-			g.down = &GoMigration{
+			g.down = &GoMigrationFunc{
 				Run: m.DownFnContext,
 			}
 		} else if m.DownFnNoTxContext != nil {
-			g.down = &GoMigration{
+			g.down = &GoMigrationFunc{
 				RunNoTx: m.DownFnNoTxContext,
 			}
 		}
 		registered[version] = g
 	}
-	migrations, err := merge(sources, registered)
+	migrations, err := merge(filesystemSources, registered)
 	if err != nil {
 		return nil, err
 	}
@@ -139,21 +163,6 @@ func NewProvider(dialect database.Dialect, db *sql.DB, fsys fs.FS, opts ...Provi
 	}, nil
 }
 
-// Provider is a goose migration provider.
-type Provider struct {
-	// mu protects all accesses to the provider and must be held when calling operations on the
-	// database.
-	mu sync.Mutex
-
-	db    *sql.DB
-	fsys  fs.FS
-	cfg   config
-	store database.Store
-
-	// migrations are ordered by version in ascending order.
-	migrations []*migration
-}
-
 // Status returns the status of all migrations, merging the list of migrations from the database and
 // filesystem. The returned items are ordered by version, in ascending order.
 func (p *Provider) Status(ctx context.Context) ([]*MigrationStatus, error) {
diff --git a/internal/provider/provider_options.go b/internal/provider/provider_options.go
index 50b4d3f..dd29ee4 100644
--- a/internal/provider/provider_options.go
+++ b/internal/provider/provider_options.go
@@ -96,8 +96,8 @@ func WithExcludes(excludes []string) ProviderOption {
 	})
 }
 
-// GoMigration is a user-defined Go migration, registered using the option [WithGoMigration].
-type GoMigration struct {
+// GoMigrationFunc is a user-defined Go migration, registered using the option [WithGoMigration].
+type GoMigrationFunc struct {
 	// One of the following must be set:
 	Run func(context.Context, *sql.Tx) error
 	// -- OR --
@@ -109,7 +109,7 @@ type GoMigration struct {
 // If WithGoMigration is called multiple times with the same version, an error is returned. Both up
 // and down [GoMigration] may be nil. But if set, exactly one of Run or RunNoTx functions must be
 // set.
-func WithGoMigration(version int64, up, down *GoMigration) ProviderOption {
+func WithGoMigration(version int64, up, down *GoMigrationFunc) ProviderOption {
 	return configFunc(func(c *config) error {
 		if version < 1 {
 			return errors.New("version must be greater than zero")
@@ -143,25 +143,27 @@ func WithGoMigration(version int64, up, down *GoMigration) ProviderOption {
 	})
 }
 
-// WithAllowMissing allows the provider to apply missing (out-of-order) migrations.
+// WithAllowedMissing allows the provider to apply missing (out-of-order) migrations. By default,
+// goose will raise an error if it encounters a missing migration.
 //
 // Example: migrations 1,3 are applied and then version 2,6 are introduced. If this option is true,
 // then goose will apply 2 (missing) and 6 (new) instead of raising an error. The final order of
 // applied migrations will be: 1,3,2,6. Out-of-order migrations are always applied first, followed
 // by new migrations.
-func WithAllowMissing(b bool) ProviderOption {
+func WithAllowedMissing(b bool) ProviderOption {
 	return configFunc(func(c *config) error {
 		c.allowMissing = b
 		return nil
 	})
 }
 
-// WithNoVersioning disables versioning. Disabling versioning allows applying migrations without
-// tracking the versions in the database schema table. Useful for tests, seeding a database or
-// running ad-hoc queries.
-func WithNoVersioning(b bool) ProviderOption {
+// WithDisabledVersioning disables versioning. Disabling versioning allows applying migrations
+// without tracking the versions in the database schema table. Useful for tests, seeding a database
+// or running ad-hoc queries. By default, goose will track all versions in the database schema
+// table.
+func WithDisabledVersioning(b bool) ProviderOption {
 	return configFunc(func(c *config) error {
-		c.noVersioning = b
+		c.disableVersioning = b
 		return nil
 	})
 }
@@ -181,8 +183,8 @@ type config struct {
 	sessionLocker lock.SessionLocker
 
 	// Feature
-	noVersioning bool
-	allowMissing bool
+	disableVersioning bool
+	allowMissing      bool
 }
 
 type configFunc func(*config) error
diff --git a/internal/provider/run.go b/internal/provider/run.go
index 79a1b2c..c5f63f1 100644
--- a/internal/provider/run.go
+++ b/internal/provider/run.go
@@ -34,13 +34,13 @@ func (p *Provider) up(ctx context.Context, upByOne bool, version int64) (_ []*Mi
 		return nil, nil
 	}
 	var apply []*migration
-	if p.cfg.noVersioning {
+	if p.cfg.disableVersioning {
 		apply = p.migrations
 	} else {
-		// optimize(mf): Listing all migrations from the database isn't great. This is only required to
-		// support the allow missing (out-of-order) feature. For users that don't use this feature, we
-		// could just query the database for the current max version and then apply migrations greater
-		// than that version.
+		// optimize(mf): Listing all migrations from the database isn't great. This is only required
+		// to support the allow missing (out-of-order) feature. For users that don't use this
+		// feature, we could just query the database for the current max version and then apply
+		// migrations greater than that version.
 		dbMigrations, err := p.store.ListMigrations(ctx, conn)
 		if err != nil {
 			return nil, err
@@ -76,13 +76,13 @@ func (p *Provider) resolveUpMigrations(
 			dbMaxVersion = m.Version
 		}
 	}
-	missingMigrations := findMissingMigrations(dbVersions, p.migrations)
+	missingMigrations := checkMissingMigrations(dbVersions, p.migrations)
 	// feat(mf): It is very possible someone may want to apply ONLY new migrations and skip missing
 	// migrations entirely. At the moment this is not supported, but leaving this comment because
 	// that's where that logic would be handled.
 	//
-	// For example, if db has 1,4 applied and 2,3,5 are new, we would apply only 5 and skip 2,3.
-	// Not sure if this is a common use case, but it's possible.
+	// For example, if db has 1,4 applied and 2,3,5 are new, we would apply only 5 and skip 2,3. Not
+	// sure if this is a common use case, but it's possible.
 	if len(missingMigrations) > 0 && !p.cfg.allowMissing {
 		var collected []string
 		for _, v := range missingMigrations {
@@ -127,7 +127,7 @@ func (p *Provider) down(ctx context.Context, downByOne bool, version int64) (_ [
 	if len(p.migrations) == 0 {
 		return nil, nil
 	}
-	if p.cfg.noVersioning {
+	if p.cfg.disableVersioning {
 		downMigrations := p.migrations
 		if downByOne {
 			last := p.migrations[len(p.migrations)-1]
@@ -245,7 +245,7 @@ func (p *Provider) runIndividually(
 			if err := m.run(ctx, tx, direction); err != nil {
 				return err
 			}
-			if p.cfg.noVersioning {
+			if p.cfg.disableVersioning {
 				return nil
 			}
 			if direction {
@@ -268,7 +268,7 @@ func (p *Provider) runIndividually(
 			return err
 		}
 	}
-	if p.cfg.noVersioning {
+	if p.cfg.disableVersioning {
 		return nil
 	}
 	if direction {
@@ -329,7 +329,7 @@ func (p *Provider) initialize(ctx context.Context) (*sql.Conn, func() error, err
 	}
 	// If versioning is enabled, ensure the version table exists. For ad-hoc migrations, we don't
 	// need the version table because there is no versioning.
-	if !p.cfg.noVersioning {
+	if !p.cfg.disableVersioning {
 		if err := p.ensureVersionTable(ctx, conn); err != nil {
 			return nil, nil, multierr.Append(err, cleanup())
 		}
@@ -370,7 +370,7 @@ func (p *Provider) ensureVersionTable(ctx context.Context, conn *sql.Conn) (retE
 		if err := p.store.CreateVersionTable(ctx, tx); err != nil {
 			return err
 		}
-		if p.cfg.noVersioning {
+		if p.cfg.disableVersioning {
 			return nil
 		}
 		return p.store.Insert(ctx, tx, database.InsertRequest{Version: 0})
@@ -382,9 +382,9 @@ type missingMigration struct {
 	filename  string
 }
 
-// findMissingMigrations returns a list of migrations that are missing from the database. A missing
+// checkMissingMigrations returns a list of migrations that are missing from the database. A missing
 // migration is one that has a version less than the max version in the database.
-func findMissingMigrations(
+func checkMissingMigrations(
 	dbMigrations []*database.ListMigrationsResult,
 	fsMigrations []*migration,
 ) []missingMigration {
