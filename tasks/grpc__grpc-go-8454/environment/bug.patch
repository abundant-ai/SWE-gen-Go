diff --git a/internal/transport/http2_server.go b/internal/transport/http2_server.go
index 9f725e15..4cf5b21e 100644
--- a/internal/transport/http2_server.go
+++ b/internal/transport/http2_server.go
@@ -602,7 +602,6 @@ func (t *http2Server) operateHeaders(ctx context.Context, frame *http2.MetaHeade
 	}
 
 	if s.ctx.Err() != nil {
-		t.mu.Unlock()
 		// Early abort in case the timeout was zero or so low it already fired.
 		t.controlBuf.put(&earlyAbortStream{
 			httpStatus:     http.StatusOK,
diff --git a/internal/xds/bootstrap/bootstrap.go b/internal/xds/bootstrap/bootstrap.go
index 6c7b2332..f409e4bd 100644
--- a/internal/xds/bootstrap/bootstrap.go
+++ b/internal/xds/bootstrap/bootstrap.go
@@ -576,9 +576,6 @@ func (c *Config) UnmarshalJSON(data []byte) error {
 // the presence of the errors) and may return a Config object with certain
 // fields left unspecified, in which case the caller should use some sane
 // defaults.
-//
-// This function returns an error if it's unable to parse the contents of the
-// bootstrap config. It returns (nil, nil) if none of the env vars are set.
 func GetConfiguration() (*Config, error) {
 	fName := envconfig.XDSBootstrapFileName
 	fContent := envconfig.XDSBootstrapFileContent
@@ -601,7 +598,7 @@ func GetConfiguration() (*Config, error) {
 		return NewConfigFromContents([]byte(fContent))
 	}
 
-	return nil, nil
+	return nil, fmt.Errorf("bootstrap environment variables (%q or %q) not defined", envconfig.XDSBootstrapFileNameEnv, envconfig.XDSBootstrapFileContentEnv)
 }
 
 // NewConfigFromContents creates a new bootstrap configuration from the provided
diff --git a/internal/xds/bootstrap/bootstrap_test.go b/internal/xds/bootstrap/bootstrap_test.go
index 88f27a4a..d0571978 100644
--- a/internal/xds/bootstrap/bootstrap_test.go
+++ b/internal/xds/bootstrap/bootstrap_test.go
@@ -383,19 +383,12 @@ func (s) TestGetConfiguration_Failure(t *testing.T) {
 	cancel := setupBootstrapOverride(bootstrapFileMap)
 	defer cancel()
 
-	for _, name := range []string{"nonExistentBootstrapFile", "badJSON", "noBalancerName", "emptyXdsServer"} {
+	for _, name := range []string{"nonExistentBootstrapFile", "empty", "badJSON", "noBalancerName", "emptyXdsServer"} {
 		t.Run(name, func(t *testing.T) {
 			testGetConfigurationWithFileNameEnv(t, name, true, nil)
 			testGetConfigurationWithFileContentEnv(t, name, true, nil)
 		})
 	}
-	const name = "empty"
-	t.Run(name, func(t *testing.T) {
-		testGetConfigurationWithFileNameEnv(t, name, true, nil)
-		// If both the env vars are empty, a nil config with a nil error must be
-		// returned.
-		testGetConfigurationWithFileContentEnv(t, name, false, nil)
-	})
 }
 
 // Tests the functionality in GetConfiguration with different bootstrap file
@@ -469,9 +462,9 @@ func (s) TestGetConfiguration_BootstrapEnvPriority(t *testing.T) {
 	envconfig.XDSBootstrapFileContent = ""
 	defer func() { envconfig.XDSBootstrapFileContent = origBootstrapContent }()
 
-	// When both env variables are empty, GetConfiguration should return nil.
-	if cfg, err := GetConfiguration(); err != nil || cfg != nil {
-		t.Errorf("GetConfiguration() returned (%v, %v), want (<nil>, <nil>)", cfg, err)
+	// When both env variables are empty, GetConfiguration should fail.
+	if _, err := GetConfiguration(); err == nil {
+		t.Errorf("GetConfiguration() returned nil error, expected to fail")
 	}
 
 	// When one of them is set, it should be used.
diff --git a/xds/internal/clients/xdsclient/channel.go b/xds/internal/clients/xdsclient/channel.go
index 2d424b81..97438353 100644
--- a/xds/internal/clients/xdsclient/channel.go
+++ b/xds/internal/clients/xdsclient/channel.go
@@ -253,10 +253,16 @@ func decodeResponse(opts *DecodeOptions, rType *ResourceType, resp response) (ma
 	perResourceErrors := make(map[string]error) // Tracks resource validation errors, where we have a resource name.
 	ret := make(map[string]dataAndErrTuple)     // Return result, a map from resource name to either resource data or error.
 	for _, r := range resp.resources {
-		result, err := rType.Decoder.Decode(AnyProto{
-			TypeURL: r.GetTypeUrl(),
-			Value:   r.GetValue(),
-		}, *opts)
+		r, err := xdsresource.UnwrapResource(r)
+		if err != nil {
+			topLevelErrors = append(topLevelErrors, err)
+			continue
+		}
+		if _, ok := opts.Config.ResourceTypes[r.TypeUrl]; !ok || r.TypeUrl != resp.typeURL {
+			topLevelErrors = append(topLevelErrors, xdsresource.NewErrorf(xdsresource.ErrorTypeResourceTypeUnsupported, "unexpected resource type: %q ", r.GetTypeUrl()))
+			continue
+		}
+		result, err := rType.Decoder.Decode(r.GetValue(), *opts)
 
 		// Name field of the result is left unpopulated only when resource
 		// deserialization fails.
diff --git a/xds/internal/clients/xdsclient/helpers_test.go b/xds/internal/clients/xdsclient/helpers_test.go
index efa025ef..d84e0a4b 100644
--- a/xds/internal/clients/xdsclient/helpers_test.go
+++ b/xds/internal/clients/xdsclient/helpers_test.go
@@ -30,7 +30,6 @@ import (
 	"google.golang.org/grpc/xds/internal/clients/internal/pretty"
 	"google.golang.org/grpc/xds/internal/clients/xdsclient/internal/xdsresource"
 	"google.golang.org/protobuf/proto"
-	"google.golang.org/protobuf/types/known/anypb"
 
 	v3listenerpb "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
 	v3httppb "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
@@ -63,16 +62,9 @@ var (
 	}
 )
 
-func unmarshalListenerResource(rProto *anypb.Any) (string, listenerUpdate, error) {
-	rProto, err := xdsresource.UnwrapResource(rProto)
-	if err != nil {
-		return "", listenerUpdate{}, fmt.Errorf("failed to unwrap resource: %v", err)
-	}
-	if !xdsresource.IsListenerResource(rProto.GetTypeUrl()) {
-		return "", listenerUpdate{}, fmt.Errorf("unexpected listener resource type: %q", rProto.GetTypeUrl())
-	}
+func unmarshalListenerResource(r []byte) (string, listenerUpdate, error) {
 	lis := &v3listenerpb.Listener{}
-	if err := proto.Unmarshal(rProto.GetValue(), lis); err != nil {
+	if err := proto.Unmarshal(r, lis); err != nil {
 		return "", listenerUpdate{}, fmt.Errorf("failed to unmarshal resource: %v", err)
 	}
 
@@ -80,7 +72,7 @@ func unmarshalListenerResource(rProto *anypb.Any) (string, listenerUpdate, error
 	if err != nil {
 		return lis.GetName(), listenerUpdate{}, err
 	}
-	lu.Raw = rProto.GetValue()
+	lu.Raw = r
 	return lis.GetName(), *lu, nil
 }
 
@@ -162,12 +154,8 @@ type listenerDecoder struct{}
 
 // Decode deserializes and validates an xDS resource serialized inside the
 // provided `Any` proto, as received from the xDS management server.
-func (listenerDecoder) Decode(resource AnyProto, _ DecodeOptions) (*DecodeResult, error) {
-	rProto := &anypb.Any{
-		TypeUrl: resource.TypeURL,
-		Value:   resource.Value,
-	}
-	name, listener, err := unmarshalListenerResource(rProto)
+func (listenerDecoder) Decode(resource []byte, _ DecodeOptions) (*DecodeResult, error) {
+	name, listener, err := unmarshalListenerResource(resource)
 	switch {
 	case name == "":
 		// Name is unset only when protobuf deserialization fails.
diff --git a/xds/internal/clients/xdsclient/resource_type.go b/xds/internal/clients/xdsclient/resource_type.go
index ae8e21df..8ca466ed 100644
--- a/xds/internal/clients/xdsclient/resource_type.go
+++ b/xds/internal/clients/xdsclient/resource_type.go
@@ -51,21 +51,9 @@ type Decoder interface {
 	// Decode deserializes and validates an xDS resource as received from the
 	// xDS management server.
 	//
-	// The `resource` parameter may contain a value of the serialized wrapped
-	// resource (i.e. with the type URL
-	// `type.googleapis.com/envoy.service.discovery.v3.Resource`).
-	// Implementations are responsible for unwrapping the underlying resource if
-	// it is wrapped.
-	//
-	// If unmarshalling or validation fails, it returns a non-nil error.
-	// Otherwise, returns a fully populated DecodeResult.
-	Decode(resource AnyProto, options DecodeOptions) (*DecodeResult, error)
-}
-
-// AnyProto contains the type URL and serialized proto data of an xDS resource.
-type AnyProto struct {
-	TypeURL string
-	Value   []byte
+	// If deserialization fails or resource validation fails, it returns a
+	// non-nil error. Otherwise, returns a fully populated DecodeResult.
+	Decode(resource []byte, options DecodeOptions) (*DecodeResult, error)
 }
 
 // DecodeOptions wraps the options required by ResourceType implementations for
diff --git a/xds/internal/clients/xdsclient/test/helpers_test.go b/xds/internal/clients/xdsclient/test/helpers_test.go
index 6e7086fb..600aa8af 100644
--- a/xds/internal/clients/xdsclient/test/helpers_test.go
+++ b/xds/internal/clients/xdsclient/test/helpers_test.go
@@ -34,7 +34,6 @@ import (
 	"google.golang.org/grpc/xds/internal/clients/xdsclient"
 	"google.golang.org/grpc/xds/internal/clients/xdsclient/internal/xdsresource"
 	"google.golang.org/protobuf/proto"
-	"google.golang.org/protobuf/types/known/anypb"
 
 	v3listenerpb "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
 	v3httppb "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
@@ -74,16 +73,9 @@ var (
 	}
 )
 
-func unmarshalListenerResource(rProto *anypb.Any) (string, listenerUpdate, error) {
-	rProto, err := xdsresource.UnwrapResource(rProto)
-	if err != nil {
-		return "", listenerUpdate{}, fmt.Errorf("failed to unwrap resource: %v", err)
-	}
-	if !xdsresource.IsListenerResource(rProto.GetTypeUrl()) {
-		return "", listenerUpdate{}, fmt.Errorf("unexpected listener resource type: %q", rProto.GetTypeUrl())
-	}
+func unmarshalListenerResource(r []byte) (string, listenerUpdate, error) {
 	lis := &v3listenerpb.Listener{}
-	if err := proto.Unmarshal(rProto.GetValue(), lis); err != nil {
+	if err := proto.Unmarshal(r, lis); err != nil {
 		return "", listenerUpdate{}, fmt.Errorf("failed to unmarshal resource: %v", err)
 	}
 
@@ -91,7 +83,7 @@ func unmarshalListenerResource(rProto *anypb.Any) (string, listenerUpdate, error
 	if err != nil {
 		return lis.GetName(), listenerUpdate{}, err
 	}
-	lu.Raw = rProto.GetValue()
+	lu.Raw = r
 	return lis.GetName(), *lu, nil
 }
 
@@ -173,12 +165,8 @@ type listenerDecoder struct{}
 
 // Decode deserializes and validates an xDS resource serialized inside the
 // provided `Any` proto, as received from the xDS management server.
-func (listenerDecoder) Decode(resource xdsclient.AnyProto, _ xdsclient.DecodeOptions) (*xdsclient.DecodeResult, error) {
-	rProto := &anypb.Any{
-		TypeUrl: resource.TypeURL,
-		Value:   resource.Value,
-	}
-	name, listener, err := unmarshalListenerResource(rProto)
+func (listenerDecoder) Decode(resource []byte, _ xdsclient.DecodeOptions) (*xdsclient.DecodeResult, error) {
+	name, listener, err := unmarshalListenerResource(resource)
 	switch {
 	case name == "":
 		// Name is unset only when protobuf deserialization fails.
diff --git a/xds/internal/xdsclient/pool.go b/xds/internal/xdsclient/pool.go
index d1cc8476..113e6e8e 100644
--- a/xds/internal/xdsclient/pool.go
+++ b/xds/internal/xdsclient/pool.go
@@ -25,7 +25,6 @@ import (
 
 	v3statuspb "github.com/envoyproxy/go-control-plane/envoy/service/status/v3"
 	estats "google.golang.org/grpc/experimental/stats"
-	"google.golang.org/grpc/internal/envconfig"
 	istats "google.golang.org/grpc/internal/stats"
 	"google.golang.org/grpc/internal/xds/bootstrap"
 	"google.golang.org/protobuf/proto"
@@ -35,10 +34,7 @@ var (
 	// DefaultPool is the default pool for xDS clients. It is created at init
 	// time and reads bootstrap configuration from env vars to create the xDS
 	// client.
-	DefaultPool = &Pool{
-		clients:          make(map[string]*clientImpl),
-		getConfiguration: sync.OnceValues(bootstrap.GetConfiguration),
-	}
+	DefaultPool = &Pool{clients: make(map[string]*clientImpl)}
 )
 
 // Pool represents a pool of xDS clients that share the same bootstrap
@@ -47,12 +43,9 @@ type Pool struct {
 	// Note that mu should ideally only have to guard clients. But here, we need
 	// it to guard config as well since SetFallbackBootstrapConfig writes to
 	// config.
-	mu             sync.Mutex
-	clients        map[string]*clientImpl
-	fallbackConfig *bootstrap.Config
-	// getConfiguration is a sync.OnceValues that attempts to read the bootstrap
-	// configuration from environment variables once.
-	getConfiguration func() (*bootstrap.Config, error)
+	mu      sync.Mutex
+	clients map[string]*clientImpl
+	config  *bootstrap.Config
 }
 
 // OptionsForTesting contains options to configure xDS client creation for
@@ -85,9 +78,7 @@ type OptionsForTesting struct {
 func NewPool(config *bootstrap.Config) *Pool {
 	return &Pool{
 		clients: make(map[string]*clientImpl),
-		getConfiguration: func() (*bootstrap.Config, error) {
-			return config, nil
-		},
+		config:  config,
 	}
 }
 
@@ -163,7 +154,12 @@ func (p *Pool) GetClientForTesting(name string) (XDSClient, func(), error) {
 func (p *Pool) SetFallbackBootstrapConfig(config *bootstrap.Config) {
 	p.mu.Lock()
 	defer p.mu.Unlock()
-	p.fallbackConfig = config
+
+	if p.config != nil {
+		logger.Error("Attempt to set a bootstrap configuration even though one is already set via environment variables.")
+		return
+	}
+	p.config = config
 }
 
 // DumpResources returns the status and contents of all xDS resources.
@@ -195,11 +191,7 @@ func (p *Pool) DumpResources() *v3statuspb.ClientStatusResponse {
 func (p *Pool) BootstrapConfigForTesting() *bootstrap.Config {
 	p.mu.Lock()
 	defer p.mu.Unlock()
-	cfg, _ := p.getConfiguration()
-	if cfg != nil {
-		return cfg
-	}
-	return p.fallbackConfig
+	return p.config
 }
 
 // UnsetBootstrapConfigForTesting unsets the bootstrap configuration used by
@@ -209,8 +201,7 @@ func (p *Pool) BootstrapConfigForTesting() *bootstrap.Config {
 func (p *Pool) UnsetBootstrapConfigForTesting() {
 	p.mu.Lock()
 	defer p.mu.Unlock()
-	p.fallbackConfig = nil
-	p.getConfiguration = sync.OnceValues(bootstrap.GetConfiguration)
+	p.config = nil
 }
 
 func (p *Pool) clientRefCountedClose(name string) {
@@ -227,6 +218,7 @@ func (p *Pool) clientRefCountedClose(name string) {
 	}
 	delete(p.clients, name)
 
+	client.Close()
 	for _, s := range client.bootstrapConfig.XDSServers() {
 		for _, f := range s.Cleanups() {
 			f()
@@ -241,11 +233,6 @@ func (p *Pool) clientRefCountedClose(name string) {
 	}
 	p.mu.Unlock()
 
-	// This attempts to close the transport to the management server and could
-	// theoretically call back into the xdsclient package again and deadlock.
-	// Hence, this needs to be called without holding the lock.
-	client.Close()
-
 	xdsClientImplCloseHook(name)
 }
 
@@ -256,19 +243,26 @@ func (p *Pool) newRefCounted(name string, metricsRecorder estats.MetricsRecorder
 	p.mu.Lock()
 	defer p.mu.Unlock()
 
-	config, err := p.getConfiguration()
-	if err != nil {
-		return nil, nil, fmt.Errorf("xds: failed to read xDS bootstrap config from env vars:  %v", err)
-	}
-
-	if config == nil {
-		// If the environment variables are not set, then fallback bootstrap
-		// configuration should be set before attempting to create an xDS client,
-		// else xDS client creation will fail.
-		config = p.fallbackConfig
-	}
-	if config == nil {
-		return nil, nil, fmt.Errorf("failed to read xDS bootstrap config from env vars: bootstrap environment variables (%q or %q) not defined and fallback config not set", envconfig.XDSBootstrapFileNameEnv, envconfig.XDSBootstrapFileContentEnv)
+	if p.config == nil {
+		if len(p.clients) != 0 || p != DefaultPool {
+			// If the current pool `p` already contains xDS clients or it is not
+			// the `DefaultPool`, the bootstrap config should have been already
+			// present in the pool.
+			return nil, nil, fmt.Errorf("xds: bootstrap configuration not set in the pool")
+		}
+		// If the current pool `p` is the `DefaultPool` and has no clients, it
+		// might be the first time an xDS client is being created on it. So,
+		// the bootstrap configuration is read from environment variables.
+		//
+		// DefaultPool is initialized with bootstrap configuration from one of the
+		// supported environment variables. If the environment variables are not
+		// set, then fallback bootstrap configuration should be set before
+		// attempting to create an xDS client, else xDS client creation will fail.
+		config, err := bootstrap.GetConfiguration()
+		if err != nil {
+			return nil, nil, fmt.Errorf("xds: failed to read xDS bootstrap config from env vars:  %v", err)
+		}
+		p.config = config
 	}
 
 	if c := p.clients[name]; c != nil {
@@ -276,16 +270,16 @@ func (p *Pool) newRefCounted(name string, metricsRecorder estats.MetricsRecorder
 		return c, sync.OnceFunc(func() { p.clientRefCountedClose(name) }), nil
 	}
 
-	c, err := newClientImpl(config, metricsRecorder, name)
+	c, err := newClientImpl(p.config, metricsRecorder, name)
 	if err != nil {
 		return nil, nil, err
 	}
 	if logger.V(2) {
-		c.logger.Infof("Created client with name %q and bootstrap configuration:\n %s", name, config)
+		c.logger.Infof("Created client with name %q and bootstrap configuration:\n %s", name, p.config)
 	}
 	p.clients[name] = c
 	xdsClientImplCreateHook(name)
 
-	logger.Infof("xDS node ID: %s", config.Node().GetId())
+	logger.Infof("xDS node ID: %s", p.config.Node().GetId())
 	return c, sync.OnceFunc(func() { p.clientRefCountedClose(name) }), nil
 }
diff --git a/xds/internal/xdsclient/pool/pool_test.go b/xds/internal/xdsclient/pool/pool_test.go
index 8b8cfe4b..b12cc737 100644
--- a/xds/internal/xdsclient/pool/pool_test.go
+++ b/xds/internal/xdsclient/pool/pool_test.go
@@ -73,10 +73,6 @@ func (s) TestDefaultPool_LazyLoadBootstrapConfig(t *testing.T) {
 		t.Fatalf("DefaultPool.BootstrapConfigForTesting() = %v, want nil", cfg)
 	}
 
-	// The pool will attempt to read the env vars only once. Reset the pool's
-	// state to make it re-read the env vars during next client creation.
-	xdsclient.DefaultPool.UnsetBootstrapConfigForTesting()
-
 	_, closeFunc, err = xdsclient.DefaultPool.NewClient(t.Name(), &stats.NoopMetricsRecorder{})
 	if err != nil {
 		t.Fatalf("Failed to create xDS client: %v", err)
diff --git a/xds/internal/xdsclient/xdsresource/resource_type.go b/xds/internal/xdsclient/xdsresource/resource_type.go
index 4ecf63a1..202bc8ef 100644
--- a/xds/internal/xdsclient/xdsresource/resource_type.go
+++ b/xds/internal/xdsclient/xdsresource/resource_type.go
@@ -184,17 +184,14 @@ type GenericResourceTypeDecoder struct {
 
 // Decode deserialize and validate resource bytes of an xDS resource received
 // from the xDS management server.
-func (gd *GenericResourceTypeDecoder) Decode(resource xdsclient.AnyProto, gOpts xdsclient.DecodeOptions) (*xdsclient.DecodeResult, error) {
-	rProto := &anypb.Any{
-		TypeUrl: resource.TypeURL,
-		Value:   resource.Value,
-	}
+func (gd *GenericResourceTypeDecoder) Decode(resourceBytes []byte, gOpts xdsclient.DecodeOptions) (*xdsclient.DecodeResult, error) {
+	raw := &anypb.Any{TypeUrl: gd.ResourceType.TypeURL(), Value: resourceBytes}
 	opts := &DecodeOptions{BootstrapConfig: gd.BootstrapConfig}
 	if gOpts.ServerConfig != nil {
 		opts.ServerConfig = gd.ServerConfigMap[*gOpts.ServerConfig]
 	}
 
-	result, err := gd.ResourceType.Decode(opts, rProto)
+	result, err := gd.ResourceType.Decode(opts, raw)
 	if result == nil {
 		return nil, err
 	}
