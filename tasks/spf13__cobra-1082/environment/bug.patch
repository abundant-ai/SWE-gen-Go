diff --git a/bash_completions.go b/bash_completions.go
index b4098f4..d23f96b 100644
--- a/bash_completions.go
+++ b/bash_completions.go
@@ -344,7 +344,7 @@ __%[1]s_handle_word()
     __%[1]s_handle_word
 }
 
-`, name, ShellCompRequestCmd, ShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp))
+`, name, CompRequestCmd, BashCompDirectiveError, BashCompDirectiveNoSpace, BashCompDirectiveNoFileComp))
 }
 
 func writePostscript(buf *bytes.Buffer, name string) {
diff --git a/bash_completions.md b/bash_completions.md
index e1590e1..db67597 100644
--- a/bash_completions.md
+++ b/bash_completions.md
@@ -128,11 +128,11 @@ cmd := &cobra.Command{
 	RunE: func(cmd *cobra.Command, args []string) {
 		RunGet(args[0])
 	},
-	ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
+	ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.BashCompDirective) {
 		if len(args) != 0 {
-			return nil, cobra.ShellCompDirectiveNoFileComp
+			return nil, cobra.BashCompDirectiveNoFileComp
 		}
-		return getReleasesFromCluster(toComplete), cobra.ShellCompDirectiveNoFileComp
+		return getReleasesFromCluster(toComplete), cobra.BashCompDirectiveNoFileComp
 	},
 }
 ```
@@ -143,20 +143,20 @@ Notice we put the `ValidArgsFunction` on the `status` subcommand. Let's assume t
 # helm status [tab][tab]
 harbor notary rook thanos
 ```
-You may have noticed the use of `cobra.ShellCompDirective`.  These directives are bit fields allowing to control some shell completion behaviors for your particular completion.  You can combine them with the bit-or operator such as `cobra.ShellCompDirectiveNoSpace | cobra.ShellCompDirectiveNoFileComp`
+You may have noticed the use of `cobra.BashCompDirective`.  These directives are bit fields allowing to control some shell completion behaviors for your particular completion.  You can combine them with the bit-or operator such as `cobra.BashCompDirectiveNoSpace | cobra.BashCompDirectiveNoFileComp`
 ```go
 // Indicates an error occurred and completions should be ignored.
-ShellCompDirectiveError
+BashCompDirectiveError
 // Indicates that the shell should not add a space after the completion,
 // even if there is a single completion provided.
-ShellCompDirectiveNoSpace
+BashCompDirectiveNoSpace
 // Indicates that the shell should not provide file completion even when
 // no completion is provided.
 // This currently does not work for zsh or bash < 4
-ShellCompDirectiveNoFileComp
+BashCompDirectiveNoFileComp
 // Indicates that the shell will perform its default behavior after completions
-// have been provided (this implies !ShellCompDirectiveNoSpace && !ShellCompDirectiveNoFileComp).
-ShellCompDirectiveDefault
+// have been provided (this implies !BashCompDirectiveNoSpace && !BashCompDirectiveNoFileComp).
+BashCompDirectiveDefault
 ```
 
 When using the `ValidArgsFunction`, Cobra will call your registered function after having parsed all flags and arguments provided in the command-line.  You therefore don't need to do this parsing yourself.  For example, when a user calls `helm status --namespace my-rook-ns [tab][tab]`, Cobra will call your registered `ValidArgsFunction` after having parsed the `--namespace` flag, as it would have done when calling the `RunE` function.
@@ -168,7 +168,7 @@ Cobra achieves dynamic completions written in Go through the use of a hidden com
 # helm __complete status har<ENTER>
 harbor
 :4
-Completion ended with directive: ShellCompDirectiveNoFileComp # This is on stderr
+Completion ended with directive: BashCompDirectiveNoFileComp # This is on stderr
 ```
 ***Important:*** If the noun to complete is empty, you must pass an empty parameter to the `__complete` command:
 ```bash
@@ -178,7 +178,7 @@ notary
 rook
 thanos
 :4
-Completion ended with directive: ShellCompDirectiveNoFileComp # This is on stderr
+Completion ended with directive: BashCompDirectiveNoFileComp # This is on stderr
 ```
 Calling the `__complete` command directly allows you to run the Go debugger to troubleshoot your code.  You can also add printouts to your code; Cobra provides the following functions to use for printouts in Go completion code:
 ```go
@@ -307,8 +307,8 @@ To provide a Go function that Cobra will execute when it needs the list of compl
 
 ```go
 flagName := "output"
-cmd.RegisterFlagCompletionFunc(flagName, func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
-	return []string{"json", "table", "yaml"}, cobra.ShellCompDirectiveDefault
+cmd.RegisterFlagCompletionFunc(flagName, func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.BashCompDirective) {
+	return []string{"json", "table", "yaml"}, cobra.BashCompDirectiveDefault
 })
 ```
 Notice that calling `RegisterFlagCompletionFunc()` is done through the `command` with which the flag is associated.  In our example this dynamic completion will give results like so:
@@ -327,7 +327,7 @@ json
 table
 yaml
 :4
-Completion ended with directive: ShellCompDirectiveNoFileComp # This is on stderr
+Completion ended with directive: BashCompDirectiveNoFileComp # This is on stderr
 ```
 ***Important:*** You should **not** leave traces that print to stdout in your completion code as they will be interpreted as completion choices by the completion script.  Instead, use the cobra-provided debugging traces functions mentioned in the above section.
 
diff --git a/command.go b/command.go
index 88e6ed7..cf02313 100644
--- a/command.go
+++ b/command.go
@@ -60,7 +60,7 @@ type Command struct {
 	// ValidArgsFunction is an optional function that provides valid non-flag arguments for bash completion.
 	// It is a dynamic version of using ValidArgs.
 	// Only one of ValidArgs and ValidArgsFunction can be used for a command.
-	ValidArgsFunction func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective)
+	ValidArgsFunction func(cmd *Command, args []string, toComplete string) ([]string, BashCompDirective)
 
 	// Expected arguments
 	Args PositionalArgs
diff --git a/custom_completions.go b/custom_completions.go
index 81f1bc3..64c7901 100644
--- a/custom_completions.go
+++ b/custom_completions.go
@@ -9,37 +9,37 @@ import (
 	"github.com/spf13/pflag"
 )
 
-// ShellCompRequestCmd is the name of the hidden command that is used to request
+// CompRequestCmd is the name of the hidden command that is used to request
 // completion results from the program.  It is used by the shell completion script.
-const ShellCompRequestCmd = "__complete"
+const CompRequestCmd = "__complete"
 
 // Global map of flag completion functions.
-var flagCompletionFunctions = map[*pflag.Flag]func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective){}
+var flagCompletionFunctions = map[*pflag.Flag]func(cmd *Command, args []string, toComplete string) ([]string, BashCompDirective){}
 
-// ShellCompDirective is a bit map representing the different behaviors the shell
+// BashCompDirective is a bit map representing the different behaviors the shell
 // can be instructed to have once completions have been provided.
-type ShellCompDirective int
+type BashCompDirective int
 
 const (
-	// ShellCompDirectiveError indicates an error occurred and completions should be ignored.
-	ShellCompDirectiveError ShellCompDirective = 1 << iota
+	// BashCompDirectiveError indicates an error occurred and completions should be ignored.
+	BashCompDirectiveError BashCompDirective = 1 << iota
 
-	// ShellCompDirectiveNoSpace indicates that the shell should not add a space
+	// BashCompDirectiveNoSpace indicates that the shell should not add a space
 	// after the completion even if there is a single completion provided.
-	ShellCompDirectiveNoSpace
+	BashCompDirectiveNoSpace
 
-	// ShellCompDirectiveNoFileComp indicates that the shell should not provide
+	// BashCompDirectiveNoFileComp indicates that the shell should not provide
 	// file completion even when no completion is provided.
 	// This currently does not work for zsh or bash < 4
-	ShellCompDirectiveNoFileComp
+	BashCompDirectiveNoFileComp
 
-	// ShellCompDirectiveDefault indicates to let the shell perform its default
+	// BashCompDirectiveDefault indicates to let the shell perform its default
 	// behavior after completions have been provided.
-	ShellCompDirectiveDefault ShellCompDirective = 0
+	BashCompDirectiveDefault BashCompDirective = 0
 )
 
 // RegisterFlagCompletionFunc should be called to register a function to provide completion for a flag.
-func (c *Command) RegisterFlagCompletionFunc(flagName string, f func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective)) error {
+func (c *Command) RegisterFlagCompletionFunc(flagName string, f func(cmd *Command, args []string, toComplete string) ([]string, BashCompDirective)) error {
 	flag := c.Flag(flagName)
 	if flag == nil {
 		return fmt.Errorf("RegisterFlagCompletionFunc: flag '%s' does not exist", flagName)
@@ -52,23 +52,23 @@ func (c *Command) RegisterFlagCompletionFunc(flagName string, f func(cmd *Comman
 }
 
 // Returns a string listing the different directive enabled in the specified parameter
-func (d ShellCompDirective) string() string {
+func (d BashCompDirective) string() string {
 	var directives []string
-	if d&ShellCompDirectiveError != 0 {
-		directives = append(directives, "ShellCompDirectiveError")
+	if d&BashCompDirectiveError != 0 {
+		directives = append(directives, "BashCompDirectiveError")
 	}
-	if d&ShellCompDirectiveNoSpace != 0 {
-		directives = append(directives, "ShellCompDirectiveNoSpace")
+	if d&BashCompDirectiveNoSpace != 0 {
+		directives = append(directives, "BashCompDirectiveNoSpace")
 	}
-	if d&ShellCompDirectiveNoFileComp != 0 {
-		directives = append(directives, "ShellCompDirectiveNoFileComp")
+	if d&BashCompDirectiveNoFileComp != 0 {
+		directives = append(directives, "BashCompDirectiveNoFileComp")
 	}
 	if len(directives) == 0 {
-		directives = append(directives, "ShellCompDirectiveDefault")
+		directives = append(directives, "BashCompDirectiveDefault")
 	}
 
-	if d > ShellCompDirectiveError+ShellCompDirectiveNoSpace+ShellCompDirectiveNoFileComp {
-		return fmt.Sprintf("ERROR: unexpected ShellCompDirective value: %d", d)
+	if d > BashCompDirectiveError+BashCompDirectiveNoSpace+BashCompDirectiveNoFileComp {
+		return fmt.Sprintf("ERROR: unexpected BashCompDirective value: %d", d)
 	}
 	return strings.Join(directives, ", ")
 }
@@ -76,14 +76,14 @@ func (d ShellCompDirective) string() string {
 // Adds a special hidden command that can be used to request custom completions.
 func (c *Command) initCompleteCmd(args []string) {
 	completeCmd := &Command{
-		Use:                   fmt.Sprintf("%s [command-line]", ShellCompRequestCmd),
+		Use:                   fmt.Sprintf("%s [command-line]", CompRequestCmd),
 		DisableFlagsInUseLine: true,
 		Hidden:                true,
 		DisableFlagParsing:    true,
 		Args:                  MinimumNArgs(1),
 		Short:                 "Request shell completion choices for the specified command-line",
 		Long: fmt.Sprintf("%[2]s is a special command that is used by the shell completion logic\n%[1]s",
-			"to request completion choices for the specified command-line.", ShellCompRequestCmd),
+			"to request completion choices for the specified command-line.", CompRequestCmd),
 		Run: func(cmd *Command, args []string) {
 			finalCmd, completions, directive, err := cmd.getCompletions(args)
 			if err != nil {
@@ -98,8 +98,8 @@ func (c *Command) initCompleteCmd(args []string) {
 				fmt.Fprintln(finalCmd.OutOrStdout(), comp)
 			}
 
-			if directive > ShellCompDirectiveError+ShellCompDirectiveNoSpace+ShellCompDirectiveNoFileComp {
-				directive = ShellCompDirectiveDefault
+			if directive > BashCompDirectiveError+BashCompDirectiveNoSpace+BashCompDirectiveNoFileComp {
+				directive = BashCompDirectiveDefault
 			}
 
 			// As the last printout, print the completion directive for the completion script to parse.
@@ -114,7 +114,7 @@ func (c *Command) initCompleteCmd(args []string) {
 	}
 	c.AddCommand(completeCmd)
 	subCmd, _, err := c.Find(args)
-	if err != nil || subCmd.Name() != ShellCompRequestCmd {
+	if err != nil || subCmd.Name() != CompRequestCmd {
 		// Only create this special command if it is actually being called.
 		// This reduces possible side-effects of creating such a command;
 		// for example, having this command would cause problems to a
@@ -124,7 +124,7 @@ func (c *Command) initCompleteCmd(args []string) {
 	}
 }
 
-func (c *Command) getCompletions(args []string) (*Command, []string, ShellCompDirective, error) {
+func (c *Command) getCompletions(args []string) (*Command, []string, BashCompDirective, error) {
 	var completions []string
 
 	// The last argument, which is not completely typed by the user,
@@ -136,7 +136,7 @@ func (c *Command) getCompletions(args []string) (*Command, []string, ShellCompDi
 	finalCmd, finalArgs, err := c.Root().Find(trimmedArgs)
 	if err != nil {
 		// Unable to find the real command. E.g., <program> someInvalidCmd <TAB>
-		return c, completions, ShellCompDirectiveDefault, fmt.Errorf("Unable to find a command for arguments: %v", trimmedArgs)
+		return c, completions, BashCompDirectiveDefault, fmt.Errorf("Unable to find a command for arguments: %v", trimmedArgs)
 	}
 
 	var flag *pflag.Flag
@@ -146,13 +146,13 @@ func (c *Command) getCompletions(args []string) (*Command, []string, ShellCompDi
 		flag, finalArgs, toComplete, err = checkIfFlagCompletion(finalCmd, finalArgs, toComplete)
 		if err != nil {
 			// Error while attempting to parse flags
-			return finalCmd, completions, ShellCompDirectiveDefault, err
+			return finalCmd, completions, BashCompDirectiveDefault, err
 		}
 	}
 
 	// Parse the flags and extract the arguments to prepare for calling the completion function
 	if err = finalCmd.ParseFlags(finalArgs); err != nil {
-		return finalCmd, completions, ShellCompDirectiveDefault, fmt.Errorf("Error while parsing flags from args %v: %s", finalArgs, err.Error())
+		return finalCmd, completions, BashCompDirectiveDefault, fmt.Errorf("Error while parsing flags from args %v: %s", finalArgs, err.Error())
 	}
 
 	// We only remove the flags from the arguments if DisableFlagParsing is not set.
@@ -162,7 +162,7 @@ func (c *Command) getCompletions(args []string) (*Command, []string, ShellCompDi
 	}
 
 	// Find the completion function for the flag or command
-	var completionFn func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective)
+	var completionFn func(cmd *Command, args []string, toComplete string) ([]string, BashCompDirective)
 	if flag != nil {
 		completionFn = flagCompletionFunctions[flag]
 	} else {
@@ -170,7 +170,7 @@ func (c *Command) getCompletions(args []string) (*Command, []string, ShellCompDi
 	}
 	if completionFn == nil {
 		// Go custom completion not supported/needed for this flag or command
-		return finalCmd, completions, ShellCompDirectiveDefault, nil
+		return finalCmd, completions, BashCompDirectiveDefault, nil
 	}
 
 	// Call the registered completion function to get the completions
diff --git a/custom_completions_test.go b/custom_completions_test.go
index ea6a6d9..61d214d 100644
--- a/custom_completions_test.go
+++ b/custom_completions_test.go
@@ -6,9 +6,9 @@ import (
 	"testing"
 )
 
-func validArgsFunc(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective) {
+func validArgsFunc(cmd *Command, args []string, toComplete string) ([]string, BashCompDirective) {
 	if len(args) != 0 {
-		return nil, ShellCompDirectiveNoFileComp
+		return nil, BashCompDirectiveNoFileComp
 	}
 
 	var completions []string
@@ -17,12 +17,12 @@ func validArgsFunc(cmd *Command, args []string, toComplete string) ([]string, Sh
 			completions = append(completions, comp)
 		}
 	}
-	return completions, ShellCompDirectiveDefault
+	return completions, BashCompDirectiveDefault
 }
 
-func validArgsFunc2(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective) {
+func validArgsFunc2(cmd *Command, args []string, toComplete string) ([]string, BashCompDirective) {
 	if len(args) != 0 {
-		return nil, ShellCompDirectiveNoFileComp
+		return nil, BashCompDirectiveNoFileComp
 	}
 
 	var completions []string
@@ -31,7 +31,7 @@ func validArgsFunc2(cmd *Command, args []string, toComplete string) ([]string, S
 			completions = append(completions, comp)
 		}
 	}
-	return completions, ShellCompDirectiveDefault
+	return completions, BashCompDirectiveDefault
 }
 
 func TestValidArgsFuncSingleCmd(t *testing.T) {
@@ -42,7 +42,7 @@ func TestValidArgsFuncSingleCmd(t *testing.T) {
 	}
 
 	// Test completing an empty string
-	output, err := executeCommand(rootCmd, ShellCompRequestCmd, "")
+	output, err := executeCommand(rootCmd, CompRequestCmd, "")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -51,14 +51,14 @@ func TestValidArgsFuncSingleCmd(t *testing.T) {
 		"one",
 		"two",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Check completing with a prefix
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "t")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "t")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -66,7 +66,7 @@ func TestValidArgsFuncSingleCmd(t *testing.T) {
 	expected = strings.Join([]string{
 		"two",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
@@ -86,14 +86,14 @@ func TestValidArgsFuncSingleCmdInvalidArg(t *testing.T) {
 	}
 
 	// Check completing with wrong number of args
-	output, err := executeCommand(rootCmd, ShellCompRequestCmd, "unexpectedArg", "t")
+	output, err := executeCommand(rootCmd, CompRequestCmd, "unexpectedArg", "t")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
 
 	expected := strings.Join([]string{
 		":4",
-		"Completion ended with directive: ShellCompDirectiveNoFileComp", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveNoFileComp", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
@@ -115,7 +115,7 @@ func TestValidArgsFuncChildCmds(t *testing.T) {
 	rootCmd.AddCommand(child1Cmd, child2Cmd)
 
 	// Test completion of first sub-command with empty argument
-	output, err := executeCommand(rootCmd, ShellCompRequestCmd, "child1", "")
+	output, err := executeCommand(rootCmd, CompRequestCmd, "child1", "")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -124,14 +124,14 @@ func TestValidArgsFuncChildCmds(t *testing.T) {
 		"one",
 		"two",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Test completion of first sub-command with a prefix to complete
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "child1", "t")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "child1", "t")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -139,28 +139,28 @@ func TestValidArgsFuncChildCmds(t *testing.T) {
 	expected = strings.Join([]string{
 		"two",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Check completing with wrong number of args
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "child1", "unexpectedArg", "t")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "child1", "unexpectedArg", "t")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
 
 	expected = strings.Join([]string{
 		":4",
-		"Completion ended with directive: ShellCompDirectiveNoFileComp", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveNoFileComp", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Test completion of second sub-command with empty argument
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "child2", "")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "child2", "")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -169,13 +169,13 @@ func TestValidArgsFuncChildCmds(t *testing.T) {
 		"three",
 		"four",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "child2", "t")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "child2", "t")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -183,21 +183,21 @@ func TestValidArgsFuncChildCmds(t *testing.T) {
 	expected = strings.Join([]string{
 		"three",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Check completing with wrong number of args
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "child2", "unexpectedArg", "t")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "child2", "unexpectedArg", "t")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
 
 	expected = strings.Join([]string{
 		":4",
-		"Completion ended with directive: ShellCompDirectiveNoFileComp", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveNoFileComp", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
@@ -215,7 +215,7 @@ func TestValidArgsFuncAliases(t *testing.T) {
 	rootCmd.AddCommand(child)
 
 	// Test completion of first sub-command with empty argument
-	output, err := executeCommand(rootCmd, ShellCompRequestCmd, "son", "")
+	output, err := executeCommand(rootCmd, CompRequestCmd, "son", "")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -224,14 +224,14 @@ func TestValidArgsFuncAliases(t *testing.T) {
 		"one",
 		"two",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Test completion of first sub-command with a prefix to complete
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "daughter", "t")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "daughter", "t")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -239,21 +239,21 @@ func TestValidArgsFuncAliases(t *testing.T) {
 	expected = strings.Join([]string{
 		"two",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Check completing with wrong number of args
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "son", "unexpectedArg", "t")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "son", "unexpectedArg", "t")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
 
 	expected = strings.Join([]string{
 		":4",
-		"Completion ended with directive: ShellCompDirectiveNoFileComp", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveNoFileComp", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
@@ -297,28 +297,28 @@ func TestFlagCompletionInGo(t *testing.T) {
 		Run: emptyRun,
 	}
 	rootCmd.Flags().IntP("introot", "i", -1, "help message for flag introot")
-	rootCmd.RegisterFlagCompletionFunc("introot", func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective) {
+	rootCmd.RegisterFlagCompletionFunc("introot", func(cmd *Command, args []string, toComplete string) ([]string, BashCompDirective) {
 		completions := []string{}
 		for _, comp := range []string{"1", "2", "10"} {
 			if strings.HasPrefix(comp, toComplete) {
 				completions = append(completions, comp)
 			}
 		}
-		return completions, ShellCompDirectiveDefault
+		return completions, BashCompDirectiveDefault
 	})
 	rootCmd.Flags().String("filename", "", "Enter a filename")
-	rootCmd.RegisterFlagCompletionFunc("filename", func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective) {
+	rootCmd.RegisterFlagCompletionFunc("filename", func(cmd *Command, args []string, toComplete string) ([]string, BashCompDirective) {
 		completions := []string{}
 		for _, comp := range []string{"file.yaml", "myfile.json", "file.xml"} {
 			if strings.HasPrefix(comp, toComplete) {
 				completions = append(completions, comp)
 			}
 		}
-		return completions, ShellCompDirectiveNoSpace | ShellCompDirectiveNoFileComp
+		return completions, BashCompDirectiveNoSpace | BashCompDirectiveNoFileComp
 	})
 
 	// Test completing an empty string
-	output, err := executeCommand(rootCmd, ShellCompRequestCmd, "--introot", "")
+	output, err := executeCommand(rootCmd, CompRequestCmd, "--introot", "")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -328,14 +328,14 @@ func TestFlagCompletionInGo(t *testing.T) {
 		"2",
 		"10",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Check completing with a prefix
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "--introot", "1")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "--introot", "1")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -344,14 +344,14 @@ func TestFlagCompletionInGo(t *testing.T) {
 		"1",
 		"10",
 		":0",
-		"Completion ended with directive: ShellCompDirectiveDefault", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveDefault", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Test completing an empty string
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "--filename", "")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "--filename", "")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -361,14 +361,14 @@ func TestFlagCompletionInGo(t *testing.T) {
 		"myfile.json",
 		"file.xml",
 		":6",
-		"Completion ended with directive: ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveNoSpace, BashCompDirectiveNoFileComp", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
 	}
 
 	// Check completing with a prefix
-	output, err = executeCommand(rootCmd, ShellCompRequestCmd, "--filename", "f")
+	output, err = executeCommand(rootCmd, CompRequestCmd, "--filename", "f")
 	if err != nil {
 		t.Errorf("Unexpected error: %v", err)
 	}
@@ -377,7 +377,7 @@ func TestFlagCompletionInGo(t *testing.T) {
 		"file.yaml",
 		"file.xml",
 		":6",
-		"Completion ended with directive: ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp", ""}, "\n")
+		"Completion ended with directive: BashCompDirectiveNoSpace, BashCompDirectiveNoFileComp", ""}, "\n")
 
 	if output != expected {
 		t.Errorf("expected: %q, got: %q", expected, output)
