diff --git a/internal/configs/configschema/coerce_value.go b/internal/configs/configschema/coerce_value.go
index 4e3263df43..d1ccc3013e 100644
--- a/internal/configs/configschema/coerce_value.go
+++ b/internal/configs/configschema/coerce_value.go
@@ -73,6 +73,14 @@ func (b *Block) coerceValue(in cty.Value, path cty.Path) (cty.Value, error) {
 			return cty.UnknownVal(impliedType), path.NewErrorf("attribute %q has none of required, optional, or computed set", name)
 		}
 
+		// check for NestingGroup which cannot be null
+		if attrS.NestedType != nil && attrS.NestedType.Nesting == NestingGroup && val.IsNull() {
+			// we can cheat here and use EmptyValue to get a "zero" value
+			// object, and expect the conversion to turn out the correct final
+			// object type
+			val = cty.EmptyObjectVal
+		}
+
 		val, err := convert.Convert(val, attrConvType)
 		if err != nil {
 			return cty.UnknownVal(impliedType), append(path, cty.GetAttrStep{Name: name}).NewError(err)
diff --git a/internal/configs/configschema/implied_type.go b/internal/configs/configschema/implied_type.go
index c94c6591ff..ced1943d67 100644
--- a/internal/configs/configschema/implied_type.go
+++ b/internal/configs/configschema/implied_type.go
@@ -138,8 +138,9 @@ func (o *Object) specType() cty.Type {
 	} else {
 		ret = cty.Object(attrTys)
 	}
+
 	switch o.Nesting {
-	case NestingSingle:
+	case NestingSingle, NestingGroup:
 		return ret
 	case NestingList:
 		return cty.List(ret)
