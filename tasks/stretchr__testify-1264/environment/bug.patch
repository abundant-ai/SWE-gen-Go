diff --git a/assert/assertion_format.go b/assert/assertion_format.go
index 3f350c4..7880b8f 100644
--- a/assert/assertion_format.go
+++ b/assert/assertion_format.go
@@ -155,31 +155,6 @@ func Eventuallyf(t TestingT, condition func() bool, waitFor time.Duration, tick
 	return Eventually(t, condition, waitFor, tick, append([]interface{}{msg}, args...)...)
 }
 
-// EventuallyWithTf asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick. In contrast to Eventually,
-// it supplies a CollectT to the condition function, so that the condition
-// function can use the CollectT to call other assertions.
-// The condition is considered "met" if no errors are raised in a tick.
-// The supplied CollectT collects all errors from one tick (if there are any).
-// If the condition is not met before waitFor, the collected errors of
-// the last tick are copied to t.
-//
-// 	externalValue := false
-// 	go func() {
-// 		time.Sleep(8*time.Second)
-// 		externalValue = true
-// 	}()
-// 	assert.EventuallyWithTf(t, func(c *assert.CollectT, "error message %s", "formatted") {
-// 		// add assertions as needed; any assertion failure will fail the current tick
-// 		assert.True(c, externalValue, "expected 'externalValue' to be true")
-// 	}, 1*time.Second, 10*time.Second, "external state has not changed to 'true'; still false")
-func EventuallyWithTf(t TestingT, condition func(collect *CollectT), waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	return EventuallyWithT(t, condition, waitFor, tick, append([]interface{}{msg}, args...)...)
-}
-
 // Exactlyf asserts that two objects are equal in value and type.
 //
 //    assert.Exactlyf(t, int32(123), int64(123), "error message %s", "formatted")
diff --git a/assert/assertion_forward.go b/assert/assertion_forward.go
index 3c8f870..339515b 100644
--- a/assert/assertion_forward.go
+++ b/assert/assertion_forward.go
@@ -288,56 +288,6 @@ func (a *Assertions) Eventually(condition func() bool, waitFor time.Duration, ti
 	return Eventually(a.t, condition, waitFor, tick, msgAndArgs...)
 }
 
-// EventuallyWithT asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick. In contrast to Eventually,
-// it supplies a CollectT to the condition function, so that the condition
-// function can use the CollectT to call other assertions.
-// The condition is considered "met" if no errors are raised in a tick.
-// The supplied CollectT collects all errors from one tick (if there are any).
-// If the condition is not met before waitFor, the collected errors of
-// the last tick are copied to t.
-//
-// 	externalValue := false
-// 	go func() {
-// 		time.Sleep(8*time.Second)
-// 		externalValue = true
-// 	}()
-// 	a.EventuallyWithT(func(c *assert.CollectT) {
-// 		// add assertions as needed; any assertion failure will fail the current tick
-// 		assert.True(c, externalValue, "expected 'externalValue' to be true")
-// 	}, 1*time.Second, 10*time.Second, "external state has not changed to 'true'; still false")
-func (a *Assertions) EventuallyWithT(condition func(collect *CollectT), waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	return EventuallyWithT(a.t, condition, waitFor, tick, msgAndArgs...)
-}
-
-// EventuallyWithTf asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick. In contrast to Eventually,
-// it supplies a CollectT to the condition function, so that the condition
-// function can use the CollectT to call other assertions.
-// The condition is considered "met" if no errors are raised in a tick.
-// The supplied CollectT collects all errors from one tick (if there are any).
-// If the condition is not met before waitFor, the collected errors of
-// the last tick are copied to t.
-//
-// 	externalValue := false
-// 	go func() {
-// 		time.Sleep(8*time.Second)
-// 		externalValue = true
-// 	}()
-// 	a.EventuallyWithTf(func(c *assert.CollectT, "error message %s", "formatted") {
-// 		// add assertions as needed; any assertion failure will fail the current tick
-// 		assert.True(c, externalValue, "expected 'externalValue' to be true")
-// 	}, 1*time.Second, 10*time.Second, "external state has not changed to 'true'; still false")
-func (a *Assertions) EventuallyWithTf(condition func(collect *CollectT), waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	return EventuallyWithTf(a.t, condition, waitFor, tick, msg, args...)
-}
-
 // Eventuallyf asserts that given condition will be met in waitFor time,
 // periodically checking target function each tick.
 //
diff --git a/assert/assertions.go b/assert/assertions.go
index ed9d677..fa1245b 100644
--- a/assert/assertions.go
+++ b/assert/assertions.go
@@ -1756,89 +1756,6 @@ func Eventually(t TestingT, condition func() bool, waitFor time.Duration, tick t
 	}
 }
 
-// CollectT implements the TestingT interface and collects all errors.
-type CollectT struct {
-	errors []error
-}
-
-// Errorf collects the error.
-func (c *CollectT) Errorf(format string, args ...interface{}) {
-	c.errors = append(c.errors, fmt.Errorf(format, args...))
-}
-
-// FailNow panics.
-func (c *CollectT) FailNow() {
-	panic("Assertion failed")
-}
-
-// Reset clears the collected errors.
-func (c *CollectT) Reset() {
-	c.errors = nil
-}
-
-// Copy copies the collected errors to the supplied t.
-func (c *CollectT) Copy(t TestingT) {
-	if tt, ok := t.(tHelper); ok {
-		tt.Helper()
-	}
-	for _, err := range c.errors {
-		t.Errorf("%v", err)
-	}
-}
-
-// EventuallyWithT asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick. In contrast to Eventually,
-// it supplies a CollectT to the condition function, so that the condition
-// function can use the CollectT to call other assertions.
-// The condition is considered "met" if no errors are raised in a tick.
-// The supplied CollectT collects all errors from one tick (if there are any).
-// If the condition is not met before waitFor, the collected errors of
-// the last tick are copied to t.
-//
-//	externalValue := false
-//	go func() {
-//		time.Sleep(8*time.Second)
-//		externalValue = true
-//	}()
-//	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-//		// add assertions as needed; any assertion failure will fail the current tick
-//		assert.True(c, externalValue, "expected 'externalValue' to be true")
-//	}, 1*time.Second, 10*time.Second, "external state has not changed to 'true'; still false")
-func EventuallyWithT(t TestingT, condition func(collect *CollectT), waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-
-	collect := new(CollectT)
-	ch := make(chan bool, 1)
-
-	timer := time.NewTimer(waitFor)
-	defer timer.Stop()
-
-	ticker := time.NewTicker(tick)
-	defer ticker.Stop()
-
-	for tick := ticker.C; ; {
-		select {
-		case <-timer.C:
-			collect.Copy(t)
-			return Fail(t, "Condition never satisfied", msgAndArgs...)
-		case <-tick:
-			tick = nil
-			collect.Reset()
-			go func() {
-				condition(collect)
-				ch <- len(collect.errors) == 0
-			}()
-		case v := <-ch:
-			if v {
-				return true
-			}
-			tick = ticker.C
-		}
-	}
-}
-
 // Never asserts that the given condition doesn't satisfy in waitFor time,
 // periodically checking the target function each tick.
 //
diff --git a/assert/assertions_test.go b/assert/assertions_test.go
index 14b657b..bdab184 100644
--- a/assert/assertions_test.go
+++ b/assert/assertions_test.go
@@ -2428,32 +2428,6 @@ func TestEventuallyTrue(t *testing.T) {
 	True(t, Eventually(t, condition, 100*time.Millisecond, 20*time.Millisecond))
 }
 
-func TestEventuallyWithTFalse(t *testing.T) {
-	mockT := new(CollectT)
-
-	condition := func(collect *CollectT) {
-		True(collect, false)
-	}
-
-	False(t, EventuallyWithT(mockT, condition, 100*time.Millisecond, 20*time.Millisecond))
-	Len(t, mockT.errors, 2)
-}
-
-func TestEventuallyWithTTrue(t *testing.T) {
-	mockT := new(CollectT)
-
-	state := 0
-	condition := func(collect *CollectT) {
-		defer func() {
-			state += 1
-		}()
-		True(collect, state == 2)
-	}
-
-	True(t, EventuallyWithT(mockT, condition, 100*time.Millisecond, 20*time.Millisecond))
-	Len(t, mockT.errors, 0)
-}
-
 func TestNeverFalse(t *testing.T) {
 	condition := func() bool {
 		return false
diff --git a/require/require.go b/require/require.go
index 282499a..880853f 100644
--- a/require/require.go
+++ b/require/require.go
@@ -364,62 +364,6 @@ func Eventually(t TestingT, condition func() bool, waitFor time.Duration, tick t
 	t.FailNow()
 }
 
-// EventuallyWithT asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick. In contrast to Eventually,
-// it supplies a CollectT to the condition function, so that the condition
-// function can use the CollectT to call other assertions.
-// The condition is considered "met" if no errors are raised in a tick.
-// The supplied CollectT collects all errors from one tick (if there are any).
-// If the condition is not met before waitFor, the collected errors of
-// the last tick are copied to t.
-//
-// 	externalValue := false
-// 	go func() {
-// 		time.Sleep(8*time.Second)
-// 		externalValue = true
-// 	}()
-// 	assert.EventuallyWithT(t, func(c *assert.CollectT) {
-// 		// add assertions as needed; any assertion failure will fail the current tick
-// 		assert.True(c, externalValue, "expected 'externalValue' to be true")
-// 	}, 1*time.Second, 10*time.Second, "external state has not changed to 'true'; still false")
-func EventuallyWithT(t TestingT, condition func(collect *assert.CollectT), waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	if assert.EventuallyWithT(t, condition, waitFor, tick, msgAndArgs...) {
-		return
-	}
-	t.FailNow()
-}
-
-// EventuallyWithTf asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick. In contrast to Eventually,
-// it supplies a CollectT to the condition function, so that the condition
-// function can use the CollectT to call other assertions.
-// The condition is considered "met" if no errors are raised in a tick.
-// The supplied CollectT collects all errors from one tick (if there are any).
-// If the condition is not met before waitFor, the collected errors of
-// the last tick are copied to t.
-//
-// 	externalValue := false
-// 	go func() {
-// 		time.Sleep(8*time.Second)
-// 		externalValue = true
-// 	}()
-// 	assert.EventuallyWithTf(t, func(c *assert.CollectT, "error message %s", "formatted") {
-// 		// add assertions as needed; any assertion failure will fail the current tick
-// 		assert.True(c, externalValue, "expected 'externalValue' to be true")
-// 	}, 1*time.Second, 10*time.Second, "external state has not changed to 'true'; still false")
-func EventuallyWithTf(t TestingT, condition func(collect *assert.CollectT), waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	if assert.EventuallyWithTf(t, condition, waitFor, tick, msg, args...) {
-		return
-	}
-	t.FailNow()
-}
-
 // Eventuallyf asserts that given condition will be met in waitFor time,
 // periodically checking target function each tick.
 //
diff --git a/require/require_forward.go b/require/require_forward.go
index 4df7b51..960bf6f 100644
--- a/require/require_forward.go
+++ b/require/require_forward.go
@@ -289,56 +289,6 @@ func (a *Assertions) Eventually(condition func() bool, waitFor time.Duration, ti
 	Eventually(a.t, condition, waitFor, tick, msgAndArgs...)
 }
 
-// EventuallyWithT asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick. In contrast to Eventually,
-// it supplies a CollectT to the condition function, so that the condition
-// function can use the CollectT to call other assertions.
-// The condition is considered "met" if no errors are raised in a tick.
-// The supplied CollectT collects all errors from one tick (if there are any).
-// If the condition is not met before waitFor, the collected errors of
-// the last tick are copied to t.
-//
-// 	externalValue := false
-// 	go func() {
-// 		time.Sleep(8*time.Second)
-// 		externalValue = true
-// 	}()
-// 	a.EventuallyWithT(func(c *assert.CollectT) {
-// 		// add assertions as needed; any assertion failure will fail the current tick
-// 		assert.True(c, externalValue, "expected 'externalValue' to be true")
-// 	}, 1*time.Second, 10*time.Second, "external state has not changed to 'true'; still false")
-func (a *Assertions) EventuallyWithT(condition func(collect *assert.CollectT), waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	EventuallyWithT(a.t, condition, waitFor, tick, msgAndArgs...)
-}
-
-// EventuallyWithTf asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick. In contrast to Eventually,
-// it supplies a CollectT to the condition function, so that the condition
-// function can use the CollectT to call other assertions.
-// The condition is considered "met" if no errors are raised in a tick.
-// The supplied CollectT collects all errors from one tick (if there are any).
-// If the condition is not met before waitFor, the collected errors of
-// the last tick are copied to t.
-//
-// 	externalValue := false
-// 	go func() {
-// 		time.Sleep(8*time.Second)
-// 		externalValue = true
-// 	}()
-// 	a.EventuallyWithTf(func(c *assert.CollectT, "error message %s", "formatted") {
-// 		// add assertions as needed; any assertion failure will fail the current tick
-// 		assert.True(c, externalValue, "expected 'externalValue' to be true")
-// 	}, 1*time.Second, 10*time.Second, "external state has not changed to 'true'; still false")
-func (a *Assertions) EventuallyWithTf(condition func(collect *assert.CollectT), waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	EventuallyWithTf(a.t, condition, waitFor, tick, msg, args...)
-}
-
 // Eventuallyf asserts that given condition will be met in waitFor time,
 // periodically checking target function each tick.
 //
