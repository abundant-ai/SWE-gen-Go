diff --git a/internal/pool/pool.go b/internal/pool/pool.go
index ed589781..30e34f16 100644
--- a/internal/pool/pool.go
+++ b/internal/pool/pool.go
@@ -33,6 +33,9 @@ var (
 	// errConnNotPooled is returned when trying to return a non-pooled connection to the pool.
 	errConnNotPooled = errors.New("connection not pooled")
 
+	// errPanicInDial is returned when a panic occurs in the dial function.
+	errPanicInQueuedNewConn = errors.New("panic in queuedNewConn")
+
 	// popAttempts is the maximum number of attempts to find a usable connection
 	// when popping from the idle connection pool. This handles cases where connections
 	// are temporarily marked as unusable (e.g., during maintenanceNotifications upgrades or network issues).
@@ -596,12 +599,15 @@ func (p *ConnPool) queuedNewConn(ctx context.Context) (*Conn, error) {
 		}
 	}()
 
+	p.dialsQueue.discardDoneAtFront()
 	p.dialsQueue.enqueue(w)
 
 	go func(w *wantConn) {
 		var freeTurnCalled bool
 		defer func() {
 			if err := recover(); err != nil {
+				w.tryDeliver(nil, errPanicInQueuedNewConn)
+				p.dialsQueue.discardDoneAtFront()
 				if !freeTurnCalled {
 					p.freeTurn()
 				}
@@ -616,12 +622,14 @@ func (p *ConnPool) queuedNewConn(ctx context.Context) (*Conn, error) {
 		cn, cnErr := p.newConn(dialCtx, true)
 		if cnErr != nil {
 			w.tryDeliver(nil, cnErr) // deliver error to caller, notify connection creation failed
+			p.dialsQueue.discardDoneAtFront()
 			p.freeTurn()
 			freeTurnCalled = true
 			return
 		}
 
 		delivered := w.tryDeliver(cn, cnErr)
+		p.dialsQueue.discardDoneAtFront()
 		if !delivered && p.putIdleConn(dialCtx, cn) {
 			p.freeTurn()
 			freeTurnCalled = true
diff --git a/internal/pool/want_conn.go b/internal/pool/want_conn.go
index 6f9e4bfa..78f86813 100644
--- a/internal/pool/want_conn.go
+++ b/internal/pool/want_conn.go
@@ -6,7 +6,7 @@ import (
 )
 
 type wantConn struct {
-	mu        sync.Mutex      // protects ctx, done and sending of the result
+	mu        sync.RWMutex    // protects ctx, done and sending of the result
 	ctx       context.Context // context for dial, cleared after delivered or canceled
 	cancelCtx context.CancelFunc
 	done      bool                // true after delivered or canceled
@@ -15,8 +15,8 @@ type wantConn struct {
 
 // getCtxForDial returns context for dial or nil if connection was delivered or canceled.
 func (w *wantConn) getCtxForDial() context.Context {
-	w.mu.Lock()
-	defer w.mu.Unlock()
+	w.mu.RLock()
+	defer w.mu.RUnlock()
 
 	return w.ctx
 }
@@ -57,6 +57,12 @@ func (w *wantConn) cancel() *Conn {
 	return cn
 }
 
+func (w *wantConn) isOngoing() bool {
+	w.mu.RLock()
+	defer w.mu.RUnlock()
+	return !w.done
+}
+
 type wantConnResult struct {
 	cn  *Conn
 	err error
@@ -91,3 +97,19 @@ func (q *wantConnQueue) dequeue() (*wantConn, bool) {
 	q.items = q.items[1:]
 	return item, true
 }
+
+func (q *wantConnQueue) discardDoneAtFront() int {
+	q.mu.Lock()
+	defer q.mu.Unlock()
+	count := 0
+	for len(q.items) > 0 {
+		if q.items[0].isOngoing() {
+			break
+		}
+
+		q.items = q.items[1:]
+		count++
+	}
+
+	return count
+}
