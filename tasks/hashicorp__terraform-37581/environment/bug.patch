diff --git a/internal/configs/action.go b/internal/configs/action.go
index f146ed36ca..391e6af3a6 100644
--- a/internal/configs/action.go
+++ b/internal/configs/action.go
@@ -5,7 +5,6 @@ package configs
 
 import (
 	"fmt"
-	"slices"
 
 	"github.com/hashicorp/hcl/v2"
 	"github.com/hashicorp/hcl/v2/hclsyntax"
@@ -152,21 +151,8 @@ func decodeActionTriggerBlock(block *hcl.Block) (*ActionTrigger, hcl.Diagnostics
 				})
 				continue
 			}
-
-			// Check for duplicate events
-			if slices.Contains(events, event) {
-				diags = append(diags, &hcl.Diagnostic{
-					Severity: hcl.DiagError,
-					Summary:  fmt.Sprintf("Duplicate %q event", hcl.ExprAsKeyword(expr)),
-					Detail:   "The event is already defined in this action_trigger block.",
-					Subject:  expr.Range().Ptr(),
-				})
-				continue
-			}
-
 			events = append(events, event)
 		}
-
 		a.Events = events
 	}
 
diff --git a/internal/configs/action_test.go b/internal/configs/action_test.go
index 41078e4752..5420afbf6d 100644
--- a/internal/configs/action_test.go
+++ b/internal/configs/action_test.go
@@ -254,32 +254,6 @@ func TestDecodeActionTriggerBlock(t *testing.T) {
 				":0,0-0: No events specified; At least one event must be specified for an action_trigger.",
 			},
 		},
-
-		"error - duplicate event": {
-			&hcl.Block{
-				Type: "action_trigger",
-				Body: hcltest.MockBody(&hcl.BodyContent{
-					Attributes: hcltest.MockAttrs(map[string]hcl.Expression{
-						"condition": conditionExpr,
-						"events":    hcltest.MockExprList([]hcl.Expression{hcltest.MockExprTraversalSrc("before_create"), hcltest.MockExprTraversalSrc("before_create")}),
-						"actions":   hcltest.MockExprList([]hcl.Expression{fooActionExpr}),
-					}),
-				}),
-			},
-			&ActionTrigger{
-				Condition: conditionExpr,
-				Events:    []ActionTriggerEvent{BeforeCreate},
-				Actions: []ActionRef{
-					{
-						fooActionExpr,
-						fooActionExpr.Range(),
-					},
-				},
-			},
-			[]string{
-				`MockExprTraversal:0,0-13: Duplicate "before_create" event; The event is already defined in this action_trigger block.`,
-			},
-		},
 	}
 
 	for name, test := range tests {
diff --git a/internal/terraform/context_apply_action_test.go b/internal/terraform/context_apply_action_test.go
index ed26343fb2..f8702c93e3 100644
--- a/internal/terraform/context_apply_action_test.go
+++ b/internal/terraform/context_apply_action_test.go
@@ -1847,82 +1847,6 @@ resource "test_object" "a" {
 			},
 			expectInvokeActionCalled: true,
 		},
-		"multiple events triggering in same action trigger": {
-			module: map[string]string{
-				"main.tf": `
-action "act_unlinked" "hello" {}
-resource "test_object" "a" {
-  lifecycle {
-    action_trigger {
-      events = [
-        before_create, // should trigger
-        after_create, // should trigger
-        before_update // should be ignored
-      ]
-      actions = [action.act_unlinked.hello]
-    }
-  }
-}
-`,
-			},
-			expectInvokeActionCalled: true,
-			expectInvokeActionCalls: []providers.InvokeActionRequest{
-				{
-					ActionType: "act_unlinked",
-					PlannedActionData: cty.NullVal(cty.Object(map[string]cty.Type{
-						"attr": cty.String,
-					})),
-				},
-				{
-					ActionType: "act_unlinked",
-					PlannedActionData: cty.NullVal(cty.Object(map[string]cty.Type{
-						"attr": cty.String,
-					})),
-				},
-			},
-		},
-
-		"multiple events triggering in multiple action trigger": {
-			module: map[string]string{
-				"main.tf": `
-action "act_unlinked" "hello" {}
-resource "test_object" "a" {
-  lifecycle {
-    // should trigger
-    action_trigger {
-      events = [before_create]
-      actions = [action.act_unlinked.hello]
-    }
-    // should trigger
-    action_trigger {
-      events = [after_create]
-      actions = [action.act_unlinked.hello]
-    }
-    // should be ignored
-    action_trigger {
-      events = [before_update]
-      actions = [action.act_unlinked.hello]
-    }
-  }
-}
-`,
-			},
-			expectInvokeActionCalled: true,
-			expectInvokeActionCalls: []providers.InvokeActionRequest{
-				{
-					ActionType: "act_unlinked",
-					PlannedActionData: cty.NullVal(cty.Object(map[string]cty.Type{
-						"attr": cty.String,
-					})),
-				},
-				{
-					ActionType: "act_unlinked",
-					PlannedActionData: cty.NullVal(cty.Object(map[string]cty.Type{
-						"attr": cty.String,
-					})),
-				},
-			},
-		},
 	} {
 		t.Run(name, func(t *testing.T) {
 			if tc.toBeImplemented {
diff --git a/internal/terraform/context_plan_actions_test.go b/internal/terraform/context_plan_actions_test.go
index 84487b9308..6e0cf303a6 100644
--- a/internal/terraform/context_plan_actions_test.go
+++ b/internal/terraform/context_plan_actions_test.go
@@ -3091,93 +3091,6 @@ resource "test_object" "a" {
 				}
 			},
 		},
-
-		"multiple events triggering in same action trigger": {
-			module: map[string]string{
-				"main.tf": `
-action "test_unlinked" "hello" {}
-resource "test_object" "a" {
-  lifecycle {
-    action_trigger {
-      events = [
-        before_create, // should trigger
-        after_create, // should trigger
-        before_update // should be ignored
-      ]
-      actions = [action.test_unlinked.hello]
-    }
-  }
-}
-`,
-			},
-			expectPlanActionCalled: true,
-
-			assertPlan: func(t *testing.T, p *plans.Plan) {
-				if len(p.Changes.ActionInvocations) != 2 {
-					t.Fatalf("expected 2 action in plan, got %d", len(p.Changes.ActionInvocations))
-				}
-
-				triggeredEvents := []configs.ActionTriggerEvent{}
-				for _, action := range p.Changes.ActionInvocations {
-					at, ok := action.ActionTrigger.(*plans.LifecycleActionTrigger)
-					if !ok {
-						t.Fatalf("expected action trigger to be a LifecycleActionTrigger, got %T", action.ActionTrigger)
-					}
-					triggeredEvents = append(triggeredEvents, at.ActionTriggerEvent)
-				}
-				slices.Sort(triggeredEvents)
-				if diff := cmp.Diff([]configs.ActionTriggerEvent{configs.BeforeCreate, configs.AfterCreate}, triggeredEvents); diff != "" {
-					t.Errorf("wrong result\n%s", diff)
-				}
-			},
-		},
-
-		"multiple events triggering in multiple action trigger": {
-			module: map[string]string{
-				"main.tf": `
-action "test_unlinked" "hello" {}
-resource "test_object" "a" {
-  lifecycle {
-    // should trigger
-    action_trigger {
-      events = [before_create]
-      actions = [action.test_unlinked.hello]
-    }
-    // should trigger
-    action_trigger {
-      events = [after_create]
-      actions = [action.test_unlinked.hello]
-    }
-    // should be ignored
-    action_trigger {
-      events = [before_update]
-      actions = [action.test_unlinked.hello]
-    }
-  }
-}
-`,
-			},
-			expectPlanActionCalled: true,
-
-			assertPlan: func(t *testing.T, p *plans.Plan) {
-				if len(p.Changes.ActionInvocations) != 2 {
-					t.Fatalf("expected 2 action in plan, got %d", len(p.Changes.ActionInvocations))
-				}
-
-				triggeredEvents := []configs.ActionTriggerEvent{}
-				for _, action := range p.Changes.ActionInvocations {
-					at, ok := action.ActionTrigger.(*plans.LifecycleActionTrigger)
-					if !ok {
-						t.Fatalf("expected action trigger to be a LifecycleActionTrigger, got %T", action.ActionTrigger)
-					}
-					triggeredEvents = append(triggeredEvents, at.ActionTriggerEvent)
-				}
-				slices.Sort(triggeredEvents)
-				if diff := cmp.Diff([]configs.ActionTriggerEvent{configs.BeforeCreate, configs.AfterCreate}, triggeredEvents); diff != "" {
-					t.Errorf("wrong result\n%s", diff)
-				}
-			},
-		},
 	} {
 		t.Run(name, func(t *testing.T) {
 			if tc.toBeImplemented {
diff --git a/internal/terraform/node_action_trigger_instance_plan.go b/internal/terraform/node_action_trigger_instance_plan.go
index 4d0dd0cb81..8484665a64 100644
--- a/internal/terraform/node_action_trigger_instance_plan.go
+++ b/internal/terraform/node_action_trigger_instance_plan.go
@@ -72,7 +72,8 @@ func (n *nodeActionTriggerPlanInstance) Execute(ctx EvalContext, operation walkO
 
 	// We need the action invocation early to check if we need to
 	ai := plans.ActionInvocationInstance{
-		Addr:          n.actionAddress,
+		Addr: n.actionAddress,
+
 		ActionTrigger: n.lifecycleActionTrigger.ActionTrigger(configs.Unknown),
 	}
 	change := ctx.Changes().GetResourceInstanceChange(n.lifecycleActionTrigger.resourceAddress, n.lifecycleActionTrigger.resourceAddress.CurrentObject().DeposedKey)
@@ -112,13 +113,16 @@ func (n *nodeActionTriggerPlanInstance) Execute(ctx EvalContext, operation walkO
 	// provider so we'll do that ourselves now.
 	ai.ConfigValue = ephemeral.RemoveEphemeralValues(actionInstance.ConfigValue)
 
-	triggeredEvents := actionIsTriggeredByEvent(n.lifecycleActionTrigger.events, change.Action)
-	if len(triggeredEvents) == 0 {
+	triggeringEvent, isTriggered := actionIsTriggeredByEvent(n.lifecycleActionTrigger.events, change.Action)
+	if !isTriggered {
 		return diags
 	}
+	if triggeringEvent == nil {
+		panic("triggeringEvent cannot be nil")
+	}
 
 	// Evaluate the condition expression if it exists (otherwise it's true)
-	if n.lifecycleActionTrigger.conditionExpr != nil {
+	if n.lifecycleActionTrigger != nil && n.lifecycleActionTrigger.conditionExpr != nil {
 		condition, conditionDiags := evaluateActionCondition(ctx, actionConditionContext{
 			events:          n.lifecycleActionTrigger.events,
 			conditionExpr:   n.lifecycleActionTrigger.conditionExpr,
@@ -135,6 +139,9 @@ func (n *nodeActionTriggerPlanInstance) Execute(ctx EvalContext, operation walkO
 		}
 	}
 
+	// We need to set the triggering event on the action invocation
+	ai.ActionTrigger = n.lifecycleActionTrigger.ActionTrigger(*triggeringEvent)
+
 	provider, _, err := getProvider(ctx, actionInstance.ProviderAddr)
 	if err != nil {
 		diags = diags.Append(&hcl.Diagnostic{
@@ -180,23 +187,15 @@ func (n *nodeActionTriggerPlanInstance) Execute(ctx EvalContext, operation walkO
 		return diags
 	}
 
-	// We are planning to run this action multiple times so
-	for _, triggeredEvent := range triggeredEvents {
-		eventSpecificAi := ai.DeepCopy()
-		// We need to set the triggering event on the action invocation
-		eventSpecificAi.ActionTrigger = n.lifecycleActionTrigger.ActionTrigger(triggeredEvent)
-
-		// If the action is deferred, we need to also defer the resource instance
-		if resp.Deferred != nil {
-			deferrals.ReportActionInvocationDeferred(*eventSpecificAi, resp.Deferred.Reason)
-			ctx.Changes().RemoveResourceInstanceChange(change.Addr, change.Addr.CurrentObject().DeposedKey)
-			deferrals.ReportResourceInstanceDeferred(change.Addr, providers.DeferredReasonDeferredPrereq, change)
-
-			return diags
-		}
-
-		ctx.Changes().AppendActionInvocation(eventSpecificAi)
+	// If the action is deferred, we need to also defer the resource instance
+	if resp.Deferred != nil {
+		deferrals.ReportActionInvocationDeferred(ai, resp.Deferred.Reason)
+		ctx.Changes().RemoveResourceInstanceChange(change.Addr, change.Addr.CurrentObject().DeposedKey)
+		deferrals.ReportResourceInstanceDeferred(change.Addr, providers.DeferredReasonDeferredPrereq, change)
+		return diags
 	}
+
+	ctx.Changes().AppendActionInvocation(&ai)
 	return diags
 }
 
diff --git a/internal/terraform/node_action_trigger_partialexp.go b/internal/terraform/node_action_trigger_partialexp.go
index 742d34db84..de1b408879 100644
--- a/internal/terraform/node_action_trigger_partialexp.go
+++ b/internal/terraform/node_action_trigger_partialexp.go
@@ -78,8 +78,8 @@ func (n *NodeActionTriggerPartialExpanded) Execute(ctx EvalContext, op walkOpera
 		panic("partialResource is nil")
 	}
 
-	triggeringEvents := actionIsTriggeredByEvent(n.lifecycleActionTrigger.events, partialResourceChange.Change.Action)
-	if len(triggeringEvents) == 0 {
+	triggeringEvent, isTriggered := actionIsTriggeredByEvent(n.lifecycleActionTrigger.events, partialResourceChange.Change.Action)
+	if !isTriggered {
 		return nil
 	}
 
@@ -114,18 +114,16 @@ func (n *NodeActionTriggerPartialExpanded) Execute(ctx EvalContext, op walkOpera
 		return diags
 	}
 
-	for _, triggeringEvent := range triggeringEvents {
-		ctx.Deferrals().ReportActionInvocationDeferred(plans.ActionInvocationInstance{
-			Addr:         n.addr.UnknownActionInstance(),
-			ProviderAddr: n.resolvedProvider,
-			ActionTrigger: &plans.LifecycleActionTrigger{
-				TriggeringResourceAddr:  n.lifecycleActionTrigger.resourceAddress.UnknownResourceInstance(),
-				ActionTriggerEvent:      triggeringEvent,
-				ActionTriggerBlockIndex: n.lifecycleActionTrigger.actionTriggerBlockIndex,
-				ActionsListIndex:        n.lifecycleActionTrigger.actionListIndex,
-			},
-			ConfigValue: actionInstance.ConfigValue,
-		}, providers.DeferredReasonInstanceCountUnknown)
-	}
+	ctx.Deferrals().ReportActionInvocationDeferred(plans.ActionInvocationInstance{
+		Addr:         n.addr.UnknownActionInstance(),
+		ProviderAddr: n.resolvedProvider,
+		ActionTrigger: &plans.LifecycleActionTrigger{
+			TriggeringResourceAddr:  n.lifecycleActionTrigger.resourceAddress.UnknownResourceInstance(),
+			ActionTriggerEvent:      *triggeringEvent,
+			ActionTriggerBlockIndex: n.lifecycleActionTrigger.actionTriggerBlockIndex,
+			ActionsListIndex:        n.lifecycleActionTrigger.actionListIndex,
+		},
+		ConfigValue: actionInstance.ConfigValue,
+	}, providers.DeferredReasonInstanceCountUnknown)
 	return nil
 }
diff --git a/internal/terraform/node_resource_plan_instance.go b/internal/terraform/node_resource_plan_instance.go
index f9c790837a..ff31fff608 100644
--- a/internal/terraform/node_resource_plan_instance.go
+++ b/internal/terraform/node_resource_plan_instance.go
@@ -1058,25 +1058,24 @@ func depsEqual(a, b []addrs.ConfigResource) bool {
 	return true
 }
 
-func actionIsTriggeredByEvent(events []configs.ActionTriggerEvent, action plans.Action) []configs.ActionTriggerEvent {
-	triggeredEvents := []configs.ActionTriggerEvent{}
+func actionIsTriggeredByEvent(events []configs.ActionTriggerEvent, action plans.Action) (*configs.ActionTriggerEvent, bool) {
 	for _, event := range events {
 		switch event {
 		case configs.BeforeCreate, configs.AfterCreate:
 			if action.IsReplace() || action == plans.Create {
-				triggeredEvents = append(triggeredEvents, event)
+				return &event, true
 			} else {
 				continue
 			}
 		case configs.BeforeUpdate, configs.AfterUpdate:
 			if action == plans.Update {
-				triggeredEvents = append(triggeredEvents, event)
+				return &event, true
 			} else {
 				continue
 			}
 		case configs.BeforeDestroy, configs.AfterDestroy:
 			if action == plans.DeleteThenCreate || action == plans.CreateThenDelete || action == plans.Delete {
-				triggeredEvents = append(triggeredEvents, event)
+				return &event, true
 			} else {
 				continue
 			}
@@ -1084,5 +1083,5 @@ func actionIsTriggeredByEvent(events []configs.ActionTriggerEvent, action plans.
 			panic(fmt.Sprintf("unknown action trigger event %s", event))
 		}
 	}
-	return triggeredEvents
+	return nil, false
 }
