diff --git a/gorm.go b/gorm.go
index 37595dd..65c9e22 100644
--- a/gorm.go
+++ b/gorm.go
@@ -37,8 +37,6 @@ type Config struct {
 	DisableAutomaticPing bool
 	// DisableForeignKeyConstraintWhenMigrating
 	DisableForeignKeyConstraintWhenMigrating bool
-	// IgnoreRelationshipsWhenMigrating
-	IgnoreRelationshipsWhenMigrating bool
 	// DisableNestedTransaction disable nested transaction
 	DisableNestedTransaction bool
 	// AllowGlobalUpdate allow global update
diff --git a/migrator/migrator.go b/migrator/migrator.go
index ebd9bc1..eafe7bb 100644
--- a/migrator/migrator.go
+++ b/migrator/migrator.go
@@ -143,11 +143,8 @@ func (m Migrator) AutoMigrate(values ...interface{}) error {
 					}
 				}
 
-				if !m.DB.DisableForeignKeyConstraintWhenMigrating && !m.DB.IgnoreRelationshipsWhenMigrating {
-					for _, rel := range stmt.Schema.Relationships.Relations {
-						if rel.Field.IgnoreMigration {
-							continue
-						}
+				for _, rel := range stmt.Schema.Relationships.Relations {
+					if !m.DB.Config.DisableForeignKeyConstraintWhenMigrating {
 						if constraint := rel.ParseConstraint(); constraint != nil &&
 							constraint.Schema == stmt.Schema && !queryTx.Migrator().HasConstraint(value, constraint.Name) {
 							if err := execTx.Migrator().CreateConstraint(value, constraint.Name); err != nil {
@@ -247,11 +244,8 @@ func (m Migrator) CreateTable(values ...interface{}) error {
 				}
 			}
 
-			if !m.DB.DisableForeignKeyConstraintWhenMigrating && !m.DB.IgnoreRelationshipsWhenMigrating {
-				for _, rel := range stmt.Schema.Relationships.Relations {
-					if rel.Field.IgnoreMigration {
-						continue
-					}
+			for _, rel := range stmt.Schema.Relationships.Relations {
+				if !m.DB.DisableForeignKeyConstraintWhenMigrating {
 					if constraint := rel.ParseConstraint(); constraint != nil {
 						if constraint.Schema == stmt.Schema {
 							sql, vars := buildConstraint(constraint)
@@ -824,31 +818,26 @@ func (m Migrator) ReorderModels(values []interface{}, autoAdd bool) (results []i
 		}
 		parsedSchemas[dep.Statement.Schema] = true
 
-		if !m.DB.IgnoreRelationshipsWhenMigrating {
-			for _, rel := range dep.Schema.Relationships.Relations {
-				if rel.Field.IgnoreMigration {
-					continue
-				}
-				if c := rel.ParseConstraint(); c != nil && c.Schema == dep.Statement.Schema && c.Schema != c.ReferenceSchema {
-					dep.Depends = append(dep.Depends, c.ReferenceSchema)
-				}
+		for _, rel := range dep.Schema.Relationships.Relations {
+			if c := rel.ParseConstraint(); c != nil && c.Schema == dep.Statement.Schema && c.Schema != c.ReferenceSchema {
+				dep.Depends = append(dep.Depends, c.ReferenceSchema)
+			}
 
-				if rel.Type == schema.HasOne || rel.Type == schema.HasMany {
-					beDependedOn[rel.FieldSchema] = true
-				}
+			if rel.Type == schema.HasOne || rel.Type == schema.HasMany {
+				beDependedOn[rel.FieldSchema] = true
+			}
 
-				if rel.JoinTable != nil {
-					// append join value
-					defer func(rel *schema.Relationship, joinValue interface{}) {
-						if !beDependedOn[rel.FieldSchema] {
-							dep.Depends = append(dep.Depends, rel.FieldSchema)
-						} else {
-							fieldValue := reflect.New(rel.FieldSchema.ModelType).Interface()
-							parseDependence(fieldValue, autoAdd)
-						}
-						parseDependence(joinValue, autoAdd)
-					}(rel, reflect.New(rel.JoinTable.ModelType).Interface())
-				}
+			if rel.JoinTable != nil {
+				// append join value
+				defer func(rel *schema.Relationship, joinValue interface{}) {
+					if !beDependedOn[rel.FieldSchema] {
+						dep.Depends = append(dep.Depends, rel.FieldSchema)
+					} else {
+						fieldValue := reflect.New(rel.FieldSchema.ModelType).Interface()
+						parseDependence(fieldValue, autoAdd)
+					}
+					parseDependence(joinValue, autoAdd)
+				}(rel, reflect.New(rel.JoinTable.ModelType).Interface())
 			}
 		}
 
diff --git a/tests/migrate_test.go b/tests/migrate_test.go
index d5d129a..9df626f 100644
--- a/tests/migrate_test.go
+++ b/tests/migrate_test.go
@@ -1203,67 +1203,3 @@ func TestMigrateSameEmbeddedFieldName(t *testing.T) {
 	_, err = findColumnType(&GameUser{}, "rate_ground_rb_ground_destory_count")
 	AssertEqual(t, nil, err)
 }
-
-func TestMigrateIgnoreRelations(t *testing.T) {
-	type RelationModel1 struct {
-		ID uint
-	}
-	type RelationModel2 struct {
-		ID uint
-	}
-	type RelationModel3 struct {
-		ID               uint
-		RelationModel1ID uint
-		RelationModel1   *RelationModel1
-		RelationModel2ID uint
-		RelationModel2   *RelationModel2 `gorm:"-:migration"`
-	}
-
-	var err error
-	_ = DB.Migrator().DropTable(&RelationModel1{}, &RelationModel2{}, &RelationModel3{})
-
-	tx := DB.Session(&gorm.Session{})
-	tx.IgnoreRelationshipsWhenMigrating = true
-
-	err = tx.AutoMigrate(&RelationModel3{})
-	if err != nil {
-		t.Errorf("AutoMigrate err:%v", err)
-	}
-
-	// RelationModel3 should be existed
-	_, err = findColumnType(&RelationModel3{}, "id")
-	AssertEqual(t, nil, err)
-
-	// RelationModel1 should not be existed
-	_, err = findColumnType(&RelationModel1{}, "id")
-	if err == nil {
-		t.Errorf("RelationModel1 should not be migrated")
-	}
-
-	// RelationModel2 should not be existed
-	_, err = findColumnType(&RelationModel2{}, "id")
-	if err == nil {
-		t.Errorf("RelationModel2 should not be migrated")
-	}
-
-	tx.IgnoreRelationshipsWhenMigrating = false
-
-	err = tx.AutoMigrate(&RelationModel3{})
-	if err != nil {
-		t.Errorf("AutoMigrate err:%v", err)
-	}
-
-	// RelationModel3 should be existed
-	_, err = findColumnType(&RelationModel3{}, "id")
-	AssertEqual(t, nil, err)
-
-	// RelationModel1 should be existed
-	_, err = findColumnType(&RelationModel1{}, "id")
-	AssertEqual(t, nil, err)
-
-	// RelationModel2 should not be existed
-	_, err = findColumnType(&RelationModel2{}, "id")
-	if err == nil {
-		t.Errorf("RelationModel2 should not be migrated")
-	}
-}
