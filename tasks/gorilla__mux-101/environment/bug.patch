diff --git a/mux_test.go b/mux_test.go
index 44cc57e..6b2c1d2 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -552,24 +552,6 @@ func TestQueries(t *testing.T) {
 			path:        "",
 			shouldMatch: false,
 		},
-		{
-			title:       "Queries route with regexp pattern with quantifier, match",
-			route:       new(Route).Queries("foo", "{v1:[0-9]{1}}"),
-			request:     newRequest("GET", "http://localhost?foo=1"),
-			vars:        map[string]string{"v1": "1"},
-			host:        "",
-			path:        "",
-			shouldMatch: true,
-		},
-		{
-			title:       "Queries route with regexp pattern with quantifier, regexp does not match",
-			route:       new(Route).Queries("foo", "{v1:[0-9]{1}}"),
-			request:     newRequest("GET", "http://localhost?foo=12"),
-			vars:        map[string]string{},
-			host:        "",
-			path:        "",
-			shouldMatch: false,
-		},
 	}
 
 	for _, test := range tests {
diff --git a/regexp.go b/regexp.go
index d98575e..aa30679 100644
--- a/regexp.go
+++ b/regexp.go
@@ -35,6 +35,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	defaultPattern := "[^/]+"
 	if matchQuery {
 		defaultPattern = "[^?&]+"
+		matchPrefix = true
 	} else if matchHost {
 		defaultPattern = "[^.]+"
 		matchPrefix = false
@@ -52,7 +53,9 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	varsN := make([]string, len(idxs)/2)
 	varsR := make([]*regexp.Regexp, len(idxs)/2)
 	pattern := bytes.NewBufferString("")
-	pattern.WriteByte('^')
+	if !matchQuery {
+		pattern.WriteByte('^')
+	}
 	reverse := bytes.NewBufferString("")
 	var end int
 	var err error
@@ -75,7 +78,6 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 		fmt.Fprintf(pattern, "%s(%s)", regexp.QuoteMeta(raw), patt)
 		// Build the reverse template.
 		fmt.Fprintf(reverse, "%s%%s", raw)
-
 		// Append variable name and compiled pattern.
 		varsN[i/2] = name
 		varsR[i/2], err = regexp.Compile(fmt.Sprintf("^%s$", patt))
@@ -139,7 +141,7 @@ type routeRegexp struct {
 func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 	if !r.matchHost {
 		if r.matchQuery {
-			return r.matchQueryString(req)
+			return r.regexp.MatchString(req.URL.RawQuery)
 		} else {
 			return r.regexp.MatchString(req.URL.Path)
 		}
@@ -173,22 +175,6 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 	return rv, nil
 }
 
-// getUrlQuery returns a single query parameter from a request URL.
-// For a URL with foo=bar&baz=ding, we return only the relevant key
-// value pair for the routeRegexp.
-func (r *routeRegexp) getUrlQuery(req *http.Request) string {
-	if !r.matchQuery {
-		return ""
-	}
-	key := strings.Split(r.template, "=")[0]
-	val := req.URL.Query().Get(key)
-	return key + "=" + val
-}
-
-func (r *routeRegexp) matchQueryString(req *http.Request) bool {
-	return r.regexp.MatchString(r.getUrlQuery(req))
-}
-
 // braceIndices returns the first level curly brace indices from a string.
 // It returns an error in case of unbalanced braces.
 func braceIndices(s string) ([]int, error) {
@@ -260,8 +246,9 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 		}
 	}
 	// Store query string variables.
+	rawQuery := req.URL.RawQuery
 	for _, q := range v.queries {
-		queryVars := q.regexp.FindStringSubmatch(q.getUrlQuery(req))
+		queryVars := q.regexp.FindStringSubmatch(rawQuery)
 		if queryVars != nil {
 			for k, v := range q.varsN {
 				m.Vars[v] = queryVars[k+1]
diff --git a/route.go b/route.go
index 6cb12d3..00d2300 100644
--- a/route.go
+++ b/route.go
@@ -336,7 +336,7 @@ func (r *Route) Queries(pairs ...string) *Route {
 		return nil
 	}
 	for i := 0; i < length; i += 2 {
-		if r.err = r.addRegexpMatcher(pairs[i]+"="+pairs[i+1], false, false, true); r.err != nil {
+		if r.err = r.addRegexpMatcher(pairs[i]+"="+pairs[i+1], false, true, true); r.err != nil {
 			return r
 		}
 	}
