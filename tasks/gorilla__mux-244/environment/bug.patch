diff --git a/README.md b/README.md
index 56c6713..cdab878 100644
--- a/README.md
+++ b/README.md
@@ -179,7 +179,6 @@ package main
 import (
     "fmt"
     "net/http"
-    "strings"
 
     "github.com/gorilla/mux"
 )
@@ -191,25 +190,15 @@ func handler(w http.ResponseWriter, r *http.Request) {
 func main() {
     r := mux.NewRouter()
     r.HandleFunc("/", handler)
-    r.Methods("POST").HandleFunc("/products", handler)
-    r.Methods("GET").HandleFunc("/articles", handler)
-    r.Methods("GET", "PUT").HandleFunc("/articles/{id}", handler)
+    r.HandleFunc("/products", handler)
+    r.HandleFunc("/articles", handler)
+    r.HandleFunc("/articles/{id}", handler)
     r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
         t, err := route.GetPathTemplate()
         if err != nil {
             return err
         }
-        // p will contain regular expression is compatible with regular expression in Perl, Python, and other languages.
-        // for instance the regular expression for path '/articles/{id}' will be '^/articles/(?P<v0>[^/]+)$'
-        p, err := route.GetPathRegexp()
-        if err != nil {
-            return err
-        }
-        m, err := route.GetMethods()
-        if err != nil {
-            return err
-        }
-        fmt.Println(strings.Join(m, ","), t, p)
+        fmt.Println(t)
         return nil
     })
     http.Handle("/", r)
diff --git a/mux_test.go b/mux_test.go
index 13b68cb..405aca6 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -35,8 +35,6 @@ type routeTest struct {
 	path           string            // the expected path of the match
 	pathTemplate   string            // the expected path template to match
 	hostTemplate   string            // the expected host template to match
-	methods        []string          // the expected route methods
-	pathRegexp     string            // the expected path regexp
 	shouldMatch    bool              // whether the request is expected to match the route at all
 	shouldRedirect bool              // whether the request should result in a redirect
 }
@@ -272,7 +270,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/111",
 			pathTemplate: `/111/`,
-			pathRegexp:   `^/111/$`,
 			shouldMatch:  false,
 		},
 		{
@@ -293,7 +290,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/",
 			pathTemplate: `/`,
-			pathRegexp:   `^/$`,
 			shouldMatch:  true,
 		},
 		{
@@ -337,7 +333,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/111/222/333",
 			pathTemplate: `/111/{v1:[0-9]{3}}/333`,
-			pathRegexp:   `^/111/(?P<v0>[0-9]{3})/333$`,
 			shouldMatch:  false,
 		},
 		{
@@ -348,7 +343,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/111/222/333",
 			pathTemplate: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
-			pathRegexp:   `^/(?P<v0>[0-9]{3})/(?P<v1>[0-9]{3})/(?P<v2>[0-9]{3})$`,
 			shouldMatch:  true,
 		},
 		{
@@ -359,7 +353,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/111/222/333",
 			pathTemplate: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
-			pathRegexp:   `^/(?P<v0>[0-9]{3})/(?P<v1>[0-9]{3})/(?P<v2>[0-9]{3})$`,
 			shouldMatch:  false,
 		},
 		{
@@ -370,7 +363,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/a/product_name/1",
 			pathTemplate: `/{category:a|(?:b/c)}/{product}/{id:[0-9]+}`,
-			pathRegexp:   `^/(?P<v0>a|(?:b/c))/(?P<v1>[^/]+)/(?P<v2>[0-9]+)$`,
 			shouldMatch:  true,
 		},
 		{
@@ -381,7 +373,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/111/222/333",
 			pathTemplate: `/111/{v-1:[0-9]{3}}/333`,
-			pathRegexp:   `^/111/(?P<v0>[0-9]{3})/333$`,
 			shouldMatch:  true,
 		},
 		{
@@ -392,7 +383,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/111/222/333",
 			pathTemplate: `/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}`,
-			pathRegexp:   `^/(?P<v0>[0-9]{3})/(?P<v1>[0-9]{3})/(?P<v2>[0-9]{3})$`,
 			shouldMatch:  true,
 		},
 		{
@@ -403,7 +393,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/a/product_name/1",
 			pathTemplate: `/{product-category:a|(?:b/c)}/{product-name}/{product-id:[0-9]+}`,
-			pathRegexp:   `^/(?P<v0>a|(?:b/c))/(?P<v1>[^/]+)/(?P<v2>[0-9]+)$`,
 			shouldMatch:  true,
 		},
 		{
@@ -414,7 +403,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/daily-2016-01-01",
 			pathTemplate: `/{type:(?i:daily|mini|variety)}-{date:\d{4,4}-\d{2,2}-\d{2,2}}`,
-			pathRegexp:   `^/(?P<v0>(?i:daily|mini|variety))-(?P<v1>\d{4,4}-\d{2,2}-\d{2,2})$`,
 			shouldMatch:  true,
 		},
 		{
@@ -425,7 +413,6 @@ func TestPath(t *testing.T) {
 			host:         "",
 			path:         "/111/222",
 			pathTemplate: `/{v1:[0-9]*}{v2:[a-z]*}/{v3:[0-9]*}`,
-			pathRegexp:   `^/(?P<v0>[0-9]*)(?P<v1>[a-z]*)/(?P<v2>[0-9]*)$`,
 			shouldMatch:  true,
 		},
 	}
@@ -434,7 +421,6 @@ func TestPath(t *testing.T) {
 		testRoute(t, test)
 		testTemplate(t, test)
 		testUseEscapedRoute(t, test)
-		testRegexp(t, test)
 	}
 }
 
@@ -661,7 +647,6 @@ func TestMethods(t *testing.T) {
 			vars:        map[string]string{},
 			host:        "",
 			path:        "",
-			methods:     []string{"GET", "POST"},
 			shouldMatch: true,
 		},
 		{
@@ -671,7 +656,6 @@ func TestMethods(t *testing.T) {
 			vars:        map[string]string{},
 			host:        "",
 			path:        "",
-			methods:     []string{"GET", "POST"},
 			shouldMatch: true,
 		},
 		{
@@ -681,25 +665,13 @@ func TestMethods(t *testing.T) {
 			vars:        map[string]string{},
 			host:        "",
 			path:        "",
-			methods:     []string{"GET", "POST"},
 			shouldMatch: false,
 		},
-		{
-			title:       "Route without methods",
-			route:       new(Route),
-			request:     newRequest("PUT", "http://localhost"),
-			vars:        map[string]string{},
-			host:        "",
-			path:        "",
-			methods:     []string{},
-			shouldMatch: true,
-		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
-		testMethods(t, test)
 	}
 }
 
@@ -1527,22 +1499,6 @@ func testTemplate(t *testing.T, test routeTest) {
 	}
 }
 
-func testMethods(t *testing.T, test routeTest) {
-	route := test.route
-	methods, _ := route.GetMethods()
-	if strings.Join(methods, ",") != strings.Join(test.methods, ",") {
-		t.Errorf("(%v) GetMethods not equal: expected %v, got %v", test.title, test.methods, methods)
-	}
-}
-
-func testRegexp(t *testing.T, test routeTest) {
-	route := test.route
-	routePathRegexp, regexpErr := route.GetPathRegexp()
-	if test.pathRegexp != "" && regexpErr == nil && routePathRegexp != test.pathRegexp {
-		t.Errorf("(%v) GetPathRegexp not equal: expected %v, got %v", test.title, test.pathRegexp, routePathRegexp)
-	}
-}
-
 type TestA301ResponseWriter struct {
 	hh     http.Header
 	status int
diff --git a/route.go b/route.go
index a7c7d8c..5544c1f 100644
--- a/route.go
+++ b/route.go
@@ -558,36 +558,6 @@ func (r *Route) GetPathTemplate() (string, error) {
 	return r.regexp.path.template, nil
 }
 
-// GetPathRegexp returns the expanded regular expression used to match route path.
-// This is useful for building simple REST API documentation and for instrumentation
-// against third-party services.
-// An error will be returned if the route does not define a path.
-func (r *Route) GetPathRegexp() (string, error) {
-	if r.err != nil {
-		return "", r.err
-	}
-	if r.regexp == nil || r.regexp.path == nil {
-		return "", errors.New("mux: route does not have a path")
-	}
-	return r.regexp.path.regexp.String(), nil
-}
-
-// GetMethods returns the methods the route matches against
-// This is useful for building simple REST API documentation and for instrumentation
-// against third-party services.
-// An empty list will be returned if route does not have methods.
-func (r *Route) GetMethods() ([]string, error) {
-	if r.err != nil {
-		return nil, r.err
-	}
-	for _, m := range r.matchers {
-		if methods, ok := m.(methodMatcher); ok {
-			return []string(methods), nil
-		}
-	}
-	return nil, nil
-}
-
 // GetHostTemplate returns the template used to build the
 // route match.
 // This is useful for building simple REST API documentation and for instrumentation
