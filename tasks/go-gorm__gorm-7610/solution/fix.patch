diff --git a/logger/slog.go b/logger/slog.go
index 613234c..27c7468 100644
--- a/logger/slog.go
+++ b/logger/slog.go
@@ -8,6 +8,8 @@ import (
 	"fmt"
 	"log/slog"
 	"time"
+
+	"gorm.io/gorm/utils"
 )
 
 type slogLogger struct {
@@ -37,19 +39,19 @@ func (l *slogLogger) LogMode(level LogLevel) Interface {
 
 func (l *slogLogger) Info(ctx context.Context, msg string, data ...interface{}) {
 	if l.LogLevel >= Info {
-		l.Logger.InfoContext(ctx, msg, slog.Any("data", data))
+		l.log(ctx, slog.LevelInfo, msg, slog.Any("data", data))
 	}
 }
 
 func (l *slogLogger) Warn(ctx context.Context, msg string, data ...interface{}) {
 	if l.LogLevel >= Warn {
-		l.Logger.WarnContext(ctx, msg, slog.Any("data", data))
+		l.log(ctx, slog.LevelWarn, msg, slog.Any("data", data))
 	}
 }
 
 func (l *slogLogger) Error(ctx context.Context, msg string, data ...interface{}) {
 	if l.LogLevel >= Error {
-		l.Logger.ErrorContext(ctx, msg, slog.Any("data", data))
+		l.log(ctx, slog.LevelError, msg, slog.Any("data", data))
 	}
 }
 
@@ -72,25 +74,39 @@ func (l *slogLogger) Trace(ctx context.Context, begin time.Time, fc func() (sql
 	switch {
 	case err != nil && (!l.IgnoreRecordNotFoundError || !errors.Is(err, ErrRecordNotFound)):
 		fields = append(fields, slog.String("error", err.Error()))
-		l.Logger.ErrorContext(ctx, "SQL executed", slog.Attr{
+		l.log(ctx, slog.LevelError, "SQL executed", slog.Attr{
 			Key:   "trace",
 			Value: slog.GroupValue(fields...),
 		})
 
 	case l.SlowThreshold != 0 && elapsed > l.SlowThreshold:
-		l.Logger.WarnContext(ctx, "SQL executed", slog.Attr{
+		l.log(ctx, slog.LevelWarn, "SQL executed", slog.Attr{
 			Key:   "trace",
 			Value: slog.GroupValue(fields...),
 		})
 
 	case l.LogLevel >= Info:
-		l.Logger.InfoContext(ctx, "SQL executed", slog.Attr{
+		l.log(ctx, slog.LevelInfo, "SQL executed", slog.Attr{
 			Key:   "trace",
 			Value: slog.GroupValue(fields...),
 		})
 	}
 }
 
+func (l *slogLogger) log(ctx context.Context, level slog.Level, msg string, args ...any) {
+	if ctx == nil {
+		ctx = context.Background()
+	}
+
+	if !l.Logger.Enabled(ctx, level) {
+		return
+	}
+
+	r := slog.NewRecord(time.Now(), level, msg, utils.CallerFrame().PC)
+	r.Add(args...)
+	_ = l.Logger.Handler().Handle(ctx, r)
+}
+
 // ParamsFilter filter params
 func (l *slogLogger) ParamsFilter(ctx context.Context, sql string, params ...interface{}) (string, []interface{}) {
 	if l.Parameterized {
diff --git a/utils/utils.go b/utils/utils.go
index b6a94d1..7e59264 100644
--- a/utils/utils.go
+++ b/utils/utils.go
@@ -30,8 +30,12 @@ func sourceDir(file string) string {
 	return filepath.ToSlash(s) + "/"
 }
 
-// FileWithLineNum return the file name and line number of the current file
-func FileWithLineNum() string {
+// CallerFrame retrieves the first relevant stack frame outside of GORM's internal implementation files.
+// It skips:
+//   - GORM's core source files (identified by gormSourceDir prefix)
+//   - Exclude test files (*_test.go)
+//   - go-gorm/gen's Generated files (*.gen.go)
+func CallerFrame() runtime.Frame {
 	pcs := [13]uintptr{}
 	// the third caller usually from gorm internal
 	len := runtime.Callers(3, pcs[:])
@@ -41,10 +45,20 @@ func FileWithLineNum() string {
 		frame, _ := frames.Next()
 		if (!strings.HasPrefix(frame.File, gormSourceDir) ||
 			strings.HasSuffix(frame.File, "_test.go")) && !strings.HasSuffix(frame.File, ".gen.go") {
-			return string(strconv.AppendInt(append([]byte(frame.File), ':'), int64(frame.Line), 10))
+			return frame
 		}
 	}
 
+	return runtime.Frame{}
+}
+
+// FileWithLineNum return the file name and line number of the current file
+func FileWithLineNum() string {
+	frame := CallerFrame()
+	if frame.PC != 0 {
+		return string(strconv.AppendInt(append([]byte(frame.File), ':'), int64(frame.Line), 10))
+	}
+
 	return ""
 }
 
