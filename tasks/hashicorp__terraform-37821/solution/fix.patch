diff --git a/internal/terraform/evaluate.go b/internal/terraform/evaluate.go
index 68c9d8aba5..343be4034a 100644
--- a/internal/terraform/evaluate.go
+++ b/internal/terraform/evaluate.go
@@ -1115,27 +1115,21 @@ func (d *evaluationStateData) GetOutput(addr addrs.OutputValue, rng tfdiags.Sour
 		return cty.DynamicVal, diags
 	}
 
-	output := d.Evaluator.State.OutputValue(addr.Absolute(d.ModulePath))
-	if output == nil {
-		// Then the output itself returned null, so we'll package that up and
-		// pass it on.
-		output = &states.OutputValue{
-			Addr:      addr.Absolute(d.ModulePath),
-			Value:     cty.NilVal,
-			Sensitive: config.Sensitive,
-		}
-	} else if output.Value == cty.NilVal || output.Value.IsNull() {
-		// Then we did get a value but Terraform itself thought it was NilVal
-		// so we treat this as if the value isn't yet known.
-		output.Value = cty.DynamicVal
+	var value cty.Value
+	if !d.Evaluator.NamedValues.HasOutputValue(addr.Absolute(d.ModulePath)) {
+		value = cty.DynamicVal
+	} else {
+		value = d.Evaluator.NamedValues.GetOutputValue(addr.Absolute(d.ModulePath))
 	}
 
-	val := output.Value
-	if output.Sensitive {
-		val = val.Mark(marks.Sensitive)
+	if config.Sensitive {
+		value = value.Mark(marks.Sensitive)
+	}
+	if config.Ephemeral {
+		value = value.Mark(marks.Ephemeral)
 	}
 
-	return val, diags
+	return value, diags
 }
 
 // moduleDisplayAddr returns a string describing the given module instance
diff --git a/internal/terraform/node_output.go b/internal/terraform/node_output.go
index 98fc1ba7bb..3e505a28fb 100644
--- a/internal/terraform/node_output.go
+++ b/internal/terraform/node_output.go
@@ -757,15 +757,6 @@ func (n *NodeApplyableOutput) setValue(namedVals *namedvals.State, state *states
 		changes.RemoveOutputChange(n.Addr)
 	}
 
-	// Null outputs must be saved for modules so that they can still be
-	// evaluated. Null root outputs are removed entirely, which is always fine
-	// because they can't be referenced by anything else in the configuration.
-	if n.Addr.Module.IsRoot() && val.IsNull() {
-		log.Printf("[TRACE] setValue: Removing %s from state (it is now null)", n.Addr)
-		state.RemoveOutputValue(n.Addr)
-		return
-	}
-
 	// caller leaves namedVals nil if they've already called this function
 	// with a different state, since we only have one namedVals regardless
 	// of how many states are involved in an operation.
@@ -779,6 +770,15 @@ func (n *NodeApplyableOutput) setValue(namedVals *namedvals.State, state *states
 		namedVals.SetOutputValue(n.Addr, saveVal)
 	}
 
+	// Null outputs must be saved for modules so that they can still be
+	// evaluated. Null root outputs are removed entirely, which is always fine
+	// because they can't be referenced by anything else in the configuration.
+	if n.Addr.Module.IsRoot() && val.IsNull() {
+		log.Printf("[TRACE] setValue: Removing %s from state (it is now null)", n.Addr)
+		state.RemoveOutputValue(n.Addr)
+		return
+	}
+
 	// Non-ephemeral output values get saved in the state too
 	if !n.Config.Ephemeral {
 		// The state itself doesn't represent unknown values, so we null them
@@ -798,6 +798,6 @@ func (n *NodeApplyableOutput) setValue(namedVals *namedvals.State, state *states
 				val = cty.UnknownAsNull(val)
 			}
 		}
+		state.SetOutputValue(n.Addr, val, n.Config.Sensitive)
 	}
-	state.SetOutputValue(n.Addr, val, n.Config.Sensitive)
 }
