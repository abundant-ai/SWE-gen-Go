diff --git a/README.md b/README.md
index 046e797..56c6713 100644
--- a/README.md
+++ b/README.md
@@ -24,9 +24,9 @@ The name mux stands for "HTTP request multiplexer". Like the standard `http.Serv
 * [Install](#install)
 * [Examples](#examples)
 * [Matching Routes](#matching-routes)
+* [Listing Routes](#listing-routes)
 * [Static Files](#static-files)
 * [Registered URLs](#registered-urls)
-* [Walking Routes](#walking-routes)
 * [Full Example](#full-example)
 
 ---
@@ -169,7 +169,6 @@ s.HandleFunc("/{key}/", ProductHandler)
 s.HandleFunc("/{key}/details", ProductDetailsHandler)
 ```
 
-<<<<<<< f85983fbfd0e0146e24ba184acbdca25f0361e99
 ### Listing Routes
 
 Routes on a mux can be listed using the Router.Walk methodâ€”useful for generating documentation:
@@ -320,37 +319,6 @@ url, err := r.Get("article").URL("subdomain", "news",
                                  "id", "42")
 ```
 
-### Walking Routes
-
-The `Walk` function on `mux.Router` can be used to visit all of the routes that are registered on a router. For example,
-the following prints all of the registered routes:
-
-```go
-r := mux.NewRouter()
-r.HandleFunc("/", handler)
-r.Methods("POST").HandleFunc("/products", handler)
-r.Methods("GET").HandleFunc("/articles", handler)
-r.Methods("GET", "PUT").HandleFunc("/articles/{id}", handler)
-r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
-    t, err := route.GetPathTemplate()
-    if err != nil {
-        return err
-    }
-    // p will contain a regular expression that is compatible with regular expressions in Perl, Python, and other languages.
-    // For example, the regular expression for path '/articles/{id}' will be '^/articles/(?P<v0>[^/]+)$'.
-    p, err := route.GetPathRegexp()
-    if err != nil {
-        return err
-    }
-    m, err := route.GetMethods()
-    if err != nil {
-        return err
-    }
-    fmt.Println(strings.Join(m, ","), t, p)
-    return nil
-})
-```
-
 ## Full Example
 
 Here's a complete, runnable example of a small `mux` based server:
diff --git a/mux.go b/mux.go
index 74d6560..d66ec38 100644
--- a/mux.go
+++ b/mux.go
@@ -312,12 +312,10 @@ func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
 		}
 		for _, sr := range t.matchers {
 			if h, ok := sr.(*Router); ok {
-				ancestors = append(ancestors, t)
 				err := h.walk(walkFn, ancestors)
 				if err != nil {
 					return err
 				}
-				ancestors = ancestors[:len(ancestors)-1]
 			}
 		}
 		if h, ok := t.handler.(*Router); ok {
diff --git a/mux_test.go b/mux_test.go
index 6beb5e6..19ef5a8 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -11,7 +11,6 @@ import (
 	"fmt"
 	"net/http"
 	"net/url"
-	"reflect"
 	"strings"
 	"testing"
 )
@@ -1383,38 +1382,22 @@ func TestWalkNested(t *testing.T) {
 	l2 := l1.PathPrefix("/l").Subrouter()
 	l2.Path("/a")
 
-	testCases := []struct {
-		path      string
-		ancestors []*Route
-	}{
-		{"/g", []*Route{}},
-		{"/g/o", []*Route{g.parent.(*Route)}},
-		{"/g/o/r", []*Route{g.parent.(*Route), o.parent.(*Route)}},
-		{"/g/o/r/i", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route)}},
-		{"/g/o/r/i/l", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route)}},
-		{"/g/o/r/i/l/l", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route), l1.parent.(*Route)}},
-		{"/g/o/r/i/l/l/a", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route), l1.parent.(*Route), l2.parent.(*Route)}},
-	}
-
+	paths := []string{"/g", "/g/o", "/g/o/r", "/g/o/r/i", "/g/o/r/i/l", "/g/o/r/i/l/l", "/g/o/r/i/l/l/a"}
 	idx := 0
 	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
-		path := testCases[idx].path
+		path := paths[idx]
 		tpl := route.regexp.path.template
 		if tpl != path {
 			t.Errorf(`Expected %s got %s`, path, tpl)
 		}
-		currWantAncestors := testCases[idx].ancestors
-		if !reflect.DeepEqual(currWantAncestors, ancestors) {
-			t.Errorf(`Expected %+v got %+v`, currWantAncestors, ancestors)
-		}
 		idx++
 		return nil
 	})
 	if err != nil {
 		panic(err)
 	}
-	if idx != len(testCases) {
-		t.Errorf("Expected %d routes, found %d", len(testCases), idx)
+	if idx != len(paths) {
+		t.Errorf("Expected %d routes, found %d", len(paths), idx)
 	}
 }
 
