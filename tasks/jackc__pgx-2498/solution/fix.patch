diff --git a/internal/pgmock/pgmock.go b/internal/pgmock/pgmock.go
index c82d7ffc..f5de5f88 100644
--- a/internal/pgmock/pgmock.go
+++ b/internal/pgmock/pgmock.go
@@ -128,9 +128,9 @@ func WaitForClose() Step {
 
 func AcceptUnauthenticatedConnRequestSteps() []Step {
 	return []Step{
-		ExpectAnyMessage(&pgproto3.StartupMessage{ProtocolVersion: pgproto3.ProtocolVersionNumber, Parameters: map[string]string{}}),
+		ExpectAnyMessage(&pgproto3.StartupMessage{ProtocolVersion: pgproto3.ProtocolVersion30, Parameters: map[string]string{}}),
 		SendMessage(&pgproto3.AuthenticationOk{}),
-		SendMessage(&pgproto3.BackendKeyData{ProcessID: 0, SecretKey: 0}),
+		SendMessage(&pgproto3.BackendKeyData{ProcessID: 0, SecretKey: []byte{0, 0, 0, 0}}),
 		SendMessage(&pgproto3.ReadyForQuery{TxStatus: 'I'}),
 	}
 }
diff --git a/pgconn/config.go b/pgconn/config.go
index 42bc2e92..d61187bd 100644
--- a/pgconn/config.go
+++ b/pgconn/config.go
@@ -83,6 +83,15 @@ type Config struct {
 	// that you close on FATAL errors by returning false.
 	OnPgError PgErrorHandler
 
+	// MinProtocolVersion is the minimum acceptable PostgreSQL protocol version.
+	// If the server does not support at least this version, the connection will fail.
+	// Valid values: "3.0", "3.2", "latest". Defaults to "3.0".
+	MinProtocolVersion string
+
+	// MaxProtocolVersion is the maximum PostgreSQL protocol version to request from the server.
+	// Valid values: "3.0", "3.2", "latest". Defaults to "3.0" for compatibility.
+	MaxProtocolVersion string
+
 	createdByParseConfig bool // Used to enforce created by ParseConfig rule.
 }
 
@@ -213,6 +222,8 @@ func NetworkAddress(host string, port uint16) (network, address string) {
 //	PGCONNECT_TIMEOUT
 //	PGTARGETSESSIONATTRS
 //	PGTZ
+//	PGMINPROTOCOLVERSION
+//	PGMAXPROTOCOLVERSION
 //
 // See http://www.postgresql.org/docs/current/static/libpq-envars.html for details on the meaning of environment variables.
 //
@@ -338,6 +349,8 @@ func ParseConfigWithOptions(connString string, options ParseConfigOptions) (*Con
 		"target_session_attrs": {},
 		"service":              {},
 		"servicefile":          {},
+		"min_protocol_version": {},
+		"max_protocol_version": {},
 	}
 
 	// Adding kerberos configuration
@@ -430,6 +443,27 @@ func ParseConfigWithOptions(connString string, options ParseConfigOptions) (*Con
 		return nil, &ParseConfigError{ConnString: connString, msg: fmt.Sprintf("unknown target_session_attrs value: %v", tsa)}
 	}
 
+	minProto, err := parseProtocolVersion(settings["min_protocol_version"])
+	if err != nil {
+		return nil, &ParseConfigError{ConnString: connString, msg: "invalid min_protocol_version", err: err}
+	}
+	maxProto, err := parseProtocolVersion(settings["max_protocol_version"])
+	if err != nil {
+		return nil, &ParseConfigError{ConnString: connString, msg: "invalid max_protocol_version", err: err}
+	}
+	if minProto > maxProto {
+		return nil, &ParseConfigError{ConnString: connString, msg: "min_protocol_version cannot be greater than max_protocol_version"}
+	}
+
+	config.MinProtocolVersion = settings["min_protocol_version"]
+	config.MaxProtocolVersion = settings["max_protocol_version"]
+	if config.MinProtocolVersion == "" {
+		config.MinProtocolVersion = "3.0"
+	}
+	if config.MaxProtocolVersion == "" {
+		config.MaxProtocolVersion = "3.0"
+	}
+
 	return config, nil
 }
 
@@ -467,6 +501,8 @@ func parseEnvSettings() map[string]string {
 		"PGSERVICEFILE":        "servicefile",
 		"PGTZ":                 "timezone",
 		"PGOPTIONS":            "options",
+		"PGMINPROTOCOLVERSION": "min_protocol_version",
+		"PGMAXPROTOCOLVERSION": "max_protocol_version",
 	}
 
 	for envname, realname := range nameMap {
@@ -960,3 +996,14 @@ func ValidateConnectTargetSessionAttrsPreferStandby(ctx context.Context, pgConn
 
 	return nil
 }
+
+func parseProtocolVersion(s string) (uint32, error) {
+	switch s {
+	case "", "3.0":
+		return pgproto3.ProtocolVersion30, nil
+	case "3.2", "latest":
+		return pgproto3.ProtocolVersion32, nil
+	default:
+		return 0, fmt.Errorf("invalid protocol version: %q", s)
+	}
+}
diff --git a/pgconn/pgconn.go b/pgconn/pgconn.go
index ec27ec34..ab87db6f 100644
--- a/pgconn/pgconn.go
+++ b/pgconn/pgconn.go
@@ -77,7 +77,7 @@ type NotificationHandler func(*PgConn, *Notification)
 type PgConn struct {
 	conn              net.Conn
 	pid               uint32            // backend pid
-	secretKey         uint32            // key to use to send a cancel query message to the server
+	secretKey         []byte            // key to use to send a cancel query message to the server
 	parameterStatuses map[string]string // parameters that have been reported by the server
 	txStatus          byte
 	frontend          *pgproto3.Frontend
@@ -319,6 +319,15 @@ func connectOne(ctx context.Context, config *Config, connectConfig *connectOneCo
 		return e
 	}
 
+	maxProtocolVersion, err := parseProtocolVersion(config.MaxProtocolVersion)
+	if err != nil {
+		return nil, newPerDialConnectError("invalid max_protocol_version", err)
+	}
+	minProtocolVersion, err := parseProtocolVersion(config.MinProtocolVersion)
+	if err != nil {
+		return nil, newPerDialConnectError("invalid min_protocol_version", err)
+	}
+
 	pgConn.conn, err = config.DialFunc(ctx, connectConfig.network, connectConfig.address)
 	if err != nil {
 		return nil, newPerDialConnectError("dial error", err)
@@ -371,7 +380,7 @@ func connectOne(ctx context.Context, config *Config, connectConfig *connectOneCo
 	pgConn.frontend = config.BuildFrontend(pgConn.bgReader, pgConn.conn)
 
 	startupMsg := pgproto3.StartupMessage{
-		ProtocolVersion: pgproto3.ProtocolVersionNumber,
+		ProtocolVersion: maxProtocolVersion,
 		Parameters:      make(map[string]string),
 	}
 
@@ -452,6 +461,12 @@ func connectOne(ctx context.Context, config *Config, connectConfig *connectOneCo
 			return pgConn, nil
 		case *pgproto3.ParameterStatus, *pgproto3.NoticeResponse:
 			// handled by ReceiveMessage
+		case *pgproto3.NegotiateProtocolVersion:
+			serverVersion := pgproto3.ProtocolVersion30&0xFFFF0000 | uint32(msg.NewestMinorProtocol)
+			if serverVersion < minProtocolVersion {
+				pgConn.conn.Close()
+				return nil, newPerDialConnectError("server protocol version too low", nil)
+			}
 		case *pgproto3.ErrorResponse:
 			pgConn.conn.Close()
 			return nil, newPerDialConnectError("server error", ErrorResponseToPgError(msg))
@@ -641,7 +656,7 @@ func (pgConn *PgConn) TxStatus() byte {
 }
 
 // SecretKey returns the backend secret key used to send a cancel query message to the server.
-func (pgConn *PgConn) SecretKey() uint32 {
+func (pgConn *PgConn) SecretKey() []byte {
 	return pgConn.secretKey
 }
 
@@ -1040,11 +1055,11 @@ func (pgConn *PgConn) CancelRequest(ctx context.Context) error {
 		defer contextWatcher.Unwatch()
 	}
 
-	buf := make([]byte, 16)
-	binary.BigEndian.PutUint32(buf[0:4], 16)
+	buf := make([]byte, 12+len(pgConn.secretKey))
+	binary.BigEndian.PutUint32(buf[0:4], uint32(len(buf)))
 	binary.BigEndian.PutUint32(buf[4:8], 80877102)
 	binary.BigEndian.PutUint32(buf[8:12], pgConn.pid)
-	binary.BigEndian.PutUint32(buf[12:16], pgConn.secretKey)
+	copy(buf[12:], pgConn.secretKey)
 
 	if _, err := cancelConn.Write(buf); err != nil {
 		return fmt.Errorf("write to connection for cancellation: %w", err)
@@ -2077,7 +2092,7 @@ func (pgConn *PgConn) CustomData() map[string]any {
 type HijackedConn struct {
 	Conn              net.Conn
 	PID               uint32            // backend pid
-	SecretKey         uint32            // key to use to send a cancel query message to the server
+	SecretKey         []byte            // key to use to send a cancel query message to the server
 	ParameterStatuses map[string]string // parameters that have been reported by the server
 	TxStatus          byte
 	Frontend          *pgproto3.Frontend
diff --git a/pgproto3/backend.go b/pgproto3/backend.go
index d9d0f370..e211c99b 100644
--- a/pgproto3/backend.go
+++ b/pgproto3/backend.go
@@ -137,7 +137,7 @@ func (b *Backend) ReceiveStartupMessage() (FrontendMessage, error) {
 	code := binary.BigEndian.Uint32(buf)
 
 	switch code {
-	case ProtocolVersionNumber:
+	case ProtocolVersion30, ProtocolVersion32:
 		err = b.startupMessage.Decode(buf)
 		if err != nil {
 			return nil, err
diff --git a/pgproto3/backend_key_data.go b/pgproto3/backend_key_data.go
index 23f5da67..c73b2da0 100644
--- a/pgproto3/backend_key_data.go
+++ b/pgproto3/backend_key_data.go
@@ -2,6 +2,7 @@ package pgproto3
 
 import (
 	"encoding/binary"
+	"encoding/hex"
 	"encoding/json"
 
 	"github.com/jackc/pgx/v5/internal/pgio"
@@ -9,7 +10,7 @@ import (
 
 type BackendKeyData struct {
 	ProcessID uint32
-	SecretKey uint32
+	SecretKey []byte
 }
 
 // Backend identifies this message as sendable by the PostgreSQL backend.
@@ -18,12 +19,13 @@ func (*BackendKeyData) Backend() {}
 // Decode decodes src into dst. src must contain the complete message with the exception of the initial 1 byte message
 // type identifier and 4 byte message length.
 func (dst *BackendKeyData) Decode(src []byte) error {
-	if len(src) != 8 {
+	if len(src) < 8 {
 		return &invalidMessageLenErr{messageType: "BackendKeyData", expectedLen: 8, actualLen: len(src)}
 	}
 
 	dst.ProcessID = binary.BigEndian.Uint32(src[:4])
-	dst.SecretKey = binary.BigEndian.Uint32(src[4:])
+	dst.SecretKey = make([]byte, len(src)-4)
+	copy(dst.SecretKey, src[4:])
 
 	return nil
 }
@@ -32,7 +34,7 @@ func (dst *BackendKeyData) Decode(src []byte) error {
 func (src *BackendKeyData) Encode(dst []byte) ([]byte, error) {
 	dst, sp := beginMessage(dst, 'K')
 	dst = pgio.AppendUint32(dst, src.ProcessID)
-	dst = pgio.AppendUint32(dst, src.SecretKey)
+	dst = append(dst, src.SecretKey...)
 	return finishMessage(dst, sp)
 }
 
@@ -41,10 +43,29 @@ func (src BackendKeyData) MarshalJSON() ([]byte, error) {
 	return json.Marshal(struct {
 		Type      string
 		ProcessID uint32
-		SecretKey uint32
+		SecretKey string
 	}{
 		Type:      "BackendKeyData",
 		ProcessID: src.ProcessID,
-		SecretKey: src.SecretKey,
+		SecretKey: hex.EncodeToString(src.SecretKey),
 	})
 }
+
+// UnmarshalJSON implements encoding/json.Unmarshaler.
+func (dst *BackendKeyData) UnmarshalJSON(data []byte) error {
+	var msg struct {
+		ProcessID uint32
+		SecretKey string
+	}
+	if err := json.Unmarshal(data, &msg); err != nil {
+		return err
+	}
+
+	dst.ProcessID = msg.ProcessID
+	secretKey, err := hex.DecodeString(msg.SecretKey)
+	if err != nil {
+		return err
+	}
+	dst.SecretKey = secretKey
+	return nil
+}
diff --git a/pgproto3/cancel_request.go b/pgproto3/cancel_request.go
index 6b52dd97..63ebe5c4 100644
--- a/pgproto3/cancel_request.go
+++ b/pgproto3/cancel_request.go
@@ -2,6 +2,7 @@ package pgproto3
 
 import (
 	"encoding/binary"
+	"encoding/hex"
 	"encoding/json"
 	"errors"
 
@@ -12,35 +13,42 @@ const cancelRequestCode = 80877102
 
 type CancelRequest struct {
 	ProcessID uint32
-	SecretKey uint32
+	SecretKey []byte
 }
 
 // Frontend identifies this message as sendable by a PostgreSQL frontend.
 func (*CancelRequest) Frontend() {}
 
 func (dst *CancelRequest) Decode(src []byte) error {
-	if len(src) != 12 {
-		return errors.New("bad cancel request size")
+	if len(src) < 12 {
+		return errors.New("cancel request too short")
+	}
+	if len(src) > 264 {
+		return errors.New("cancel request too long")
 	}
 
 	requestCode := binary.BigEndian.Uint32(src)
-
 	if requestCode != cancelRequestCode {
 		return errors.New("bad cancel request code")
 	}
 
 	dst.ProcessID = binary.BigEndian.Uint32(src[4:])
-	dst.SecretKey = binary.BigEndian.Uint32(src[8:])
+	dst.SecretKey = make([]byte, len(src)-8)
+	copy(dst.SecretKey, src[8:])
 
 	return nil
 }
 
 // Encode encodes src into dst. dst will include the 4 byte message length.
 func (src *CancelRequest) Encode(dst []byte) ([]byte, error) {
-	dst = pgio.AppendInt32(dst, 16)
+	if len(src.SecretKey) > 256 {
+		return nil, errors.New("secret key too long")
+	}
+	msgLen := int32(12 + len(src.SecretKey))
+	dst = pgio.AppendInt32(dst, msgLen)
 	dst = pgio.AppendInt32(dst, cancelRequestCode)
 	dst = pgio.AppendUint32(dst, src.ProcessID)
-	dst = pgio.AppendUint32(dst, src.SecretKey)
+	dst = append(dst, src.SecretKey...)
 	return dst, nil
 }
 
@@ -49,10 +57,29 @@ func (src CancelRequest) MarshalJSON() ([]byte, error) {
 	return json.Marshal(struct {
 		Type      string
 		ProcessID uint32
-		SecretKey uint32
+		SecretKey string
 	}{
 		Type:      "CancelRequest",
 		ProcessID: src.ProcessID,
-		SecretKey: src.SecretKey,
+		SecretKey: hex.EncodeToString(src.SecretKey),
 	})
 }
+
+// UnmarshalJSON implements encoding/json.Unmarshaler.
+func (dst *CancelRequest) UnmarshalJSON(data []byte) error {
+	var msg struct {
+		ProcessID uint32
+		SecretKey string
+	}
+	if err := json.Unmarshal(data, &msg); err != nil {
+		return err
+	}
+
+	dst.ProcessID = msg.ProcessID
+	secretKey, err := hex.DecodeString(msg.SecretKey)
+	if err != nil {
+		return err
+	}
+	dst.SecretKey = secretKey
+	return nil
+}
diff --git a/pgproto3/frontend.go b/pgproto3/frontend.go
index 056e547c..23e10aad 100644
--- a/pgproto3/frontend.go
+++ b/pgproto3/frontend.go
@@ -52,6 +52,7 @@ type Frontend struct {
 	readyForQuery                   ReadyForQuery
 	rowDescription                  RowDescription
 	portalSuspended                 PortalSuspended
+	negotiateProtocolVersion        NegotiateProtocolVersion
 
 	bodyLen    int
 	maxBodyLen int // maxBodyLen is the maximum length of a message body in octets. If a message body exceeds this length, Receive will return an error.
@@ -383,6 +384,8 @@ func (f *Frontend) Receive() (BackendMessage, error) {
 		msg = &f.copyBothResponse
 	case 'Z':
 		msg = &f.readyForQuery
+	case 'v':
+		msg = &f.negotiateProtocolVersion
 	default:
 		return nil, fmt.Errorf("unknown message type: %c", f.msgType)
 	}
diff --git a/pgproto3/negotiate_protocol_version.go b/pgproto3/negotiate_protocol_version.go
new file mode 100644
index 00000000..6e96554f
--- /dev/null
+++ b/pgproto3/negotiate_protocol_version.go
@@ -0,0 +1,86 @@
+package pgproto3
+
+import (
+	"encoding/binary"
+	"encoding/json"
+
+	"github.com/jackc/pgx/v5/internal/pgio"
+)
+
+type NegotiateProtocolVersion struct {
+	NewestMinorProtocol uint32
+	UnrecognizedOptions []string
+}
+
+// Backend identifies this message as sendable by the PostgreSQL backend.
+func (*NegotiateProtocolVersion) Backend() {}
+
+// Decode decodes src into dst. src must contain the complete message with the exception of the initial 1 byte message
+// type identifier and 4 byte message length.
+func (dst *NegotiateProtocolVersion) Decode(src []byte) error {
+	if len(src) < 8 {
+		return &invalidMessageLenErr{messageType: "NegotiateProtocolVersion", expectedLen: 8, actualLen: len(src)}
+	}
+
+	dst.NewestMinorProtocol = binary.BigEndian.Uint32(src[:4])
+	optionCount := int(binary.BigEndian.Uint32(src[4:8]))
+
+	rp := 8
+	dst.UnrecognizedOptions = make([]string, 0, optionCount)
+	for i := 0; i < optionCount; i++ {
+		if rp >= len(src) {
+			return &invalidMessageFormatErr{messageType: "NegotiateProtocolVersion"}
+		}
+		end := rp
+		for end < len(src) && src[end] != 0 {
+			end++
+		}
+		if end >= len(src) {
+			return &invalidMessageFormatErr{messageType: "NegotiateProtocolVersion"}
+		}
+		dst.UnrecognizedOptions = append(dst.UnrecognizedOptions, string(src[rp:end]))
+		rp = end + 1
+	}
+
+	return nil
+}
+
+// Encode encodes src into dst. dst will include the 1 byte message type identifier and the 4 byte message length.
+func (src *NegotiateProtocolVersion) Encode(dst []byte) ([]byte, error) {
+	dst, sp := beginMessage(dst, 'v')
+	dst = pgio.AppendUint32(dst, src.NewestMinorProtocol)
+	dst = pgio.AppendUint32(dst, uint32(len(src.UnrecognizedOptions)))
+	for _, option := range src.UnrecognizedOptions {
+		dst = append(dst, option...)
+		dst = append(dst, 0)
+	}
+	return finishMessage(dst, sp)
+}
+
+// MarshalJSON implements encoding/json.Marshaler.
+func (src NegotiateProtocolVersion) MarshalJSON() ([]byte, error) {
+	return json.Marshal(struct {
+		Type                string
+		NewestMinorProtocol uint32
+		UnrecognizedOptions []string
+	}{
+		Type:                "NegotiateProtocolVersion",
+		NewestMinorProtocol: src.NewestMinorProtocol,
+		UnrecognizedOptions: src.UnrecognizedOptions,
+	})
+}
+
+// UnmarshalJSON implements encoding/json.Unmarshaler.
+func (dst *NegotiateProtocolVersion) UnmarshalJSON(data []byte) error {
+	var msg struct {
+		NewestMinorProtocol uint32
+		UnrecognizedOptions []string
+	}
+	if err := json.Unmarshal(data, &msg); err != nil {
+		return err
+	}
+
+	dst.NewestMinorProtocol = msg.NewestMinorProtocol
+	dst.UnrecognizedOptions = msg.UnrecognizedOptions
+	return nil
+}
diff --git a/pgproto3/startup_message.go b/pgproto3/startup_message.go
index 3af4587d..6caab3ee 100644
--- a/pgproto3/startup_message.go
+++ b/pgproto3/startup_message.go
@@ -10,7 +10,11 @@ import (
 	"github.com/jackc/pgx/v5/internal/pgio"
 )
 
-const ProtocolVersionNumber = 196608 // 3.0
+const (
+	ProtocolVersion30     = 196608            // 3.0
+	ProtocolVersion32     = 196610            // 3.2
+	ProtocolVersionNumber = ProtocolVersion30 // Default is still 3.0
+)
 
 type StartupMessage struct {
 	ProtocolVersion uint32
@@ -30,8 +34,8 @@ func (dst *StartupMessage) Decode(src []byte) error {
 	dst.ProtocolVersion = binary.BigEndian.Uint32(src)
 	rp := 4
 
-	if dst.ProtocolVersion != ProtocolVersionNumber {
-		return fmt.Errorf("Bad startup message version number. Expected %d, got %d", ProtocolVersionNumber, dst.ProtocolVersion)
+	if dst.ProtocolVersion != ProtocolVersion30 && dst.ProtocolVersion != ProtocolVersion32 {
+		return fmt.Errorf("Bad startup message version number. Expected %d or %d, got %d", ProtocolVersion30, ProtocolVersion32, dst.ProtocolVersion)
 	}
 
 	dst.Parameters = make(map[string]string)
