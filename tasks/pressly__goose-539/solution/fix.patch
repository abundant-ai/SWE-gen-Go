diff --git a/create.go b/create.go
index 1a8bb74..8634763 100644
--- a/create.go
+++ b/create.go
@@ -2,6 +2,7 @@ package goose
 
 import (
 	"database/sql"
+	"errors"
 	"fmt"
 	"os"
 	"path/filepath"
@@ -25,11 +26,12 @@ func SetSequential(s bool) {
 
 // Create writes a new blank migration file.
 func CreateWithTemplate(db *sql.DB, dir string, tmpl *template.Template, name, migrationType string) error {
-	var version string
+	version := time.Now().Format(timestampFormat)
+
 	if sequential {
 		// always use DirFS here because it's modifying operation
 		migrations, err := collectMigrationsFS(osFS{}, dir, minVersion, maxVersion)
-		if err != nil {
+		if err != nil && !errors.Is(err, ErrNoMigrationFiles) {
 			return err
 		}
 
@@ -43,8 +45,6 @@ func CreateWithTemplate(db *sql.DB, dir string, tmpl *template.Template, name, m
 		} else {
 			version = fmt.Sprintf(seqVersionTemplate, int64(1))
 		}
-	} else {
-		version = time.Now().Format(timestampFormat)
 	}
 
 	filename := fmt.Sprintf("%v_%v.%v", version, snakeCase(name), migrationType)
diff --git a/migrate.go b/migrate.go
index fb1500a..96c2ccc 100644
--- a/migrate.go
+++ b/migrate.go
@@ -15,6 +15,8 @@ import (
 )
 
 var (
+	// ErrNoMigrationFiles when no migration files have been found.
+	ErrNoMigrationFiles = errors.New("no migration files found")
 	// ErrNoCurrentVersion when a current migration version is not found.
 	ErrNoCurrentVersion = errors.New("no current version found")
 	// ErrNoNextVersion when the next migration version is not found.
@@ -192,8 +194,12 @@ func register(
 }
 
 func collectMigrationsFS(fsys fs.FS, dirpath string, current, target int64) (Migrations, error) {
-	if _, err := fs.Stat(fsys, dirpath); errors.Is(err, fs.ErrNotExist) {
-		return nil, fmt.Errorf("%s directory does not exist", dirpath)
+	if _, err := fs.Stat(fsys, dirpath); err != nil {
+		if errors.Is(err, fs.ErrNotExist) {
+			return nil, fmt.Errorf("%s directory does not exist", dirpath)
+		}
+
+		return nil, err
 	}
 
 	var migrations Migrations
@@ -251,6 +257,10 @@ func collectMigrationsFS(fsys fs.FS, dirpath string, current, target int64) (Mig
 		}
 	}
 
+	if len(migrations) == 0 {
+		return nil, ErrNoMigrationFiles
+	}
+
 	migrations = sortAndConnectMigrations(migrations)
 
 	return migrations, nil
