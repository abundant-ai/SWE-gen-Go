diff --git a/echo.go b/echo.go
index d284ff3..4b0c785 100644
--- a/echo.go
+++ b/echo.go
@@ -500,6 +500,7 @@ func (common) static(prefix, root string, get func(string, HandlerFunc, ...Middl
 		}
 		return c.File(name)
 	}
+	get(prefix, h)
 	if prefix == "/" {
 		return get(prefix+"*", h)
 	}
diff --git a/echo_test.go b/echo_test.go
index a6071e1..895ea18 100644
--- a/echo_test.go
+++ b/echo_test.go
@@ -102,6 +102,15 @@ func TestEchoStatic(t *testing.T) {
 			expectHeaderLocation: "/folder/",
 			expectBodyStartsWith: "",
 		},
+    {
+			name:                 "Directory Redirect with non-root path",
+			givenPrefix:          "/static",
+			givenRoot:            "_fixture",
+			whenURL:              "/static",
+			expectStatus:         http.StatusMovedPermanently,
+			expectHeaderLocation: "/static/",
+			expectBodyStartsWith: "",
+		},
 		{
 			name:                 "Directory with index.html",
 			givenPrefix:          "/",
@@ -161,6 +170,40 @@ func TestEchoStatic(t *testing.T) {
 	}
 }
 
+func TestEchoStaticRedirectIndex(t *testing.T) {
+	assert := assert.New(t)
+	e := New()
+
+	// HandlerFunc
+	e.Static("/static", "_fixture")
+
+	errCh := make(chan error)
+
+	go func() {
+		errCh <- e.Start("127.0.0.1:1323")
+	}()
+
+	time.Sleep(200 * time.Millisecond)
+
+	if resp, err := http.Get("http://127.0.0.1:1323/static"); err == nil {
+		defer resp.Body.Close()
+		assert.Equal(http.StatusOK, resp.StatusCode)
+
+		if body, err := ioutil.ReadAll(resp.Body); err == nil {
+			assert.Equal(true, strings.HasPrefix(string(body), "<!doctype html>"))
+		} else {
+			assert.Fail(err.Error())
+		}
+
+	} else {
+		assert.Fail(err.Error())
+	}
+
+	if err := e.Close(); err != nil {
+		t.Fatal(err)
+	}
+}
+
 func TestEchoFile(t *testing.T) {
 	e := New()
 	e.File("/walle", "_fixture/images/walle.png")
diff --git a/group.go b/group.go
index 426bef9..d239fb5 100644
--- a/group.go
+++ b/group.go
@@ -23,10 +23,6 @@ func (g *Group) Use(middleware ...MiddlewareFunc) {
 	if len(g.middleware) == 0 {
 		return
 	}
-	// Allow all requests to reach the group as they might get dropped if router
-	// doesn't find a match, making none of the group middleware process.
-	g.Any("", NotFoundHandler)
-	g.Any("/*", NotFoundHandler)
 }
 
 // CONNECT implements `Echo#CONNECT()` for sub-routes within the Group.
diff --git a/group_test.go b/group_test.go
index c51fd91..d4a6846 100644
--- a/group_test.go
+++ b/group_test.go
@@ -119,3 +119,37 @@ func TestGroupRouteMiddlewareWithMatchAny(t *testing.T) {
 	assert.Equal(t, "/*", m)
 
 }
+
+func TestMultipleGroupSamePathMiddleware(t *testing.T) {
+	// Ensure multiple groups with the same path do not clobber previous routes or mixup middlewares
+	e := New()
+	m1 := func(next HandlerFunc) HandlerFunc {
+		return func(c Context) error {
+			c.Set("middleware", "m1")
+			return next(c)
+		}
+	}
+	m2 := func(next HandlerFunc) HandlerFunc {
+		return func(c Context) error {
+			c.Set("middleware", "m2")
+			return next(c)
+		}
+	}
+	h := func(c Context) error {
+		return c.String(http.StatusOK, c.Get("middleware").(string))
+	}
+
+	g1 := e.Group("/group", m1)
+	{
+		g1.GET("", h)
+	}
+	g2 := e.Group("/group", m2)
+	{
+		g2.GET("/other", h)
+	}
+
+	_, m := request(http.MethodGet, "/group", e)
+	assert.Equal(t, "m1", m)
+	_, m = request(http.MethodGet, "/group/other", e)
+	assert.Equal(t, "m2", m)
+}
