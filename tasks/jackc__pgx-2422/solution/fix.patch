diff --git a/conn.go b/conn.go
index 1fc0b568..0823c79a 100644
--- a/conn.go
+++ b/conn.go
@@ -610,7 +610,7 @@ func (c *Conn) execPrepared(ctx context.Context, sd *pgconn.StatementDescription
 		return pgconn.CommandTag{}, err
 	}
 
-	result := c.pgConn.ExecPrepared(ctx, sd.Name, c.eqb.ParamValues, c.eqb.ParamFormats, c.eqb.ResultFormats).Read()
+	result := c.pgConn.ExecStatement(ctx, sd, c.eqb.ParamValues, c.eqb.ParamFormats, c.eqb.ResultFormats).Read()
 	c.eqb.reset() // Allow c.eqb internal memory to be GC'ed as soon as possible.
 	return result.CommandTag, result.Err
 }
@@ -844,7 +844,7 @@ optionLoop:
 		if !explicitPreparedStatement && mode == QueryExecModeCacheDescribe {
 			rows.resultReader = c.pgConn.ExecParams(ctx, sql, c.eqb.ParamValues, sd.ParamOIDs, c.eqb.ParamFormats, resultFormats)
 		} else {
-			rows.resultReader = c.pgConn.ExecPrepared(ctx, sd.Name, c.eqb.ParamValues, c.eqb.ParamFormats, resultFormats)
+			rows.resultReader = c.pgConn.ExecStatement(ctx, sd, c.eqb.ParamValues, c.eqb.ParamFormats, resultFormats)
 		}
 	} else if mode == QueryExecModeExec {
 		err := c.eqb.Build(c.typeMap, nil, args)
@@ -1236,7 +1236,7 @@ func (c *Conn) sendBatchExtendedWithDescription(ctx context.Context, b *Batch, d
 		if bi.sd.Name == "" {
 			pipeline.SendQueryParams(bi.sd.SQL, c.eqb.ParamValues, bi.sd.ParamOIDs, c.eqb.ParamFormats, c.eqb.ResultFormats)
 		} else {
-			pipeline.SendQueryPrepared(bi.sd.Name, c.eqb.ParamValues, c.eqb.ParamFormats, c.eqb.ResultFormats)
+			pipeline.SendQueryStatement(bi.sd, c.eqb.ParamValues, c.eqb.ParamFormats, c.eqb.ResultFormats)
 		}
 	}
 
diff --git a/pgconn/pgconn.go b/pgconn/pgconn.go
index a18f1874..ec27ec34 100644
--- a/pgconn/pgconn.go
+++ b/pgconn/pgconn.go
@@ -23,6 +23,7 @@ import (
 	"github.com/jackc/pgx/v5/pgconn/ctxwatch"
 	"github.com/jackc/pgx/v5/pgconn/internal/bgreader"
 	"github.com/jackc/pgx/v5/pgproto3"
+	"github.com/jackc/pgx/v5/pgtype"
 )
 
 const (
@@ -828,13 +829,15 @@ type FieldDescription struct {
 	Format               int16
 }
 
-func (pgConn *PgConn) convertRowDescription(dst []FieldDescription, rd *pgproto3.RowDescription) []FieldDescription {
-	if cap(dst) >= len(rd.Fields) {
-		dst = dst[:len(rd.Fields):len(rd.Fields)]
+func (pgConn *PgConn) getFieldDescriptionSlice(n int) []FieldDescription {
+	if cap(pgConn.fieldDescriptions) >= n {
+		return pgConn.fieldDescriptions[:n:n]
 	} else {
-		dst = make([]FieldDescription, len(rd.Fields))
+		return make([]FieldDescription, n)
 	}
+}
 
+func convertRowDescription(dst []FieldDescription, rd *pgproto3.RowDescription) {
 	for i := range rd.Fields {
 		dst[i].Name = string(rd.Fields[i].Name)
 		dst[i].TableOID = rd.Fields[i].TableOID
@@ -844,8 +847,6 @@ func (pgConn *PgConn) convertRowDescription(dst []FieldDescription, rd *pgproto3
 		dst[i].TypeModifier = rd.Fields[i].TypeModifier
 		dst[i].Format = rd.Fields[i].Format
 	}
-
-	return dst
 }
 
 type StatementDescription struct {
@@ -909,7 +910,8 @@ readloop:
 			psd.ParamOIDs = make([]uint32, len(msg.ParameterOIDs))
 			copy(psd.ParamOIDs, msg.ParameterOIDs)
 		case *pgproto3.RowDescription:
-			psd.Fields = pgConn.convertRowDescription(nil, msg)
+			psd.Fields = make([]FieldDescription, len(msg.Fields))
+			convertRowDescription(psd.Fields, msg)
 		case *pgproto3.ErrorResponse:
 			pgErr = ErrorResponseToPgError(msg)
 		case *pgproto3.ReadyForQuery:
@@ -1159,7 +1161,7 @@ func (pgConn *PgConn) ExecParams(ctx context.Context, sql string, paramValues []
 	pgConn.frontend.SendParse(&pgproto3.Parse{Query: sql, ParameterOIDs: paramOIDs})
 	pgConn.frontend.SendBind(&pgproto3.Bind{ParameterFormatCodes: paramFormats, Parameters: paramValues, ResultFormatCodes: resultFormats})
 
-	pgConn.execExtendedSuffix(result)
+	pgConn.execExtendedSuffix(result, nil, nil)
 
 	return result
 }
@@ -1184,7 +1186,36 @@ func (pgConn *PgConn) ExecPrepared(ctx context.Context, stmtName string, paramVa
 
 	pgConn.frontend.SendBind(&pgproto3.Bind{PreparedStatement: stmtName, ParameterFormatCodes: paramFormats, Parameters: paramValues, ResultFormatCodes: resultFormats})
 
-	pgConn.execExtendedSuffix(result)
+	pgConn.execExtendedSuffix(result, nil, nil)
+
+	return result
+}
+
+// ExecStatement enqueues the execution of a prepared statement via the PostgreSQL extended query protocol.
+//
+// This differs from ExecPrepared in that it takes a *StatementDescription instead of the prepared statement name.
+// Because it has the *StatementDescription it can avoid the Describe Portal message that ExecPrepared must send to get
+// the result column descriptions.
+//
+// paramValues are the parameter values. It must be encoded in the format given by paramFormats.
+//
+// paramFormats is a slice of format codes determining for each paramValue column whether it is encoded in text or
+// binary format. If paramFormats is nil all params are text format. ExecPrepared will panic if len(paramFormats) is not
+// 0, 1, or len(paramValues).
+//
+// resultFormats is a slice of format codes determining for each result column whether it is encoded in text or binary
+// format. If resultFormats is nil all results will be in text format.
+//
+// ResultReader must be closed before PgConn can be used again.
+func (pgConn *PgConn) ExecStatement(ctx context.Context, statementDescription *StatementDescription, paramValues [][]byte, paramFormats, resultFormats []int16) *ResultReader {
+	result := pgConn.execExtendedPrefix(ctx, paramValues)
+	if result.closed {
+		return result
+	}
+
+	pgConn.frontend.SendBind(&pgproto3.Bind{PreparedStatement: statementDescription.Name, ParameterFormatCodes: paramFormats, Parameters: paramValues, ResultFormatCodes: resultFormats})
+
+	pgConn.execExtendedSuffix(result, statementDescription, resultFormats)
 
 	return result
 }
@@ -1224,8 +1255,10 @@ func (pgConn *PgConn) execExtendedPrefix(ctx context.Context, paramValues [][]by
 	return result
 }
 
-func (pgConn *PgConn) execExtendedSuffix(result *ResultReader) {
-	pgConn.frontend.SendDescribe(&pgproto3.Describe{ObjectType: 'P'})
+func (pgConn *PgConn) execExtendedSuffix(result *ResultReader, statementDescription *StatementDescription, resultFormats []int16) {
+	if statementDescription == nil {
+		pgConn.frontend.SendDescribe(&pgproto3.Describe{ObjectType: 'P'})
+	}
 	pgConn.frontend.SendExecute(&pgproto3.Execute{})
 	pgConn.frontend.SendSync(&pgproto3.Sync{})
 
@@ -1239,7 +1272,7 @@ func (pgConn *PgConn) execExtendedSuffix(result *ResultReader) {
 		return
 	}
 
-	result.readUntilRowDescription()
+	result.readUntilRowDescription(statementDescription, resultFormats)
 }
 
 // CopyTo executes the copy command sql and copies the results to w.
@@ -1442,6 +1475,10 @@ type MultiResultReader struct {
 
 	rr *ResultReader
 
+	// Data from when the batch was queued.
+	statementDescriptions []*StatementDescription
+	resultFormats         [][]int16
+
 	closed bool
 	err    error
 }
@@ -1483,6 +1520,39 @@ func (mrr *MultiResultReader) receiveMessage() (pgproto3.BackendMessage, error)
 // NextResult returns advances the MultiResultReader to the next result and returns true if a result is available.
 func (mrr *MultiResultReader) NextResult() bool {
 	for !mrr.closed && mrr.err == nil {
+		msg, _ := mrr.pgConn.peekMessage()
+		if _, ok := msg.(*pgproto3.DataRow); ok {
+			if len(mrr.statementDescriptions) > 0 {
+				rr := ResultReader{
+					pgConn:            mrr.pgConn,
+					multiResultReader: mrr,
+					ctx:               mrr.ctx,
+				}
+
+				// This result corresponds to a prepared statement description that was provided when queuing the batch.
+				sd := mrr.statementDescriptions[0]
+				mrr.statementDescriptions = mrr.statementDescriptions[1:]
+
+				resultFormats := mrr.resultFormats[0]
+				mrr.resultFormats = mrr.resultFormats[1:]
+
+				sdFields := sd.Fields
+				rr.fieldDescriptions = rr.pgConn.getFieldDescriptionSlice(len(sdFields))
+
+				err := combineFieldDescriptionsAndResultFormats(rr.fieldDescriptions, sdFields, resultFormats)
+				if err != nil {
+					rr.concludeCommand(CommandTag{}, err)
+				}
+
+				mrr.pgConn.resultReader = rr
+				mrr.rr = &mrr.pgConn.resultReader
+				return true
+			}
+
+			mrr.err = fmt.Errorf("unexpected DataRow message without preceding RowDescription")
+			return false
+		}
+
 		msg, err := mrr.receiveMessage()
 		if err != nil {
 			return false
@@ -1494,8 +1564,9 @@ func (mrr *MultiResultReader) NextResult() bool {
 				pgConn:            mrr.pgConn,
 				multiResultReader: mrr,
 				ctx:               mrr.ctx,
-				fieldDescriptions: mrr.pgConn.convertRowDescription(mrr.pgConn.fieldDescriptions[:], msg),
+				fieldDescriptions: mrr.pgConn.getFieldDescriptionSlice(len(msg.Fields)),
 			}
+			convertRowDescription(mrr.pgConn.resultReader.fieldDescriptions, msg)
 
 			mrr.rr = &mrr.pgConn.resultReader
 			return true
@@ -1547,6 +1618,7 @@ type ResultReader struct {
 	fieldDescriptions []FieldDescription
 	rowValues         [][]byte
 	commandTag        CommandTag
+	preloaded         bool
 	commandConcluded  bool
 	closed            bool
 	err               error
@@ -1588,6 +1660,11 @@ func (rr *ResultReader) Read() *Result {
 
 // NextRow advances the ResultReader to the next row and returns true if a row is available.
 func (rr *ResultReader) NextRow() bool {
+	if rr.preloaded {
+		rr.preloaded = false
+		return true
+	}
+
 	for !rr.commandConcluded {
 		msg, err := rr.receiveMessage()
 		if err != nil {
@@ -1604,6 +1681,11 @@ func (rr *ResultReader) NextRow() bool {
 	return false
 }
 
+func (rr *ResultReader) preloadRowValues(values [][]byte) {
+	rr.rowValues = values
+	rr.preloaded = true
+}
+
 // FieldDescriptions returns the field descriptions for the current result set. The returned slice is only valid until
 // the ResultReader is closed. It may return nil (for example, if the query did not return a result set or an error was
 // encountered.)
@@ -1656,19 +1738,34 @@ func (rr *ResultReader) Close() (CommandTag, error) {
 
 // readUntilRowDescription ensures the ResultReader's fieldDescriptions are loaded. It does not return an error as any
 // error will be stored in the ResultReader.
-func (rr *ResultReader) readUntilRowDescription() {
+func (rr *ResultReader) readUntilRowDescription(statementDescription *StatementDescription, resultFormats []int16) {
 	for !rr.commandConcluded {
-		// Peek before receive to avoid consuming a DataRow if the result set does not include a RowDescription method.
-		// This should never happen under normal pgconn usage, but it is possible if SendBytes and ReceiveResults are
-		// manually used to construct a query that does not issue a describe statement.
-		msg, _ := rr.pgConn.peekMessage()
-		if _, ok := msg.(*pgproto3.DataRow); ok {
+		msg, _ := rr.receiveMessage()
+		switch msg := msg.(type) {
+		case *pgproto3.RowDescription:
 			return
-		}
+		case *pgproto3.DataRow:
+			rr.preloadRowValues(msg.Values)
+			if statementDescription != nil {
+				sdFields := statementDescription.Fields
+				rr.fieldDescriptions = rr.pgConn.getFieldDescriptionSlice(len(sdFields))
 
-		// Consume the message
-		msg, _ = rr.receiveMessage()
-		if _, ok := msg.(*pgproto3.RowDescription); ok {
+				err := combineFieldDescriptionsAndResultFormats(rr.fieldDescriptions, sdFields, resultFormats)
+				if err != nil {
+					rr.concludeCommand(CommandTag{}, err)
+				}
+			}
+			return
+		case *pgproto3.CommandComplete:
+			if statementDescription != nil {
+				sdFields := statementDescription.Fields
+				rr.fieldDescriptions = rr.pgConn.getFieldDescriptionSlice(len(sdFields))
+
+				err := combineFieldDescriptionsAndResultFormats(rr.fieldDescriptions, sdFields, resultFormats)
+				if err != nil {
+					rr.concludeCommand(CommandTag{}, err)
+				}
+			}
 			return
 		}
 	}
@@ -1695,7 +1792,8 @@ func (rr *ResultReader) receiveMessage() (msg pgproto3.BackendMessage, err error
 
 	switch msg := msg.(type) {
 	case *pgproto3.RowDescription:
-		rr.fieldDescriptions = rr.pgConn.convertRowDescription(rr.pgConn.fieldDescriptions[:], msg)
+		rr.fieldDescriptions = rr.pgConn.getFieldDescriptionSlice(len(msg.Fields))
+		convertRowDescription(rr.fieldDescriptions, msg)
 	case *pgproto3.CommandComplete:
 		rr.concludeCommand(rr.pgConn.makeCommandTag(msg.CommandTag), nil)
 	case *pgproto3.EmptyQueryResponse:
@@ -1729,8 +1827,10 @@ func (rr *ResultReader) concludeCommand(commandTag CommandTag, err error) {
 
 // Batch is a collection of queries that can be sent to the PostgreSQL server in a single round-trip.
 type Batch struct {
-	buf []byte
-	err error
+	buf                   []byte
+	statementDescriptions []*StatementDescription
+	resultFormats         [][]int16
+	err                   error
 }
 
 // ExecParams appends an ExecParams command to the batch. See PgConn.ExecParams for parameter descriptions.
@@ -1768,6 +1868,30 @@ func (batch *Batch) ExecPrepared(stmtName string, paramValues [][]byte, paramFor
 	}
 }
 
+// ExecStatement appends an ExecStatement command to the batch. See PgConn.ExecPrepared for parameter descriptions.
+//
+// This differs from ExecPrepared in that it takes a *StatementDescription instead of just the prepared statement name.
+// Because it has the *StatementDescription it can avoid the Describe Portal message that ExecPrepared must send to get
+// the result column descriptions.
+func (batch *Batch) ExecStatement(statementDescription *StatementDescription, paramValues [][]byte, paramFormats, resultFormats []int16) {
+	if batch.err != nil {
+		return
+	}
+
+	batch.buf, batch.err = (&pgproto3.Bind{PreparedStatement: statementDescription.Name, ParameterFormatCodes: paramFormats, Parameters: paramValues, ResultFormatCodes: resultFormats}).Encode(batch.buf)
+	if batch.err != nil {
+		return
+	}
+
+	batch.statementDescriptions = append(batch.statementDescriptions, statementDescription)
+	batch.resultFormats = append(batch.resultFormats, resultFormats)
+
+	batch.buf, batch.err = (&pgproto3.Execute{}).Encode(batch.buf)
+	if batch.err != nil {
+		return
+	}
+}
+
 // ExecBatch executes all the queries in batch in a single round-trip. Execution is implicitly transactional unless a
 // transaction is already in progress or SQL contains transaction control statements. This is a simpler way of executing
 // multiple queries in a single round trip than using pipeline mode.
@@ -1787,8 +1911,10 @@ func (pgConn *PgConn) ExecBatch(ctx context.Context, batch *Batch) *MultiResultR
 	}
 
 	pgConn.multiResultReader = MultiResultReader{
-		pgConn: pgConn,
-		ctx:    ctx,
+		pgConn:                pgConn,
+		ctx:                   ctx,
+		statementDescriptions: batch.statementDescriptions,
+		resultFormats:         batch.resultFormats,
 	}
 	multiResult := &pgConn.multiResultReader
 
@@ -2023,9 +2149,10 @@ func Construct(hc *HijackedConn) (*PgConn, error) {
 
 // Pipeline represents a connection in pipeline mode.
 //
-// SendPrepare, SendQueryParams, and SendQueryPrepared queue requests to the server. These requests are not written until
-// pipeline is flushed by Flush or Sync. Sync must be called after the last request is queued. Requests between
-// synchronization points are implicitly transactional unless explicit transaction control statements have been issued.
+// SendPrepare, SendQueryParams, SendQueryPrepared, and SendQueryStatement queue requests to the server. These requests
+// are not written until pipeline is flushed by Flush or Sync. Sync must be called after the last request is queued.
+// Requests between synchronization points are implicitly transactional unless explicit transaction control statements
+// have been issued.
 //
 // The context the pipeline was started with is in effect for the entire life of the Pipeline.
 //
@@ -2054,6 +2181,7 @@ const (
 	pipelinePrepare
 	pipelineQueryParams
 	pipelineQueryPrepared
+	pipelineQueryStatement
 	pipelineDeallocate
 	pipelineSyncRequest
 	pipelineFlushRequest
@@ -2067,6 +2195,8 @@ type pipelineRequestEvent struct {
 
 type pipelineState struct {
 	requestEventQueue          list.List
+	statementDescriptionsQueue list.List
+	resultFormatsQueue         list.List
 	lastRequestType            pipelineRequestType
 	pgErr                      *PgError
 	expectedReadyForQueryCount int
@@ -2074,6 +2204,8 @@ type pipelineState struct {
 
 func (s *pipelineState) Init() {
 	s.requestEventQueue.Init()
+	s.statementDescriptionsQueue.Init()
+	s.resultFormatsQueue.Init()
 	s.lastRequestType = pipelineNil
 }
 
@@ -2138,6 +2270,29 @@ func (s *pipelineState) ExtractFrontRequestType() pipelineRequestType {
 	}
 }
 
+func (s *pipelineState) PushBackStatementData(sd *StatementDescription, resultFormats []int16) {
+	s.statementDescriptionsQueue.PushBack(sd)
+	s.resultFormatsQueue.PushBack(resultFormats)
+}
+
+func (s *pipelineState) ExtractFrontStatementData() (*StatementDescription, []int16) {
+	sdElem := s.statementDescriptionsQueue.Front()
+	var sd *StatementDescription
+	if sdElem != nil {
+		s.statementDescriptionsQueue.Remove(sdElem)
+		sd = sdElem.Value.(*StatementDescription)
+	}
+
+	rfElem := s.resultFormatsQueue.Front()
+	var resultFormats []int16
+	if rfElem != nil {
+		s.resultFormatsQueue.Remove(rfElem)
+		resultFormats = rfElem.Value.([]int16)
+	}
+
+	return sd, resultFormats
+}
+
 func (s *pipelineState) HandleError(err *PgError) {
 	s.pgErr = err
 }
@@ -2180,6 +2335,8 @@ func (pgConn *PgConn) StartPipeline(ctx context.Context) *Pipeline {
 		return pipeline
 	}
 
+	pgConn.resultReader = ResultReader{closed: true}
+
 	pgConn.pipeline = Pipeline{
 		conn: pgConn,
 		ctx:  ctx,
@@ -2249,6 +2406,18 @@ func (p *Pipeline) SendQueryPrepared(stmtName string, paramValues [][]byte, para
 	p.state.PushBackRequestType(pipelineQueryPrepared)
 }
 
+// SendQueryStatement is the pipeline version of *PgConn.ExecStatement.
+func (p *Pipeline) SendQueryStatement(statementDescription *StatementDescription, paramValues [][]byte, paramFormats, resultFormats []int16) {
+	if p.closed {
+		return
+	}
+
+	p.conn.frontend.SendBind(&pgproto3.Bind{PreparedStatement: statementDescription.Name, ParameterFormatCodes: paramFormats, Parameters: paramValues, ResultFormatCodes: resultFormats})
+	p.conn.frontend.SendExecute(&pgproto3.Execute{})
+	p.state.PushBackRequestType(pipelineQueryStatement)
+	p.state.PushBackStatementData(statementDescription, resultFormats)
+}
+
 // SendFlushRequest sends a request for the server to flush its output buffer.
 //
 // The server flushes its output buffer automatically as a result of Sync being called,
@@ -2323,99 +2492,317 @@ func (p *Pipeline) GetResults() (results any, err error) {
 		return nil, errors.New("pipeline closed")
 	}
 
-	if p.state.ExtractFrontRequestType() == pipelineNil {
-		return nil, nil
-	}
-
 	return p.getResults()
 }
 
 func (p *Pipeline) getResults() (results any, err error) {
-	for {
-		msg, err := p.conn.receiveMessage()
+	if !p.conn.resultReader.closed {
+		_, err := p.conn.resultReader.Close()
 		if err != nil {
-			p.closed = true
-			p.err = err
-			p.conn.asyncClose()
-			return nil, normalizeTimeoutError(p.ctx, err)
+			return nil, err
 		}
+	}
 
-		switch msg := msg.(type) {
-		case *pgproto3.RowDescription:
-			p.conn.resultReader = ResultReader{
-				pgConn:            p.conn,
-				pipeline:          p,
-				ctx:               p.ctx,
-				fieldDescriptions: p.conn.convertRowDescription(p.conn.fieldDescriptions[:], msg),
-			}
-			return &p.conn.resultReader, nil
-		case *pgproto3.CommandComplete:
-			p.conn.resultReader = ResultReader{
-				commandTag:       p.conn.makeCommandTag(msg.CommandTag),
-				commandConcluded: true,
-				closed:           true,
-			}
-			return &p.conn.resultReader, nil
-		case *pgproto3.ParseComplete:
-			peekedMsg, err := p.conn.peekMessage()
-			if err != nil {
-				p.conn.asyncClose()
-				return nil, normalizeTimeoutError(p.ctx, err)
-			}
-			if _, ok := peekedMsg.(*pgproto3.ParameterDescription); ok {
-				return p.getResultsPrepare()
-			}
-		case *pgproto3.CloseComplete:
-			return &CloseComplete{}, nil
-		case *pgproto3.ReadyForQuery:
-			p.state.HandleReadyForQuery()
-			return &PipelineSync{}, nil
-		case *pgproto3.ErrorResponse:
-			pgErr := ErrorResponseToPgError(msg)
-			p.state.HandleError(pgErr)
-			return nil, pgErr
-		}
+	currentRequestType := p.state.ExtractFrontRequestType()
+	switch currentRequestType {
+	case pipelineNil:
+		return nil, nil
+	case pipelinePrepare:
+		return p.getResultsPrepare()
+	case pipelineQueryParams:
+		return p.getResultsQueryParams()
+	case pipelineQueryPrepared:
+		return p.getResultsQueryPrepared()
+	case pipelineQueryStatement:
+		return p.getResultsQueryStatement()
+	case pipelineDeallocate:
+		return p.getResultsDeallocate()
+	case pipelineSyncRequest:
+		return p.getResultsSync()
+	case pipelineFlushRequest:
+		return nil, errors.New("BUG: pipelineFlushRequest should not be in request queue")
+	default:
+		return nil, errors.New("BUG: unknown pipeline request type")
 	}
 }
 
 func (p *Pipeline) getResultsPrepare() (*StatementDescription, error) {
+	err := p.receiveParseComplete("Prepare")
+	if err != nil {
+		return nil, err
+	}
+
 	psd := &StatementDescription{}
 
+	msg, err := p.receiveMessage()
+	if err != nil {
+		return nil, err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.ParameterDescription:
+		psd.ParamOIDs = make([]uint32, len(msg.ParameterOIDs))
+		copy(psd.ParamOIDs, msg.ParameterOIDs)
+	case *pgproto3.ErrorResponse:
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		return nil, pgErr
+	default:
+		return nil, p.handleUnexpectedMessage("Prepare ParameterDescription", msg)
+	}
+
+	msg, err = p.receiveMessage()
+	if err != nil {
+		return nil, err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.RowDescription:
+		psd.Fields = make([]FieldDescription, len(msg.Fields))
+		convertRowDescription(psd.Fields, msg)
+		return psd, nil
+
+	// NoData is returned instead of RowDescription when there is no expected result. e.g. An INSERT without a RETURNING
+	// clause.
+	case *pgproto3.NoData:
+		return psd, nil
+
+	case *pgproto3.ErrorResponse:
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		return nil, pgErr
+	default:
+		return nil, p.handleUnexpectedMessage("Prepare RowDescription", msg)
+	}
+}
+
+func (p *Pipeline) getResultsQueryParams() (*ResultReader, error) {
+	err := p.receiveParseComplete("QueryParams")
+	if err != nil {
+		return nil, err
+	}
+
+	err = p.receiveBindComplete("QueryParams")
+	if err != nil {
+		return nil, err
+	}
+
+	return p.receiveDescribedResultReader("QueryParams")
+}
+
+func (p *Pipeline) getResultsQueryPrepared() (*ResultReader, error) {
+	err := p.receiveBindComplete("QueryPrepared")
+	if err != nil {
+		return nil, err
+	}
+
+	return p.receiveDescribedResultReader("QueryPrepared")
+}
+
+func (p *Pipeline) getResultsQueryStatement() (*ResultReader, error) {
+	err := p.receiveBindComplete("QueryStatement")
+	if err != nil {
+		return nil, err
+	}
+
+	msg, err := p.receiveMessage()
+	if err != nil {
+		return nil, err
+	}
+
+	sd, resultFormats := p.state.ExtractFrontStatementData()
+	if sd == nil {
+		return nil, errors.New("BUG: missing statement description or result formats for QueryStatement")
+	}
+	sdFields := sd.Fields
+	fieldDescriptions := p.conn.getFieldDescriptionSlice(len(sdFields))
+	err = combineFieldDescriptionsAndResultFormats(fieldDescriptions, sdFields, resultFormats)
+	if err != nil {
+		return nil, err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.DataRow:
+		rr := ResultReader{
+			pgConn:            p.conn,
+			pipeline:          p,
+			ctx:               p.ctx,
+			fieldDescriptions: fieldDescriptions,
+		}
+		rr.preloadRowValues(msg.Values)
+		p.conn.resultReader = rr
+		return &p.conn.resultReader, nil
+	case *pgproto3.CommandComplete:
+		p.conn.resultReader = ResultReader{
+			commandTag:        p.conn.makeCommandTag(msg.CommandTag),
+			commandConcluded:  true,
+			closed:            true,
+			fieldDescriptions: fieldDescriptions,
+		}
+		return &p.conn.resultReader, nil
+	case *pgproto3.ErrorResponse:
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		p.conn.resultReader.closed = true
+		return nil, pgErr
+	default:
+		return nil, p.handleUnexpectedMessage("QueryStatement", msg)
+	}
+}
+
+func (p *Pipeline) getResultsDeallocate() (*CloseComplete, error) {
+	msg, err := p.receiveMessage()
+	if err != nil {
+		return nil, err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.CloseComplete:
+		return &CloseComplete{}, nil
+	case *pgproto3.ErrorResponse:
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		p.conn.resultReader.closed = true
+		return nil, pgErr
+	default:
+		return nil, p.handleUnexpectedMessage("Deallocate", msg)
+	}
+}
+
+func (p *Pipeline) getResultsSync() (*PipelineSync, error) {
+	msg, err := p.receiveMessage()
+	if err != nil {
+		return nil, err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.ReadyForQuery:
+		p.state.HandleReadyForQuery()
+		return &PipelineSync{}, nil
+	case *pgproto3.ErrorResponse:
+		// Error message that is received while expecting a Sync message still consumes the expected Sync. Put it back.
+		p.state.requestEventQueue.PushFront(pipelineRequestEvent{RequestType: pipelineSyncRequest, WasSentToServer: true, BeforeFlushOrSync: true})
+
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		p.conn.resultReader.closed = true
+		return nil, pgErr
+	default:
+		return nil, p.handleUnexpectedMessage("Sync", msg)
+	}
+}
+
+func (p *Pipeline) receiveParseComplete(errStr string) error {
+	msg, err := p.receiveMessage()
+	if err != nil {
+		return err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.ParseComplete:
+		return nil
+	case *pgproto3.ErrorResponse:
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		return pgErr
+	default:
+		return p.handleUnexpectedMessage(fmt.Sprintf("%s Parse", errStr), msg)
+	}
+}
+
+func (p *Pipeline) receiveBindComplete(errStr string) error {
+	msg, err := p.receiveMessage()
+	if err != nil {
+		return err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.BindComplete:
+		return nil
+	case *pgproto3.ErrorResponse:
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		return pgErr
+	default:
+		return p.handleUnexpectedMessage(fmt.Sprintf("%s Bind", errStr), msg)
+	}
+}
+
+func (p *Pipeline) receiveDescribedResultReader(errStr string) (*ResultReader, error) {
+	msg, err := p.receiveMessage()
+	if err != nil {
+		return nil, err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.RowDescription:
+		p.conn.resultReader = ResultReader{
+			pgConn:            p.conn,
+			pipeline:          p,
+			ctx:               p.ctx,
+			fieldDescriptions: p.conn.getFieldDescriptionSlice(len(msg.Fields)),
+		}
+		convertRowDescription(p.conn.resultReader.fieldDescriptions, msg)
+		return &p.conn.resultReader, nil
+	case *pgproto3.NoData:
+	case *pgproto3.ErrorResponse:
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		p.conn.resultReader.closed = true
+		return nil, pgErr
+	default:
+		return nil, p.handleUnexpectedMessage(fmt.Sprintf("%s RowDescription or NoData", errStr), msg)
+	}
+
+	msg, err = p.receiveMessage()
+	if err != nil {
+		return nil, err
+	}
+
+	switch msg := msg.(type) {
+	case *pgproto3.CommandComplete:
+		p.conn.resultReader = ResultReader{
+			commandTag:       p.conn.makeCommandTag(msg.CommandTag),
+			commandConcluded: true,
+			closed:           true,
+		}
+		return &p.conn.resultReader, nil
+	case *pgproto3.ErrorResponse:
+		pgErr := ErrorResponseToPgError(msg)
+		p.state.HandleError(pgErr)
+		p.conn.resultReader.closed = true
+		return nil, pgErr
+	default:
+		return nil, p.handleUnexpectedMessage(fmt.Sprintf("%s CommandComplete", errStr), msg)
+	}
+}
+
+func (p *Pipeline) receiveMessage() (pgproto3.BackendMessage, error) {
 	for {
 		msg, err := p.conn.receiveMessage()
 		if err != nil {
+			p.closed = true
+			p.err = err
 			p.conn.asyncClose()
 			return nil, normalizeTimeoutError(p.ctx, err)
 		}
 
 		switch msg := msg.(type) {
-		case *pgproto3.ParameterDescription:
-			psd.ParamOIDs = make([]uint32, len(msg.ParameterOIDs))
-			copy(psd.ParamOIDs, msg.ParameterOIDs)
-		case *pgproto3.RowDescription:
-			psd.Fields = p.conn.convertRowDescription(nil, msg)
-			return psd, nil
-
-		// NoData is returned instead of RowDescription when there is no expected result. e.g. An INSERT without a RETURNING
-		// clause.
-		case *pgproto3.NoData:
-			return psd, nil
-
-		// These should never happen here. But don't take chances that could lead to a deadlock.
-		case *pgproto3.ErrorResponse:
-			pgErr := ErrorResponseToPgError(msg)
-			p.state.HandleError(pgErr)
-			return nil, pgErr
-		case *pgproto3.CommandComplete:
-			p.conn.asyncClose()
-			return nil, errors.New("BUG: received CommandComplete while handling Describe")
-		case *pgproto3.ReadyForQuery:
-			p.conn.asyncClose()
-			return nil, errors.New("BUG: received ReadyForQuery while handling Describe")
+		case *pgproto3.ParameterStatus, *pgproto3.NoticeResponse, *pgproto3.NotificationResponse:
+			// Filter these message types out in pipeline mode. The normal processing is handled by PgConn.receiveMessage.
+		default:
+			return msg, nil
 		}
 	}
 }
 
+func (p *Pipeline) handleUnexpectedMessage(errStr string, msg pgproto3.BackendMessage) error {
+	p.closed = true
+	p.err = fmt.Errorf("pipeline: %s: received unexpected message type %T", errStr, msg)
+	p.conn.asyncClose()
+	return p.err
+}
+
 // Close closes the pipeline and returns the connection to normal mode.
 func (p *Pipeline) Close() error {
 	if p.closed {
@@ -2518,3 +2905,32 @@ func (h *CancelRequestContextWatcherHandler) HandleUnwatchAfterCancel() {
 
 	h.Conn.conn.SetDeadline(time.Time{})
 }
+
+func combineFieldDescriptionsAndResultFormats(outputFields, inputFields []FieldDescription, resultFormats []int16) error {
+	switch {
+	case len(resultFormats) == 0:
+		// No format codes provided means text format for all columns.
+		for i := range inputFields {
+			outputFields[i] = inputFields[i]
+			outputFields[i].Format = pgtype.TextFormatCode
+		}
+	case len(resultFormats) == 1:
+		// Single format code applies to all columns.
+		format := resultFormats[0]
+		for i := range inputFields {
+			outputFields[i] = inputFields[i]
+			outputFields[i].Format = format
+		}
+	case len(resultFormats) == len(inputFields):
+		// One format code per column.
+		for i := range inputFields {
+			outputFields[i] = inputFields[i]
+			outputFields[i].Format = resultFormats[i]
+		}
+	default:
+		// This should not occur if Bind validation is correct, but handle gracefully
+		return fmt.Errorf("result format codes length %d does not match field count %d", len(resultFormats), len(inputFields))
+	}
+
+	return nil
+}
