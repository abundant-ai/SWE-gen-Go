diff --git a/cobra.go b/cobra.go
index a6b160c..f23f509 100644
--- a/cobra.go
+++ b/cobra.go
@@ -43,10 +43,9 @@ var initializers []func()
 var finalizers []func()
 
 const (
-	defaultPrefixMatching   = false
-	defaultCommandSorting   = true
-	defaultCaseInsensitive  = false
-	defaultTraverseRunHooks = false
+	defaultPrefixMatching  = false
+	defaultCommandSorting  = true
+	defaultCaseInsensitive = false
 )
 
 // EnablePrefixMatching allows setting automatic prefix matching. Automatic prefix matching can be a dangerous thing
@@ -61,10 +60,6 @@ var EnableCommandSorting = defaultCommandSorting
 // EnableCaseInsensitive allows case-insensitive commands names. (case sensitive by default)
 var EnableCaseInsensitive = defaultCaseInsensitive
 
-// EnableTraverseRunHooks executes persistent pre-run and post-run hooks from all parents.
-// By default this is disabled, which means only the first run hook to be found is executed.
-var EnableTraverseRunHooks = defaultTraverseRunHooks
-
 // MousetrapHelpText enables an information splash screen on Windows
 // if the CLI is started from explorer.exe.
 // To disable the mousetrap, just set this variable to blank string ("").
diff --git a/command.go b/command.go
index ae3e4e0..909d858 100644
--- a/command.go
+++ b/command.go
@@ -934,31 +934,15 @@ func (c *Command) execute(a []string) (err error) {
 		return err
 	}
 
-	parents := make([]*Command, 0, 5)
 	for p := c; p != nil; p = p.Parent() {
-		if EnableTraverseRunHooks {
-			// When EnableTraverseRunHooks is set:
-			// - Execute all persistent pre-runs from the root parent till this command.
-			// - Execute all persistent post-runs from this command till the root parent.
-			parents = append([]*Command{p}, parents...)
-		} else {
-			// Otherwise, execute only the first found persistent hook.
-			parents = append(parents, p)
-		}
-	}
-	for _, p := range parents {
 		if p.PersistentPreRunE != nil {
 			if err := p.PersistentPreRunE(c, argWoFlags); err != nil {
 				return err
 			}
-			if !EnableTraverseRunHooks {
-				break
-			}
+			break
 		} else if p.PersistentPreRun != nil {
 			p.PersistentPreRun(c, argWoFlags)
-			if !EnableTraverseRunHooks {
-				break
-			}
+			break
 		}
 	}
 	if c.PreRunE != nil {
@@ -995,14 +979,10 @@ func (c *Command) execute(a []string) (err error) {
 			if err := p.PersistentPostRunE(c, argWoFlags); err != nil {
 				return err
 			}
-			if !EnableTraverseRunHooks {
-				break
-			}
+			break
 		} else if p.PersistentPostRun != nil {
 			p.PersistentPostRun(c, argWoFlags)
-			if !EnableTraverseRunHooks {
-				break
-			}
+			break
 		}
 	}
 
diff --git a/command_test.go b/command_test.go
index 4d8908d..4afb7f7 100644
--- a/command_test.go
+++ b/command_test.go
@@ -1530,73 +1530,57 @@ func TestHooks(t *testing.T) {
 }
 
 func TestPersistentHooks(t *testing.T) {
-	EnableTraverseRunHooks = true
-	testPersistentHooks(t, []string{
-		"parent PersistentPreRun",
-		"child PersistentPreRun",
-		"child PreRun",
-		"child Run",
-		"child PostRun",
-		"child PersistentPostRun",
-		"parent PersistentPostRun",
-	})
-
-	EnableTraverseRunHooks = false
-	testPersistentHooks(t, []string{
-		"child PersistentPreRun",
-		"child PreRun",
-		"child Run",
-		"child PostRun",
-		"child PersistentPostRun",
-	})
-}
-
-func testPersistentHooks(t *testing.T, expectedHookRunOrder []string) {
-	var hookRunOrder []string
+	var (
+		parentPersPreArgs  string
+		parentPreArgs      string
+		parentRunArgs      string
+		parentPostArgs     string
+		parentPersPostArgs string
+	)
 
-	validateHook := func(args []string, hookName string) {
-		hookRunOrder = append(hookRunOrder, hookName)
-		got := strings.Join(args, " ")
-		if onetwo != got {
-			t.Errorf("Expected %s %q, got %q", hookName, onetwo, got)
-		}
-	}
+	var (
+		childPersPreArgs  string
+		childPreArgs      string
+		childRunArgs      string
+		childPostArgs     string
+		childPersPostArgs string
+	)
 
 	parentCmd := &Command{
 		Use: "parent",
 		PersistentPreRun: func(_ *Command, args []string) {
-			validateHook(args, "parent PersistentPreRun")
+			parentPersPreArgs = strings.Join(args, " ")
 		},
 		PreRun: func(_ *Command, args []string) {
-			validateHook(args, "parent PreRun")
+			parentPreArgs = strings.Join(args, " ")
 		},
 		Run: func(_ *Command, args []string) {
-			validateHook(args, "parent Run")
+			parentRunArgs = strings.Join(args, " ")
 		},
 		PostRun: func(_ *Command, args []string) {
-			validateHook(args, "parent PostRun")
+			parentPostArgs = strings.Join(args, " ")
 		},
 		PersistentPostRun: func(_ *Command, args []string) {
-			validateHook(args, "parent PersistentPostRun")
+			parentPersPostArgs = strings.Join(args, " ")
 		},
 	}
 
 	childCmd := &Command{
 		Use: "child",
 		PersistentPreRun: func(_ *Command, args []string) {
-			validateHook(args, "child PersistentPreRun")
+			childPersPreArgs = strings.Join(args, " ")
 		},
 		PreRun: func(_ *Command, args []string) {
-			validateHook(args, "child PreRun")
+			childPreArgs = strings.Join(args, " ")
 		},
 		Run: func(_ *Command, args []string) {
-			validateHook(args, "child Run")
+			childRunArgs = strings.Join(args, " ")
 		},
 		PostRun: func(_ *Command, args []string) {
-			validateHook(args, "child PostRun")
+			childPostArgs = strings.Join(args, " ")
 		},
 		PersistentPostRun: func(_ *Command, args []string) {
-			validateHook(args, "child PersistentPostRun")
+			childPersPostArgs = strings.Join(args, " ")
 		},
 	}
 	parentCmd.AddCommand(childCmd)
@@ -1609,13 +1593,41 @@ func testPersistentHooks(t *testing.T, expectedHookRunOrder []string) {
 		t.Errorf("Unexpected error: %v", err)
 	}
 
-	for idx, exp := range expectedHookRunOrder {
-		if len(hookRunOrder) > idx {
-			if act := hookRunOrder[idx]; act != exp {
-				t.Errorf("Expected %q at %d, got %q", exp, idx, act)
-			}
-		} else {
-			t.Errorf("Expected %q at %d, got nothing", exp, idx)
+	for _, v := range []struct {
+		name string
+		got  string
+	}{
+		// TODO: currently PersistentPreRun* defined in parent does not
+		// run if the matching child subcommand has PersistentPreRun.
+		// If the behavior changes (https://github.com/spf13/cobra/issues/252)
+		// this test must be fixed.
+		{"parentPersPreArgs", parentPersPreArgs},
+		{"parentPreArgs", parentPreArgs},
+		{"parentRunArgs", parentRunArgs},
+		{"parentPostArgs", parentPostArgs},
+		// TODO: currently PersistentPostRun* defined in parent does not
+		// run if the matching child subcommand has PersistentPostRun.
+		// If the behavior changes (https://github.com/spf13/cobra/issues/252)
+		// this test must be fixed.
+		{"parentPersPostArgs", parentPersPostArgs},
+	} {
+		if v.got != "" {
+			t.Errorf("Expected blank %s, got %q", v.name, v.got)
+		}
+	}
+
+	for _, v := range []struct {
+		name string
+		got  string
+	}{
+		{"childPersPreArgs", childPersPreArgs},
+		{"childPreArgs", childPreArgs},
+		{"childRunArgs", childRunArgs},
+		{"childPostArgs", childPostArgs},
+		{"childPersPostArgs", childPersPostArgs},
+	} {
+		if v.got != onetwo {
+			t.Errorf("Expected %s %q, got %q", v.name, onetwo, v.got)
 		}
 	}
 }
diff --git a/site/content/user_guide.md b/site/content/user_guide.md
index 4116e8d..55cc252 100644
--- a/site/content/user_guide.md
+++ b/site/content/user_guide.md
@@ -687,10 +687,6 @@ Inside subCmd PostRun with args: [arg1 arg2]
 Inside subCmd PersistentPostRun with args: [arg1 arg2]
 ```
 
-By default, only the first persistent hook found in the command chain is executed.
-That is why in the above output, the `rootCmd PersistentPostRun` was not called for a child command.
-Set `EnableTraverseRunHooks` global variable to `true` if you want to execute all parents' persistent hooks.
-
 ## Suggestions when "unknown command" happens
 
 Cobra will print automatic suggestions when "unknown command" errors happen. This allows Cobra to behave similarly to the `git` command when a typo happens. For example:
