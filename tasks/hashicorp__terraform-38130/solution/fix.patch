diff --git a/internal/addrs/output_value.go b/internal/addrs/output_value.go
index 5afdd5cf46..f4c0ebff1b 100644
--- a/internal/addrs/output_value.go
+++ b/internal/addrs/output_value.go
@@ -226,6 +226,13 @@ func (v ConfigOutputValue) String() string {
 	return fmt.Sprintf("%s.%s", v.Module.String(), v.OutputValue.String())
 }
 
+func (v ConfigOutputValue) ForDisplay() string {
+	if v.Module.IsRoot() {
+		return v.OutputValue.Name
+	}
+	return fmt.Sprintf("%s.%s", v.Module.String(), v.OutputValue.Name)
+}
+
 func (v ConfigOutputValue) configCheckableSigil() {
 	// ConfigOutputValue is the ConfigCheckable for AbsOutputValue.
 }
diff --git a/internal/terraform/evaluate.go b/internal/terraform/evaluate.go
index 47b63e29e2..88d08044f3 100644
--- a/internal/terraform/evaluate.go
+++ b/internal/terraform/evaluate.go
@@ -422,7 +422,7 @@ func (d *evaluationStateData) GetModule(addr addrs.ModuleCall, rng tfdiags.Sourc
 			atys[name] = cty.DynamicPseudoType // output values are dynamically-typed
 			val := cty.UnknownVal(cty.DynamicPseudoType)
 			if c.DeprecatedSet {
-				val = val.Mark(marks.NewDeprecation(c.Deprecated, absAddr.Output(name).ConfigOutputValue().String()))
+				val = val.Mark(marks.NewDeprecation(c.Deprecated, absAddr.Output(name).ConfigOutputValue().ForDisplay()))
 			}
 			as[name] = val
 		}
@@ -483,7 +483,7 @@ func (d *evaluationStateData) GetModule(addr addrs.ModuleCall, rng tfdiags.Sourc
 			}
 
 			if cfg.DeprecatedSet {
-				outputVal = outputVal.Mark(marks.NewDeprecation(cfg.Deprecated, moduleInstAddr.OutputValue(name).ConfigOutputValue().String()))
+				outputVal = outputVal.Mark(marks.NewDeprecation(cfg.Deprecated, moduleInstAddr.OutputValue(name).ConfigOutputValue().ForDisplay()))
 			}
 			attrs[name] = outputVal
 		}
@@ -1163,7 +1163,7 @@ func (d *evaluationStateData) GetOutput(addr addrs.OutputValue, rng tfdiags.Sour
 		value = value.Mark(marks.Ephemeral)
 	}
 	if config.DeprecatedSet {
-		value = value.Mark(marks.NewDeprecation(config.Deprecated, addr.InModule(d.Module).String()))
+		value = value.Mark(marks.NewDeprecation(config.Deprecated, addr.InModule(d.Module).ForDisplay()))
 	}
 
 	return value, diags
diff --git a/internal/tfdiags/diagnostic_extra.go b/internal/tfdiags/diagnostic_extra.go
index 6294503af3..b6e940a1c5 100644
--- a/internal/tfdiags/diagnostic_extra.go
+++ b/internal/tfdiags/diagnostic_extra.go
@@ -307,3 +307,83 @@ func (c *DeprecationOriginDiagnosticExtra) WrapDiagnosticExtra(inner interface{}
 func (c *DeprecationOriginDiagnosticExtra) DeprecatedOriginDescription() string {
 	return c.OriginDescription
 }
+
+// DiagnosticExtrasEqual compares the extra information of two diagnostics.
+// This is intended to be used for testing purposes where we want to verify
+// that diagnostics have the expected extra information.
+// We only compare extra information that we know about (so from inside Terraform).
+// Extra information can also come from external sources, we won't be able to compare those
+// and we don't want to fail tests just because of that.
+//
+// The comparison checks all known DiagnosticExtra* interfaces defined in this file.
+// NOTE: This function should be kept in sync with the extra interfaces defined
+// in this file. When adding a new DiagnosticExtra* interface, also add a
+// corresponding check here to ensure test coverage remains comprehensive.
+func DiagnosticExtrasEqual(diag1, diag2 Diagnostic) bool {
+	// Check DiagnosticExtraBecauseUnknown
+	unknown1 := ExtraInfo[DiagnosticExtraBecauseUnknown](diag1)
+	unknown2 := ExtraInfo[DiagnosticExtraBecauseUnknown](diag2)
+	if (unknown1 == nil) != (unknown2 == nil) {
+		return false
+	}
+	if unknown1 != nil && unknown1.DiagnosticCausedByUnknown() != unknown2.DiagnosticCausedByUnknown() {
+		return false
+	}
+
+	// Check DiagnosticExtraBecauseEphemeral
+	ephemeral1 := ExtraInfo[DiagnosticExtraBecauseEphemeral](diag1)
+	ephemeral2 := ExtraInfo[DiagnosticExtraBecauseEphemeral](diag2)
+	if (ephemeral1 == nil) != (ephemeral2 == nil) {
+		return false
+	}
+	if ephemeral1 != nil && ephemeral1.DiagnosticCausedByEphemeral() != ephemeral2.DiagnosticCausedByEphemeral() {
+		return false
+	}
+
+	// Check DiagnosticExtraBecauseSensitive
+	sensitive1 := ExtraInfo[DiagnosticExtraBecauseSensitive](diag1)
+	sensitive2 := ExtraInfo[DiagnosticExtraBecauseSensitive](diag2)
+	if (sensitive1 == nil) != (sensitive2 == nil) {
+		return false
+	}
+	if sensitive1 != nil && sensitive1.DiagnosticCausedBySensitive() != sensitive2.DiagnosticCausedBySensitive() {
+		return false
+	}
+
+	// Check DiagnosticExtraDoNotConsolidate
+	doNotConsolidate1 := ExtraInfo[DiagnosticExtraDoNotConsolidate](diag1)
+	doNotConsolidate2 := ExtraInfo[DiagnosticExtraDoNotConsolidate](diag2)
+	if (doNotConsolidate1 == nil) != (doNotConsolidate2 == nil) {
+		return false
+	}
+	if doNotConsolidate1 != nil && doNotConsolidate1.DoNotConsolidateDiagnostic() != doNotConsolidate2.DoNotConsolidateDiagnostic() {
+		return false
+	}
+
+	// Check DiagnosticExtraCausedByTestFailure
+	testFailure1 := ExtraInfo[DiagnosticExtraCausedByTestFailure](diag1)
+	testFailure2 := ExtraInfo[DiagnosticExtraCausedByTestFailure](diag2)
+	if (testFailure1 == nil) != (testFailure2 == nil) {
+		return false
+	}
+	if testFailure1 != nil {
+		if testFailure1.DiagnosticCausedByTestFailure() != testFailure2.DiagnosticCausedByTestFailure() {
+			return false
+		}
+		if testFailure1.IsTestVerboseMode() != testFailure2.IsTestVerboseMode() {
+			return false
+		}
+	}
+
+	// Check DiagnosticExtraDeprecationOrigin
+	deprecation1 := ExtraInfo[DiagnosticExtraDeprecationOrigin](diag1)
+	deprecation2 := ExtraInfo[DiagnosticExtraDeprecationOrigin](diag2)
+	if (deprecation1 == nil) != (deprecation2 == nil) {
+		return false
+	}
+	if deprecation1 != nil && deprecation1.DeprecatedOriginDescription() != deprecation2.DeprecatedOriginDescription() {
+		return false
+	}
+
+	return true
+}
diff --git a/internal/tfdiags/testing.go b/internal/tfdiags/testing.go
index c918cd9056..bedf622b98 100644
--- a/internal/tfdiags/testing.go
+++ b/internal/tfdiags/testing.go
@@ -3,6 +3,7 @@
 package tfdiags
 
 import (
+	"fmt"
 	"testing"
 
 	"github.com/google/go-cmp/cmp"
@@ -54,6 +55,52 @@ func assertDiagnosticMatch(got, want Diagnostic) string {
 	return cmp.Diff(want, got, DiagnosticComparer)
 }
 
+// AssertDiagnosticsAndExtrasMatch fails the test in progress (using t.Fatal) if the
+// two sets of diagnostics don't match after being normalized using the
+// "ForRPC" processing step, AND also checks that the extra information on each
+// diagnostic matches.
+//
+// This is similar to AssertDiagnosticsMatch but additionally verifies that the
+// extra information (ExtraInfo) on diagnostics is equal, using DiagnosticExtrasEqual.
+//
+// AssertDiagnosticsAndExtrasMatch sorts the two sets of diagnostics in the usual way
+// before comparing them, though diagnostics only have a partial order so that
+// will not totally normalize the ordering of all diagnostics sets.
+func AssertDiagnosticsAndExtrasMatch(t *testing.T, got, want Diagnostics) {
+	t.Helper()
+
+	if diff := assertDiagnosticsAndExtrasMatch(got, want); diff != "" {
+		t.Fatalf("unexpected diagnostics difference:\n%s", diff)
+	}
+}
+
+func assertDiagnosticsAndExtrasMatch(got, want Diagnostics) string {
+	// First check that the basic diagnostic info matches
+	if diff := assertDiagnosticsMatch(got, want); diff != "" {
+		return diff
+	}
+
+	// Now check extras - we need to compare the original diagnostics
+	// since ForRPC discards extra info
+	gotSorted := make(Diagnostics, len(got))
+	copy(gotSorted, got)
+	gotSorted.Sort()
+
+	wantSorted := make(Diagnostics, len(want))
+	copy(wantSorted, want)
+	wantSorted.Sort()
+
+	// Length should already match if assertDiagnosticsMatch passed
+	for i := range gotSorted {
+		if !DiagnosticExtrasEqual(gotSorted[i], wantSorted[i]) {
+			return fmt.Sprintf("diagnostic[%d] extras do not match:\n  got extra: %#v\n  want extra: %#v",
+				i, gotSorted[i].ExtraInfo(), wantSorted[i].ExtraInfo())
+		}
+	}
+
+	return ""
+}
+
 // AssertNoDiagnostics will fail a test if any diagnostics are present.
 // If diagnostics are present, they will each be logged.
 func AssertNoDiagnostics(t *testing.T, diags Diagnostics) {
