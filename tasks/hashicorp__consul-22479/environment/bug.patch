diff --git a/.changelog/22467.txt b/.changelog/22467.txt
deleted file mode 100644
index 8c6b8b3fd6..0000000000
--- a/.changelog/22467.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-```release-note:bug
-cli: validate IP address in service registration to prevent invalid IPs in service and tagged addresses.
-```
\ No newline at end of file
diff --git a/command/services/register/register.go b/command/services/register/register.go
index ac330d9725..33599dda01 100644
--- a/command/services/register/register.go
+++ b/command/services/register/register.go
@@ -6,8 +6,6 @@ package register
 import (
 	"flag"
 	"fmt"
-	"net"
-	"strings"
 
 	"github.com/hashicorp/consul/api"
 	"github.com/hashicorp/consul/command/flags"
@@ -75,26 +73,13 @@ func (c *cmd) Run(args []string) int {
 		return 1
 	}
 
-	// Validate service address if provided
-	if c.flagAddress != "" {
-		if err := validateServiceAddressWithPortCheck(c.flagAddress, false); err != nil {
-			c.UI.Error(fmt.Sprintf("Invalid Service address when using CLI flags. Use -port flag instead: %v", err))
-			return 1
-		}
-	}
-
 	var taggedAddrs map[string]api.ServiceAddress
 	if len(c.flagTaggedAddresses) > 0 {
 		taggedAddrs = make(map[string]api.ServiceAddress)
 		for k, v := range c.flagTaggedAddresses {
 			addr, err := api.ParseServiceAddr(v)
 			if err != nil {
-				c.UI.Error(fmt.Sprintf("Invalid Tagged address: %v", err))
-				return 1
-			}
-			// Validate the address part of the tagged address
-			if err := validateServiceAddressWithPortCheck(addr.Address, true); err != nil {
-				c.UI.Error(fmt.Sprintf("Invalid Tagged address for tagged address '%s': %v", k, err))
+				c.UI.Error(fmt.Sprintf("Invalid Tagged Address: %v", err))
 				return 1
 			}
 			taggedAddrs[k] = addr
@@ -130,22 +115,6 @@ func (c *cmd) Run(args []string) int {
 			c.UI.Error(fmt.Sprintf("Error: %s", err))
 			return 1
 		}
-		// Validate addresses in services loaded from files
-		for _, svc := range svcs {
-			if svc.Address != "" {
-				if err := validateServiceAddressWithPortCheck(svc.Address, false); err != nil {
-					c.UI.Error(fmt.Sprintf("Invalid Service address for service '%s'. Use port field instead: %v", svc.Name, err))
-					return 1
-				}
-			}
-			// Validate tagged addresses
-			for tag, addr := range svc.TaggedAddresses {
-				if err := validateServiceAddressWithPortCheck(addr.Address, true); err != nil {
-					c.UI.Error(fmt.Sprintf("Invalid Tagged address for tagged address '%s' in service '%s': %v", tag, svc.Name, err))
-					return 1
-				}
-			}
-		}
 	}
 
 	// Create and test the HTTP client
@@ -193,99 +162,3 @@ Usage: consul services register [options] [FILE...]
   Additional flags and more advanced use cases are detailed below.
 `
 )
-
-// This function validates that a service address is properly formatted
-// and catches common malformed IP patterns
-func validateServiceAddress(addr string) error {
-	if addr == "" {
-		return nil // Empty addresses are allowed
-	}
-
-	// Parse the address to separate host and port if present
-	host, _, err := net.SplitHostPort(addr)
-	if err != nil {
-		// If SplitHostPort fails, treat the whole string as host
-		host = addr
-	}
-
-	// Check if it's a valid IP address
-	if ip := net.ParseIP(host); ip != nil {
-		// Valid IP - allow all valid IPs including ANY addresses
-		return nil
-	}
-
-	// If not an IP, it might be a hostname or malformed IP
-	// Check for common malformed IP patterns
-	if looksLikeIP(host) {
-		return fmt.Errorf("malformed IP address: %s", host)
-	}
-
-	// If not an IP, assume it's a hostname - validate it's not empty
-	if strings.TrimSpace(host) == "" {
-		return fmt.Errorf("address cannot be empty")
-	}
-
-	return nil
-}
-
-// This function validates a service address and optionally checks for port presence
-func validateServiceAddressWithPortCheck(addr string, allowPort bool) error {
-
-	// Validate the basic address format
-	if err := validateServiceAddress(addr); err != nil {
-		return err
-	}
-
-	// Check for port presence if not allowed
-	if !allowPort {
-		if _, port, err := net.SplitHostPort(addr); err == nil && port != "" {
-			return fmt.Errorf("address should not contain port")
-		}
-	}
-
-	return nil
-}
-
-// This function returns true if the string appears to be an IP address
-// but fails to parse correctly (indicating it's malformed)
-func looksLikeIP(addr string) bool {
-	// Check for obviously malformed IP patterns
-	if strings.Contains(addr, "..") || strings.Contains(addr, ":::") {
-		return true
-	}
-
-	// Check for multiple :: sequences (IPv6 can have at most one ::)
-	if strings.Count(addr, "::") > 1 {
-		return true
-	}
-
-	// Check for too many colons (IPv6 can have at most 7)
-	if strings.Count(addr, ":") > 7 {
-		return true
-	}
-
-	// Check for IPv4-like patterns with too many dots
-	if strings.Count(addr, ".") > 3 {
-		// Check if most segments are numeric, which may indicate a malformed IP
-		parts := strings.Split(addr, ".")
-		numericParts := 0
-		for _, part := range parts {
-			if part != "" {
-				isNumeric := true
-				for _, r := range part {
-					if r < '0' || r > '9' {
-						isNumeric = false
-						break
-					}
-				}
-				if isNumeric {
-					numericParts++
-				}
-			}
-		}
-		// If most parts are numeric, it's likely a malformed IP
-		return numericParts > 2
-	}
-
-	return false
-}
diff --git a/command/services/register/register_test.go b/command/services/register/register_test.go
index aacb67790d..8b4d94328a 100644
--- a/command/services/register/register_test.go
+++ b/command/services/register/register_test.go
@@ -228,129 +228,3 @@ func testFile(t *testing.T, suffix string) *os.File {
 
 	return f
 }
-
-func TestValidateServiceAddress(t *testing.T) {
-	tests := []struct {
-		name    string
-		addr    string
-		wantErr bool
-	}{
-		{
-			name:    "empty address",
-			addr:    "",
-			wantErr: false,
-		},
-		{
-			name:    "valid IPv4",
-			addr:    "192.168.1.1",
-			wantErr: false,
-		},
-		{
-			name:    "valid IPv4 with port",
-			addr:    "192.168.1.1:8080",
-			wantErr: false,
-		},
-		{
-			name:    "valid IPv6",
-			addr:    "::1",
-			wantErr: false,
-		},
-		{
-			name:    "valid IPv6 with brackets and port",
-			addr:    "[::1]:8080",
-			wantErr: false,
-		},
-		{
-			name:    "IPv4 ANY address",
-			addr:    "0.0.0.0",
-			wantErr: false, // Allow ANY addresses
-		},
-		{
-			name:    "IPv6 ANY address",
-			addr:    "::",
-			wantErr: false, // Allow ANY addresses
-		},
-		{
-			name:    "IPv6 ANY address with brackets",
-			addr:    "[::]",
-			wantErr: false, // Allow ANY addresses
-		},
-		{
-			name:    "malformed IPv6 - too many colons",
-			addr:    ":::8500",
-			wantErr: true,
-		},
-		{
-			name:    "malformed IPv4 - too many octets",
-			addr:    "192.168.1.1.1",
-			wantErr: true, // This should be caught as malformed IP
-		},
-		{
-			name:    "malformed IP with consecutive dots",
-			addr:    "192.168..1",
-			wantErr: true,
-		},
-		{
-			name:    "valid full IPv6 address",
-			addr:    "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
-			wantErr: false,
-		},
-		{
-			name:    "invalid  IPv6 address with port",
-			addr:    "2001:0db8:85a3:0000:0000:8a2e:0370:7334:8080",
-			wantErr: true,
-		},
-		{
-			name:    "valid IPv6 address with port",
-			addr:    "[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:8080",
-			wantErr: false,
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			err := validateServiceAddress(tt.addr)
-			if (err != nil) != tt.wantErr {
-				t.Errorf("validateServiceAddress(%q) error = %v, wantErr %v", tt.addr, err, tt.wantErr)
-			}
-		})
-	}
-}
-
-func TestLooksLikeIP(t *testing.T) {
-	tests := []struct {
-		name string
-		addr string
-		want bool
-	}{
-		{
-			name: "malformed with consecutive colons",
-			addr: ":::8500",
-			want: true,
-		},
-		{
-			name: "malformed with consecutive dots",
-			addr: "192.168..1",
-			want: true,
-		},
-		{
-			name: "valid IPv4",
-			addr: "192.168.1.1",
-			want: false,
-		},
-		{
-			name: "too many colons",
-			addr: ":::::::::",
-			want: true,
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			got := looksLikeIP(tt.addr)
-			if got != tt.want {
-				t.Errorf("looksLikeIP(%q) = %v, want %v", tt.addr, got, tt.want)
-			}
-		})
-	}
-}
