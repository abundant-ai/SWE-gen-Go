diff --git a/assert/assertion_format.go b/assert/assertion_format.go
index ae99d47..aa1c2b9 100644
--- a/assert/assertion_format.go
+++ b/assert/assertion_format.go
@@ -113,17 +113,6 @@ func Errorf(t TestingT, err error, msg string, args ...interface{}) bool {
 	return Error(t, err, append([]interface{}{msg}, args...)...)
 }
 
-// Eventuallyf asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick.
-//
-//    assert.Eventuallyf(t, func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
-func Eventuallyf(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	return Eventually(t, condition, waitFor, tick, append([]interface{}{msg}, args...)...)
-}
-
 // Exactlyf asserts that two objects are equal in value and type.
 //
 //    assert.Exactlyf(t, int32(123, "error message %s", "formatted"), int64(123))
diff --git a/assert/assertion_forward.go b/assert/assertion_forward.go
index 8b8ddf0..de39f79 100644
--- a/assert/assertion_forward.go
+++ b/assert/assertion_forward.go
@@ -215,28 +215,6 @@ func (a *Assertions) Errorf(err error, msg string, args ...interface{}) bool {
 	return Errorf(a.t, err, msg, args...)
 }
 
-// Eventually asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick.
-//
-//    a.Eventually(func() bool { return true; }, time.Second, 10*time.Millisecond)
-func (a *Assertions) Eventually(condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	return Eventually(a.t, condition, waitFor, tick, msgAndArgs...)
-}
-
-// Eventuallyf asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick.
-//
-//    a.Eventuallyf(func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
-func (a *Assertions) Eventuallyf(condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	return Eventuallyf(a.t, condition, waitFor, tick, msg, args...)
-}
-
 // Exactly asserts that two objects are equal in value and type.
 //
 //    a.Exactly(int32(123), int64(123))
diff --git a/assert/assertions.go b/assert/assertions.go
index 5c121ea..cf1807e 100644
--- a/assert/assertions.go
+++ b/assert/assertions.go
@@ -479,14 +479,14 @@ func isEmpty(object interface{}) bool {
 	// collection types are empty when they have no element
 	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:
 		return objValue.Len() == 0
-		// pointers are empty if nil or if the value they point to is empty
+	// pointers are empty if nil or if the value they point to is empty
 	case reflect.Ptr:
 		if objValue.IsNil() {
 			return true
 		}
 		deref := objValue.Elem().Interface()
 		return isEmpty(deref)
-		// for all other types, compare against the zero value
+	// for all other types, compare against the zero value
 	default:
 		zero := reflect.Zero(objValue.Type())
 		return reflect.DeepEqual(object, zero.Interface())
@@ -1415,34 +1415,3 @@ var spewConfig = spew.ConfigState{
 type tHelper interface {
 	Helper()
 }
-
-// Eventually asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick.
-//
-//    assert.Eventually(t, func() bool { return true; }, time.Second, 10*time.Millisecond)
-func Eventually(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-
-	timer := time.NewTimer(waitFor)
-	ticker := time.NewTicker(tick)
-	checkPassed := make(chan bool)
-	defer timer.Stop()
-	defer ticker.Stop()
-	defer close(checkPassed)
-	for {
-		select {
-		case <-timer.C:
-			return Fail(t, "Condition never satisfied", msgAndArgs...)
-		case result := <-checkPassed:
-			if result {
-				return true
-			}
-		case <-ticker.C:
-			go func() {
-				checkPassed <- condition()
-			}()
-		}
-	}
-}
diff --git a/assert/assertions_test.go b/assert/assertions_test.go
index 27c6349..00e2d21 100644
--- a/assert/assertions_test.go
+++ b/assert/assertions_test.go
@@ -1801,25 +1801,3 @@ func TestErrorAssertionFunc(t *testing.T) {
 		})
 	}
 }
-
-func TestEventuallyFalse(t *testing.T) {
-	mockT := new(testing.T)
-
-	condition := func() bool {
-		return false
-	}
-
-	False(t, Eventually(mockT, condition, 100*time.Millisecond, 20*time.Millisecond))
-}
-
-func TestEventuallyTrue(t *testing.T) {
-	state := 0
-	condition := func() bool {
-		defer func() {
-			state = state + 1
-		}()
-		return state == 2
-	}
-
-	True(t, Eventually(t, condition, 100*time.Millisecond, 20*time.Millisecond))
-}
diff --git a/require/require.go b/require/require.go
index 9cfb80d..535f293 100644
--- a/require/require.go
+++ b/require/require.go
@@ -270,34 +270,6 @@ func Errorf(t TestingT, err error, msg string, args ...interface{}) {
 	t.FailNow()
 }
 
-// Eventually asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick.
-//
-//    assert.Eventually(t, func() bool { return true; }, time.Second, 10*time.Millisecond)
-func Eventually(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) {
-	if assert.Eventually(t, condition, waitFor, tick, msgAndArgs...) {
-		return
-	}
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	t.FailNow()
-}
-
-// Eventuallyf asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick.
-//
-//    assert.Eventuallyf(t, func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
-func Eventuallyf(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) {
-	if assert.Eventuallyf(t, condition, waitFor, tick, msg, args...) {
-		return
-	}
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	t.FailNow()
-}
-
 // Exactly asserts that two objects are equal in value and type.
 //
 //    assert.Exactly(t, int32(123), int64(123))
diff --git a/require/require_forward.go b/require/require_forward.go
index c1f51df..9fe41db 100644
--- a/require/require_forward.go
+++ b/require/require_forward.go
@@ -216,28 +216,6 @@ func (a *Assertions) Errorf(err error, msg string, args ...interface{}) {
 	Errorf(a.t, err, msg, args...)
 }
 
-// Eventually asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick.
-//
-//    a.Eventually(func() bool { return true; }, time.Second, 10*time.Millisecond)
-func (a *Assertions) Eventually(condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	Eventually(a.t, condition, waitFor, tick, msgAndArgs...)
-}
-
-// Eventuallyf asserts that given condition will be met in waitFor time,
-// periodically checking target function each tick.
-//
-//    a.Eventuallyf(func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
-func (a *Assertions) Eventuallyf(condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	Eventuallyf(a.t, condition, waitFor, tick, msg, args...)
-}
-
 // Exactly asserts that two objects are equal in value and type.
 //
 //    a.Exactly(int32(123), int64(123))
