diff --git a/conn.go b/conn.go
index 340bca5a..42e955fc 100644
--- a/conn.go
+++ b/conn.go
@@ -65,11 +65,12 @@ func (cc *ConnConfig) ConnString() string { return cc.connString }
 // Conn is a PostgreSQL connection handle. It is not safe for concurrent usage. Use a connection pool to manage access
 // to multiple database connections from multiple goroutines.
 type Conn struct {
-	pgConn             *pgconn.PgConn
-	config             *ConnConfig // config used when establishing this connection
-	preparedStatements map[string]*pgconn.StatementDescription
-	statementCache     stmtcache.Cache
-	descriptionCache   stmtcache.Cache
+	pgConn                  *pgconn.PgConn
+	config                  *ConnConfig // config used when establishing this connection
+	preparedStatements      map[string]*pgconn.StatementDescription
+	failedDescribeStatement string
+	statementCache          stmtcache.Cache
+	descriptionCache        stmtcache.Cache
 
 	queryTracer    QueryTracer
 	batchTracer    BatchTracer
@@ -314,6 +315,14 @@ func (c *Conn) Close(ctx context.Context) error {
 // Prepare is idempotent; i.e. it is safe to call Prepare multiple times with the same name and sql arguments. This
 // allows a code path to Prepare and Query/Exec without concern for if the statement has already been prepared.
 func (c *Conn) Prepare(ctx context.Context, name, sql string) (sd *pgconn.StatementDescription, err error) {
+	if c.failedDescribeStatement != "" {
+		err = c.Deallocate(ctx, c.failedDescribeStatement)
+		if err != nil {
+			return nil, fmt.Errorf("failed to deallocate previously failed statement %q: %w", c.failedDescribeStatement, err)
+		}
+		c.failedDescribeStatement = ""
+	}
+
 	if c.prepareTracer != nil {
 		ctx = c.prepareTracer.TracePrepareStart(ctx, c, TracePrepareStartData{Name: name, SQL: sql})
 	}
@@ -346,6 +355,10 @@ func (c *Conn) Prepare(ctx context.Context, name, sql string) (sd *pgconn.Statem
 
 	sd, err = c.pgConn.Prepare(ctx, psName, sql, nil)
 	if err != nil {
+		var pErr *pgconn.PrepareError
+		if errors.As(err, &pErr) {
+			c.failedDescribeStatement = psKey
+		}
 		return nil, err
 	}
 
diff --git a/internal/faultyconn/faultyconn.go b/internal/faultyconn/faultyconn.go
new file mode 100644
index 00000000..73d4a067
--- /dev/null
+++ b/internal/faultyconn/faultyconn.go
@@ -0,0 +1,99 @@
+package faultyconn
+
+import (
+	"bytes"
+	"io"
+	"net"
+	"time"
+
+	"github.com/jackc/pgx/v5/pgproto3"
+)
+
+// Conn is a wrapper for a net.Conn that allows inspection and modification of messages between a PostgreSQL client and
+// server. It is designed to be used in tests that use a *pgx.Conn or *pgconn.PgConn connected to a real PostgreSQL
+// server. Instead of mocking an entire server connection, this is used to specify and modify only the particular
+// aspects of a connection that are necessary. This can be easier to setup and is more true to real world conditions.
+//
+// It currently only supports handling frontend messages.
+type Conn struct {
+	// HandleFrontendMessage is called for each frontend message received. It should use backendWriter to write to the
+	// backend.
+	HandleFrontendMessage func(backendWriter io.Writer, msg pgproto3.FrontendMessage) error
+
+	// TODO: Implement this if we need to handle backend messages.
+	// HandleBackendMessage  func(w io.Writer, msg pgproto3.BackendMessage) error
+
+	conn            net.Conn
+	fromFrontendBuf *bytes.Buffer
+	fromBackendBuf  *bytes.Buffer
+	backend         *pgproto3.Backend
+	frontend        *pgproto3.Frontend
+}
+
+// NewConn creates a new Conn that proxies the messages sent to and from the given net.Conn. New can be used with
+// pgconn.Config.AfterNetConnect to wrap a net.Conn for testing purposes.
+func New(c net.Conn) *Conn {
+	fromFrontendBuf := &bytes.Buffer{}
+	fromBackendBuf := &bytes.Buffer{}
+
+	return &Conn{
+		conn:            c,
+		fromFrontendBuf: fromFrontendBuf,
+		fromBackendBuf:  fromBackendBuf,
+		backend:         pgproto3.NewBackend(fromFrontendBuf, c),
+		frontend:        pgproto3.NewFrontend(fromBackendBuf, c),
+	}
+}
+
+func (c *Conn) Read(b []byte) (n int, err error) {
+	return c.conn.Read(b)
+}
+
+func (c *Conn) Write(b []byte) (n int, err error) {
+	if c.HandleFrontendMessage == nil {
+		return c.conn.Write(b)
+	}
+
+	c.fromFrontendBuf.Write(b)
+
+	for {
+		msg, err := c.backend.Receive()
+		if err != nil {
+			if err == io.ErrUnexpectedEOF {
+				break
+			}
+			return len(b), err
+		}
+
+		err = c.HandleFrontendMessage(c.conn, msg)
+		if err != nil {
+			return len(b), err
+		}
+	}
+
+	return len(b), nil
+}
+
+func (c *Conn) Close() error {
+	return c.conn.Close()
+}
+
+func (c *Conn) LocalAddr() net.Addr {
+	return c.conn.LocalAddr()
+}
+
+func (c *Conn) RemoteAddr() net.Addr {
+	return c.conn.RemoteAddr()
+}
+
+func (c *Conn) SetDeadline(t time.Time) error {
+	return c.conn.SetDeadline(t)
+}
+
+func (c *Conn) SetReadDeadline(t time.Time) error {
+	return c.conn.SetReadDeadline(t)
+}
+
+func (c *Conn) SetWriteDeadline(t time.Time) error {
+	return c.conn.SetWriteDeadline(t)
+}
diff --git a/pgconn/config.go b/pgconn/config.go
index 3937dc40..3cd5d877 100644
--- a/pgconn/config.go
+++ b/pgconn/config.go
@@ -55,6 +55,13 @@ type Config struct {
 
 	SSLNegotiation string // sslnegotiation=postgres or sslnegotiation=direct
 
+	// AfterNetConnect is called after the network connection, including TLS if applicable, is established but before any
+	// PostgreSQL protocol communication. It takes the established net.Conn and returns a net.Conn that will be used in
+	// its place. It can be used to wrap the net.Conn (e.g. for logging, diagnostics, or testing). Its functionality has
+	// some overlap with DialFunc. However, DialFunc takes place before TLS is established and cannot be used to control
+	// the final net.Conn used for PostgreSQL protocol communication while AfterNetConnect can.
+	AfterNetConnect func(ctx context.Context, config *Config, conn net.Conn) (net.Conn, error)
+
 	// ValidateConnect is called during a connection attempt after a successful authentication with the PostgreSQL server.
 	// It can be used to validate that the server is acceptable. If this returns an error the connection is closed and the next
 	// fallback config is tried. This allows implementing high availability behavior such as libpq does with target_session_attrs.
diff --git a/pgconn/errors.go b/pgconn/errors.go
index d968d3f0..bc1e31e3 100644
--- a/pgconn/errors.go
+++ b/pgconn/errors.go
@@ -254,3 +254,20 @@ func (e *NotPreferredError) SafeToRetry() bool {
 func (e *NotPreferredError) Unwrap() error {
 	return e.err
 }
+
+type PrepareError struct {
+	err error
+
+	ParseComplete bool // Indicates whether the error occurred after a ParseComplete message was received.
+}
+
+func (e *PrepareError) Error() string {
+	if e.ParseComplete {
+		return fmt.Sprintf("prepare failed after ParseComplete: %s", e.err.Error())
+	}
+	return e.err.Error()
+}
+
+func (e *PrepareError) Unwrap() error {
+	return e.err
+}
diff --git a/pgconn/pgconn.go b/pgconn/pgconn.go
index 321656f9..5c77a836 100644
--- a/pgconn/pgconn.go
+++ b/pgconn/pgconn.go
@@ -343,6 +343,14 @@ func connectOne(ctx context.Context, config *Config, connectConfig *connectOneCo
 		pgConn.conn = tlsConn
 	}
 
+	if config.AfterNetConnect != nil {
+		pgConn.conn, err = config.AfterNetConnect(ctx, config, pgConn.conn)
+		if err != nil {
+			pgConn.conn.Close()
+			return nil, newPerDialConnectError("AfterNetConnect failed", err)
+		}
+	}
+
 	pgConn.contextWatcher = ctxwatch.NewContextWatcher(config.BuildContextWatcherHandler(pgConn))
 	pgConn.contextWatcher.Watch(ctx)
 	defer pgConn.contextWatcher.Unwatch()
@@ -858,6 +866,10 @@ type StatementDescription struct {
 //
 // Prepare does not send a PREPARE statement to the server. It uses the PostgreSQL Parse and Describe protocol messages
 // directly.
+//
+// In extremely rare cases, Prepare may fail after the Parse is successful, but before the Describe is complete. In this
+// case, the returned error will be an error where errors.As with a *PrepareError succeeds and the *PrepareError has
+// ParseComplete set to true.
 func (pgConn *PgConn) Prepare(ctx context.Context, name, sql string, paramOIDs []uint32) (*StatementDescription, error) {
 	if err := pgConn.lock(); err != nil {
 		return nil, err
@@ -885,7 +897,8 @@ func (pgConn *PgConn) Prepare(ctx context.Context, name, sql string, paramOIDs [
 
 	psd := &StatementDescription{Name: name, SQL: sql}
 
-	var parseErr error
+	var ParseComplete bool
+	var pgErr *PgError
 
 readloop:
 	for {
@@ -896,20 +909,22 @@ readloop:
 		}
 
 		switch msg := msg.(type) {
+		case *pgproto3.ParseComplete:
+			ParseComplete = true
 		case *pgproto3.ParameterDescription:
 			psd.ParamOIDs = make([]uint32, len(msg.ParameterOIDs))
 			copy(psd.ParamOIDs, msg.ParameterOIDs)
 		case *pgproto3.RowDescription:
 			psd.Fields = pgConn.convertRowDescription(nil, msg)
 		case *pgproto3.ErrorResponse:
-			parseErr = ErrorResponseToPgError(msg)
+			pgErr = ErrorResponseToPgError(msg)
 		case *pgproto3.ReadyForQuery:
 			break readloop
 		}
 	}
 
-	if parseErr != nil {
-		return nil, parseErr
+	if pgErr != nil {
+		return nil, &PrepareError{err: pgErr, ParseComplete: ParseComplete}
 	}
 	return psd, nil
 }
