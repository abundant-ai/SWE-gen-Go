diff --git a/examples/addsvc/pkg/addendpoint/set.go b/examples/addsvc/pkg/addendpoint/set.go
index e4acaff..3a65b08 100644
--- a/examples/addsvc/pkg/addendpoint/set.go
+++ b/examples/addsvc/pkg/addendpoint/set.go
@@ -2,10 +2,8 @@ package addendpoint
 
 import (
 	"context"
-	"time"
-
-	"golang.org/x/time/rate"
 
+	rl "github.com/juju/ratelimit"
 	stdopentracing "github.com/opentracing/opentracing-go"
 	"github.com/sony/gobreaker"
 
@@ -33,7 +31,7 @@ func New(svc addservice.Service, logger log.Logger, duration metrics.Histogram,
 	var sumEndpoint endpoint.Endpoint
 	{
 		sumEndpoint = MakeSumEndpoint(svc)
-		sumEndpoint = ratelimit.NewErroringLimiter(rate.NewLimiter(rate.Every(time.Second), 1))(sumEndpoint)
+		sumEndpoint = ratelimit.NewTokenBucketLimiter(rl.NewBucketWithRate(1, 1))(sumEndpoint)
 		sumEndpoint = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{}))(sumEndpoint)
 		sumEndpoint = opentracing.TraceServer(trace, "Sum")(sumEndpoint)
 		sumEndpoint = LoggingMiddleware(log.With(logger, "method", "Sum"))(sumEndpoint)
@@ -42,7 +40,7 @@ func New(svc addservice.Service, logger log.Logger, duration metrics.Histogram,
 	var concatEndpoint endpoint.Endpoint
 	{
 		concatEndpoint = MakeConcatEndpoint(svc)
-		concatEndpoint = ratelimit.NewErroringLimiter(rate.NewLimiter(rate.Every(time.Second), 100))(concatEndpoint)
+		concatEndpoint = ratelimit.NewTokenBucketLimiter(rl.NewBucketWithRate(100, 100))(concatEndpoint)
 		concatEndpoint = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{}))(concatEndpoint)
 		concatEndpoint = opentracing.TraceServer(trace, "Concat")(concatEndpoint)
 		concatEndpoint = LoggingMiddleware(log.With(logger, "method", "Concat"))(concatEndpoint)
diff --git a/examples/addsvc/pkg/addtransport/grpc.go b/examples/addsvc/pkg/addtransport/grpc.go
index 6ec58d7..ec05baa 100644
--- a/examples/addsvc/pkg/addtransport/grpc.go
+++ b/examples/addsvc/pkg/addtransport/grpc.go
@@ -7,10 +7,10 @@ import (
 
 	"google.golang.org/grpc"
 
+	jujuratelimit "github.com/juju/ratelimit"
 	stdopentracing "github.com/opentracing/opentracing-go"
 	"github.com/sony/gobreaker"
 	oldcontext "golang.org/x/net/context"
-	"golang.org/x/time/rate"
 
 	"github.com/go-kit/kit/circuitbreaker"
 	"github.com/go-kit/kit/endpoint"
@@ -76,7 +76,7 @@ func NewGRPCClient(conn *grpc.ClientConn, tracer stdopentracing.Tracer, logger l
 	// construct per-endpoint circuitbreaker middlewares to demonstrate how
 	// that's done, although they could easily be combined into a single breaker
 	// for the entire remote instance, too.
-	limiter := ratelimit.NewErroringLimiter(rate.NewLimiter(rate.Every(time.Second), 100))
+	limiter := ratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(100, 100))
 
 	// Each individual endpoint is an http/transport.Client (which implements
 	// endpoint.Endpoint) that gets wrapped with various middlewares. If you
diff --git a/examples/addsvc/pkg/addtransport/http.go b/examples/addsvc/pkg/addtransport/http.go
index 3819c6d..ecdee92 100644
--- a/examples/addsvc/pkg/addtransport/http.go
+++ b/examples/addsvc/pkg/addtransport/http.go
@@ -11,8 +11,7 @@ import (
 	"strings"
 	"time"
 
-	"golang.org/x/time/rate"
-
+	jujuratelimit "github.com/juju/ratelimit"
 	stdopentracing "github.com/opentracing/opentracing-go"
 	"github.com/sony/gobreaker"
 
@@ -69,7 +68,7 @@ func NewHTTPClient(instance string, tracer stdopentracing.Tracer, logger log.Log
 	// construct per-endpoint circuitbreaker middlewares to demonstrate how
 	// that's done, although they could easily be combined into a single breaker
 	// for the entire remote instance, too.
-	limiter := ratelimit.NewErroringLimiter(rate.NewLimiter(rate.Every(time.Second), 100))
+	limiter := ratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(100, 100))
 
 	// Each individual endpoint is an http/transport.Client (which implements
 	// endpoint.Endpoint) that gets wrapped with various middlewares. If you
diff --git a/examples/addsvc/pkg/addtransport/thrift.go b/examples/addsvc/pkg/addtransport/thrift.go
index 485840f..c6797ec 100644
--- a/examples/addsvc/pkg/addtransport/thrift.go
+++ b/examples/addsvc/pkg/addtransport/thrift.go
@@ -4,8 +4,7 @@ import (
 	"context"
 	"time"
 
-	"golang.org/x/time/rate"
-
+	jujuratelimit "github.com/juju/ratelimit"
 	"github.com/sony/gobreaker"
 
 	"github.com/go-kit/kit/circuitbreaker"
@@ -59,7 +58,7 @@ func NewThriftClient(client *addthrift.AddServiceClient) addservice.Service {
 	// construct per-endpoint circuitbreaker middlewares to demonstrate how
 	// that's done, although they could easily be combined into a single breaker
 	// for the entire remote instance, too.
-	limiter := ratelimit.NewErroringLimiter(rate.NewLimiter(rate.Every(time.Second), 100))
+	limiter := ratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(100, 100))
 
 	// Each individual endpoint is an http/transport.Client (which implements
 	// endpoint.Endpoint) that gets wrapped with various middlewares. If you
diff --git a/examples/stringsvc3/proxying.go b/examples/stringsvc3/proxying.go
index 0f67807..8b1013f 100644
--- a/examples/stringsvc3/proxying.go
+++ b/examples/stringsvc3/proxying.go
@@ -8,8 +8,7 @@ import (
 	"strings"
 	"time"
 
-	"golang.org/x/time/rate"
-
+	jujuratelimit "github.com/juju/ratelimit"
 	"github.com/sony/gobreaker"
 
 	"github.com/go-kit/kit/circuitbreaker"
@@ -48,7 +47,7 @@ func proxyingMiddleware(ctx context.Context, instances string, logger log.Logger
 		var e endpoint.Endpoint
 		e = makeUppercaseProxy(ctx, instance)
 		e = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{}))(e)
-		e = ratelimit.NewErroringLimiter(rate.NewLimiter(rate.Every(time.Second), qps))(e)
+		e = ratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(float64(qps), int64(qps)))(e)
 		endpointer = append(endpointer, e)
 	}
 
diff --git a/ratelimit/token_bucket.go b/ratelimit/token_bucket.go
index e8a6de6..b71e50b 100644
--- a/ratelimit/token_bucket.go
+++ b/ratelimit/token_bucket.go
@@ -3,6 +3,9 @@ package ratelimit
 import (
 	"context"
 	"errors"
+	"time"
+
+	"github.com/juju/ratelimit"
 
 	"github.com/go-kit/kit/endpoint"
 )
@@ -11,6 +14,22 @@ import (
 // triggered and the request is rejected.
 var ErrLimited = errors.New("rate limit exceeded")
 
+// NewTokenBucketLimiter returns an endpoint.Middleware that acts as a rate
+// limiter based on a token-bucket algorithm. Requests that would exceed the
+// maximum request rate are simply rejected with an error.
+func NewTokenBucketLimiter(tb *ratelimit.Bucket) endpoint.Middleware {
+	return NewErroringLimiter(NewAllower(tb))
+}
+
+// NewTokenBucketThrottler returns an endpoint.Middleware that acts as a
+// request throttler based on a token-bucket algorithm. Requests that would
+// exceed the maximum request rate are delayed.
+// The parameterized function "_" is kept for backwards-compatiblity of
+// the API, but it is no longer used for anything. You may pass it nil.
+func NewTokenBucketThrottler(tb *ratelimit.Bucket, _ func(time.Duration)) endpoint.Middleware {
+	return NewDelayingLimiter(NewWaiter(tb))
+}
+
 // Allower dictates whether or not a request is acceptable to run.
 // The Limiter from "golang.org/x/time/rate" already implements this interface,
 // one is able to use that in NewErroringLimiter without any modifications.
@@ -62,6 +81,13 @@ func (f AllowerFunc) Allow() bool {
 	return f()
 }
 
+// NewAllower turns an existing ratelimit.Bucket into an API-compatible form
+func NewAllower(tb *ratelimit.Bucket) Allower {
+	return AllowerFunc(func() bool {
+		return (tb.TakeAvailable(1) != 0)
+	})
+}
+
 // WaiterFunc is an adapter that lets a function operate as if
 // it implements Waiter
 type WaiterFunc func(ctx context.Context) error
@@ -70,3 +96,17 @@ type WaiterFunc func(ctx context.Context) error
 func (f WaiterFunc) Wait(ctx context.Context) error {
 	return f(ctx)
 }
+
+// NewWaiter turns an existing ratelimit.Bucket into an API-compatible form
+func NewWaiter(tb *ratelimit.Bucket) Waiter {
+	return WaiterFunc(func(ctx context.Context) error {
+		dur := tb.Take(1)
+		select {
+		case <-ctx.Done():
+			return ctx.Err()
+		case <-time.After(dur):
+			// happy path
+		}
+		return nil
+	})
+}
diff --git a/ratelimit/token_bucket_test.go b/ratelimit/token_bucket_test.go
index 3845c9e..d444fe9 100644
--- a/ratelimit/token_bucket_test.go
+++ b/ratelimit/token_bucket_test.go
@@ -6,6 +6,7 @@ import (
 	"testing"
 	"time"
 
+	jujuratelimit "github.com/juju/ratelimit"
 	"golang.org/x/time/rate"
 
 	"github.com/go-kit/kit/endpoint"
@@ -14,6 +15,22 @@ import (
 
 var nopEndpoint = func(context.Context, interface{}) (interface{}, error) { return struct{}{}, nil }
 
+func TestTokenBucketLimiter(t *testing.T) {
+	tb := jujuratelimit.NewBucket(time.Minute, 1)
+	testSuccessThenFailure(
+		t,
+		ratelimit.NewTokenBucketLimiter(tb)(nopEndpoint),
+		ratelimit.ErrLimited.Error())
+}
+
+func TestTokenBucketThrottler(t *testing.T) {
+	tb := jujuratelimit.NewBucket(time.Minute, 1)
+	testSuccessThenFailure(
+		t,
+		ratelimit.NewTokenBucketThrottler(tb, nil)(nopEndpoint),
+		"context deadline exceeded")
+}
+
 func TestXRateErroring(t *testing.T) {
 	limit := rate.NewLimiter(rate.Every(time.Minute), 1)
 	testSuccessThenFailure(
