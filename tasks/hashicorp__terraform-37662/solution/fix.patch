diff --git a/internal/plugin/convert/schema.go b/internal/plugin/convert/schema.go
index d07f91645f..d3b003d561 100644
--- a/internal/plugin/convert/schema.go
+++ b/internal/plugin/convert/schema.go
@@ -11,6 +11,7 @@ import (
 	"github.com/hashicorp/terraform/internal/configs/configschema"
 	"github.com/hashicorp/terraform/internal/providers"
 	proto "github.com/hashicorp/terraform/internal/tfplugin5"
+	"github.com/zclconf/go-cty/cty"
 )
 
 // ConfigSchemaToProto takes a *configschema.Block and converts it to a
@@ -111,6 +112,45 @@ func ProtoToActionSchema(s *proto.ActionSchema) providers.ActionSchema {
 	}
 }
 
+func ProtoToListSchema(s *proto.Schema) providers.Schema {
+	listSchema := ProtoToProviderSchema(s, nil)
+	itemCount := 0
+	// check if the provider has set some attributes/blocks as required.
+	// When yes, then we set minItem = 1, which
+	// validates that the configuration contains a "config" block.
+	for _, attrS := range listSchema.Body.Attributes {
+		if attrS.Required {
+			itemCount = 1
+			break
+		}
+	}
+	for _, block := range listSchema.Body.BlockTypes {
+		if block.MinItems > 0 {
+			itemCount = 1
+			break
+		}
+	}
+	return providers.Schema{
+		Version: s.Version,
+		Body: &configschema.Block{
+			Attributes: map[string]*configschema.Attribute{
+				"data": {
+					Type:     cty.DynamicPseudoType,
+					Computed: true,
+				},
+			},
+			BlockTypes: map[string]*configschema.NestedBlock{
+				"config": {
+					Block:    *listSchema.Body,
+					Nesting:  configschema.NestingSingle,
+					MinItems: itemCount,
+					MaxItems: itemCount,
+				},
+			},
+		},
+	}
+}
+
 // ProtoToConfigSchema takes the GetSchcema_Block from a grpc response and converts it
 // to a terraform *configschema.Block.
 func ProtoToConfigSchema(b *proto.Schema_Block) *configschema.Block {
diff --git a/internal/plugin/grpc_provider.go b/internal/plugin/grpc_provider.go
index c3c0793dc2..3f8251b4a1 100644
--- a/internal/plugin/grpc_provider.go
+++ b/internal/plugin/grpc_provider.go
@@ -20,7 +20,6 @@ import (
 	"google.golang.org/grpc/status"
 
 	"github.com/hashicorp/terraform/internal/addrs"
-	"github.com/hashicorp/terraform/internal/configs/configschema"
 	"github.com/hashicorp/terraform/internal/logging"
 	"github.com/hashicorp/terraform/internal/plugin/convert"
 	"github.com/hashicorp/terraform/internal/providers"
@@ -171,24 +170,7 @@ func (p *GRPCProvider) GetProviderSchema() providers.GetProviderSchemaResponse {
 	}
 
 	for name, list := range protoResp.ListResourceSchemas {
-		ret := convert.ProtoToProviderSchema(list, nil)
-		resp.ListResourceTypes[name] = providers.Schema{
-			Version: ret.Version,
-			Body: &configschema.Block{
-				Attributes: map[string]*configschema.Attribute{
-					"data": {
-						Type:     cty.DynamicPseudoType,
-						Computed: true,
-					},
-				},
-				BlockTypes: map[string]*configschema.NestedBlock{
-					"config": {
-						Block:   *ret.Body,
-						Nesting: configschema.NestingSingle,
-					},
-				},
-			},
-		}
+		resp.ListResourceTypes[name] = convert.ProtoToListSchema(list)
 	}
 
 	for name, action := range protoResp.ActionSchemas {
@@ -381,10 +363,12 @@ func (p *GRPCProvider) ValidateListResourceConfig(r providers.ValidateListResour
 	}
 
 	configSchema := listResourceSchema.Body.BlockTypes["config"]
-	config := cty.NullVal(configSchema.ImpliedType())
-	if r.Config.Type().HasAttribute("config") {
-		config = r.Config.GetAttr("config")
+	if !r.Config.Type().HasAttribute("config") {
+		resp.Diagnostics = resp.Diagnostics.Append(fmt.Errorf("missing required attribute \"config\"; this is a bug in Terraform - please report it"))
+		return resp
 	}
+
+	config := r.Config.GetAttr("config")
 	mp, err := msgpack.Marshal(config, configSchema.ImpliedType())
 	if err != nil {
 		resp.Diagnostics = resp.Diagnostics.Append(err)
@@ -1342,10 +1326,12 @@ func (p *GRPCProvider) ListResource(r providers.ListResourceRequest) providers.L
 	}
 
 	configSchema := listResourceSchema.Body.BlockTypes["config"]
-	config := cty.NullVal(configSchema.ImpliedType())
-	if r.Config.Type().HasAttribute("config") {
-		config = r.Config.GetAttr("config")
+	if !r.Config.Type().HasAttribute("config") {
+		resp.Diagnostics = resp.Diagnostics.Append(fmt.Errorf("missing required attribute \"config\"; this is a bug in Terraform - please report it"))
+		return resp
 	}
+
+	config := r.Config.GetAttr("config")
 	mp, err := msgpack.Marshal(config, configSchema.ImpliedType())
 	if err != nil {
 		resp.Diagnostics = resp.Diagnostics.Append(err)
diff --git a/internal/plugin6/convert/schema.go b/internal/plugin6/convert/schema.go
index a762590862..4ea6a8faf5 100644
--- a/internal/plugin6/convert/schema.go
+++ b/internal/plugin6/convert/schema.go
@@ -118,6 +118,45 @@ func ProtoToActionSchema(s *proto.ActionSchema) providers.ActionSchema {
 	}
 }
 
+func ProtoToListSchema(s *proto.Schema) providers.Schema {
+	listSchema := ProtoToProviderSchema(s, nil)
+	itemCount := 0
+	// check if the provider has set some attributes/blocks as required.
+	// When yes, then we set minItem = 1, which
+	// validates that the configuration contains a "config" block.
+	for _, attrS := range listSchema.Body.Attributes {
+		if attrS.Required {
+			itemCount = 1
+			break
+		}
+	}
+	for _, block := range listSchema.Body.BlockTypes {
+		if block.MinItems > 0 {
+			itemCount = 1
+			break
+		}
+	}
+	return providers.Schema{
+		Version: listSchema.Version,
+		Body: &configschema.Block{
+			Attributes: map[string]*configschema.Attribute{
+				"data": {
+					Type:     cty.DynamicPseudoType,
+					Computed: true,
+				},
+			},
+			BlockTypes: map[string]*configschema.NestedBlock{
+				"config": {
+					Block:    *listSchema.Body,
+					Nesting:  configschema.NestingSingle,
+					MinItems: itemCount,
+					MaxItems: itemCount,
+				},
+			},
+		},
+	}
+}
+
 func ProtoToIdentitySchema(attributes []*proto.ResourceIdentitySchema_IdentityAttribute) *configschema.Object {
 	obj := &configschema.Object{
 		Attributes: make(map[string]*configschema.Attribute),
diff --git a/internal/plugin6/grpc_provider.go b/internal/plugin6/grpc_provider.go
index b991ed6b8d..0ab7da98b1 100644
--- a/internal/plugin6/grpc_provider.go
+++ b/internal/plugin6/grpc_provider.go
@@ -20,7 +20,6 @@ import (
 	"google.golang.org/grpc/status"
 
 	"github.com/hashicorp/terraform/internal/addrs"
-	"github.com/hashicorp/terraform/internal/configs/configschema"
 	"github.com/hashicorp/terraform/internal/logging"
 	"github.com/hashicorp/terraform/internal/plugin6/convert"
 	"github.com/hashicorp/terraform/internal/providers"
@@ -172,24 +171,7 @@ func (p *GRPCProvider) GetProviderSchema() providers.GetProviderSchemaResponse {
 	}
 
 	for name, list := range protoResp.ListResourceSchemas {
-		ret := convert.ProtoToProviderSchema(list, nil)
-		resp.ListResourceTypes[name] = providers.Schema{
-			Version: ret.Version,
-			Body: &configschema.Block{
-				Attributes: map[string]*configschema.Attribute{
-					"data": {
-						Type:     cty.DynamicPseudoType,
-						Computed: true,
-					},
-				},
-				BlockTypes: map[string]*configschema.NestedBlock{
-					"config": {
-						Block:   *ret.Body,
-						Nesting: configschema.NestingSingle,
-					},
-				},
-			},
-		}
+		resp.ListResourceTypes[name] = convert.ProtoToListSchema(list)
 	}
 
 	for name, store := range protoResp.StateStoreSchemas {
@@ -377,11 +359,14 @@ func (p *GRPCProvider) ValidateListResourceConfig(r providers.ValidateListResour
 		resp.Diagnostics = resp.Diagnostics.Append(fmt.Errorf("unknown list resource type %q", r.TypeName))
 		return resp
 	}
+
 	configSchema := listResourceSchema.Body.BlockTypes["config"]
-	config := cty.NullVal(configSchema.ImpliedType())
-	if r.Config.Type().HasAttribute("config") {
-		config = r.Config.GetAttr("config")
+	if !r.Config.Type().HasAttribute("config") {
+		resp.Diagnostics = resp.Diagnostics.Append(fmt.Errorf("missing required attribute \"config\"; this is a bug in Terraform - please report it"))
+		return resp
 	}
+
+	config := r.Config.GetAttr("config")
 	mp, err := msgpack.Marshal(config, configSchema.ImpliedType())
 	if err != nil {
 		resp.Diagnostics = resp.Diagnostics.Append(err)
@@ -1337,10 +1322,12 @@ func (p *GRPCProvider) ListResource(r providers.ListResourceRequest) providers.L
 	}
 
 	configSchema := listResourceSchema.Body.BlockTypes["config"]
-	config := cty.NullVal(configSchema.ImpliedType())
-	if r.Config.Type().HasAttribute("config") {
-		config = r.Config.GetAttr("config")
+	if !r.Config.Type().HasAttribute("config") {
+		resp.Diagnostics = resp.Diagnostics.Append(fmt.Errorf("missing required attribute \"config\"; this is a bug in Terraform - please report it"))
+		return resp
 	}
+
+	config := r.Config.GetAttr("config")
 	mp, err := msgpack.Marshal(config, configSchema.ImpliedType())
 	if err != nil {
 		resp.Diagnostics = resp.Diagnostics.Append(err)
diff --git a/internal/providers/provider.go b/internal/providers/provider.go
index b19c1451a5..579626c369 100644
--- a/internal/providers/provider.go
+++ b/internal/providers/provider.go
@@ -220,6 +220,19 @@ func (a ActionSchema) IsNil() bool {
 	return a.ConfigSchema == nil
 }
 
+type ListResourceSchema struct {
+	// schema for the nested "config" block.
+	ConfigSchema *configschema.Block
+
+	// schema for the entire block (including "config" block)
+	FullSchema *configschema.Block
+}
+
+// IsNil() returns true if there is no list resource schema at all.
+func (l ListResourceSchema) IsNil() bool {
+	return l.FullSchema == nil
+}
+
 // Schema pairs a provider or resource schema with that schema's version.
 // This is used to be able to upgrade the schema in UpgradeResourceState.
 //
diff --git a/internal/providers/schemas.go b/internal/providers/schemas.go
index 4d02c8bdc8..9cb64b5ecf 100644
--- a/internal/providers/schemas.go
+++ b/internal/providers/schemas.go
@@ -47,3 +47,20 @@ func (ss ProviderSchema) SchemaForActionType(typeName string) (schema ActionSche
 	}
 	return ActionSchema{}
 }
+
+// SchemaForListResourceType attempts to find a schema for the given type. Returns an
+// empty schema if none is available.
+func (ss ProviderSchema) SchemaForListResourceType(typeName string) ListResourceSchema {
+	schema, ok := ss.ListResourceTypes[typeName]
+	ret := ListResourceSchema{FullSchema: schema.Body}
+	if !ok || schema.Body == nil {
+		return ret
+	}
+	// The configuration for the list block is nested within a "config" block.
+	configSchema, ok := schema.Body.BlockTypes["config"]
+	if !ok {
+		return ret
+	}
+	ret.ConfigSchema = &configSchema.Block
+	return ret
+}
diff --git a/internal/terraform/evaluate_valid.go b/internal/terraform/evaluate_valid.go
index 16315abd5d..9ce292d251 100644
--- a/internal/terraform/evaluate_valid.go
+++ b/internal/terraform/evaluate_valid.go
@@ -303,7 +303,7 @@ func staticValidateResourceReference(modCfg *configs.Config, addr addrs.Resource
 				diags = diags.Append(&hcl.Diagnostic{
 					Severity: hcl.DiagError,
 					Summary:  `Invalid list resource traversal`,
-					Detail:   fmt.Sprintf(`The first step in the traversal for a %s resource must be an attribute "data", but got %q instead.`, modeAdjective, remain[0]),
+					Detail:   fmt.Sprintf(`The first step in the traversal for a %s resource must be an attribute "data".`, modeAdjective),
 					Subject:  rng.ToHCL().Ptr(),
 				})
 				return diags
@@ -315,7 +315,7 @@ func staticValidateResourceReference(modCfg *configs.Config, addr addrs.Resource
 				diags = diags.Append(&hcl.Diagnostic{
 					Severity: hcl.DiagError,
 					Summary:  `Invalid list resource traversal`,
-					Detail:   fmt.Sprintf(`The second step in the traversal for a %s resource must be an index, but got %q instead.`, modeAdjective, remain[0]),
+					Detail:   fmt.Sprintf(`The second step in the traversal for a %s resource must be an index.`, modeAdjective),
 					Subject:  rng.ToHCL().Ptr(),
 				})
 				return diags
@@ -331,7 +331,7 @@ func staticValidateResourceReference(modCfg *configs.Config, addr addrs.Resource
 				diags = diags.Append(&hcl.Diagnostic{
 					Severity: hcl.DiagError,
 					Summary:  `Invalid list resource traversal`,
-					Detail:   fmt.Sprintf(`The third step in the traversal for a %s resource must be an attribute "state" or "identity", but got %q instead.`, modeAdjective, remain[0]),
+					Detail:   fmt.Sprintf(`The third step in the traversal for a %s resource must be an attribute "state" or "identity".`, modeAdjective),
 					Subject:  rng.ToHCL().Ptr(),
 				})
 				return diags
@@ -340,7 +340,7 @@ func staticValidateResourceReference(modCfg *configs.Config, addr addrs.Resource
 				diags = diags.Append(&hcl.Diagnostic{
 					Severity: hcl.DiagError,
 					Summary:  `Invalid list resource traversal`,
-					Detail:   fmt.Sprintf(`The third step in the traversal for a %s resource must be an attribute "state" or "identity", but got %q instead.`, modeAdjective, stateOrIdent.Name),
+					Detail:   fmt.Sprintf(`The third step in the traversal for a %s resource must be an attribute "state" or "identity".`, modeAdjective),
 					Subject:  rng.ToHCL().Ptr(),
 				})
 				return diags
diff --git a/internal/terraform/node_resource_plan_instance_query.go b/internal/terraform/node_resource_plan_instance_query.go
index 2a517f3af8..c1ddf131fc 100644
--- a/internal/terraform/node_resource_plan_instance_query.go
+++ b/internal/terraform/node_resource_plan_instance_query.go
@@ -36,9 +36,15 @@ func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (di
 		keyData = EvalDataForInstanceKey(addr.Resource.Key, forEach)
 	}
 
+	schema := providerSchema.SchemaForListResourceType(n.Config.Type)
+	if schema.IsNil() { // Not possible, as the schema should have already been validated to exist
+		diags = diags.Append(fmt.Errorf("no schema available for %s; this is a bug in Terraform and should be reported", addr))
+		return diags
+	}
+
 	// evaluate the list config block
 	var configDiags tfdiags.Diagnostics
-	blockVal, _, configDiags := ctx.EvaluateBlock(config.Config, n.Schema.Body, nil, keyData)
+	blockVal, _, configDiags := ctx.EvaluateBlock(config.Config, schema.FullSchema, nil, keyData)
 	diags = diags.Append(configDiags)
 	if diags.HasErrors() {
 		return diags
@@ -79,6 +85,13 @@ func (n *NodePlannableResourceInstance) listResourceExecute(ctx EvalContext) (di
 	}
 
 	log.Printf("[TRACE] NodePlannableResourceInstance: Re-validating config for %s", n.Addr)
+	// if the config value is null, we still want to send a full object with all attributes being null
+	if !unmarkedBlockVal.IsNull() && unmarkedBlockVal.GetAttr("config").IsNull() {
+		mp := unmarkedBlockVal.AsValueMap()
+		mp["config"] = schema.ConfigSchema.EmptyValue()
+		unmarkedBlockVal = cty.ObjectVal(mp)
+	}
+
 	validateResp := provider.ValidateListResourceConfig(
 		providers.ValidateListResourceConfigRequest{
 			TypeName:              n.Config.Type,
diff --git a/internal/terraform/node_resource_validate.go b/internal/terraform/node_resource_validate.go
index 8d106bc168..7dd60e24c1 100644
--- a/internal/terraform/node_resource_validate.go
+++ b/internal/terraform/node_resource_validate.go
@@ -471,8 +471,8 @@ func (n *NodeValidatableResource) validateResource(ctx EvalContext) tfdiags.Diag
 		resp := provider.ValidateEphemeralResourceConfig(req)
 		diags = diags.Append(resp.Diagnostics.InConfigBody(n.Config.Config, n.Addr.String()))
 	case addrs.ListResourceMode:
-		schema := providerSchema.SchemaForResourceType(n.Config.Mode, n.Config.Type)
-		if schema.Body == nil {
+		schema := providerSchema.SchemaForListResourceType(n.Config.Type)
+		if schema.IsNil() {
 			diags = diags.Append(&hcl.Diagnostic{
 				Severity: hcl.DiagError,
 				Summary:  "Invalid list resource",
@@ -482,7 +482,7 @@ func (n *NodeValidatableResource) validateResource(ctx EvalContext) tfdiags.Diag
 			return diags
 		}
 
-		blockVal, _, valDiags := ctx.EvaluateBlock(n.Config.Config, schema.Body, nil, keyData)
+		blockVal, _, valDiags := ctx.EvaluateBlock(n.Config.Config, schema.FullSchema, nil, keyData)
 		diags = diags.Append(valDiags)
 		if valDiags.HasErrors() {
 			return diags
@@ -502,6 +502,13 @@ func (n *NodeValidatableResource) validateResource(ctx EvalContext) tfdiags.Diag
 
 		// Use unmarked value for validate request
 		unmarkedBlockVal, _ := blockVal.UnmarkDeep()
+
+		// if the config value is null, we still want to send a full object with all attributes being null
+		if !unmarkedBlockVal.IsNull() && unmarkedBlockVal.GetAttr("config").IsNull() {
+			mp := unmarkedBlockVal.AsValueMap()
+			mp["config"] = schema.ConfigSchema.EmptyValue()
+			unmarkedBlockVal = cty.ObjectVal(mp)
+		}
 		req := providers.ValidateListResourceConfigRequest{
 			TypeName:              n.Config.Type,
 			Config:                unmarkedBlockVal,
