diff --git a/metrics/graphite/graphite.go b/metrics/graphite/graphite.go
deleted file mode 100644
index b8ca4bd..0000000
--- a/metrics/graphite/graphite.go
+++ /dev/null
@@ -1,304 +0,0 @@
-// Package graphite implements a Graphite backend for package metrics. Metrics
-// will be emitted to a Graphite server in the plaintext protocol which looks
-// like:
-//
-//   "<metric path> <metric value> <metric timestamp>"
-//
-// See http://graphite.readthedocs.io/en/latest/feeding-carbon.html#the-plaintext-protocol.
-// The current implementation ignores fields.
-package graphite
-
-import (
-	"bufio"
-	"fmt"
-	"io"
-	"math"
-	"net"
-	"sort"
-	"sync"
-	"sync/atomic"
-	"time"
-
-	"github.com/codahale/hdrhistogram"
-	"github.com/go-kit/kit/log"
-	"github.com/go-kit/kit/metrics"
-)
-
-// Emitter will keep track of all metrics and, once started, will emit the
-// metrics via the Flush method to the given address.
-type Emitter struct {
-	mtx        sync.Mutex
-	prefix     string
-	mgr        *manager
-	counters   []*counter
-	histograms []*windowedHistogram
-	gauges     []*gauge
-	logger     log.Logger
-	quitc      chan chan struct{}
-}
-
-// NewEmitter will return an Emitter that will prefix all metrics names with the
-// given prefix. Once started, it will attempt to create a connection with the
-// given network and address via `net.Dial` and periodically post metrics to the
-// connection in the Graphite plaintext protocol.
-func NewEmitter(network, address string, metricsPrefix string, flushInterval time.Duration, logger log.Logger) *Emitter {
-	return NewEmitterDial(net.Dial, network, address, metricsPrefix, flushInterval, logger)
-}
-
-// NewEmitterDial is the same as NewEmitter, but allows you to specify your own
-// Dialer function. This is primarily useful for tests.
-func NewEmitterDial(dialer Dialer, network, address string, metricsPrefix string, flushInterval time.Duration, logger log.Logger) *Emitter {
-	e := &Emitter{
-		prefix: metricsPrefix,
-		mgr:    newManager(dialer, network, address, time.After, logger),
-		logger: logger,
-		quitc:  make(chan chan struct{}),
-	}
-	go e.loop(flushInterval)
-	return e
-}
-
-// NewCounter returns a Counter whose value will be periodically emitted in
-// a Graphite-compatible format once the Emitter is started. Fields are ignored.
-func (e *Emitter) NewCounter(name string) metrics.Counter {
-	e.mtx.Lock()
-	defer e.mtx.Unlock()
-	c := &counter{name, 0}
-	e.counters = append(e.counters, c)
-	return c
-}
-
-// NewHistogram is taken from http://github.com/codahale/metrics. It returns a
-// windowed HDR histogram which drops data older than five minutes.
-//
-// The histogram exposes metrics for each passed quantile as gauges. Quantiles
-// should be integers in the range 1..99. The gauge names are assigned by using
-// the passed name as a prefix and appending "_pNN" e.g. "_p50".
-//
-// The values of this histogram will be periodically emitted in a
-// Graphite-compatible format once the Emitter is started. Fields are ignored.
-func (e *Emitter) NewHistogram(name string, minValue, maxValue int64, sigfigs int, quantiles ...int) (metrics.Histogram, error) {
-	gauges := map[int]metrics.Gauge{}
-	for _, quantile := range quantiles {
-		if quantile <= 0 || quantile >= 100 {
-			return nil, fmt.Errorf("invalid quantile %d", quantile)
-		}
-		gauges[quantile] = e.gauge(fmt.Sprintf("%s_p%02d", name, quantile))
-	}
-	h := newWindowedHistogram(name, minValue, maxValue, sigfigs, gauges, e.logger)
-
-	e.mtx.Lock()
-	defer e.mtx.Unlock()
-	e.histograms = append(e.histograms, h)
-	return h, nil
-}
-
-// NewTimeHistogram returns a TimeHistogram wrapper around the windowed HDR
-// histrogram provided by this package.
-func (e *Emitter) NewTimeHistogram(name string, unit time.Duration, minValue, maxValue int64, sigfigs int, quantiles ...int) (metrics.TimeHistogram, error) {
-	h, err := e.NewHistogram(name, minValue, maxValue, sigfigs, quantiles...)
-	if err != nil {
-		return nil, err
-	}
-	return metrics.NewTimeHistogram(unit, h), nil
-}
-
-// NewGauge returns a Gauge whose value will be periodically emitted in a
-// Graphite-compatible format once the Emitter is started. Fields are ignored.
-func (e *Emitter) NewGauge(name string) metrics.Gauge {
-	e.mtx.Lock()
-	defer e.mtx.Unlock()
-	return e.gauge(name)
-}
-
-func (e *Emitter) gauge(name string) metrics.Gauge {
-	g := &gauge{name, 0}
-	e.gauges = append(e.gauges, g)
-	return g
-}
-
-func (e *Emitter) loop(d time.Duration) {
-	ticker := time.NewTicker(d)
-	defer ticker.Stop()
-
-	for {
-		select {
-		case <-ticker.C:
-			e.Flush()
-
-		case q := <-e.quitc:
-			e.Flush()
-			close(q)
-			return
-		}
-	}
-}
-
-// Stop will flush the current metrics and close the active connection. Calling
-// stop more than once is a programmer error.
-func (e *Emitter) Stop() {
-	q := make(chan struct{})
-	e.quitc <- q
-	<-q
-}
-
-// Flush will write the current metrics to the Emitter's connection in the
-// Graphite plaintext protocol.
-func (e *Emitter) Flush() {
-	e.mtx.Lock() // one flush at a time
-	defer e.mtx.Unlock()
-
-	conn := e.mgr.take()
-	if conn == nil {
-		e.logger.Log("during", "flush", "err", "connection unavailable")
-		return
-	}
-
-	err := e.flush(conn)
-	if err != nil {
-		e.logger.Log("during", "flush", "err", err)
-	}
-	e.mgr.put(err)
-}
-
-func (e *Emitter) flush(conn io.Writer) error {
-	w := bufio.NewWriter(conn)
-
-	for _, c := range e.counters {
-		fmt.Fprintf(w, "%s.%s.count %d %d\n", e.prefix, c.Name(), c.count, time.Now().Unix())
-	}
-
-	for _, h := range e.histograms {
-		hist := h.hist.Merge()
-		now := time.Now().Unix()
-		fmt.Fprintf(w, "%s.%s.count %d %d\n", e.prefix, h.Name(), hist.TotalCount(), now)
-		fmt.Fprintf(w, "%s.%s.min %d %d\n", e.prefix, h.Name(), hist.Min(), now)
-		fmt.Fprintf(w, "%s.%s.max %d %d\n", e.prefix, h.Name(), hist.Max(), now)
-		fmt.Fprintf(w, "%s.%s.mean %.2f %d\n", e.prefix, h.Name(), hist.Mean(), now)
-		fmt.Fprintf(w, "%s.%s.std-dev %.2f %d\n", e.prefix, h.Name(), hist.StdDev(), now)
-	}
-
-	for _, g := range e.gauges {
-		fmt.Fprintf(w, "%s.%s %.2f %d\n", e.prefix, g.Name(), g.Get(), time.Now().Unix())
-	}
-
-	return w.Flush()
-}
-
-type counter struct {
-	key   string
-	count uint64
-}
-
-func (c *counter) Name() string { return c.key }
-
-func (c *counter) With(metrics.Field) metrics.Counter { return c }
-
-func (c *counter) Add(delta uint64) { atomic.AddUint64(&c.count, delta) }
-
-type gauge struct {
-	key   string
-	value uint64 // math.Float64bits
-}
-
-func (g *gauge) Name() string { return g.key }
-
-func (g *gauge) With(metrics.Field) metrics.Gauge { return g }
-
-func (g *gauge) Add(delta float64) {
-	for {
-		old := atomic.LoadUint64(&g.value)
-		new := math.Float64bits(math.Float64frombits(old) + delta)
-		if atomic.CompareAndSwapUint64(&g.value, old, new) {
-			return
-		}
-	}
-}
-
-func (g *gauge) Set(value float64) {
-	atomic.StoreUint64(&g.value, math.Float64bits(value))
-}
-
-func (g *gauge) Get() float64 {
-	return math.Float64frombits(atomic.LoadUint64(&g.value))
-}
-
-type windowedHistogram struct {
-	mtx  sync.Mutex
-	hist *hdrhistogram.WindowedHistogram
-
-	name   string
-	gauges map[int]metrics.Gauge
-	logger log.Logger
-}
-
-// newWindowedHistogram is taken from http://github.com/codahale/metrics. It
-// returns a windowed HDR histogram which drops data older than five minutes.
-//
-// The histogram exposes metrics for each passed quantile as gauges. Users are
-// expected to provide their own set of Gauges for quantiles to make this
-// Histogram work across multiple metrics providers.
-func newWindowedHistogram(name string, minValue, maxValue int64, sigfigs int, quantiles map[int]metrics.Gauge, logger log.Logger) *windowedHistogram {
-	h := &windowedHistogram{
-		hist:   hdrhistogram.NewWindowed(5, minValue, maxValue, sigfigs),
-		name:   name,
-		gauges: quantiles,
-		logger: logger,
-	}
-	go h.rotateLoop(1 * time.Minute)
-	return h
-}
-
-func (h *windowedHistogram) Name() string { return h.name }
-
-func (h *windowedHistogram) With(metrics.Field) metrics.Histogram { return h }
-
-func (h *windowedHistogram) Observe(value int64) {
-	h.mtx.Lock()
-	err := h.hist.Current.RecordValue(value)
-	h.mtx.Unlock()
-
-	if err != nil {
-		h.logger.Log("err", err, "msg", "unable to record histogram value")
-		return
-	}
-
-	for q, gauge := range h.gauges {
-		gauge.Set(float64(h.hist.Current.ValueAtQuantile(float64(q))))
-	}
-}
-
-func (h *windowedHistogram) Distribution() ([]metrics.Bucket, []metrics.Quantile) {
-	bars := h.hist.Merge().Distribution()
-	buckets := make([]metrics.Bucket, len(bars))
-	for i, bar := range bars {
-		buckets[i] = metrics.Bucket{
-			From:  bar.From,
-			To:    bar.To,
-			Count: bar.Count,
-		}
-	}
-	quantiles := make([]metrics.Quantile, 0, len(h.gauges))
-	for quantile, gauge := range h.gauges {
-		quantiles = append(quantiles, metrics.Quantile{
-			Quantile: quantile,
-			Value:    int64(gauge.Get()),
-		})
-	}
-	sort.Sort(quantileSlice(quantiles))
-	return buckets, quantiles
-}
-
-func (h *windowedHistogram) rotateLoop(d time.Duration) {
-	for range time.Tick(d) {
-		h.mtx.Lock()
-		h.hist.Rotate()
-		h.mtx.Unlock()
-	}
-}
-
-type quantileSlice []metrics.Quantile
-
-func (a quantileSlice) Len() int           { return len(a) }
-func (a quantileSlice) Less(i, j int) bool { return a[i].Quantile < a[j].Quantile }
-func (a quantileSlice) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
diff --git a/metrics/graphite/graphite_test.go b/metrics/graphite/graphite_test.go
deleted file mode 100644
index 925aed2..0000000
--- a/metrics/graphite/graphite_test.go
+++ /dev/null
@@ -1,80 +0,0 @@
-package graphite
-
-import (
-	"bytes"
-	"fmt"
-	"strings"
-	"testing"
-	"time"
-
-	"github.com/go-kit/kit/log"
-	"github.com/go-kit/kit/metrics"
-	"github.com/go-kit/kit/metrics/teststat"
-)
-
-func TestHistogramQuantiles(t *testing.T) {
-	prefix := "prefix"
-	e := NewEmitter("", "", prefix, time.Second, log.NewNopLogger())
-	var (
-		name      = "test_histogram_quantiles"
-		quantiles = []int{50, 90, 95, 99}
-	)
-	h, err := e.NewHistogram(name, 0, 100, 3, quantiles...)
-	if err != nil {
-		t.Fatalf("unable to create test histogram: %v", err)
-	}
-	h = h.With(metrics.Field{Key: "ignored", Value: "field"})
-	const seed, mean, stdev int64 = 424242, 50, 10
-	teststat.PopulateNormalHistogram(t, h, seed, mean, stdev)
-
-	// flush the current metrics into a buffer to examine
-	var b bytes.Buffer
-	e.flush(&b)
-	teststat.AssertGraphiteNormalHistogram(t, prefix, name, mean, stdev, quantiles, b.String())
-}
-
-func TestCounter(t *testing.T) {
-	var (
-		prefix = "prefix"
-		name   = "m"
-		value  = 123
-		e      = NewEmitter("", "", prefix, time.Second, log.NewNopLogger())
-		b      bytes.Buffer
-	)
-	e.NewCounter(name).With(metrics.Field{Key: "ignored", Value: "field"}).Add(uint64(value))
-	e.flush(&b)
-	want := fmt.Sprintf("%s.%s.count %d", prefix, name, value)
-	payload := b.String()
-	if !strings.HasPrefix(payload, want) {
-		t.Errorf("counter %s want\n%s, have\n%s", name, want, payload)
-	}
-}
-
-func TestGauge(t *testing.T) {
-	var (
-		prefix = "prefix"
-		name   = "xyz"
-		value  = 54321
-		delta  = 12345
-		e      = NewEmitter("", "", prefix, time.Second, log.NewNopLogger())
-		b      bytes.Buffer
-		g      = e.NewGauge(name).With(metrics.Field{Key: "ignored", Value: "field"})
-	)
-
-	g.Set(float64(value))
-	g.Add(float64(delta))
-
-	e.flush(&b)
-	payload := b.String()
-
-	want := fmt.Sprintf("%s.%s %d", prefix, name, value+delta)
-	if !strings.HasPrefix(payload, want) {
-		t.Errorf("gauge %s want\n%s, have\n%s", name, want, payload)
-	}
-}
-
-func TestEmitterStops(t *testing.T) {
-	e := NewEmitter("foo", "bar", "baz", time.Second, log.NewNopLogger())
-	time.Sleep(100 * time.Millisecond)
-	e.Stop()
-}
diff --git a/metrics/graphite/manager.go b/metrics/graphite/manager.go
deleted file mode 100644
index ecc6b74..0000000
--- a/metrics/graphite/manager.go
+++ /dev/null
@@ -1,105 +0,0 @@
-package graphite
-
-import (
-	"net"
-	"time"
-
-	"github.com/go-kit/kit/log"
-)
-
-// Dialer dials a network and address. net.Dial is a good default Dialer.
-type Dialer func(network, address string) (net.Conn, error)
-
-// time.After is a good default afterFunc.
-type afterFunc func(time.Duration) <-chan time.Time
-
-// manager manages a net.Conn. Clients should take the conn when they want to
-// use it, and put back whatever error they receive from an e.g. Write. When a
-// non-nil error is put, the conn is invalidated and a new conn is established.
-// Connection failures are retried after an exponential backoff.
-type manager struct {
-	dial    Dialer
-	network string
-	address string
-	after   afterFunc
-	logger  log.Logger
-
-	takec chan net.Conn
-	putc  chan error
-}
-
-func newManager(d Dialer, network, address string, after afterFunc, logger log.Logger) *manager {
-	m := &manager{
-		dial:    d,
-		network: network,
-		address: address,
-		after:   after,
-		logger:  logger,
-
-		takec: make(chan net.Conn),
-		putc:  make(chan error),
-	}
-	go m.loop()
-	return m
-}
-
-func (m *manager) take() net.Conn {
-	return <-m.takec
-}
-
-func (m *manager) put(err error) {
-	m.putc <- err
-}
-
-func (m *manager) loop() {
-	var (
-		conn       = dial(m.dial, m.network, m.address, m.logger) // may block slightly
-		connc      = make(chan net.Conn)
-		reconnectc <-chan time.Time // initially nil
-		backoff    = time.Second
-	)
-
-	for {
-		select {
-		case <-reconnectc:
-			reconnectc = nil
-			go func() { connc <- dial(m.dial, m.network, m.address, m.logger) }()
-
-		case conn = <-connc:
-			if conn == nil {
-				backoff = exponential(backoff)
-				reconnectc = m.after(backoff)
-			} else {
-				backoff = time.Second
-				reconnectc = nil
-			}
-
-		case m.takec <- conn:
-			// might be nil
-
-		case err := <-m.putc:
-			if err != nil && conn != nil {
-				m.logger.Log("err", err)
-				conn = nil                            // connection is bad
-				reconnectc = m.after(time.Nanosecond) // trigger immediately
-			}
-		}
-	}
-}
-
-func dial(d Dialer, network, address string, logger log.Logger) net.Conn {
-	conn, err := d(network, address)
-	if err != nil {
-		logger.Log("err", err)
-		conn = nil
-	}
-	return conn
-}
-
-func exponential(d time.Duration) time.Duration {
-	d *= 2
-	if d > time.Minute {
-		d = time.Minute
-	}
-	return d
-}
diff --git a/metrics/graphite/manager_test.go b/metrics/graphite/manager_test.go
deleted file mode 100644
index ff9f413..0000000
--- a/metrics/graphite/manager_test.go
+++ /dev/null
@@ -1,126 +0,0 @@
-package graphite
-
-import (
-	"errors"
-	"net"
-	"sync/atomic"
-	"testing"
-	"time"
-
-	"github.com/go-kit/kit/log"
-)
-
-func TestManager(t *testing.T) {
-	var (
-		tickc    = make(chan time.Time)
-		after    = func(time.Duration) <-chan time.Time { return tickc }
-		dialconn = &mockConn{}
-		dialerr  = error(nil)
-		dialer   = func(string, string) (net.Conn, error) { return dialconn, dialerr }
-		mgr      = newManager(dialer, "netw", "addr", after, log.NewNopLogger())
-	)
-
-	// First conn should be fine.
-	conn := mgr.take()
-	if conn == nil {
-		t.Fatal("nil conn")
-	}
-
-	// Write and check it went thru.
-	if _, err := conn.Write([]byte{1, 2, 3}); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := uint64(3), atomic.LoadUint64(&dialconn.wr); want != have {
-		t.Errorf("want %d, have %d", want, have)
-	}
-
-	// Put an error to kill the conn.
-	mgr.put(errors.New("should kill the connection"))
-
-	// First takes should fail.
-	for i := 0; i < 10; i++ {
-		if conn = mgr.take(); conn != nil {
-			t.Fatalf("want nil conn, got real conn")
-		}
-	}
-
-	// Trigger the reconnect.
-	tickc <- time.Now()
-
-	// The dial should eventually succeed and yield a good conn.
-	if !within(100*time.Millisecond, func() bool {
-		conn = mgr.take()
-		return conn != nil
-	}) {
-		t.Fatal("conn remained nil")
-	}
-
-	// Write and check it went thru.
-	if _, err := conn.Write([]byte{4, 5}); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := uint64(5), atomic.LoadUint64(&dialconn.wr); want != have {
-		t.Errorf("want %d, have %d", want, have)
-	}
-
-	// Dial starts failing.
-	dialconn, dialerr = nil, errors.New("oh noes")
-	mgr.put(errors.New("trigger that reconnect y'all"))
-	if conn = mgr.take(); conn != nil {
-		t.Fatalf("want nil conn, got real conn")
-	}
-
-	// As many reconnects as they want.
-	go func() {
-		done := time.After(100 * time.Millisecond)
-		for {
-			select {
-			case tickc <- time.Now():
-			case <-done:
-				return
-			}
-		}
-	}()
-
-	// The dial should never succeed.
-	if within(100*time.Millisecond, func() bool {
-		conn = mgr.take()
-		return conn != nil
-	}) {
-		t.Fatal("eventually got a good conn, despite failing dialer")
-	}
-}
-
-type mockConn struct {
-	rd, wr uint64
-}
-
-func (c *mockConn) Read(b []byte) (n int, err error) {
-	atomic.AddUint64(&c.rd, uint64(len(b)))
-	return len(b), nil
-}
-
-func (c *mockConn) Write(b []byte) (n int, err error) {
-	atomic.AddUint64(&c.wr, uint64(len(b)))
-	return len(b), nil
-}
-
-func (c *mockConn) Close() error                       { return nil }
-func (c *mockConn) LocalAddr() net.Addr                { return nil }
-func (c *mockConn) RemoteAddr() net.Addr               { return nil }
-func (c *mockConn) SetDeadline(t time.Time) error      { return nil }
-func (c *mockConn) SetReadDeadline(t time.Time) error  { return nil }
-func (c *mockConn) SetWriteDeadline(t time.Time) error { return nil }
-
-func within(d time.Duration, f func() bool) bool {
-	deadline := time.Now().Add(d)
-	for {
-		if time.Now().After(deadline) {
-			return false
-		}
-		if f() {
-			return true
-		}
-		time.Sleep(d / 10)
-	}
-}
diff --git a/metrics/teststat/graphite.go b/metrics/teststat/graphite.go
deleted file mode 100644
index 4cb5994..0000000
--- a/metrics/teststat/graphite.go
+++ /dev/null
@@ -1,63 +0,0 @@
-package teststat
-
-import (
-	"fmt"
-	"math"
-	"regexp"
-	"strconv"
-	"testing"
-)
-
-// AssertGraphiteNormalHistogram ensures the expvar Histogram referenced by
-// metricName abides a normal distribution.
-func AssertGraphiteNormalHistogram(t *testing.T, prefix, metricName string, mean, stdev int64, quantiles []int, gPayload string) {
-	// check for hdr histo data
-	wants := map[string]int64{"count": 1234, "min": 15, "max": 83}
-	for key, want := range wants {
-		re := regexp.MustCompile(fmt.Sprintf("%s.%s.%s (\\d*)", prefix, metricName, key))
-		res := re.FindAllStringSubmatch(gPayload, 1)
-		if res == nil {
-			t.Error("did not find metrics log for", key, "in \n", gPayload)
-			continue
-		}
-
-		if len(res[0]) == 1 {
-			t.Fatalf("%q: bad regex, please check the test scenario", key)
-		}
-
-		have, err := strconv.ParseInt(res[0][1], 10, 64)
-		if err != nil {
-			t.Fatal(err)
-		}
-
-		if want != have {
-			t.Errorf("key %s: want %d, have %d", key, want, have)
-		}
-	}
-
-	const tolerance int = 2
-	wants = map[string]int64{".std-dev": stdev, ".mean": mean}
-	for _, quantile := range quantiles {
-		wants[fmt.Sprintf("_p%02d", quantile)] = normalValueAtQuantile(mean, stdev, quantile)
-	}
-	// check for quantile gauges
-	for key, want := range wants {
-		re := regexp.MustCompile(fmt.Sprintf("%s.%s%s (\\d*\\.\\d*)", prefix, metricName, key))
-		res := re.FindAllStringSubmatch(gPayload, 1)
-		if res == nil {
-			t.Errorf("did not find metrics log for %s", key)
-			continue
-		}
-
-		if len(res[0]) == 1 {
-			t.Fatalf("%q: bad regex found, please check the test scenario", key)
-		}
-		have, err := strconv.ParseFloat(res[0][1], 64)
-		if err != nil {
-			t.Fatal(err)
-		}
-		if int(math.Abs(float64(want)-have)) > tolerance {
-			t.Errorf("key %s: want %.2f, have %.2f", key, want, have)
-		}
-	}
-}
