diff --git a/internal/testutils/xds/e2e/clientresources.go b/internal/testutils/xds/e2e/clientresources.go
index e94d226f..0bfcad18 100644
--- a/internal/testutils/xds/e2e/clientresources.go
+++ b/internal/testutils/xds/e2e/clientresources.go
@@ -140,6 +140,72 @@ func marshalAny(m proto.Message) *anypb.Any {
 	return a
 }
 
+// filterChainWontMatch returns a filter chain that won't match if running the
+// test locally.
+func filterChainWontMatch(routeName string, addressPrefix string, srcPorts []uint32) *v3listenerpb.FilterChain {
+	hcm := &v3httppb.HttpConnectionManager{
+		RouteSpecifier: &v3httppb.HttpConnectionManager_Rds{
+			Rds: &v3httppb.Rds{
+				ConfigSource: &v3corepb.ConfigSource{
+					ConfigSourceSpecifier: &v3corepb.ConfigSource_Ads{Ads: &v3corepb.AggregatedConfigSource{}},
+				},
+				RouteConfigName: routeName,
+			},
+		},
+		HttpFilters: []*v3httppb.HttpFilter{RouterHTTPFilter},
+	}
+	return &v3listenerpb.FilterChain{
+		Name: routeName + "-wont-match",
+		FilterChainMatch: &v3listenerpb.FilterChainMatch{
+			PrefixRanges: []*v3corepb.CidrRange{
+				{
+					AddressPrefix: addressPrefix,
+					PrefixLen: &wrapperspb.UInt32Value{
+						Value: uint32(0),
+					},
+				},
+			},
+			SourceType:  v3listenerpb.FilterChainMatch_SAME_IP_OR_LOOPBACK,
+			SourcePorts: srcPorts,
+			SourcePrefixRanges: []*v3corepb.CidrRange{
+				{
+					AddressPrefix: addressPrefix,
+					PrefixLen: &wrapperspb.UInt32Value{
+						Value: uint32(0),
+					},
+				},
+			},
+		},
+		Filters: []*v3listenerpb.Filter{
+			{
+				Name:       "filter-1",
+				ConfigType: &v3listenerpb.Filter_TypedConfig{TypedConfig: marshalAny(hcm)},
+			},
+		},
+	}
+}
+
+// ListenerResourceThreeRouteResources returns a listener resource that points
+// to three route configurations. Only the filter chain that points to the first
+// route config can be matched to.
+func ListenerResourceThreeRouteResources(host string, port uint32, secLevel SecurityLevel, routeName string) *v3listenerpb.Listener {
+	lis := defaultServerListenerCommon(host, port, secLevel, routeName, false)
+	lis.FilterChains = append(lis.FilterChains, filterChainWontMatch("routeName2", "1.1.1.1", []uint32{1}))
+	lis.FilterChains = append(lis.FilterChains, filterChainWontMatch("routeName3", "2.2.2.2", []uint32{2}))
+	return lis
+}
+
+// ListenerResourceFallbackToDefault returns a listener resource that contains a
+// filter chain that will never get chosen to process traffic and a default
+// filter chain. The default filter chain points to routeName2.
+func ListenerResourceFallbackToDefault(host string, port uint32, secLevel SecurityLevel) *v3listenerpb.Listener {
+	lis := defaultServerListenerCommon(host, port, secLevel, "", false)
+	lis.FilterChains = nil
+	lis.FilterChains = append(lis.FilterChains, filterChainWontMatch("routeName", "1.1.1.1", []uint32{1}))
+	lis.DefaultFilterChain = filterChainWontMatch("routeName2", "2.2.2.2", []uint32{2})
+	return lis
+}
+
 // DefaultServerListener returns a basic xds Listener resource to be used on the
 // server side. The returned Listener resource contains an inline route
 // configuration with the name of routeName.
diff --git a/xds/server_security_ext_test.go b/test/xds/xds_server_certificate_providers_test.go
similarity index 77%
rename from xds/server_security_ext_test.go
rename to test/xds/xds_server_certificate_providers_test.go
index 28685b02..9fcf6f49 100644
--- a/xds/server_security_ext_test.go
+++ b/test/xds/xds_server_certificate_providers_test.go
@@ -1,6 +1,6 @@
 /*
  *
- * Copyright 2025 gRPC authors.
+ * Copyright 2023 gRPC authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,14 +28,15 @@ import (
 
 	"github.com/google/uuid"
 	"google.golang.org/grpc"
-	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/connectivity"
 	"google.golang.org/grpc/credentials/insecure"
 	xdscreds "google.golang.org/grpc/credentials/xds"
+	"google.golang.org/grpc/internal/stubserver"
 	"google.golang.org/grpc/internal/testutils"
 	"google.golang.org/grpc/internal/testutils/xds/e2e"
+	"google.golang.org/grpc/internal/testutils/xds/e2e/setup"
 	"google.golang.org/grpc/internal/xds/bootstrap"
 	"google.golang.org/grpc/xds"
-	"google.golang.org/grpc/xds/internal/xdsclient"
 	"google.golang.org/protobuf/types/known/wrapperspb"
 
 	v3corepb "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
@@ -55,59 +56,33 @@ import (
 // verifies that a gRPC client configured with insecure credentials is able to
 // make RPCs to the backend. This ensures that the insecure fallback
 // credentials are getting used on the server.
-func (s) TestServer_Security_NoCertProvidersInBootstrap_Success(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-
-	// Start an xDS management server.
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{})
-
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
-
-	// Create a listener on a local port to act as the xDS enabled gRPC server.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("Failed to listen to local port: %v", err)
-	}
+func (s) TestServerSideXDS_WithNoCertificateProvidersInBootstrap_Success(t *testing.T) {
+	// Spin up an xDS management server.
+	mgmtServer, nodeID, bootstrapContents, _ := setup.ManagementServerAndResolver(t)
+
+	// Spin up an xDS-enabled gRPC server that uses xDS credentials with
+	// insecure fallback, and the above bootstrap configuration.
+	lis, cleanup := setupGRPCServer(t, bootstrapContents)
+	defer cleanup()
+
+	// Create an inbound xDS listener resource for the server side that does not
+	// contain any security configuration. This should force the server-side
+	// xdsCredentials to use fallback.
 	host, port, err := hostPortFromListener(lis)
 	if err != nil {
 		t.Fatalf("Failed to retrieve host and port of server: %v", err)
 	}
-
-	// Configure the managegement server with a listener and route configuration
-	// resource for the above xDS enabled gRPC server.
-	const routeConfigName = "routeName"
 	resources := e2e.UpdateOptions{
 		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")},
-		Routes:         []*v3routepb.RouteConfiguration{e2e.RouteConfigNonForwardingAction(routeConfigName)},
+		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListener(host, port, e2e.SecurityLevelNone, "routeName")},
 		SkipValidation: true,
 	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration
-	// and configure xDS credentials to be used on the server-side.
-	creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{
-		FallbackCreds: insecure.NewCredentials(),
-	})
-	if err != nil {
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+	if err := mgmtServer.Update(ctx, resources); err != nil {
 		t.Fatal(err)
 	}
 
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
-		t.Logf("Serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
-	})
-	createStubServer(t, lis, grpc.Creds(creds), modeChangeOpt, xds.ClientPoolForTesting(pool))
-
 	// Create a client that uses insecure creds and verify RPCs.
 	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
 	if err != nil {
@@ -129,7 +104,7 @@ func (s) TestServer_Security_NoCertProvidersInBootstrap_Success(t *testing.T) {
 // instance name specified in the Listener resource will not be present in the
 // bootstrap file. The test verifies that server creation does not fail and that
 // the xDS-enabled gRPC server does not enter "serving" mode.
-func (s) TestServer_Security_NoCertificateProvidersInBootstrap_Failure(t *testing.T) {
+func (s) TestServerSideXDS_WithNoCertificateProvidersInBootstrap_Failure(t *testing.T) {
 	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
 	defer cancel()
 
@@ -155,7 +130,7 @@ func (s) TestServer_Security_NoCertificateProvidersInBootstrap_Failure(t *testin
 
 	// Create bootstrap configuration with no certificate providers.
 	nodeID := uuid.New().String()
-	bootstrapContents, err := bootstrap.NewContentsForTesting(bootstrap.ConfigOptionsForTesting{
+	bs, err := bootstrap.NewContentsForTesting(bootstrap.ConfigOptionsForTesting{
 		Servers: []byte(fmt.Sprintf(`[{
 			"server_uri": %q,
 			"channel_creds": [{"type": "insecure"}]
@@ -167,37 +142,46 @@ func (s) TestServer_Security_NoCertificateProvidersInBootstrap_Failure(t *testin
 		t.Fatalf("Failed to create bootstrap configuration: %v", err)
 	}
 
-	// Create a listener on a local port to act as the xDS enabled gRPC server.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("Failed to listen to local port: %v", err)
-	}
-	host, port, err := hostPortFromListener(lis)
+	// Configure xDS credentials with an insecure fallback to be used on the
+	// server-side.
+	creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})
 	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
+		t.Fatal(err)
 	}
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration
-	// and configure xDS credentials to be used on the server-side.
-	creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{
-		FallbackCreds: insecure.NewCredentials(),
+
+	// Initialize an xDS-enabled gRPC server and register the stubServer on it.
+	// Pass it a mode change server option that pushes on a channel the mode
+	// changes to "not serving".
+	servingModeCh := make(chan struct{})
+	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		if args.Mode == connectivity.ServingModeServing {
+			close(servingModeCh)
+		}
 	})
+
+	// Create a local listener and assign it to the stub server.
+	lis, err := testutils.LocalTCPListener()
 	if err != nil {
-		t.Fatal(err)
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
 	}
 
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
+	stub := &stubserver.StubServer{
+		Listener: lis,
 	}
-	pool := xdsclient.NewPool(config)
-	modeChangeHandler := newServingModeChangeHandler(t)
-	modeChangeOpt := xds.ServingModeCallback(modeChangeHandler.modeChangeCallback)
-	createStubServer(t, lis, grpc.Creds(creds), modeChangeOpt, xds.ClientPoolForTesting(pool))
+	if stub.S, err = xds.NewGRPCServer(grpc.Creds(creds), modeChangeOpt, xds.BootstrapContentsForTesting(bs)); err != nil {
+		t.Fatalf("Failed to create an xDS enabled gRPC server: %v", err)
+	}
+	defer stub.S.Stop()
+	stubserver.StartTestService(t, stub)
 
 	// Create an inbound xDS listener resource for the server side that contains
 	// mTLS security configuration. Since the received certificate provider
 	// instance name would be missing in the bootstrap configuration, this
 	// resource is expected to NACKed by the xDS client.
+	host, port, err := hostPortFromListener(lis)
+	if err != nil {
+		t.Fatalf("Failed to retrieve host and port of server: %v", err)
+	}
 	resources := e2e.UpdateOptions{
 		NodeID:         nodeID,
 		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListener(host, port, e2e.SecurityLevelMTLS, "routeName")},
@@ -216,12 +200,10 @@ func (s) TestServer_Security_NoCertificateProvidersInBootstrap_Failure(t *testin
 
 	// Wait a short duration and ensure that the server does not enter "serving"
 	// mode.
-	sCtx, sCancel := context.WithTimeout(ctx, defaultTestShortTimeout)
-	defer sCancel()
 	select {
-	case <-sCtx.Done():
-	case <-modeChangeHandler.modeCh:
-		t.Fatal("Server started serving RPCs before the route config was received")
+	case <-time.After(2 * defaultTestShortTimeout):
+	case <-servingModeCh:
+		t.Fatal("Server changed to serving mode when not expected to")
 	}
 
 	// Create a client that uses insecure creds and verify that RPCs don't
@@ -232,7 +214,7 @@ func (s) TestServer_Security_NoCertificateProvidersInBootstrap_Failure(t *testin
 	}
 	defer cc.Close()
 
-	waitForFailedRPCWithStatus(ctx, t, cc, codes.Unavailable, "", "")
+	waitForFailedRPCWithStatus(ctx, t, cc, errAcceptAndClose)
 }
 
 // Tests the case where the bootstrap configuration contains one certificate
@@ -246,7 +228,7 @@ func (s) TestServer_Security_NoCertificateProvidersInBootstrap_Failure(t *testin
 //
 // The test verifies that an RPC to the first listener succeeds, while the
 // second listener never moves to "serving" mode and RPCs to it fail.
-func (s) TestServer_Security_WithValidAndInvalidSecurityConfiguration(t *testing.T) {
+func (s) TestServerSideXDS_WithValidAndInvalidSecurityConfiguration(t *testing.T) {
 	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
 	defer cancel()
 
@@ -274,7 +256,7 @@ func (s) TestServer_Security_WithValidAndInvalidSecurityConfiguration(t *testing
 	nodeID := uuid.New().String()
 	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
 
-	// Create two xDS-enabled gRPC servers using the above bootstrap configs.
+	// Create two local listeners.
 	lis1, err := testutils.LocalTCPListener()
 	if err != nil {
 		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
@@ -284,21 +266,26 @@ func (s) TestServer_Security_WithValidAndInvalidSecurityConfiguration(t *testing
 		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
 	}
 
-	modeChangeHandler1 := newServingModeChangeHandler(t)
-	modeChangeOpt1 := xds.ServingModeCallback(modeChangeHandler1.modeChangeCallback)
-	modeChangeHandler2 := newServingModeChangeHandler(t)
-	modeChangeOpt2 := xds.ServingModeCallback(modeChangeHandler2.modeChangeCallback)
+	// Create an xDS-enabled gRPC server that is configured to use xDS
+	// credentials and assigned to a stub server, configuring a mode change
+	// option that closes a channel when listener2 enters serving mode.
 	creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})
 	if err != nil {
 		t.Fatal(err)
 	}
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	createStubServer(t, lis1, grpc.Creds(creds), modeChangeOpt1, xds.ClientPoolForTesting(pool))
-	createStubServer(t, lis2, grpc.Creds(creds), modeChangeOpt2, xds.ClientPoolForTesting(pool))
+	servingModeCh := make(chan struct{})
+	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		if addr.String() == lis2.Addr().String() {
+			if args.Mode == connectivity.ServingModeServing {
+				close(servingModeCh)
+			}
+		}
+	})
+
+	stub1 := createStubServer(t, lis1, creds, modeChangeOpt, bootstrapContents)
+	defer stub1.S.Stop()
+	stub2 := createStubServer(t, lis2, creds, modeChangeOpt, bootstrapContents)
+	defer stub2.S.Stop()
 
 	// Create inbound xDS listener resources for the server side that contains
 	// mTLS security configuration.
@@ -452,7 +439,7 @@ func (s) TestServer_Security_WithValidAndInvalidSecurityConfiguration(t *testing
 	// mode.
 	select {
 	case <-time.After(2 * defaultTestShortTimeout):
-	case <-modeChangeHandler2.modeCh:
+	case <-servingModeCh:
 		t.Fatal("Server changed to serving mode when not expected to")
 	}
 
@@ -464,5 +451,5 @@ func (s) TestServer_Security_WithValidAndInvalidSecurityConfiguration(t *testing
 	}
 	defer cc2.Close()
 
-	waitForFailedRPCWithStatus(ctx, t, cc2, codes.Unavailable, "", "")
+	waitForFailedRPCWithStatus(ctx, t, cc2, errAcceptAndClose)
 }
diff --git a/test/xds/xds_server_rbac_test.go b/test/xds/xds_server_rbac_test.go
index c0e51f5f..5c618911 100644
--- a/test/xds/xds_server_rbac_test.go
+++ b/test/xds/xds_server_rbac_test.go
@@ -265,13 +265,9 @@ func (s) TestServerSideXDS_RouteConfiguration(t *testing.T) {
 	// This Unary Call should match to a route with an incorrect action. Thus,
 	// this RPC should not go through as per A36, and this call should receive
 	// an error with codes.Unavailable.
-	_, err = client.UnaryCall(ctx, &testpb.SimpleRequest{})
-	if status.Code(err) != codes.Unavailable {
+	if _, err = client.UnaryCall(ctx, &testpb.SimpleRequest{}); status.Code(err) != codes.Unavailable {
 		t.Fatalf("client.UnaryCall() = _, %v, want _, error code %s", err, codes.Unavailable)
 	}
-	if !strings.Contains(err.Error(), nodeID) {
-		t.Fatalf("client.UnaryCall() = %v, want xDS node id %q", err, nodeID)
-	}
 
 	// This Streaming Call should match to a route with an incorrect action.
 	// Thus, this RPC should not go through as per A36, and this call should
@@ -280,13 +276,8 @@ func (s) TestServerSideXDS_RouteConfiguration(t *testing.T) {
 	if err != nil {
 		t.Fatalf("StreamingInputCall(_) = _, %v, want <nil>", err)
 	}
-	_, err = stream.CloseAndRecv()
-	const wantStreamingErr = "the incoming RPC matched to a route that was not of action type non forwarding"
-	if status.Code(err) != codes.Unavailable || !strings.Contains(err.Error(), wantStreamingErr) {
-		t.Fatalf("client.StreamingInputCall() = %v, want error with code %s and message %q", err, codes.Unavailable, wantStreamingErr)
-	}
-	if !strings.Contains(err.Error(), nodeID) {
-		t.Fatalf("client.StreamingInputCall() = %v, want xDS node id %q", err, nodeID)
+	if _, err = stream.CloseAndRecv(); status.Code(err) != codes.Unavailable || !strings.Contains(err.Error(), "the incoming RPC matched to a route that was not of action type non forwarding") {
+		t.Fatalf("streaming RPC should have been denied")
 	}
 
 	// This Full Duplex should not match to a route, and thus should return an
@@ -295,13 +286,8 @@ func (s) TestServerSideXDS_RouteConfiguration(t *testing.T) {
 	if err != nil {
 		t.Fatalf("FullDuplexCall(_) = _, %v, want <nil>", err)
 	}
-	_, err = dStream.Recv()
-	const wantFullDuplexErr = "the incoming RPC did not match a configured Route"
-	if status.Code(err) != codes.Unavailable || !strings.Contains(err.Error(), wantFullDuplexErr) {
-		t.Fatalf("client.FullDuplexCall() = %v, want error with code %s and message %q", err, codes.Unavailable, wantFullDuplexErr)
-	}
-	if !strings.Contains(err.Error(), nodeID) {
-		t.Fatalf("client.FullDuplexCall() = %v, want xDS node id %q", err, nodeID)
+	if _, err = dStream.Recv(); status.Code(err) != codes.Unavailable || !strings.Contains(err.Error(), "the incoming RPC did not match a configured Route") {
+		t.Fatalf("streaming RPC should have been denied")
 	}
 }
 
@@ -840,7 +826,7 @@ func serverListenerWithBadRouteConfiguration(t *testing.T, host string, port uin
 	}
 }
 
-func (s) TestRBAC_WithBadRouteConfiguration(t *testing.T) {
+func (s) TestRBACToggledOn_WithBadRouteConfiguration(t *testing.T) {
 	managementServer, nodeID, bootstrapContents, xdsResolver := setup.ManagementServerAndResolver(t)
 
 	lis, cleanup2 := setupGRPCServer(t, bootstrapContents)
@@ -881,19 +867,11 @@ func (s) TestRBAC_WithBadRouteConfiguration(t *testing.T) {
 	defer cc.Close()
 
 	client := testgrpc.NewTestServiceClient(cc)
-	_, err = client.EmptyCall(ctx, &testpb.Empty{})
-	if status.Code(err) != codes.Unavailable {
-		t.Fatalf("EmptyCall() returned %v, want Unavailable", err)
-	}
-	if !strings.Contains(err.Error(), nodeID) {
-		t.Fatalf("EmptyCall() = %v, want xDS node id %q", err, nodeID)
-	}
-	_, err = client.UnaryCall(ctx, &testpb.SimpleRequest{})
-	if status.Code(err) != codes.Unavailable {
-		t.Fatalf("UnaryCall() returned %v, want Unavailable", err)
+	if _, err := client.EmptyCall(ctx, &testpb.Empty{}); status.Code(err) != codes.Unavailable {
+		t.Fatalf("EmptyCall() returned err with status: %v, if RBAC is disabled all RPC's should proceed as normal", status.Code(err))
 	}
-	if !strings.Contains(err.Error(), nodeID) {
-		t.Fatalf("UnaryCall() = %v, want xDS node id %q", err, nodeID)
+	if _, err := client.UnaryCall(ctx, &testpb.SimpleRequest{}); status.Code(err) != codes.Unavailable {
+		t.Fatalf("UnaryCall() returned err with status: %v, if RBAC is disabled all RPC's should proceed as normal", status.Code(err))
 	}
 }
 
diff --git a/test/xds/xds_server_serving_mode_test.go b/test/xds/xds_server_serving_mode_test.go
new file mode 100644
index 00000000..a2e16489
--- /dev/null
+++ b/test/xds/xds_server_serving_mode_test.go
@@ -0,0 +1,401 @@
+/*
+ *
+ * Copyright 2021 gRPC authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package xds_test
+
+import (
+	"context"
+	"fmt"
+	"net"
+	"testing"
+	"time"
+
+	"google.golang.org/grpc"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/connectivity"
+	"google.golang.org/grpc/credentials"
+	"google.golang.org/grpc/credentials/insecure"
+	xdscreds "google.golang.org/grpc/credentials/xds"
+	"google.golang.org/grpc/internal/stubserver"
+	"google.golang.org/grpc/internal/testutils"
+	"google.golang.org/grpc/internal/testutils/xds/e2e"
+	"google.golang.org/grpc/internal/testutils/xds/e2e/setup"
+	"google.golang.org/grpc/status"
+	"google.golang.org/grpc/xds"
+
+	v3listenerpb "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	testgrpc "google.golang.org/grpc/interop/grpc_testing"
+	testpb "google.golang.org/grpc/interop/grpc_testing"
+)
+
+// TestServerSideXDS_RedundantUpdateSuppression tests the scenario where the
+// control plane sends the same resource update. It verifies that the mode
+// change callback is not invoked and client connections to the server are not
+// recycled.
+func (s) TestServerSideXDS_RedundantUpdateSuppression(t *testing.T) {
+	managementServer, nodeID, bootstrapContents, _ := setup.ManagementServerAndResolver(t)
+
+	creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})
+	if err != nil {
+		t.Fatal(err)
+	}
+	lis, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
+	}
+	updateCh := make(chan connectivity.ServingMode, 1)
+
+	// Create a server option to get notified about serving mode changes.
+	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		t.Logf("serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
+		updateCh <- args.Mode
+	})
+
+	// Initialize a test gRPC server, assign it to the stub server, and start
+	// the test service.
+	stub := createStubServer(t, lis, creds, modeChangeOpt, bootstrapContents)
+	defer stub.S.Stop()
+
+	// Setup the management server to respond with the listener resources.
+	host, port, err := hostPortFromListener(lis)
+	if err != nil {
+		t.Fatalf("failed to retrieve host and port of server: %v", err)
+	}
+	listener := e2e.DefaultServerListener(host, port, e2e.SecurityLevelNone, "routeName")
+	resources := e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{listener},
+	}
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	// Wait for the listener to move to "serving" mode.
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timed out waiting for a mode change update: %v", err)
+	case mode := <-updateCh:
+		if mode != connectivity.ServingModeServing {
+			t.Fatalf("listener received new mode %v, want %v", mode, connectivity.ServingModeServing)
+		}
+	}
+
+	// Create a ClientConn and make a successful RPCs.
+	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
+	if err != nil {
+		t.Fatalf("failed to dial local test server: %v", err)
+	}
+	defer cc.Close()
+	waitForSuccessfulRPC(ctx, t, cc)
+
+	// Start a goroutine to make sure that we do not see any connectivity state
+	// changes on the client connection. If redundant updates are not
+	// suppressed, server will recycle client connections.
+	errCh := make(chan error, 1)
+	go func() {
+		prev := connectivity.Ready // We know we are READY since we just did an RPC.
+		for {
+			curr := cc.GetState()
+			if !(curr == connectivity.Ready || curr == connectivity.Idle) {
+				errCh <- fmt.Errorf("unexpected connectivity state change {%s --> %s} on the client connection", prev, curr)
+				return
+			}
+			if !cc.WaitForStateChange(ctx, curr) {
+				// Break out of the for loop when the context has been cancelled.
+				break
+			}
+			prev = curr
+		}
+		errCh <- nil
+	}()
+
+	// Update the management server with the same listener resource. This will
+	// update the resource version though, and should result in a the management
+	// server sending the same resource to the xDS-enabled gRPC server.
+	if err := managementServer.Update(ctx, e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{listener},
+	}); err != nil {
+		t.Fatal(err)
+	}
+
+	// Since redundant resource updates are suppressed, we should not see the
+	// mode change callback being invoked.
+	sCtx, sCancel := context.WithTimeout(ctx, defaultTestShortTimeout)
+	defer sCancel()
+	select {
+	case <-sCtx.Done():
+	case mode := <-updateCh:
+		t.Fatalf("unexpected mode change callback with new mode %v", mode)
+	}
+
+	// Make sure RPCs continue to succeed.
+	waitForSuccessfulRPC(ctx, t, cc)
+
+	// Cancel the context to ensure that the WaitForStateChange call exits early
+	// and returns false.
+	cancel()
+	if err := <-errCh; err != nil {
+		t.Fatal(err)
+	}
+}
+
+// TestServerSideXDS_ServingModeChanges tests the serving mode functionality in
+// xDS enabled gRPC servers. It verifies that appropriate mode changes happen in
+// the server, and also verifies behavior of clientConns under these modes.
+func (s) TestServerSideXDS_ServingModeChanges(t *testing.T) {
+	managementServer, nodeID, bootstrapContents, _ := setup.ManagementServerAndResolver(t)
+
+	// Configure xDS credentials to be used on the server-side.
+	creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{
+		FallbackCreds: insecure.NewCredentials(),
+	})
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	// Create two local listeners and pass it to Serve().
+	lis1, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
+	}
+	lis2, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
+	}
+
+	// Create a couple of channels on which mode updates will be pushed.
+	updateCh1 := make(chan connectivity.ServingMode, 1)
+	updateCh2 := make(chan connectivity.ServingMode, 1)
+
+	// Create a server option to get notified about serving mode changes, and
+	// push the updated mode on the channels created above.
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		t.Logf("serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
+		switch addr.String() {
+		case lis1.Addr().String():
+			updateCh1 <- args.Mode
+		case lis2.Addr().String():
+			updateCh2 <- args.Mode
+		default:
+			t.Errorf("serving mode callback invoked for unknown listener address: %q", addr.String())
+		}
+	})
+
+	// Initialize a test gRPC server, assign it to the stub server, and start
+	// the test service.
+	stub1 := createStubServer(t, lis1, creds, modeChangeOpt, bootstrapContents)
+	defer stub1.S.Stop()
+	stub2 := createStubServer(t, lis2, creds, modeChangeOpt, bootstrapContents)
+	defer stub2.S.Stop()
+
+	// Setup the management server to respond with server-side Listener
+	// resources for both listeners.
+	host1, port1, err := hostPortFromListener(lis1)
+	if err != nil {
+		t.Fatalf("failed to retrieve host and port of server: %v", err)
+	}
+	listener1 := e2e.DefaultServerListener(host1, port1, e2e.SecurityLevelNone, "routeName")
+	host2, port2, err := hostPortFromListener(lis2)
+	if err != nil {
+		t.Fatalf("failed to retrieve host and port of server: %v", err)
+	}
+	listener2 := e2e.DefaultServerListener(host2, port2, e2e.SecurityLevelNone, "routeName")
+	resources := e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{listener1, listener2},
+	}
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	// Wait for both listeners to move to "serving" mode.
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timed out waiting for a mode change update: %v", err)
+	case mode := <-updateCh1:
+		if mode != connectivity.ServingModeServing {
+			t.Fatalf("listener received new mode %v, want %v", mode, connectivity.ServingModeServing)
+		}
+	}
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timed out waiting for a mode change update: %v", err)
+	case mode := <-updateCh2:
+		if mode != connectivity.ServingModeServing {
+			t.Fatalf("listener received new mode %v, want %v", mode, connectivity.ServingModeServing)
+		}
+	}
+
+	// Create a ClientConn to the first listener and make a successful RPCs.
+	cc1, err := grpc.NewClient(lis1.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
+	if err != nil {
+		t.Fatalf("grpc.NewClient() failed: %v", err)
+	}
+	defer cc1.Close()
+	waitForSuccessfulRPC(ctx, t, cc1)
+
+	// Create a ClientConn to the second listener and make a successful RPCs.
+	cc2, err := grpc.NewClient(lis2.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
+	if err != nil {
+		t.Fatalf("grpc.NewClient() failed: %v", err)
+	}
+	defer cc2.Close()
+	waitForSuccessfulRPC(ctx, t, cc2)
+
+	// Update the management server to remove the second listener resource. This
+	// should push only the second listener into "not-serving" mode.
+	if err := managementServer.Update(ctx, e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{listener1},
+	}); err != nil {
+		t.Fatal(err)
+	}
+
+	// Wait for lis2 to move to "not-serving" mode.
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timed out waiting for a mode change update: %v", err)
+	case mode := <-updateCh2:
+		if mode != connectivity.ServingModeNotServing {
+			t.Fatalf("listener received new mode %v, want %v", mode, connectivity.ServingModeNotServing)
+		}
+	}
+
+	// Make sure RPCs succeed on cc1 and fail on cc2.
+	waitForSuccessfulRPC(ctx, t, cc1)
+	waitForFailedRPC(ctx, t, cc2)
+
+	// Update the management server to remove the first listener resource as
+	// well. This should push the first listener into "not-serving" mode. Second
+	// listener is already in "not-serving" mode.
+	if err := managementServer.Update(ctx, e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{},
+	}); err != nil {
+		t.Fatal(err)
+	}
+
+	// Wait for lis1 to move to "not-serving" mode. lis2 was already removed
+	// from the xdsclient's resource cache. So, lis2's callback will not be
+	// invoked this time around.
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timed out waiting for a mode change update: %v", err)
+	case mode := <-updateCh1:
+		if mode != connectivity.ServingModeNotServing {
+			t.Fatalf("listener received new mode %v, want %v", mode, connectivity.ServingModeNotServing)
+		}
+	}
+
+	// Make sure RPCs fail on both.
+	waitForFailedRPC(ctx, t, cc1)
+	waitForFailedRPC(ctx, t, cc2)
+
+	// Make sure new connection attempts to "not-serving" servers fail.
+	if cc1, err = grpc.NewClient(lis1.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials())); err != nil {
+		t.Fatal("Failed to create clientConn to a server in \"not-serving\" state")
+	}
+	defer cc1.Close()
+
+	if _, err := testgrpc.NewTestServiceClient(cc1).FullDuplexCall(ctx); status.Code(err) != codes.Unavailable {
+		t.Fatalf("FullDuplexCall failed with status code: %v, want: Unavailable", status.Code(err))
+	}
+
+	// Update the management server with both listener resources.
+	if err := managementServer.Update(ctx, e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{listener1, listener2},
+	}); err != nil {
+		t.Fatal(err)
+	}
+
+	// Wait for both listeners to move to "serving" mode.
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timed out waiting for a mode change update: %v", err)
+	case mode := <-updateCh1:
+		if mode != connectivity.ServingModeServing {
+			t.Fatalf("listener received new mode %v, want %v", mode, connectivity.ServingModeServing)
+		}
+	}
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timed out waiting for a mode change update: %v", err)
+	case mode := <-updateCh2:
+		if mode != connectivity.ServingModeServing {
+			t.Fatalf("listener received new mode %v, want %v", mode, connectivity.ServingModeServing)
+		}
+	}
+
+	// The clientConns created earlier should be able to make RPCs now.
+	waitForSuccessfulRPC(ctx, t, cc1)
+	waitForSuccessfulRPC(ctx, t, cc2)
+}
+
+func createStubServer(t *testing.T, lis net.Listener, creds credentials.TransportCredentials, modeChangeOpt grpc.ServerOption, bootstrapContents []byte) *stubserver.StubServer {
+	stub := &stubserver.StubServer{
+		Listener: lis,
+		EmptyCallF: func(ctx context.Context, in *testpb.Empty) (*testpb.Empty, error) {
+			return &testpb.Empty{}, nil
+		},
+	}
+	server, err := xds.NewGRPCServer(grpc.Creds(creds), modeChangeOpt, xds.BootstrapContentsForTesting(bootstrapContents))
+	if err != nil {
+		t.Fatalf("Failed to create an xDS enabled gRPC server: %v", err)
+	}
+	stub.S = server
+	stubserver.StartTestService(t, stub)
+	return stub
+}
+
+func waitForSuccessfulRPC(ctx context.Context, t *testing.T, cc *grpc.ClientConn) {
+	t.Helper()
+
+	c := testgrpc.NewTestServiceClient(cc)
+	if _, err := c.EmptyCall(ctx, &testpb.Empty{}, grpc.WaitForReady(true)); err != nil {
+		t.Fatalf("rpc EmptyCall() failed: %v", err)
+	}
+}
+
+func waitForFailedRPC(ctx context.Context, t *testing.T, cc *grpc.ClientConn) {
+	t.Helper()
+
+	// Attempt one RPC before waiting for the ticker to expire.
+	c := testgrpc.NewTestServiceClient(cc)
+	if _, err := c.EmptyCall(ctx, &testpb.Empty{}); err != nil {
+		return
+	}
+
+	ticker := time.NewTicker(10 * time.Millisecond)
+	defer ticker.Stop()
+	for {
+		select {
+		case <-ctx.Done():
+			t.Fatalf("failure when waiting for RPCs to fail: %v", ctx.Err())
+		case <-ticker.C:
+			if _, err := c.EmptyCall(ctx, &testpb.Empty{}); err != nil {
+				return
+			}
+		}
+	}
+}
diff --git a/test/xds/xds_server_test.go b/test/xds/xds_server_test.go
new file mode 100644
index 00000000..bee9d401
--- /dev/null
+++ b/test/xds/xds_server_test.go
@@ -0,0 +1,371 @@
+/*
+ *
+ * Copyright 2023 gRPC authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package xds_test
+
+import (
+	"context"
+	"io"
+	"net"
+	"strings"
+	"testing"
+	"time"
+
+	"google.golang.org/grpc"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/connectivity"
+	"google.golang.org/grpc/credentials/insecure"
+	xdscreds "google.golang.org/grpc/credentials/xds"
+	"google.golang.org/grpc/internal/grpcsync"
+	"google.golang.org/grpc/internal/stubserver"
+	"google.golang.org/grpc/internal/testutils"
+	"google.golang.org/grpc/internal/testutils/xds/e2e"
+	"google.golang.org/grpc/internal/testutils/xds/e2e/setup"
+	"google.golang.org/grpc/status"
+	"google.golang.org/grpc/xds"
+
+	v3listenerpb "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	v3routepb "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
+	testgrpc "google.golang.org/grpc/interop/grpc_testing"
+	testpb "google.golang.org/grpc/interop/grpc_testing"
+)
+
+var (
+	errAcceptAndClose = status.New(codes.Unavailable, "")
+)
+
+// TestServeLDSRDS tests the case where a server receives LDS resource which
+// specifies RDS. LDS and RDS resources are configured on the management server,
+// which the server should pick up. The server should successfully accept
+// connections and RPCs should work on these accepted connections. It then
+// switches the RDS resource to match incoming RPC's to a route type of type
+// that isn't non forwarding action. This should get picked up by the connection
+// dynamically, and subsequent RPC's on that connection should start failing
+// with status code UNAVAILABLE.
+func (s) TestServeLDSRDS(t *testing.T) {
+	managementServer, nodeID, bootstrapContents, _ := setup.ManagementServerAndResolver(t)
+
+	lis, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
+	}
+	// Setup the management server to respond with a listener resource that
+	// specifies a route name to watch, and a RDS resource corresponding to this
+	// route name.
+	host, port, err := hostPortFromListener(lis)
+	if err != nil {
+		t.Fatalf("failed to retrieve host and port of server: %v", err)
+	}
+
+	listener := e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")
+	routeConfig := e2e.RouteConfigNonForwardingAction("routeName")
+
+	resources := e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{listener},
+		Routes:    []*v3routepb.RouteConfiguration{routeConfig},
+	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	serving := grpcsync.NewEvent()
+	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		t.Logf("serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
+		if args.Mode == connectivity.ServingModeServing {
+			serving.Fire()
+		}
+	})
+	// Configure xDS credentials with an insecure fallback to be used on the
+	// server-side.
+	creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})
+	if err != nil {
+		t.Fatalf("failed to create server credentials: %v", err)
+	}
+	stub := createStubServer(t, lis, creds, modeChangeOpt, bootstrapContents)
+	defer stub.S.Stop()
+
+	select {
+	case <-ctx.Done():
+		t.Fatal("timeout waiting for the xDS Server to go Serving")
+	case <-serving.Done():
+	}
+
+	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
+	if err != nil {
+		t.Fatalf("failed to dial local test server: %v", err)
+	}
+	defer cc.Close()
+
+	waitForSuccessfulRPC(ctx, t, cc) // Eventually, the LDS and dynamic RDS get processed, work, and RPC's should work as usual.
+
+	// Set the route config to be of type route action route, which the rpc will
+	// match to. This should eventually reflect in the Conn's routing
+	// configuration and fail the rpc with a status code UNAVAILABLE.
+	routeConfig = e2e.RouteConfigFilterAction("routeName")
+	resources = e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{listener}, // Same lis, so will get eaten by the xDS Client.
+		Routes:    []*v3routepb.RouteConfiguration{routeConfig},
+	}
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	// "NonForwardingAction is expected for all Routes used on server-side; a
+	// route with an inappropriate action causes RPCs matching that route to
+	// fail with UNAVAILABLE." - A36
+	waitForFailedRPCWithStatus(ctx, t, cc, status.New(codes.Unavailable, "the incoming RPC matched to a route that was not of action type non forwarding"))
+}
+
+// waitForFailedRPCWithStatus makes unary RPC's until it receives the expected
+// status in a polling manner. Fails if the RPC made does not return the
+// expected status before the context expires.
+func waitForFailedRPCWithStatus(ctx context.Context, t *testing.T, cc *grpc.ClientConn, st *status.Status) {
+	t.Helper()
+
+	c := testgrpc.NewTestServiceClient(cc)
+	ticker := time.NewTicker(10 * time.Millisecond)
+	defer ticker.Stop()
+	var err error
+	for {
+		select {
+		case <-ctx.Done():
+			t.Fatalf("failure when waiting for RPCs to fail with certain status %v: %v. most recent error received from RPC: %v", st, ctx.Err(), err)
+		case <-ticker.C:
+			_, err = c.EmptyCall(ctx, &testpb.Empty{})
+			if status.Code(err) == st.Code() && strings.Contains(err.Error(), st.Message()) {
+				t.Logf("most recent error happy case: %v", err.Error())
+				return
+			}
+		}
+	}
+}
+
+// TestResourceNack tests the case where an LDS points to an RDS which returns
+// an RDS Resource which is NACKed. This should trigger server should move to
+// serving, successfully Accept Connections, and fail at the L7 level with a
+// certain error message.
+func (s) TestRDSNack(t *testing.T) {
+	managementServer, nodeID, bootstrapContents, _ := setup.ManagementServerAndResolver(t)
+	lis, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
+	}
+	// Setup the management server to respond with a listener resource that
+	// specifies a route name to watch, and no RDS resource corresponding to
+	// this route name.
+	host, port, err := hostPortFromListener(lis)
+	if err != nil {
+		t.Fatalf("failed to retrieve host and port of server: %v", err)
+	}
+
+	listener := e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")
+	routeConfig := e2e.RouteConfigNoRouteMatch("routeName")
+	resources := e2e.UpdateOptions{
+		NodeID:         nodeID,
+		Listeners:      []*v3listenerpb.Listener{listener},
+		Routes:         []*v3routepb.RouteConfiguration{routeConfig},
+		SkipValidation: true,
+	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+	serving := grpcsync.NewEvent()
+	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		t.Logf("serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
+		if args.Mode == connectivity.ServingModeServing {
+			serving.Fire()
+		}
+	})
+
+	// Configure xDS credentials with an insecure fallback to be used on the
+	// server-side.
+	creds, err := xdscreds.NewServerCredentials(xdscreds.ServerOptions{FallbackCreds: insecure.NewCredentials()})
+	if err != nil {
+		t.Fatalf("failed to create server credentials: %v", err)
+	}
+
+	stub := createStubServer(t, lis, creds, modeChangeOpt, bootstrapContents)
+	defer stub.S.Stop()
+
+	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
+	if err != nil {
+		t.Fatalf("failed to dial local test server: %v", err)
+	}
+	defer cc.Close()
+
+	<-serving.Done()
+	waitForFailedRPCWithStatus(ctx, t, cc, status.New(codes.Unavailable, "error from xDS configuration for matched route configuration"))
+}
+
+// TestMultipleUpdatesImmediatelySwitch tests the case where you get an LDS
+// specifying RDS A, B, and C (with A being matched to). The Server should be in
+// not serving until it receives all 3 RDS Configurations, and then transition
+// into serving. RPCs will match to RDS A and work properly. Afterward, it
+// receives an LDS specifying RDS A, B. The Filter Chain pointing to RDS A
+// doesn't get matched, and the Default Filter Chain pointing to RDS B does get
+// matched. RDS B is of the wrong route type for server side, so RPC's are
+// expected to eventually fail with that information. However, any RPC's on the
+// old configuration should be allowed to complete due to the transition being
+// graceful stop.After, it receives an LDS specifying RDS A (which incoming
+// RPC's will match to). This configuration should eventually be represented in
+// the Server's state, and RPCs should proceed successfully.
+func (s) TestMultipleUpdatesImmediatelySwitch(t *testing.T) {
+	managementServer, nodeID, bootstrapContents, _ := setup.ManagementServerAndResolver(t)
+	lis, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
+	}
+	host, port, err := hostPortFromListener(lis)
+	if err != nil {
+		t.Fatalf("failed to retrieve host and port of server: %v", err)
+	}
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+
+	// Setup the management server to respond with a listener resource that
+	// specifies three route names to watch.
+	ldsResource := e2e.ListenerResourceThreeRouteResources(host, port, e2e.SecurityLevelNone, "routeName")
+	resources := e2e.UpdateOptions{
+		NodeID:         nodeID,
+		Listeners:      []*v3listenerpb.Listener{ldsResource},
+		SkipValidation: true,
+	}
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	stub := &stubserver.StubServer{
+		Listener: lis,
+		EmptyCallF: func(ctx context.Context, in *testpb.Empty) (*testpb.Empty, error) {
+			return &testpb.Empty{}, nil
+		},
+		FullDuplexCallF: func(stream testgrpc.TestService_FullDuplexCallServer) error {
+			for {
+				_, err := stream.Recv() // hangs here forever if stream doesn't shut down...doesn't receive EOF without any errors
+				if err == io.EOF {
+					return nil
+				}
+			}
+		},
+	}
+
+	if stub.S, err = xds.NewGRPCServer(grpc.Creds(insecure.NewCredentials()), testModeChangeServerOption(t), xds.BootstrapContentsForTesting(bootstrapContents)); err != nil {
+		t.Fatalf("Failed to create an xDS enabled gRPC server: %v", err)
+	}
+	defer stub.S.Stop()
+	stubserver.StartTestService(t, stub)
+
+	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
+	if err != nil {
+		t.Fatalf("failed to dial local test server: %v", err)
+	}
+	defer cc.Close()
+
+	waitForFailedRPCWithStatus(ctx, t, cc, errAcceptAndClose)
+
+	routeConfig1 := e2e.RouteConfigNonForwardingAction("routeName")
+	routeConfig2 := e2e.RouteConfigFilterAction("routeName2")
+	routeConfig3 := e2e.RouteConfigFilterAction("routeName3")
+	resources = e2e.UpdateOptions{
+		NodeID:         nodeID,
+		Listeners:      []*v3listenerpb.Listener{ldsResource},
+		Routes:         []*v3routepb.RouteConfiguration{routeConfig1, routeConfig2, routeConfig3},
+		SkipValidation: true,
+	}
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+	pollForSuccessfulRPC(ctx, t, cc)
+
+	c := testgrpc.NewTestServiceClient(cc)
+	stream, err := c.FullDuplexCall(ctx)
+	if err != nil {
+		t.Fatalf("cc.FullDuplexCall failed: %f", err)
+	}
+	if err = stream.Send(&testpb.StreamingOutputCallRequest{}); err != nil {
+		t.Fatalf("stream.Send() failed: %v, should continue to work due to graceful stop", err)
+	}
+
+	// Configure with LDS with a filter chain that doesn't get matched to and a
+	// default filter chain that matches to RDS A.
+	ldsResource = e2e.ListenerResourceFallbackToDefault(host, port, e2e.SecurityLevelNone)
+	resources = e2e.UpdateOptions{
+		NodeID:         nodeID,
+		Listeners:      []*v3listenerpb.Listener{ldsResource},
+		Routes:         []*v3routepb.RouteConfiguration{routeConfig1, routeConfig2, routeConfig3},
+		SkipValidation: true,
+	}
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatalf("error updating management server: %v", err)
+	}
+
+	// xDS is eventually consistent. So simply poll for the new change to be
+	// reflected.
+	// "NonForwardingAction is expected for all Routes used on server-side; a
+	// route with an inappropriate action causes RPCs matching that route to
+	// fail with UNAVAILABLE." - A36
+	waitForFailedRPCWithStatus(ctx, t, cc, status.New(codes.Unavailable, "the incoming RPC matched to a route that was not of action type non forwarding"))
+
+	// Stream should be allowed to continue on the old working configuration -
+	// as it on a connection that is gracefully closed (old FCM/LDS
+	// Configuration which is allowed to continue).
+	if err = stream.CloseSend(); err != nil {
+		t.Fatalf("stream.CloseSend() failed: %v, should continue to work due to graceful stop", err)
+	}
+	if _, err = stream.Recv(); err != io.EOF {
+		t.Fatalf("unexpected error: %v, expected an EOF error", err)
+	}
+
+	ldsResource = e2e.DefaultServerListener(host, port, e2e.SecurityLevelNone, "routeName")
+	resources = e2e.UpdateOptions{
+		NodeID:         nodeID,
+		Listeners:      []*v3listenerpb.Listener{ldsResource},
+		Routes:         []*v3routepb.RouteConfiguration{routeConfig1, routeConfig2, routeConfig3},
+		SkipValidation: true,
+	}
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	pollForSuccessfulRPC(ctx, t, cc)
+}
+
+func pollForSuccessfulRPC(ctx context.Context, t *testing.T, cc *grpc.ClientConn) {
+	t.Helper()
+	c := testgrpc.NewTestServiceClient(cc)
+	ticker := time.NewTicker(10 * time.Millisecond)
+	defer ticker.Stop()
+	for {
+		select {
+		case <-ctx.Done():
+			t.Fatalf("timeout waiting for RPCs to succeed")
+		case <-ticker.C:
+			if _, err := c.EmptyCall(ctx, &testpb.Empty{}); err == nil {
+				return
+			}
+		}
+	}
+}
diff --git a/xds/internal/server/listener_wrapper.go b/xds/internal/server/listener_wrapper.go
index 6fd1e766..09d32001 100644
--- a/xds/internal/server/listener_wrapper.go
+++ b/xds/internal/server/listener_wrapper.go
@@ -84,7 +84,6 @@ func NewListenerWrapper(params ListenerWrapperParams) net.Listener {
 		Listener:          params.Listener,
 		name:              params.ListenerResourceName,
 		xdsC:              params.XDSClient,
-		xdsNodeID:         params.XDSClient.BootstrapConfig().Node().GetId(),
 		modeCallback:      params.ModeCallback,
 		isUnspecifiedAddr: params.Listener.Addr().(*net.TCPAddr).IP.IsUnspecified(),
 		conns:             make(map[*connWrapper]bool),
@@ -117,7 +116,6 @@ type listenerWrapper struct {
 
 	name         string
 	xdsC         XDSClient
-	xdsNodeID    string
 	cancelWatch  func()
 	modeCallback ServingModeCallback
 
@@ -175,8 +173,7 @@ func (l *listenerWrapper) handleLDSUpdate(update xdsresource.ListenerUpdate) {
 	// what we have decided to do.
 	if ilc.Address != l.addr || ilc.Port != l.port {
 		l.mu.Lock()
-		err := l.annotateErrorWithNodeID(fmt.Errorf("address (%s:%s) in Listener update does not match listening address: (%s:%s)", ilc.Address, ilc.Port, l.addr, l.port))
-		l.switchModeLocked(connectivity.ServingModeNotServing, err)
+		l.switchModeLocked(connectivity.ServingModeNotServing, fmt.Errorf("address (%s:%s) in Listener update does not match listening address: (%s:%s)", ilc.Address, ilc.Port, l.addr, l.port))
 		l.mu.Unlock()
 		return
 	}
@@ -231,14 +228,12 @@ func (l *listenerWrapper) handleRDSUpdate(routeName string, rcu rdsWatcherUpdate
 				continue
 			}
 			if rcu.err != nil && rcu.data == nil { // Either NACK before update, or resource not found triggers this conditional.
-				urc := &xdsresource.UsableRouteConfiguration{Err: rcu.err}
-				urc.NodeID = l.xdsNodeID
-				fc.UsableRouteConfiguration.Store(urc)
+				fc.UsableRouteConfiguration.Store(&xdsresource.UsableRouteConfiguration{
+					Err: rcu.err,
+				})
 				continue
 			}
-			urc := fc.ConstructUsableRouteConfiguration(*rcu.data)
-			urc.NodeID = l.xdsNodeID
-			fc.UsableRouteConfiguration.Store(urc)
+			fc.UsableRouteConfiguration.Store(fc.ConstructUsableRouteConfiguration(*rcu.data))
 		}
 	}
 	if l.rdsHandler.determineRouteConfigurationReady() {
@@ -253,21 +248,15 @@ func (l *listenerWrapper) handleRDSUpdate(routeName string, rcu rdsWatcherUpdate
 func (l *listenerWrapper) instantiateFilterChainRoutingConfigurationsLocked() {
 	for _, fc := range l.activeFilterChainManager.FilterChains() {
 		if fc.InlineRouteConfig != nil {
-			urc := fc.ConstructUsableRouteConfiguration(*fc.InlineRouteConfig)
-			urc.NodeID = l.xdsNodeID
-			fc.UsableRouteConfiguration.Store(urc) // Can't race with an RPC coming in but no harm making atomic.
+			fc.UsableRouteConfiguration.Store(fc.ConstructUsableRouteConfiguration(*fc.InlineRouteConfig)) // Can't race with an RPC coming in but no harm making atomic.
 			continue
 		} // Inline configuration constructed once here, will remain for lifetime of filter chain.
 		rcu := l.rdsHandler.updates[fc.RouteConfigName]
 		if rcu.err != nil && rcu.data == nil {
-			urc := &xdsresource.UsableRouteConfiguration{Err: rcu.err}
-			urc.NodeID = l.xdsNodeID
-			fc.UsableRouteConfiguration.Store(urc)
+			fc.UsableRouteConfiguration.Store(&xdsresource.UsableRouteConfiguration{Err: rcu.err})
 			continue
 		}
-		urc := fc.ConstructUsableRouteConfiguration(*rcu.data)
-		urc.NodeID = l.xdsNodeID
-		fc.UsableRouteConfiguration.Store(urc) // Can't race with an RPC coming in but no harm making atomic.
+		fc.UsableRouteConfiguration.Store(fc.ConstructUsableRouteConfiguration(*rcu.data)) // Can't race with an RPC coming in but no harm making atomic.
 	}
 }
 
@@ -408,14 +397,10 @@ func (l *listenerWrapper) switchModeLocked(newMode connectivity.ServingMode, err
 	}
 }
 
-func (l *listenerWrapper) annotateErrorWithNodeID(err error) error {
-	return fmt.Errorf("[xDS node id: %v]: %w", l.xdsNodeID, err)
-}
-
 func (l *listenerWrapper) onLDSResourceDoesNotExist(err error) {
 	l.mu.Lock()
 	defer l.mu.Unlock()
-	l.switchModeLocked(connectivity.ServingModeNotServing, l.annotateErrorWithNodeID(err))
+	l.switchModeLocked(connectivity.ServingModeNotServing, err)
 	l.activeFilterChainManager = nil
 	l.pendingFilterChainManager = nil
 	l.rdsHandler.updateRouteNamesToWatch(make(map[string]bool))
diff --git a/xds/internal/server/listener_wrapper_test.go b/xds/internal/server/listener_wrapper_test.go
new file mode 100644
index 00000000..e181a7b8
--- /dev/null
+++ b/xds/internal/server/listener_wrapper_test.go
@@ -0,0 +1,251 @@
+/*
+ *
+ * Copyright 2021 gRPC authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package server
+
+import (
+	"context"
+	"fmt"
+	"net"
+	"strconv"
+	"testing"
+	"time"
+
+	"google.golang.org/grpc"
+	"google.golang.org/grpc/connectivity"
+	"google.golang.org/grpc/credentials/insecure"
+	"google.golang.org/grpc/internal"
+	"google.golang.org/grpc/internal/stubserver"
+	"google.golang.org/grpc/internal/testutils"
+	"google.golang.org/grpc/internal/testutils/xds/e2e"
+	testgrpc "google.golang.org/grpc/interop/grpc_testing"
+	testpb "google.golang.org/grpc/interop/grpc_testing"
+	xdsinternal "google.golang.org/grpc/xds/internal"
+	"google.golang.org/grpc/xds/internal/xdsclient"
+	"google.golang.org/grpc/xds/internal/xdsclient/xdsresource"
+	"google.golang.org/grpc/xds/internal/xdsclient/xdsresource/version"
+
+	v3listenerpb "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
+	v3routepb "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
+
+	_ "google.golang.org/grpc/xds/internal/httpfilter/router" // Register the router filter
+)
+
+type verifyMode struct {
+	modeCh chan connectivity.ServingMode
+}
+
+func (vm *verifyMode) verifyModeCallback(_ net.Addr, mode connectivity.ServingMode, _ error) {
+	vm.modeCh <- mode
+}
+
+func hostPortFromListener(t *testing.T, lis net.Listener) (string, uint32) {
+	t.Helper()
+
+	host, p, err := net.SplitHostPort(lis.Addr().String())
+	if err != nil {
+		t.Fatalf("net.SplitHostPort(%s) failed: %v", lis.Addr().String(), err)
+	}
+	port, err := strconv.ParseInt(p, 10, 32)
+	if err != nil {
+		t.Fatalf("strconv.ParseInt(%s, 10, 32) failed: %v", p, err)
+	}
+	return host, uint32(port)
+}
+
+// TestListenerWrapper tests the listener wrapper. It configures the listener
+// wrapper with a certain LDS, and makes sure that it requests the LDS name. It
+// then receives an LDS resource that points to an RDS for Route Configuration.
+// The listener wrapper should then start a watch for the RDS name. This should
+// not trigger a mode change (the mode starts out non serving). Then a RDS
+// resource is configured to return for the RDS name. This should transition the
+// Listener Wrapper to READY.
+func (s) TestListenerWrapper(t *testing.T) {
+	mgmtServer, nodeID, ldsResourceNamesCh, rdsResourceNamesCh, xdsC := xdsSetupForTests(t)
+	lis, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("Failed to create a local TCP listener: %v", err)
+	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+
+	modeCh := make(chan connectivity.ServingMode, 1)
+	vm := verifyMode{
+		modeCh: modeCh,
+	}
+	host, port := hostPortFromListener(t, lis)
+	lisResourceName := fmt.Sprintf(e2e.ServerListenerResourceNameTemplate, net.JoinHostPort(host, strconv.Itoa(int(port))))
+	params := ListenerWrapperParams{
+		Listener:             lis,
+		ListenerResourceName: lisResourceName,
+		XDSClient:            xdsC,
+		ModeCallback:         vm.verifyModeCallback,
+	}
+	l := NewListenerWrapper(params)
+	if l == nil {
+		t.Fatalf("NewListenerWrapper(%+v) returned nil", params)
+	}
+	defer l.Close()
+	waitForResourceNames(ctx, t, ldsResourceNamesCh, []string{lisResourceName})
+	// Configure the management server with a listener resource that specifies
+	// the name of RDS resources that need to be resolved.
+	listener := e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, route1)
+	resources := e2e.UpdateOptions{
+		NodeID:         nodeID,
+		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, route1)},
+		SkipValidation: true,
+	}
+	if err := mgmtServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	waitForResourceNames(ctx, t, rdsResourceNamesCh, []string{route1})
+
+	// Verify that there is no mode change.
+	sCtx, sCancel := context.WithTimeout(context.Background(), defaultTestShortTimeout)
+	defer sCancel()
+	select {
+	case mode := <-modeCh:
+		t.Fatalf("received mode change to %v when no mode expected", mode)
+	case <-sCtx.Done():
+	}
+
+	// Configure the management server with the route configuration resource
+	// specified by the listener resource.
+	resources.Routes = []*v3routepb.RouteConfiguration{e2e.DefaultRouteConfig(route1, lisResourceName, clusterName)}
+	if err := mgmtServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	// Mode should go serving.
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timeout waiting for mode change")
+	case mode := <-modeCh:
+		if mode != connectivity.ServingModeServing {
+			t.Fatalf("mode change received: %v, want: %v", mode, connectivity.ServingModeServing)
+		}
+	}
+
+	// Invoke lds resource not found - should go back to non serving.
+	triggerResourceNotFound := internal.TriggerXDSResourceNotFoundForTesting.(func(xdsclient.XDSClient, xdsresource.Type, string) error)
+	listenerResourceType := xdsinternal.ResourceTypeMapForTesting[version.V3ListenerURL].(xdsresource.Type)
+	if err := triggerResourceNotFound(xdsC, listenerResourceType, listener.GetName()); err != nil {
+		t.Fatalf("Failed to trigger resource name not found for testing: %v", err)
+	}
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timeout waiting for mode change")
+	case mode := <-modeCh:
+		if mode != connectivity.ServingModeNotServing {
+			t.Fatalf("mode change received: %v, want: %v", mode, connectivity.ServingModeNotServing)
+		}
+	}
+}
+
+// TestConnsCleanup tests that the listener wrapper clears it's connection
+// references when connections close. It sets up a listener wrapper and gRPC
+// Server, and connects to the server 100 times and makes an RPC each time, and
+// then closes the connection. After these 100 connections Close, the listener
+// wrapper should have no more references to any connections.
+func (s) TestConnsCleanup(t *testing.T) {
+	mgmtServer, nodeID, _, _, xdsC := xdsSetupForTests(t)
+	lis, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("Failed to create a local TCP listener: %v", err)
+	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+
+	modeCh := make(chan connectivity.ServingMode, 1)
+	vm := verifyMode{
+		modeCh: modeCh,
+	}
+
+	host, port := hostPortFromListener(t, lis)
+	lisResourceName := fmt.Sprintf(e2e.ServerListenerResourceNameTemplate, net.JoinHostPort(host, strconv.Itoa(int(port))))
+	params := ListenerWrapperParams{
+		Listener:             lis,
+		ListenerResourceName: lisResourceName,
+		XDSClient:            xdsC,
+		ModeCallback:         vm.verifyModeCallback,
+	}
+	lw := NewListenerWrapper(params)
+	if lw == nil {
+		t.Fatalf("NewListenerWrapper(%+v) returned nil", params)
+	}
+	defer lw.Close()
+
+	resources := e2e.UpdateOptions{
+		NodeID:         nodeID,
+		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListener(host, port, e2e.SecurityLevelNone, route1)},
+		SkipValidation: true,
+	}
+	if err := mgmtServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+
+	// Wait for Listener Mode to go serving.
+	select {
+	case <-ctx.Done():
+		t.Fatalf("timeout waiting for mode change")
+	case mode := <-modeCh:
+		if mode != connectivity.ServingModeServing {
+			t.Fatalf("mode change received: %v, want: %v", mode, connectivity.ServingModeServing)
+		}
+	}
+
+	ss := &stubserver.StubServer{
+		Listener: lis,
+		EmptyCallF: func(context.Context, *testpb.Empty) (*testpb.Empty, error) {
+			return &testpb.Empty{}, nil
+		},
+		S: grpc.NewServer(grpc.Creds(insecure.NewCredentials())),
+	}
+	stubserver.StartTestService(t, ss)
+	defer ss.S.Stop()
+
+	// Make 100 connections to the server, and make an RPC on each one.
+	for i := 0; i < 100; i++ {
+		cc, err := grpc.NewClient(lw.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
+		if err != nil {
+			t.Fatalf("grpc.NewClient failed with err: %v", err)
+		}
+		client := testgrpc.NewTestServiceClient(cc)
+		if _, err := client.EmptyCall(ctx, &testpb.Empty{}); err != nil {
+			t.Fatalf("client.EmptyCall() failed: %v", err)
+		}
+		cc.Close()
+	}
+
+	lisWrapper := lw.(*listenerWrapper)
+	// Eventually when the server processes the connection shutdowns, the
+	// listener wrapper should clear its references to the wrapped connections.
+	lenConns := 1
+	for ; ctx.Err() == nil && lenConns > 0; <-time.After(time.Millisecond) {
+		lisWrapper.mu.Lock()
+		lenConns = len(lisWrapper.conns)
+		lisWrapper.mu.Unlock()
+	}
+	if lenConns > 0 {
+		t.Fatalf("timeout waiting for lis wrapper conns to clear, size: %v", lenConns)
+	}
+
+}
diff --git a/xds/internal/server/rds_handler.go b/xds/internal/server/rds_handler.go
index b4d536ff..bcd3938e 100644
--- a/xds/internal/server/rds_handler.go
+++ b/xds/internal/server/rds_handler.go
@@ -19,7 +19,6 @@
 package server
 
 import (
-	"fmt"
 	"sync"
 
 	igrpclog "google.golang.org/grpc/internal/grpclog"
@@ -31,9 +30,8 @@ import (
 // updates for later use and also determines whether all the rdsWatcher updates
 // needed have been received or not.
 type rdsHandler struct {
-	xdsC      XDSClient
-	xdsNodeID string
-	logger    *igrpclog.PrefixLogger
+	xdsC   XDSClient
+	logger *igrpclog.PrefixLogger
 
 	callback func(string, rdsWatcherUpdate)
 
@@ -52,15 +50,13 @@ type rdsHandler struct {
 // resources. listenerWrapper updates the list of route names to watch by
 // calling updateRouteNamesToWatch() upon receipt of new Listener configuration.
 func newRDSHandler(cb func(string, rdsWatcherUpdate), xdsC XDSClient, logger *igrpclog.PrefixLogger) *rdsHandler {
-	r := &rdsHandler{
+	return &rdsHandler{
 		xdsC:     xdsC,
 		logger:   logger,
 		callback: cb,
 		updates:  make(map[string]rdsWatcherUpdate),
 		cancels:  make(map[string]func()),
 	}
-	r.xdsNodeID = xdsC.BootstrapConfig().Node().GetId()
-	return r
 }
 
 // updateRouteNamesToWatch handles a list of route names to watch for a given
@@ -188,9 +184,8 @@ func (rw *rdsWatcher) OnResourceDoesNotExist(onDone xdsresource.OnDoneFunc) {
 	}
 	rw.mu.Unlock()
 	if rw.logger.V(2) {
-		rw.logger.Infof("RDS watch for resource %q reported resource-does-not-exist error", rw.routeName)
+		rw.logger.Infof("RDS watch for resource %q reported resource-does-not-exist error: %v", rw.routeName)
 	}
 	err := xdsresource.NewErrorf(xdsresource.ErrorTypeResourceNotFound, "resource name %q of type RouteConfiguration not found in received response", rw.routeName)
-	err = fmt.Errorf("[xDS node id: %v]: %w", rw.parent.xdsNodeID, err)
 	rw.parent.handleRouteUpdate(rw.routeName, rdsWatcherUpdate{err: err})
 }
diff --git a/xds/internal/xdsclient/xdsresource/filter_chain.go b/xds/internal/xdsclient/xdsresource/filter_chain.go
index 39451991..56a94dea 100644
--- a/xds/internal/xdsclient/xdsresource/filter_chain.go
+++ b/xds/internal/xdsclient/xdsresource/filter_chain.go
@@ -23,9 +23,7 @@ import (
 	"net"
 	"sync/atomic"
 
-	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/internal/resolver"
-	"google.golang.org/grpc/status"
 	"google.golang.org/grpc/xds/internal/httpfilter"
 	"google.golang.org/grpc/xds/internal/xdsclient/xdsresource/version"
 	"google.golang.org/protobuf/proto"
@@ -101,15 +99,8 @@ type RouteWithInterceptors struct {
 // UsableRouteConfiguration contains a matchable route configuration, with
 // instantiated HTTP Filters per route.
 type UsableRouteConfiguration struct {
-	VHS    []VirtualHostWithInterceptors
-	Err    error
-	NodeID string // For logging purposes. Populated by the listener wrapper.
-}
-
-// StatusErrWithNodeID returns an error produced by the status package with the
-// specified code and message, and includes the xDS node ID.
-func (rc *UsableRouteConfiguration) StatusErrWithNodeID(c codes.Code, msg string, args ...any) error {
-	return status.Error(c, fmt.Sprintf("[xDS node id: %v]: %s", rc.NodeID, fmt.Sprintf(msg, args...)))
+	VHS []VirtualHostWithInterceptors
+	Err error
 }
 
 // ConstructUsableRouteConfiguration takes Route Configuration and converts it
diff --git a/xds/server.go b/xds/server.go
index 5baf91de..aa93130d 100644
--- a/xds/server.go
+++ b/xds/server.go
@@ -256,7 +256,7 @@ func routeAndProcess(ctx context.Context) error {
 		if logger.V(2) {
 			logger.Infof("RPC on connection with xDS Configuration error: %v", rc.Err)
 		}
-		return status.Error(codes.Unavailable, fmt.Sprintf("error from xDS configuration for matched route configuration: %v", rc.Err))
+		return status.Error(codes.Unavailable, "error from xDS configuration for matched route configuration")
 	}
 
 	mn, ok := grpc.Method(ctx)
@@ -273,7 +273,7 @@ func routeAndProcess(ctx context.Context) error {
 	authority := md.Get(":authority")
 	vh := xdsresource.FindBestMatchingVirtualHostServer(authority[0], rc.VHS)
 	if vh == nil {
-		return rc.StatusErrWithNodeID(codes.Unavailable, "the incoming RPC did not match a configured Virtual Host")
+		return status.Error(codes.Unavailable, "the incoming RPC did not match a configured Virtual Host")
 	}
 
 	var rwi *xdsresource.RouteWithInterceptors
@@ -283,22 +283,21 @@ func routeAndProcess(ctx context.Context) error {
 	}
 	for _, r := range vh.Routes {
 		if r.M.Match(rpcInfo) {
-			// "NonForwardingAction is expected for all Routes used on
-			// server-side; a route with an inappropriate action causes RPCs
-			// matching that route to fail with UNAVAILABLE." - A36
+			// "NonForwardingAction is expected for all Routes used on server-side; a route with an inappropriate action causes
+			// RPCs matching that route to fail with UNAVAILABLE." - A36
 			if r.ActionType != xdsresource.RouteActionNonForwardingAction {
-				return rc.StatusErrWithNodeID(codes.Unavailable, "the incoming RPC matched to a route that was not of action type non forwarding")
+				return status.Error(codes.Unavailable, "the incoming RPC matched to a route that was not of action type non forwarding")
 			}
 			rwi = &r
 			break
 		}
 	}
 	if rwi == nil {
-		return rc.StatusErrWithNodeID(codes.Unavailable, "the incoming RPC did not match a configured Route")
+		return status.Error(codes.Unavailable, "the incoming RPC did not match a configured Route")
 	}
 	for _, interceptor := range rwi.Interceptors {
 		if err := interceptor.AllowRPC(ctx); err != nil {
-			return rc.StatusErrWithNodeID(codes.PermissionDenied, "Incoming RPC is not allowed: %v", err)
+			return status.Errorf(codes.PermissionDenied, "Incoming RPC is not allowed: %v", err)
 		}
 	}
 	return nil
diff --git a/xds/server_ext_test.go b/xds/server_ext_test.go
index 80f33a0b..1de20d1c 100644
--- a/xds/server_ext_test.go
+++ b/xds/server_ext_test.go
@@ -25,16 +25,15 @@ import (
 	"net"
 	"strconv"
 	"strings"
-	"sync"
 	"testing"
 	"time"
 
-	"github.com/google/go-cmp/cmp"
-	"github.com/google/uuid"
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/connectivity"
 	"google.golang.org/grpc/credentials/insecure"
+	"google.golang.org/grpc/internal"
+	"google.golang.org/grpc/internal/grpcsync"
 	"google.golang.org/grpc/internal/grpctest"
 	"google.golang.org/grpc/internal/stubserver"
 	"google.golang.org/grpc/internal/testutils"
@@ -43,15 +42,20 @@ import (
 	"google.golang.org/grpc/peer"
 	"google.golang.org/grpc/status"
 	"google.golang.org/grpc/xds"
+	xdsinternal "google.golang.org/grpc/xds/internal"
 	"google.golang.org/grpc/xds/internal/xdsclient"
+	"google.golang.org/grpc/xds/internal/xdsclient/xdsresource"
+	"google.golang.org/grpc/xds/internal/xdsclient/xdsresource/version"
 
 	v3listenerpb "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
 	v3routepb "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
-	v3discoverypb "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
+	"github.com/google/uuid"
 	testgrpc "google.golang.org/grpc/interop/grpc_testing"
 	testpb "google.golang.org/grpc/interop/grpc_testing"
 )
 
+var errAcceptAndClose = status.New(codes.Unavailable, "")
+
 type s struct {
 	grpctest.Tester
 }
@@ -77,333 +81,159 @@ func hostPortFromListener(lis net.Listener) (string, uint32, error) {
 	return host, uint32(port), nil
 }
 
-// servingModeChangeHandler handles changes to the serving mode of an
-// xDS-enabled gRPC server. It logs the changes and sends the new mode and any
-// errors on appropriate channels for the test to consume.
-type servingModeChangeHandler struct {
-	logger interface {
-		Logf(format string, args ...any)
-	}
-	modeCh chan connectivity.ServingMode
-	errCh  chan error
-}
-
-func newServingModeChangeHandler(t *testing.T) *servingModeChangeHandler {
-	return &servingModeChangeHandler{
-		logger: t,
-		modeCh: make(chan connectivity.ServingMode, 1),
-		errCh:  make(chan error, 1),
-	}
-}
-
-func (m *servingModeChangeHandler) modeChangeCallback(addr net.Addr, args xds.ServingModeChangeArgs) {
-	m.logger.Logf("Serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
-	m.modeCh <- args.Mode
-	if args.Err != nil {
-		m.errCh <- args.Err
-	}
-}
-
-// createStubServer creates a new xDS-enabled gRPC server and returns a
-// stubserver.StubServer that can be used for testing. The server is configured
-// with the provided modeChangeOpt and xdsclient.Pool.
-func createStubServer(t *testing.T, lis net.Listener, opts ...grpc.ServerOption) *stubserver.StubServer {
-	stub := &stubserver.StubServer{
-		Listener: lis,
-		EmptyCallF: func(ctx context.Context, in *testpb.Empty) (*testpb.Empty, error) {
-			return &testpb.Empty{}, nil
-		},
-		FullDuplexCallF: func(stream testgrpc.TestService_FullDuplexCallServer) error {
-			for {
-				if _, err := stream.Recv(); err == io.EOF {
-					return nil
-				} else if err != nil {
-					return err
-				}
-			}
-		},
-	}
-	server, err := xds.NewGRPCServer(opts...)
-	if err != nil {
-		t.Fatalf("Failed to create an xDS enabled gRPC server: %v", err)
-	}
-	stub.S = server
-	stubserver.StartTestService(t, stub)
-	t.Cleanup(stub.Stop)
-	return stub
-}
-
-// waitForSuccessfulRPC waits for an RPC to succeed, repeatedly calling the
-// EmptyCall RPC on the provided client connection until the call succeeds.
-// If the context is canceled or the expected error is not before the context
-// timeout expires, the test will fail.
-func waitForSuccessfulRPC(ctx context.Context, t *testing.T, cc *grpc.ClientConn, opts ...grpc.CallOption) {
-	t.Helper()
-
-	client := testgrpc.NewTestServiceClient(cc)
-	for {
-		select {
-		case <-ctx.Done():
-			t.Fatalf("Timeout waiting for RPCs to succeed")
-		case <-time.After(defaultTestShortTimeout):
-			if _, err := client.EmptyCall(ctx, &testpb.Empty{}, opts...); err == nil {
-				return
-			}
-		}
-	}
-}
-
-// waitForFailedRPCWithStatus waits for an RPC to fail with the expected status
-// code, error message, and node ID.  It repeatedly calls the EmptyCall RPC on
-// the provided client connection until the error matches the expected values.
-// If the context is canceled or the expected error is not before the context
-// timeout expires, the test will fail.
-func waitForFailedRPCWithStatus(ctx context.Context, t *testing.T, cc *grpc.ClientConn, wantCode codes.Code, wantErr, wantNodeID string) {
-	t.Helper()
-
-	client := testgrpc.NewTestServiceClient(cc)
-	var err error
-	for {
-		select {
-		case <-ctx.Done():
-			t.Fatalf("RPCs failed with most recent error: %v. Want status code %v, error: %s, node id: %s", err, wantCode, wantErr, wantNodeID)
-		case <-time.After(defaultTestShortTimeout):
-			_, err = client.EmptyCall(ctx, &testpb.Empty{})
-			if gotCode := status.Code(err); gotCode != wantCode {
-				continue
-			}
-			if gotErr := err.Error(); !strings.Contains(gotErr, wantErr) {
-				continue
-			}
-			if !strings.Contains(err.Error(), wantNodeID) {
-				continue
-			}
-			t.Logf("Most recent error happy case: %v", err.Error())
-			return
-		}
-	}
-}
-
-// Tests the basic scenario for an xDS enabled gRPC server.
-//
-//   - Verifies that the xDS enabled gRPC server requests for the expected
-//     listener resource.
-//   - Once the listener resource is received from the management server, it
-//     verifies that the xDS enabled gRPC server requests for the appropriate
-//     route configuration name. Also verifies that at this point, the server has
-//     not yet started serving RPCs
-//   - Once the route configuration is received from the management server, it
-//     verifies that the server can serve RPCs successfully.
-func (s) TestServer_Basic(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-
-	// Start an xDS management server.
-	listenerNamesCh := make(chan []string, 1)
-	routeNamesCh := make(chan []string, 1)
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{
-		OnStreamRequest: func(_ int64, req *v3discoverypb.DiscoveryRequest) error {
-			switch req.GetTypeUrl() {
-			case "type.googleapis.com/envoy.config.listener.v3.Listener":
-				select {
-				case listenerNamesCh <- req.GetResourceNames():
-				case <-ctx.Done():
-				}
-			case "type.googleapis.com/envoy.config.route.v3.RouteConfiguration":
-				select {
-				case routeNamesCh <- req.GetResourceNames():
-				case <-ctx.Done():
-				}
-			}
-			return nil
-		},
-		AllowResourceSubset: true,
-	})
+// TestServingModeChanges tests the Server's logic as it transitions from Not
+// Ready to Ready, then to Not Ready. Before it goes Ready, connections should
+// be accepted and closed. After it goes ready, RPC's should proceed as normal
+// according to matched route configuration. After it transitions back into not
+// ready (through an explicit LDS Resource Not Found), previously running RPC's
+// should be gracefully closed and still work, and new RPC's should fail.
+func (s) TestServingModeChanges(t *testing.T) {
+	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{AllowResourceSubset: true})
 
 	// Create bootstrap configuration pointing to the above management server.
 	nodeID := uuid.New().String()
 	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
 
-	// Create a listener on a local port to act as the xDS enabled gRPC server.
 	lis, err := testutils.LocalTCPListener()
 	if err != nil {
-		t.Fatalf("Failed to listen to local port: %v", err)
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
 	}
+	// Setup the management server to respond with a listener resource that
+	// specifies a route name to watch. Due to not having received the full
+	// configuration, this should cause the server to be in mode Serving.
 	host, port, err := hostPortFromListener(lis)
 	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
+		t.Fatalf("failed to retrieve host and port of server: %v", err)
 	}
 
-	// Configure the managegement server with a listener resource for the above
-	// xDS enabled gRPC server.
-	const routeConfigName = "routeName"
+	listener := e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")
 	resources := e2e.UpdateOptions{
 		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")},
+		Listeners:      []*v3listenerpb.Listener{listener},
 		SkipValidation: true,
 	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
 	if err := managementServer.Update(ctx, resources); err != nil {
 		t.Fatal(err)
 	}
 
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration.
+	serving := grpcsync.NewEvent()
+	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		t.Logf("serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
+		if args.Mode == connectivity.ServingModeServing {
+			serving.Fire()
+		}
+	})
+
+	stub := &stubserver.StubServer{
+		Listener: lis,
+		EmptyCallF: func(context.Context, *testpb.Empty) (*testpb.Empty, error) {
+			return &testpb.Empty{}, nil
+		},
+		UnaryCallF: func(context.Context, *testpb.SimpleRequest) (*testpb.SimpleResponse, error) {
+			return &testpb.SimpleResponse{}, nil
+		},
+		FullDuplexCallF: func(stream testgrpc.TestService_FullDuplexCallServer) error {
+			for {
+				_, err := stream.Recv() // hangs here forever if stream doesn't shut down...doesn't receive EOF without any errors
+				if err == io.EOF {
+					return nil
+				}
+			}
+		},
+	}
 	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
 	if err != nil {
 		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
 	}
 	pool := xdsclient.NewPool(config)
-	modeChangeHandler := newServingModeChangeHandler(t)
-	modeChangeOpt := xds.ServingModeCallback(modeChangeHandler.modeChangeCallback)
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	// Wait for the expected listener resource to be requested.
-	wantLisResourceNames := []string{fmt.Sprintf(e2e.ServerListenerResourceNameTemplate, net.JoinHostPort(host, strconv.Itoa(int(port))))}
-	select {
-	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the expected listener resource to be requested")
-	case gotLisResourceName := <-listenerNamesCh:
-		if !cmp.Equal(gotLisResourceName, wantLisResourceNames) {
-			t.Fatalf("Got unexpected listener resource names: %v, want %v", gotLisResourceName, wantLisResourceNames)
-		}
-	}
-
-	// Wait for the expected route config resource to be requested.
-	select {
-	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the expected route config resource to be requested")
-	case gotRouteNames := <-routeNamesCh:
-		if !cmp.Equal(gotRouteNames, []string{routeConfigName}) {
-			t.Fatalf("Got unexpected route config resource names: %v, want %v", gotRouteNames, []string{routeConfigName})
-		}
-	}
-
-	// Ensure that the server is not serving RPCs yet.
-	sCtx, sCancel := context.WithTimeout(ctx, defaultTestShortTimeout)
-	defer sCancel()
-	select {
-	case <-sCtx.Done():
-	case <-modeChangeHandler.modeCh:
-		t.Fatal("Server started serving RPCs before the route config was received")
+	sopts := []grpc.ServerOption{grpc.Creds(insecure.NewCredentials()), modeChangeOpt, xds.ClientPoolForTesting(pool)}
+	if stub.S, err = xds.NewGRPCServer(sopts...); err != nil {
+		t.Fatalf("Failed to create an xDS enabled gRPC server: %v", err)
 	}
-
-	// Create a gRPC channel to the xDS enabled server.
+	stubserver.StartTestService(t, stub)
+	defer stub.S.Stop()
 	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
 	if err != nil {
-		t.Fatalf("grpc.NewClient(%q) failed: %v", lis.Addr(), err)
+		t.Fatalf("failed to dial local test server: %v", err)
 	}
 	defer cc.Close()
 
-	// Ensure that the server isnt't serving RPCs successfully.
-	client := testgrpc.NewTestServiceClient(cc)
-	if _, err := client.EmptyCall(ctx, &testpb.Empty{}); err == nil || status.Code(err) != codes.Unavailable {
-		t.Fatalf("EmptyCall() returned %v, want %v", err, codes.Unavailable)
+	waitForFailedRPCWithStatus(ctx, t, cc, errAcceptAndClose)
+	routeConfig := e2e.RouteConfigNonForwardingAction("routeName")
+	resources = e2e.UpdateOptions{
+		NodeID:    nodeID,
+		Listeners: []*v3listenerpb.Listener{listener},
+		Routes:    []*v3routepb.RouteConfiguration{routeConfig},
 	}
-
-	// Configure the management server with the expected route config resource,
-	// and expext RPCs to succeed.
-	resources.Routes = []*v3routepb.RouteConfiguration{e2e.RouteConfigNonForwardingAction(routeConfigName)}
+	defer cancel()
 	if err := managementServer.Update(ctx, resources); err != nil {
 		t.Fatal(err)
 	}
+
 	select {
 	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the server to start serving RPCs")
-	case gotMode := <-modeChangeHandler.modeCh:
-		if gotMode != connectivity.ServingModeServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeServing)
-		}
+		t.Fatal("timeout waiting for the xDS Server to go Serving")
+	case <-serving.Done():
 	}
-	waitForSuccessfulRPC(ctx, t, cc)
-}
-
-// Tests that the xDS-enabled gRPC server cleans up all its resources when all
-// connections to it are closed.
-func (s) TestServer_ConnectionCleanup(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-
-	// Start an xDS management server.
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{})
 
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
+	// A unary RPC should work once it transitions into serving. (need this same
+	// assertion from LDS resource not found triggering it).
+	waitForSuccessfulRPC(ctx, t, cc, grpc.WaitForReady(true))
 
-	// Create a listener on a local port to act as the xDS enabled gRPC server.
-	lis, err := testutils.LocalTCPListener()
+	// Start a stream before switching the server to not serving. Due to the
+	// stream being created before the graceful stop of the underlying
+	// connection, it should be able to continue even after the server switches
+	// to not serving.
+	c := testgrpc.NewTestServiceClient(cc)
+	stream, err := c.FullDuplexCall(ctx)
 	if err != nil {
-		t.Fatalf("Failed to listen to local port: %v", err)
+		t.Fatalf("cc.FullDuplexCall failed: %f", err)
 	}
-	host, port, err := hostPortFromListener(lis)
+
+	// Lookup the xDS client in use based on the dedicated well-known key, as
+	// defined in A71, used by the xDS enabled gRPC server.
+	xdsC, close, err := pool.GetClientForTesting(xdsclient.NameForServer)
 	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
+		t.Fatalf("Failed to find xDS client for configuration: %v", string(bootstrapContents))
 	}
+	defer close()
 
-	// Configure the managegement server with a listener and route configuration
-	// resource for the above xDS enabled gRPC server.
-	const routeConfigName = "routeName"
-	resources := e2e.UpdateOptions{
-		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")},
-		Routes:         []*v3routepb.RouteConfiguration{e2e.RouteConfigNonForwardingAction(routeConfigName)},
-		SkipValidation: true,
-	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
+	// Invoke LDS Resource not found here (tests graceful close).
+	triggerResourceNotFound := internal.TriggerXDSResourceNotFoundForTesting.(func(xdsclient.XDSClient, xdsresource.Type, string) error)
+	listenerResourceType := xdsinternal.ResourceTypeMapForTesting[version.V3ListenerURL].(xdsresource.Type)
+	if err := triggerResourceNotFound(xdsC, listenerResourceType, listener.GetName()); err != nil {
+		t.Fatalf("Failed to trigger resource name not found for testing: %v", err)
 	}
 
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration.
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
+	// New RPCs on that connection should eventually start failing. Due to
+	// Graceful Stop any started streams continue to work.
+	if err = stream.Send(&testpb.StreamingOutputCallRequest{}); err != nil {
+		t.Fatalf("stream.Send() failed: %v, should continue to work due to graceful stop", err)
 	}
-	pool := xdsclient.NewPool(config)
-	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
-		t.Logf("Serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
-	})
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	// Create a gRPC channel and verify that RPCs succeed.
-	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("grpc.NewClient(%q) failed: %v", lis.Addr(), err)
+	if err = stream.CloseSend(); err != nil {
+		t.Fatalf("stream.CloseSend() failed: %v, should continue to work due to graceful stop", err)
 	}
-	defer cc.Close()
-	waitForSuccessfulRPC(ctx, t, cc)
-
-	// Create multiple channels to the server, and make an RPC on each one. When
-	// everything is closed, the server should have cleaned up all its resources
-	// as well (and this will be verified by the leakchecker).
-	const numConns = 100
-	var wg sync.WaitGroup
-	wg.Add(numConns)
-	for range numConns {
-		go func() {
-			defer wg.Done()
-			cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-			if err != nil {
-				t.Errorf("grpc.NewClient failed with err: %v", err)
-			}
-			client := testgrpc.NewTestServiceClient(cc)
-			if _, err := client.EmptyCall(ctx, &testpb.Empty{}); err != nil {
-				t.Errorf("EmptyCall() failed: %v", err)
-			}
-			cc.Close()
-		}()
+	if _, err = stream.Recv(); err != io.EOF {
+		t.Fatalf("unexpected error: %v, expected an EOF error", err)
 	}
-	wg.Wait()
+
+	// New RPCs on that connection should eventually start failing.
+	waitForFailedRPCWithStatus(ctx, t, cc, errAcceptAndClose)
 }
 
-// Tests that multiple xDS-enabled gRPC servers can be created with different
-// bootstrap configurations, and that they correctly request different LDS
-// resources from the management server based on their respective listening
-// ports.  It also ensures that gRPC clients can connect to the intended server
-// and that RPCs function correctly. The test uses the grpc.Peer() call option
-// to validate that the client is connected to the correct server.
-func (s) TestServer_MultipleServers_DifferentBootstrapConfigurations(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-	mgmtServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{AllowResourceSubset: true})
+// TestMultipleServers_DifferentBootstrapConfigurations verifies that multiple
+// xDS-enabled gRPC servers can be created with different bootstrap
+// configurations, and that they correctly request different LDS resources from
+// the management server based on their respective listening ports.  It also
+// ensures that gRPC clients can connect to the intended server and that RPCs
+// function correctly. The test uses the grpc.Peer() call option to validate
+// that the client is connected to the correct server.
+func (s) TestMultipleServers_DifferentBootstrapConfigurations(t *testing.T) {
+	// Setup an xDS management server.
+	mgmtServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{})
 
 	// Create two bootstrap configurations pointing to the above management server.
 	nodeID1 := uuid.New().String()
@@ -421,25 +251,50 @@ func (s) TestServer_MultipleServers_DifferentBootstrapConfigurations(t *testing.
 		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
 	}
 
-	modeChangeHandler1 := newServingModeChangeHandler(t)
-	modeChangeOpt1 := xds.ServingModeCallback(modeChangeHandler1.modeChangeCallback)
-	modeChangeHandler2 := newServingModeChangeHandler(t)
-	modeChangeOpt2 := xds.ServingModeCallback(modeChangeHandler2.modeChangeCallback)
-	config1, err := bootstrap.NewConfigFromContents(bootstrapContents1)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents1), err)
+	serving1 := grpcsync.NewEvent()
+	modeChangeOpt1 := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		t.Logf("Serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
+		if args.Mode == connectivity.ServingModeServing {
+			serving1.Fire()
+		}
+	})
+	serving2 := grpcsync.NewEvent()
+	modeChangeOpt2 := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		t.Logf("Serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
+		if args.Mode == connectivity.ServingModeServing {
+			serving2.Fire()
+		}
+	})
+
+	stub1 := &stubserver.StubServer{
+		Listener: lis1,
+		EmptyCallF: func(ctx context.Context, _ *testpb.Empty) (*testpb.Empty, error) {
+			return &testpb.Empty{}, nil
+		},
 	}
-	pool1 := xdsclient.NewPool(config1)
-	config2, err := bootstrap.NewConfigFromContents(bootstrapContents2)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents2), err)
+	if stub1.S, err = xds.NewGRPCServer(xds.BootstrapContentsForTesting(bootstrapContents1), modeChangeOpt1); err != nil {
+		t.Fatalf("Failed to create first xDS enabled gRPC server: %v", err)
+	}
+	stubserver.StartTestService(t, stub1)
+	defer stub1.S.Stop()
+
+	stub2 := &stubserver.StubServer{
+		Listener: lis2,
+		EmptyCallF: func(ctx context.Context, _ *testpb.Empty) (*testpb.Empty, error) {
+			return &testpb.Empty{}, nil
+		},
+	}
+	if stub2.S, err = xds.NewGRPCServer(xds.BootstrapContentsForTesting(bootstrapContents2), modeChangeOpt2); err != nil {
+		t.Fatalf("Failed to create second xDS enabled gRPC server: %v", err)
 	}
-	pool2 := xdsclient.NewPool(config2)
-	createStubServer(t, lis1, modeChangeOpt1, xds.ClientPoolForTesting(pool1))
-	createStubServer(t, lis2, modeChangeOpt2, xds.ClientPoolForTesting(pool2))
+	stubserver.StartTestService(t, stub2)
+	defer stub2.S.Stop()
 
 	// Update the management server with the listener resources pointing to the
 	// corresponding gRPC servers.
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+
 	host1, port1, err := hostPortFromListener(lis1)
 	if err != nil {
 		t.Fatalf("Failed to retrieve host and port of server: %v", err)
@@ -467,19 +322,13 @@ func (s) TestServer_MultipleServers_DifferentBootstrapConfigurations(t *testing.
 
 	select {
 	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the xDS-enabled gRPC server to go SERVING")
-	case gotMode := <-modeChangeHandler1.modeCh:
-		if gotMode != connectivity.ServingModeServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeServing)
-		}
+		t.Fatal("Timeout waiting for the server 1 to go Serving")
+	case <-serving1.Done():
 	}
 	select {
 	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the xDS-enabled gRPC server to go SERVING")
-	case gotMode := <-modeChangeHandler2.modeCh:
-		if gotMode != connectivity.ServingModeServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeServing)
-		}
+		t.Fatal("Timeout waiting for the server 2 to go Serving")
+	case <-serving2.Done():
 	}
 
 	// Create two gRPC clients, one for each server.
@@ -508,3 +357,149 @@ func (s) TestServer_MultipleServers_DifferentBootstrapConfigurations(t *testing.
 		t.Errorf("Connected to wrong peer: %s, want %s", peer2.Addr, lis2.Addr())
 	}
 }
+
+// TestResourceNotFoundRDS tests the case where an LDS points to an RDS which
+// returns resource not found. Before getting the resource not found, the xDS
+// Server has not received all configuration needed, so it should Accept and
+// Close any new connections. After it has received the resource not found
+// error, the server should move to serving, successfully Accept Connections,
+// and fail at the L7 level with resource not found specified.
+func (s) TestResourceNotFoundRDS(t *testing.T) {
+	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{AllowResourceSubset: true})
+
+	// Create bootstrap configuration pointing to the above management server.
+	nodeID := uuid.New().String()
+	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
+
+	lis, err := testutils.LocalTCPListener()
+	if err != nil {
+		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
+	}
+	// Setup the management server to respond with a listener resource that
+	// specifies a route name to watch, and no RDS resource corresponding to
+	// this route name.
+	host, port, err := hostPortFromListener(lis)
+	if err != nil {
+		t.Fatalf("failed to retrieve host and port of server: %v", err)
+	}
+
+	const routeConfigResourceName = "routeName"
+	listener := e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, routeConfigResourceName)
+	resources := e2e.UpdateOptions{
+		NodeID:         nodeID,
+		Listeners:      []*v3listenerpb.Listener{listener},
+		SkipValidation: true,
+	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
+	defer cancel()
+	if err := managementServer.Update(ctx, resources); err != nil {
+		t.Fatal(err)
+	}
+	serving := grpcsync.NewEvent()
+	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
+		t.Logf("serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
+		if args.Mode == connectivity.ServingModeServing {
+			serving.Fire()
+		}
+	})
+
+	stub := &stubserver.StubServer{
+		Listener: lis,
+		EmptyCallF: func(context.Context, *testpb.Empty) (*testpb.Empty, error) {
+			return &testpb.Empty{}, nil
+		},
+		UnaryCallF: func(context.Context, *testpb.SimpleRequest) (*testpb.SimpleResponse, error) {
+			return &testpb.SimpleResponse{}, nil
+		},
+		FullDuplexCallF: func(stream testgrpc.TestService_FullDuplexCallServer) error {
+			for {
+				_, err := stream.Recv() // hangs here forever if stream doesn't shut down...doesn't receive EOF without any errors
+				if err == io.EOF {
+					return nil
+				}
+			}
+		},
+	}
+	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
+	if err != nil {
+		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
+	}
+	pool := xdsclient.NewPool(config)
+	sopts := []grpc.ServerOption{grpc.Creds(insecure.NewCredentials()), modeChangeOpt, xds.ClientPoolForTesting(pool)}
+	if stub.S, err = xds.NewGRPCServer(sopts...); err != nil {
+		t.Fatalf("Failed to create an xDS enabled gRPC server: %v", err)
+	}
+	stubserver.StartTestService(t, stub)
+	defer stub.S.Stop()
+
+	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
+	if err != nil {
+		t.Fatalf("failed to dial local test server: %v", err)
+	}
+	defer cc.Close()
+
+	waitForFailedRPCWithStatus(ctx, t, cc, errAcceptAndClose)
+
+	// Lookup the xDS client in use based on the dedicated well-known key, as
+	// defined in A71, used by the xDS enabled gRPC server.
+	xdsC, close, err := pool.GetClientForTesting(xdsclient.NameForServer)
+	if err != nil {
+		t.Fatalf("Failed to find xDS client for configuration: %v", string(bootstrapContents))
+	}
+	defer close()
+
+	// Invoke resource not found - this should result in L7 RPC error with
+	// unavailable receive on serving as a result, should trigger it to go
+	// serving. Poll as watch might not be started yet to trigger resource not
+	// found.
+	triggerResourceNotFound := internal.TriggerXDSResourceNotFoundForTesting.(func(xdsclient.XDSClient, xdsresource.Type, string) error)
+	routeConfigResourceType := xdsinternal.ResourceTypeMapForTesting[version.V3RouteConfigURL].(xdsresource.Type)
+loop:
+	for {
+		if err := triggerResourceNotFound(xdsC, routeConfigResourceType, routeConfigResourceName); err != nil {
+			t.Fatalf("Failed to trigger resource name not found for testing: %v", err)
+		}
+		select {
+		case <-serving.Done():
+			break loop
+		case <-ctx.Done():
+			t.Fatalf("timed out waiting for serving mode to go serving")
+		case <-time.After(time.Millisecond):
+		}
+	}
+	waitForFailedRPCWithStatus(ctx, t, cc, status.New(codes.Unavailable, "error from xDS configuration for matched route configuration"))
+}
+
+func waitForSuccessfulRPC(ctx context.Context, t *testing.T, cc *grpc.ClientConn, opts ...grpc.CallOption) {
+	t.Helper()
+
+	c := testgrpc.NewTestServiceClient(cc)
+	if _, err := c.EmptyCall(ctx, &testpb.Empty{}, opts...); err != nil {
+		t.Fatalf("rpc EmptyCall() failed: %v", err)
+	}
+}
+
+// waitForFailedRPCWithStatus makes unary RPC's until it receives the expected
+// status in a polling manner. Fails if the RPC made does not return the
+// expected status before the context expires.
+func waitForFailedRPCWithStatus(ctx context.Context, t *testing.T, cc *grpc.ClientConn, st *status.Status) {
+	t.Helper()
+
+	c := testgrpc.NewTestServiceClient(cc)
+	ticker := time.NewTicker(10 * time.Millisecond)
+	defer ticker.Stop()
+	var err error
+	for {
+		select {
+		case <-ctx.Done():
+			t.Fatalf("failure when waiting for RPCs to fail with certain status %v: %v. most recent error received from RPC: %v", st, ctx.Err(), err)
+		case <-ticker.C:
+			_, err = c.EmptyCall(ctx, &testpb.Empty{})
+			if status.Code(err) == st.Code() && strings.Contains(err.Error(), st.Message()) {
+				t.Logf("most recent error happy case: %v", err.Error())
+				return
+			}
+		}
+	}
+}
diff --git a/xds/server_resource_ext_test.go b/xds/server_resource_ext_test.go
deleted file mode 100644
index 364d27a0..00000000
--- a/xds/server_resource_ext_test.go
+++ /dev/null
@@ -1,650 +0,0 @@
-/*
- *
- * Copyright 2025 gRPC authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-package xds_test
-
-import (
-	"context"
-	"fmt"
-	"io"
-	"net"
-	"strings"
-	"testing"
-
-	"github.com/google/go-cmp/cmp"
-	"github.com/google/uuid"
-	"google.golang.org/grpc"
-	"google.golang.org/grpc/codes"
-	"google.golang.org/grpc/connectivity"
-	"google.golang.org/grpc/credentials/insecure"
-	"google.golang.org/grpc/internal"
-	"google.golang.org/grpc/internal/testutils"
-	"google.golang.org/grpc/internal/testutils/xds/e2e"
-	"google.golang.org/grpc/internal/xds/bootstrap"
-	"google.golang.org/grpc/xds"
-	xdsinternal "google.golang.org/grpc/xds/internal"
-	"google.golang.org/grpc/xds/internal/xdsclient"
-	"google.golang.org/grpc/xds/internal/xdsclient/xdsresource"
-	"google.golang.org/grpc/xds/internal/xdsclient/xdsresource/version"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-
-	v3corepb "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
-	v3listenerpb "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
-	v3routepb "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
-	v3routerpb "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3"
-	v3httppb "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
-	v3discoverypb "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
-	testgrpc "google.golang.org/grpc/interop/grpc_testing"
-	testpb "google.golang.org/grpc/interop/grpc_testing"
-)
-
-// Tests the case where an LDS points to an RDS which returns resource not
-// found. Before getting the resource not found, the xDS Server has not received
-// all configuration needed, so it should Accept and Close any new connections.
-// After it has received the resource not found error, the server should move to
-// serving, successfully Accept Connections, and fail at the L7 level with
-// resource not found specified.
-func (s) TestServer_RouteConfiguration_ResourceNotFound(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-	routeConfigNamesCh := make(chan []string, 1)
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{
-		OnStreamRequest: func(_ int64, req *v3discoverypb.DiscoveryRequest) error {
-			if req.TypeUrl == version.V3RouteConfigURL {
-				select {
-				case routeConfigNamesCh <- req.GetResourceNames():
-				case <-ctx.Done():
-				}
-			}
-			return nil
-		},
-		AllowResourceSubset: true,
-	})
-
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
-
-	// Setup the management server to respond with a listener resource that
-	// specifies a route name to watch, and no RDS resource corresponding to
-	// this route name.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
-	}
-	host, port, err := hostPortFromListener(lis)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-
-	const routeConfigResourceName = "routeName"
-	listener := e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, routeConfigResourceName)
-	resources := e2e.UpdateOptions{
-		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{listener},
-		SkipValidation: true,
-	}
-
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-	modeChangeHandler := newServingModeChangeHandler(t)
-	modeChangeOpt := xds.ServingModeCallback(modeChangeHandler.modeChangeCallback)
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	// Wait for the route configuration resource to be requested from the
-	// management server.
-	select {
-	case gotNames := <-routeConfigNamesCh:
-		if !cmp.Equal(gotNames, []string{routeConfigResourceName}) {
-			t.Fatalf("Requested route config resource names: %v, want %v", gotNames, []string{routeConfigResourceName})
-		}
-	case <-ctx.Done():
-		t.Fatal("Timeout waiting for route config resource to be requested")
-	}
-
-	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("failed to dial local test server: %v", err)
-	}
-	defer cc.Close()
-	waitForFailedRPCWithStatus(ctx, t, cc, codes.Unavailable, "", "")
-
-	// Lookup the xDS client in use based on the dedicated well-known key, as
-	// defined in A71, used by the xDS enabled gRPC server.
-	xdsC, close, err := pool.GetClientForTesting(xdsclient.NameForServer)
-	if err != nil {
-		t.Fatalf("Failed to find xDS client for configuration: %v", string(bootstrapContents))
-	}
-	defer close()
-
-	// Invoke resource not found error for the route configuration resource.
-	// This should cause the server to go SERVING, but fail RPCs with the
-	// appropriate error code.
-	triggerResourceNotFound := internal.TriggerXDSResourceNotFoundForTesting.(func(xdsclient.XDSClient, xdsresource.Type, string) error)
-	routeConfigResourceType := xdsinternal.ResourceTypeMapForTesting[version.V3RouteConfigURL].(xdsresource.Type)
-	if err := triggerResourceNotFound(xdsC, routeConfigResourceType, routeConfigResourceName); err != nil {
-		t.Fatalf("Failed to trigger resource name not found for testing: %v", err)
-	}
-	select {
-	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the xDS-enabled gRPC server to go SERVING")
-	case gotMode := <-modeChangeHandler.modeCh:
-		if gotMode != connectivity.ServingModeServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeServing)
-		}
-	}
-	waitForFailedRPCWithStatus(ctx, t, cc, codes.Unavailable, "error from xDS configuration for matched route configuration", nodeID)
-}
-
-// Tests the scenario where the control plane sends the same resource update. It
-// verifies that the mode change callback is not invoked and client connections
-// to the server are not recycled.
-func (s) TestServer_RedundantUpdateSuppression(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{AllowResourceSubset: true})
-
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
-
-	// Setup the management server to respond with the listener resources.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
-	}
-	host, port, err := hostPortFromListener(lis)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-	listener := e2e.DefaultServerListener(host, port, e2e.SecurityLevelNone, "routeName")
-	resources := e2e.UpdateOptions{
-		NodeID:    nodeID,
-		Listeners: []*v3listenerpb.Listener{listener},
-	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration.
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	modeChangeHandler := newServingModeChangeHandler(t)
-	modeChangeOpt := xds.ServingModeCallback(modeChangeHandler.modeChangeCallback)
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	select {
-	case <-ctx.Done():
-		t.Fatalf("Timed out waiting for a mode change update: %v", err)
-	case mode := <-modeChangeHandler.modeCh:
-		if mode != connectivity.ServingModeServing {
-			t.Fatalf("Listener received new mode %v, want %v", mode, connectivity.ServingModeServing)
-		}
-	}
-
-	// Create a ClientConn and make a successful RPCs.
-	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("grpc.NewClient(%q) failed: %v", lis.Addr(), err)
-	}
-	defer cc.Close()
-	waitForSuccessfulRPC(ctx, t, cc)
-
-	// Start a goroutine to make sure that we do not see any connectivity state
-	// changes on the client connection. If redundant updates are not
-	// suppressed, server will recycle client connections.
-	errCh := make(chan error, 1)
-	go func() {
-		prev := connectivity.Ready // We know we are READY since we just did an RPC.
-		for {
-			curr := cc.GetState()
-			if !(curr == connectivity.Ready || curr == connectivity.Idle) {
-				errCh <- fmt.Errorf("unexpected connectivity state change {%s --> %s} on the client connection", prev, curr)
-				return
-			}
-			if !cc.WaitForStateChange(ctx, curr) {
-				// Break out of the for loop when the context has been cancelled.
-				break
-			}
-			prev = curr
-		}
-		errCh <- nil
-	}()
-
-	// Update the management server with the same listener resource. This will
-	// update the resource version though, and should result in a the management
-	// server sending the same resource to the xDS-enabled gRPC server.
-	if err := managementServer.Update(ctx, e2e.UpdateOptions{
-		NodeID:    nodeID,
-		Listeners: []*v3listenerpb.Listener{listener},
-	}); err != nil {
-		t.Fatal(err)
-	}
-
-	// Since redundant resource updates are suppressed, we should not see the
-	// mode change callback being invoked.
-	sCtx, sCancel := context.WithTimeout(ctx, defaultTestShortTimeout)
-	defer sCancel()
-	select {
-	case <-sCtx.Done():
-	case mode := <-modeChangeHandler.modeCh:
-		t.Fatalf("Unexpected mode change callback with new mode %v", mode)
-	}
-
-	// Make sure RPCs continue to succeed.
-	waitForSuccessfulRPC(ctx, t, cc)
-
-	// Cancel the context to ensure that the WaitForStateChange call exits early
-	// and returns false.
-	cancel()
-	if err := <-errCh; err != nil {
-		t.Fatal(err)
-	}
-}
-
-// Tests the case where the route configuration contains an unsupported route
-// action.  Verifies that RPCs fail with UNAVAILABLE.
-func (s) TestServer_FailWithRouteActionRoute(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-
-	// Start an xDS management server.
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{})
-
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
-
-	// Configure the managegement server with a listener and route configuration
-	// resource for the above xDS enabled gRPC server.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("Failed to listen to local port: %v", err)
-	}
-	host, port, err := hostPortFromListener(lis)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-	const routeConfigName = "routeName"
-	resources := e2e.UpdateOptions{
-		NodeID:    nodeID,
-		Listeners: []*v3listenerpb.Listener{e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")},
-		Routes:    []*v3routepb.RouteConfiguration{e2e.RouteConfigNonForwardingAction(routeConfigName)},
-	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration.
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
-		t.Logf("Serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
-	})
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	// Create a gRPC channel and verify that RPCs succeed.
-	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("grpc.NewClient(%q) failed: %v", lis.Addr(), err)
-	}
-	defer cc.Close()
-	waitForSuccessfulRPC(ctx, t, cc)
-
-	// Update the route config resource to contain an unsupported action.
-	//
-	// "NonForwardingAction is expected for all Routes used on server-side; a
-	// route with an inappropriate action causes RPCs matching that route to
-	// fail with UNAVAILABLE." - A36
-	resources.Routes = []*v3routepb.RouteConfiguration{e2e.RouteConfigFilterAction("routeName")}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-	waitForFailedRPCWithStatus(ctx, t, cc, codes.Unavailable, "the incoming RPC matched to a route that was not of action type non forwarding", nodeID)
-}
-
-// Tests the case where the listener resource is removed from the management
-// server. This should cause the xDS server to transition to NOT_SERVING mode,
-// and the error message should contain the xDS node ID.
-func (s) TestServer_ListenerResourceRemoved(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-
-	// Start an xDS management server.
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{})
-
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
-
-	// Configure the managegement server with a listener and route configuration
-	// resource for the above xDS enabled gRPC server.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("Failed to listen to local port: %v", err)
-	}
-	host, port, err := hostPortFromListener(lis)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-	const routeConfigName = "routeName"
-	resources := e2e.UpdateOptions{
-		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")},
-		Routes:         []*v3routepb.RouteConfiguration{e2e.RouteConfigNonForwardingAction(routeConfigName)},
-		SkipValidation: true,
-	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration.
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	modeChangeHandler := newServingModeChangeHandler(t)
-	modeChangeOpt := xds.ServingModeCallback(modeChangeHandler.modeChangeCallback)
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	select {
-	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the xDS-enabled gRPC server to go SERVING")
-	case gotMode := <-modeChangeHandler.modeCh:
-		if gotMode != connectivity.ServingModeServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeServing)
-		}
-	}
-
-	// Create a gRPC channel and verify that RPCs succeed.
-	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("grpc.NewClient(%q) failed: %v", lis.Addr(), err)
-	}
-	defer cc.Close()
-	waitForSuccessfulRPC(ctx, t, cc)
-
-	// Remove the listener resource from the management server. This should
-	// cause the server to go NOT_SERVING, and the error message should contain
-	// the xDS node ID.
-	resources.Listeners = nil
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-	select {
-	case <-ctx.Done():
-		t.Fatalf("Timed out waiting for server to go NOT_SERVING")
-	case gotMode := <-modeChangeHandler.modeCh:
-		if gotMode != connectivity.ServingModeNotServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeNotServing)
-		}
-		gotErr := <-modeChangeHandler.errCh
-		if gotErr == nil || !strings.Contains(gotErr.Error(), nodeID) {
-			t.Fatalf("Unexpected error: %v, want xDS Node id: %s", gotErr, nodeID)
-		}
-	}
-}
-
-// Tests the case where the listener resource points to a route configuration
-// name that is NACKed. This should trigger the server to move to SERVING,
-// successfully accept connections, and fail at RPCs with an expected error
-// message.
-func (s) TestServer_RouteConfiguration_ResourceNACK(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-
-	// Start an xDS management server.
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{})
-
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
-
-	// Configure the managegement server with a listener and route configuration
-	// resource (that will be NACKed) for the above xDS enabled gRPC server.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("Failed to listen to local port: %v", err)
-	}
-	host, port, err := hostPortFromListener(lis)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-	const routeConfigName = "routeName"
-	resources := e2e.UpdateOptions{
-		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")},
-		Routes:         []*v3routepb.RouteConfiguration{e2e.RouteConfigNoRouteMatch(routeConfigName)},
-		SkipValidation: true,
-	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration.
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	modeChangeHandler := newServingModeChangeHandler(t)
-	modeChangeOpt := xds.ServingModeCallback(modeChangeHandler.modeChangeCallback)
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	// Create a gRPC channel and verify that RPCs succeed.
-	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("grpc.NewClient(%q) failed: %v", lis.Addr(), err)
-	}
-	defer cc.Close()
-
-	select {
-	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the server to start serving RPCs")
-	case gotMode := <-modeChangeHandler.modeCh:
-		if gotMode != connectivity.ServingModeServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeServing)
-		}
-	}
-	waitForFailedRPCWithStatus(ctx, t, cc, codes.Unavailable, "error from xDS configuration for matched route configuration", nodeID)
-}
-
-// Tests the case where the listener resource points to multiple route
-// configuration resources.
-//
-//   - Initially the listener resource points to three route configuration
-//     resources (A, B and C). The filter chain in the listener matches incoming
-//     connections to route A, and RPCs are expected to succeed.
-//   - A streaming RPC is also kept open at this point.
-//   - The listener resource is then updated to point to two route configuration
-//     resources (A and B). The filter chain in the listener resource does not
-//     match to any of the configured routes. The default filter chain though
-//     matches to route B, which contains a route action of type "Route", and this
-//     is not supported on the server side. New RPCs are expected to fail, while
-//     any ongoing RPCs should be allowed to complete.
-//   - The listener resource is then updated to point to a single route
-//     configuration (A), and the filter chain in the listener matches to route A.
-//     New RPCs are expected to succeed at this point.
-func (s) TestServer_MultipleRouteConfigurations(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-
-	// Start an xDS management server.
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{})
-
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
-
-	// Create a listener on a local port to act as the xDS enabled gRPC server.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("Failed to listen to local port: %v", err)
-	}
-	host, port, err := hostPortFromListener(lis)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-
-	// Setup the management server to respond with a listener resource that
-	// specifies three route names to watch, and the corresponding route
-	// configuration resources.
-	const routeConfigNameA = "routeName-A"
-	const routeConfigNameB = "routeName-B"
-	const routeConfigNameC = "routeName-C"
-	ldsResource := e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, routeConfigNameA)
-	ldsResource.FilterChains = append(ldsResource.FilterChains,
-		filterChainWontMatch(t, routeConfigNameB, "1.1.1.1", []uint32{1}),
-		filterChainWontMatch(t, routeConfigNameC, "2.2.2.2", []uint32{2}),
-	)
-	routeConfigA := e2e.RouteConfigNonForwardingAction(routeConfigNameA)
-	routeConfigB := e2e.RouteConfigFilterAction(routeConfigNameB) // Unsupported route action on server.
-	routeConfigC := e2e.RouteConfigFilterAction(routeConfigNameC) // Unsupported route action on server.
-	resources := e2e.UpdateOptions{
-		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{ldsResource},
-		Routes:         []*v3routepb.RouteConfiguration{routeConfigA, routeConfigB, routeConfigC},
-		SkipValidation: true,
-	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration.
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	modeChangeOpt := xds.ServingModeCallback(func(addr net.Addr, args xds.ServingModeChangeArgs) {
-		t.Logf("Serving mode for listener %q changed to %q, err: %v", addr.String(), args.Mode, args.Err)
-	})
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	// Create a gRPC channel and verify that RPCs succeed.
-	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("grpc.NewClient(%q) failed: %v", lis.Addr(), err)
-	}
-	defer cc.Close()
-	waitForSuccessfulRPC(ctx, t, cc)
-
-	// Start a streaming RPC and keep the stream open.
-	client := testgrpc.NewTestServiceClient(cc)
-	stream, err := client.FullDuplexCall(ctx)
-	if err != nil {
-		t.Fatalf("FullDuplexCall failed: %v", err)
-	}
-	if err = stream.Send(&testpb.StreamingOutputCallRequest{}); err != nil {
-		t.Fatalf("stream.Send() failed: %v, should continue to work due to graceful stop", err)
-	}
-
-	// Update the listener resource such that the filter chain does not match
-	// incoming connections to route A. Instead a default filter chain matches
-	// to route B, which contains an unsupported route action.
-	ldsResource = e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, routeConfigNameA)
-	ldsResource.FilterChains = []*v3listenerpb.FilterChain{filterChainWontMatch(t, routeConfigNameA, "1.1.1.1", []uint32{1})}
-	ldsResource.DefaultFilterChain = filterChainWontMatch(t, routeConfigNameB, "2.2.2.2", []uint32{2})
-	resources.Listeners = []*v3listenerpb.Listener{ldsResource}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// xDS is eventually consistent. So simply poll for the new change to be
-	// reflected.
-	// "NonForwardingAction is expected for all Routes used on server-side; a
-	// route with an inappropriate action causes RPCs matching that route to
-	// fail with UNAVAILABLE." - A36
-	waitForFailedRPCWithStatus(ctx, t, cc, codes.Unavailable, "the incoming RPC matched to a route that was not of action type non forwarding", nodeID)
-
-	// Stream should be allowed to continue on the old working configuration -
-	// as it on a connection that is gracefully closed (old FCM/LDS
-	// Configuration which is allowed to continue).
-	if err = stream.CloseSend(); err != nil {
-		t.Fatalf("stream.CloseSend() failed: %v, should continue to work due to graceful stop", err)
-	}
-	if _, err = stream.Recv(); err != io.EOF {
-		t.Fatalf("unexpected error: %v, expected an EOF error", err)
-	}
-
-	// Update the listener resource to point to a single route configuration
-	// that is expected to match and verify that RPCs succeed.
-	resources.Listeners = []*v3listenerpb.Listener{e2e.DefaultServerListener(host, port, e2e.SecurityLevelNone, routeConfigNameA)}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-	waitForSuccessfulRPC(ctx, t, cc)
-}
-
-// filterChainWontMatch returns a filter chain that won't match if running the
-// test locally.
-func filterChainWontMatch(t *testing.T, routeName string, addressPrefix string, srcPorts []uint32) *v3listenerpb.FilterChain {
-	hcm := &v3httppb.HttpConnectionManager{
-		RouteSpecifier: &v3httppb.HttpConnectionManager_Rds{
-			Rds: &v3httppb.Rds{
-				ConfigSource: &v3corepb.ConfigSource{
-					ConfigSourceSpecifier: &v3corepb.ConfigSource_Ads{Ads: &v3corepb.AggregatedConfigSource{}},
-				},
-				RouteConfigName: routeName,
-			},
-		},
-		HttpFilters: []*v3httppb.HttpFilter{e2e.HTTPFilter("router", &v3routerpb.Router{})},
-	}
-	return &v3listenerpb.FilterChain{
-		Name: routeName + "-wont-match",
-		FilterChainMatch: &v3listenerpb.FilterChainMatch{
-			PrefixRanges: []*v3corepb.CidrRange{
-				{
-					AddressPrefix: addressPrefix,
-					PrefixLen: &wrapperspb.UInt32Value{
-						Value: uint32(0),
-					},
-				},
-			},
-			SourceType:  v3listenerpb.FilterChainMatch_SAME_IP_OR_LOOPBACK,
-			SourcePorts: srcPorts,
-			SourcePrefixRanges: []*v3corepb.CidrRange{
-				{
-					AddressPrefix: addressPrefix,
-					PrefixLen: &wrapperspb.UInt32Value{
-						Value: uint32(0),
-					},
-				},
-			},
-		},
-		Filters: []*v3listenerpb.Filter{
-			{
-				Name:       "filter-1",
-				ConfigType: &v3listenerpb.Filter_TypedConfig{TypedConfig: testutils.MarshalAny(t, hcm)},
-			},
-		},
-	}
-}
diff --git a/xds/server_serving_mode_ext_test.go b/xds/server_serving_mode_ext_test.go
deleted file mode 100644
index ce4f65f1..00000000
--- a/xds/server_serving_mode_ext_test.go
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- *
- * Copyright 2025 gRPC authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-package xds_test
-
-import (
-	"context"
-	"io"
-	"strings"
-	"testing"
-
-	"github.com/google/uuid"
-	"google.golang.org/grpc"
-	"google.golang.org/grpc/codes"
-	"google.golang.org/grpc/connectivity"
-	"google.golang.org/grpc/credentials/insecure"
-	"google.golang.org/grpc/internal/testutils"
-	"google.golang.org/grpc/internal/testutils/xds/e2e"
-	"google.golang.org/grpc/internal/testutils/xds/e2e/setup"
-	"google.golang.org/grpc/internal/xds/bootstrap"
-	"google.golang.org/grpc/status"
-	"google.golang.org/grpc/xds"
-	"google.golang.org/grpc/xds/internal/xdsclient"
-
-	v3listenerpb "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
-	v3routepb "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
-	testgrpc "google.golang.org/grpc/interop/grpc_testing"
-	testpb "google.golang.org/grpc/interop/grpc_testing"
-)
-
-// Tests the Server's logic as it transitions from NOT_SERVING to SERVING, then
-// to NOT_SERVING again. Before it goes to SERVING, connections should be
-// accepted and closed. After it goes SERVING, RPC's should proceed as normal
-// according to matched route configuration. After it transitions back into
-// NOT_SERVING, (through an explicit LDS Resource Not Found), previously running
-// RPC's should be gracefully closed and still work, and new RPC's should fail.
-func (s) TestServer_ServingModeChanges_SingleServer(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-	managementServer := e2e.StartManagementServer(t, e2e.ManagementServerOptions{AllowResourceSubset: true})
-
-	// Create bootstrap configuration pointing to the above management server.
-	nodeID := uuid.New().String()
-	bootstrapContents := e2e.DefaultBootstrapContents(t, nodeID, managementServer.Address)
-
-	// Setup the management server to respond with a listener resource that
-	// specifies a route name to watch. Due to not having received the full
-	// configuration, this should cause the server to be in mode NOT_SERVING.
-	lis, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
-	}
-	host, port, err := hostPortFromListener(lis)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-	listener := e2e.DefaultServerListenerWithRouteConfigName(host, port, e2e.SecurityLevelNone, "routeName")
-	resources := e2e.UpdateOptions{
-		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{listener},
-		SkipValidation: true,
-	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Start an xDS-enabled gRPC server with the above bootstrap configuration.
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	modeChangeHandler := newServingModeChangeHandler(t)
-	modeChangeOpt := xds.ServingModeCallback(modeChangeHandler.modeChangeCallback)
-	createStubServer(t, lis, modeChangeOpt, xds.ClientPoolForTesting(pool))
-
-	// Start a gRPC channel to the above server. The server is yet to receive
-	// route configuration, and therefore RPCs must fail at this time.
-	cc, err := grpc.NewClient(lis.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("Failed to dial local test server: %v", err)
-	}
-	defer cc.Close()
-	waitForFailedRPCWithStatus(ctx, t, cc, codes.Unavailable, "", "")
-
-	// Setup the route configuration resource on the management server. This
-	// should cause the xDS-enabled gRPC server to move to SERVING mode.
-	routeConfig := e2e.RouteConfigNonForwardingAction("routeName")
-	resources = e2e.UpdateOptions{
-		NodeID:         nodeID,
-		Listeners:      []*v3listenerpb.Listener{listener},
-		Routes:         []*v3routepb.RouteConfiguration{routeConfig},
-		SkipValidation: true,
-	}
-	defer cancel()
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-	select {
-	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the xDS-enabled gRPC server to go SERVING")
-	case gotMode := <-modeChangeHandler.modeCh:
-		if gotMode != connectivity.ServingModeServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeServing)
-		}
-	}
-	waitForSuccessfulRPC(ctx, t, cc)
-
-	// Start a stream before switching the server to not serving. Due to the
-	// stream being created before the graceful stop of the underlying
-	// connection, it should be able to continue even after the server switches
-	// to not serving.
-	c := testgrpc.NewTestServiceClient(cc)
-	stream, err := c.FullDuplexCall(ctx)
-	if err != nil {
-		t.Fatalf("cc.FullDuplexCall failed: %f", err)
-	}
-
-	// Remove the listener resource from the management server.
-	resources.Listeners = nil
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Ensure the server is in NOT_SERVING mode.
-	select {
-	case <-ctx.Done():
-		t.Fatal("Timeout waiting for the xDS-enabled gRPC server to go NOT_SERVING")
-	case gotMode := <-modeChangeHandler.modeCh:
-		if gotMode != connectivity.ServingModeNotServing {
-			t.Fatalf("Mode changed to %v, want %v", gotMode, connectivity.ServingModeNotServing)
-		}
-		gotErr := <-modeChangeHandler.errCh
-		if gotErr == nil || !strings.Contains(gotErr.Error(), nodeID) {
-			t.Fatalf("Unexpected error: %v, want xDS Node id: %s", gotErr, nodeID)
-		}
-	}
-
-	// Due to graceful stop, any started streams continue to work.
-	if err = stream.Send(&testpb.StreamingOutputCallRequest{}); err != nil {
-		t.Fatalf("stream.Send() failed: %v, should continue to work due to graceful stop", err)
-	}
-	if err = stream.CloseSend(); err != nil {
-		t.Fatalf("stream.CloseSend() failed: %v, should continue to work due to graceful stop", err)
-	}
-	if _, err = stream.Recv(); err != io.EOF {
-		t.Fatalf("stream.Recv() failed with %v, want io.EOF", err)
-	}
-
-	// New RPCs on that connection should eventually start failing.
-	waitForFailedRPCWithStatus(ctx, t, cc, codes.Unavailable, "", "")
-}
-
-// Tests the serving mode functionality with multiple xDS enabled gRPC servers.
-func (s) TestServer_ServingModeChanges_MultipleServers(t *testing.T) {
-	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
-	defer cancel()
-	managementServer, nodeID, bootstrapContents, _ := setup.ManagementServerAndResolver(t)
-
-	// Create two local listeners and pass it to Serve().
-	lis1, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
-	}
-	lis2, err := testutils.LocalTCPListener()
-	if err != nil {
-		t.Fatalf("testutils.LocalTCPListener() failed: %v", err)
-	}
-
-	// Create a server option to get notified about serving mode changes.
-	modeChangeHandler1 := newServingModeChangeHandler(t)
-	modeChangeOpt1 := xds.ServingModeCallback(modeChangeHandler1.modeChangeCallback)
-	modeChangeHandler2 := newServingModeChangeHandler(t)
-	modeChangeOpt2 := xds.ServingModeCallback(modeChangeHandler2.modeChangeCallback)
-
-	// Start two xDS-enabled gRPC servers with the above bootstrap configuration.
-	config, err := bootstrap.NewConfigFromContents(bootstrapContents)
-	if err != nil {
-		t.Fatalf("Failed to parse bootstrap contents: %s, %v", string(bootstrapContents), err)
-	}
-	pool := xdsclient.NewPool(config)
-	createStubServer(t, lis1, modeChangeOpt1, xds.ClientPoolForTesting(pool))
-	createStubServer(t, lis2, modeChangeOpt2, xds.ClientPoolForTesting(pool))
-
-	// Setup the management server to respond with server-side Listener
-	// resources for both listeners.
-	host1, port1, err := hostPortFromListener(lis1)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-	listener1 := e2e.DefaultServerListener(host1, port1, e2e.SecurityLevelNone, "routeName")
-	host2, port2, err := hostPortFromListener(lis2)
-	if err != nil {
-		t.Fatalf("Failed to retrieve host and port of server: %v", err)
-	}
-	listener2 := e2e.DefaultServerListener(host2, port2, e2e.SecurityLevelNone, "routeName")
-	resources := e2e.UpdateOptions{
-		NodeID:    nodeID,
-		Listeners: []*v3listenerpb.Listener{listener1, listener2},
-	}
-	if err := managementServer.Update(ctx, resources); err != nil {
-		t.Fatal(err)
-	}
-
-	// Wait for both listeners to move to "serving" mode.
-	select {
-	case <-ctx.Done():
-		t.Fatalf("Timed out waiting for a mode change update: %v", err)
-	case mode := <-modeChangeHandler1.modeCh:
-		if mode != connectivity.ServingModeServing {
-			t.Fatalf("Listener 1 received new mode %v, want %v", mode, connectivity.ServingModeServing)
-		}
-	}
-	select {
-	case <-ctx.Done():
-		t.Fatalf("Timed out waiting for a mode change update: %v", err)
-	case mode := <-modeChangeHandler2.modeCh:
-		if mode != connectivity.ServingModeServing {
-			t.Fatalf("Listener 2 received new mode %v, want %v", mode, connectivity.ServingModeServing)
-		}
-	}
-
-	// Create a ClientConn to the first listener and make a successful RPCs.
-	cc1, err := grpc.NewClient(lis1.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("grpc.NewClient() failed: %v", err)
-	}
-	defer cc1.Close()
-	waitForSuccessfulRPC(ctx, t, cc1)
-
-	// Create a ClientConn to the second listener and make a successful RPCs.
-	cc2, err := grpc.NewClient(lis2.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials()))
-	if err != nil {
-		t.Fatalf("grpc.NewClient() failed: %v", err)
-	}
-	defer cc2.Close()
-	waitForSuccessfulRPC(ctx, t, cc2)
-
-	// Update the management server to remove the second listener resource. This
-	// should push only the second listener into "not-serving" mode.
-	if err := managementServer.Update(ctx, e2e.UpdateOptions{
-		NodeID:    nodeID,
-		Listeners: []*v3listenerpb.Listener{listener1},
-	}); err != nil {
-		t.Fatal(err)
-	}
-
-	// Wait for lis2 to move to "not-serving" mode.
-	select {
-	case <-ctx.Done():
-		t.Fatalf("Timed out waiting for a mode change update: %v", err)
-	case mode := <-modeChangeHandler2.modeCh:
-		if mode != connectivity.ServingModeNotServing {
-			t.Fatalf("Listener received new mode %v, want %v", mode, connectivity.ServingModeNotServing)
-		}
-		gotErr := <-modeChangeHandler2.errCh
-		if gotErr == nil || !strings.Contains(gotErr.Error(), nodeID) {
-			t.Fatalf("Unexpected error: %v, want xDS Node id: %s", gotErr, nodeID)
-		}
-	}
-
-	// Make sure RPCs succeed on cc1 and fail on cc2.
-	waitForSuccessfulRPC(ctx, t, cc1)
-	waitForFailedRPCWithStatus(ctx, t, cc2, codes.Unavailable, "", "")
-
-	// Update the management server to remove the first listener resource as
-	// well. This should push the first listener into "not-serving" mode. Second
-	// listener is already in "not-serving" mode.
-	if err := managementServer.Update(ctx, e2e.UpdateOptions{
-		NodeID:    nodeID,
-		Listeners: []*v3listenerpb.Listener{},
-	}); err != nil {
-		t.Fatal(err)
-	}
-
-	// Wait for lis1 to move to "not-serving" mode. lis2 was already removed
-	// from the xdsclient's resource cache. So, lis2's callback will not be
-	// invoked this time around.
-	select {
-	case <-ctx.Done():
-		t.Fatalf("Timed out waiting for a mode change update: %v", err)
-	case mode := <-modeChangeHandler1.modeCh:
-		if mode != connectivity.ServingModeNotServing {
-			t.Fatalf("Listener received new mode %v, want %v", mode, connectivity.ServingModeNotServing)
-		}
-		gotErr := <-modeChangeHandler1.errCh
-		if gotErr == nil || !strings.Contains(gotErr.Error(), nodeID) {
-			t.Fatalf("Unexpected error: %v, want xDS Node id: %s", gotErr, nodeID)
-		}
-	}
-
-	// Make sure RPCs fail on both.
-	waitForFailedRPCWithStatus(ctx, t, cc1, codes.Unavailable, "", "")
-	waitForFailedRPCWithStatus(ctx, t, cc2, codes.Unavailable, "", "")
-
-	// Make sure new connection attempts to "not-serving" servers fail.
-	if cc1, err = grpc.NewClient(lis1.Addr().String(), grpc.WithTransportCredentials(insecure.NewCredentials())); err != nil {
-		t.Fatal("Failed to create clientConn to a server in \"not-serving\" state")
-	}
-	defer cc1.Close()
-	if _, err := testgrpc.NewTestServiceClient(cc1).FullDuplexCall(ctx); status.Code(err) != codes.Unavailable {
-		t.Fatalf("FullDuplexCall failed with status code: %v, want: Unavailable", status.Code(err))
-	}
-
-	// Update the management server with both listener resources.
-	if err := managementServer.Update(ctx, e2e.UpdateOptions{
-		NodeID:    nodeID,
-		Listeners: []*v3listenerpb.Listener{listener1, listener2},
-	}); err != nil {
-		t.Fatal(err)
-	}
-
-	// Wait for both listeners to move to "serving" mode.
-	select {
-	case <-ctx.Done():
-		t.Fatalf("Timed out waiting for a mode change update: %v", err)
-	case mode := <-modeChangeHandler1.modeCh:
-		if mode != connectivity.ServingModeServing {
-			t.Fatalf("Listener received new mode %v, want %v", mode, connectivity.ServingModeServing)
-		}
-	}
-	select {
-	case <-ctx.Done():
-		t.Fatalf("Timed out waiting for a mode change update: %v", err)
-	case mode := <-modeChangeHandler2.modeCh:
-		if mode != connectivity.ServingModeServing {
-			t.Fatalf("Listener received new mode %v, want %v", mode, connectivity.ServingModeServing)
-		}
-	}
-
-	// The clientConns created earlier should be able to make RPCs now.
-	waitForSuccessfulRPC(ctx, t, cc1)
-	waitForSuccessfulRPC(ctx, t, cc2)
-}
