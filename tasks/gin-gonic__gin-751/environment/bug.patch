diff --git a/.travis.yml b/.travis.yml
index 3305174..2f78c8a 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,19 +4,20 @@ go:
   - 1.4
   - 1.5
   - 1.6
-  - 1.7
   - tip
 
 script:
+  - go get golang.org/x/tools/cmd/cover
+  - go get github.com/mattn/goveralls
   - go test -v -covermode=count -coverprofile=coverage.out
 
 after_success:
-  - bash <(curl -s https://codecov.io/bash)
+  - goveralls -coverprofile=coverage.out -service=travis-ci -repotoken yFj7FrCeddvBzUaaCyG33jCLfWXeb93eA
 
 notifications:
   webhooks:
     urls:
-      - https://webhooks.gitter.im/e/7f95bf605c4d356372f4
+      - https://webhooks.gitter.im/e/acc2c57482e94b44f557
     on_success: change  # options: [always|never|change] default: always
     on_failure: always  # options: [always|never|change] default: always
     on_start: false     # default: false
diff --git a/README.md b/README.md
index 82ea6a5..8023dc5 100644
--- a/README.md
+++ b/README.md
@@ -1,15 +1,16 @@
 
 #Gin Web Framework
-
 <img align="right" src="https://raw.githubusercontent.com/gin-gonic/gin/master/logo.jpg">
 [![Build Status](https://travis-ci.org/gin-gonic/gin.svg)](https://travis-ci.org/gin-gonic/gin)
-[![codecov](https://codecov.io/gh/gin-gonic/gin/branch/master/graph/badge.svg)](https://codecov.io/gh/gin-gonic/gin)
+[![Coverage Status](https://coveralls.io/repos/gin-gonic/gin/badge.svg?branch=master)](https://coveralls.io/r/gin-gonic/gin?branch=master)
 [![Go Report Card](https://goreportcard.com/badge/github.com/gin-gonic/gin)](https://goreportcard.com/report/github.com/gin-gonic/gin)
 [![GoDoc](https://godoc.org/github.com/gin-gonic/gin?status.svg)](https://godoc.org/github.com/gin-gonic/gin)
 [![Join the chat at https://gitter.im/gin-gonic/gin](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/gin-gonic/gin?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
 Gin is a web framework written in Go (Golang). It features a martini-like API with much better performance, up to 40 times faster thanks to [httprouter](https://github.com/julienschmidt/httprouter). If you need performance and good productivity, you will love Gin.
 
+
+
 ![Gin console logger](https://gin-gonic.github.io/gin/other/console.png)
 
 ```sh
@@ -18,7 +19,7 @@ $ cat test.go
 ```go
 package main
 
-import "gopkg.in/gin-gonic/gin.v1"
+import "github.com/gin-gonic/gin"
 
 func main() {
 	r := gin.Default()
@@ -27,7 +28,7 @@ func main() {
 			"message": "pong",
 		})
 	})
-	r.Run() // listen and serve on 0.0.0.0:8080
+	r.Run() // listen and server on 0.0.0.0:8080
 }
 ```
 
@@ -87,13 +88,13 @@ BenchmarkZeus_GithubAll 		| 2000 		| 944234 	| 300688 	| 2648
 1. Download and install it:
 
     ```sh
-    $ go get gopkg.in/gin-gonic/gin.v1
+    $ go get github.com/gin-gonic/gin
     ```
 
 2. Import it in your code:
 
     ```go
-    import "gopkg.in/gin-gonic/gin.v1"
+    import "github.com/gin-gonic/gin"
     ```
 
 3. (Optional) Import `net/http`. This is required for example if using constants such as `http.StatusOK`.
@@ -316,7 +317,7 @@ func main() {
 		testing.GET("/analytics", analyticsEndpoint)
 	}
 
-	// Listen and serve on 0.0.0.0:8080
+	// Listen and server on 0.0.0.0:8080
 	r.Run(":8080")
 }
 ```
@@ -366,7 +367,7 @@ func main() {
 		}
 	})
 
-	// Listen and serve on 0.0.0.0:8080
+	// Listen and server on 0.0.0.0:8080
 	router.Run(":8080")
 }
 ```
@@ -377,7 +378,8 @@ func main() {
 package main
 
 import (
-	"gopkg.in/gin-gonic/gin.v1"
+	"github.com/gin-gonic/gin"
+	"github.com/gin-gonic/gin/binding"
 )
 
 type LoginForm struct {
@@ -445,7 +447,7 @@ func main() {
 		c.YAML(http.StatusOK, gin.H{"message": "hey", "status": http.StatusOK})
 	})
 
-	// Listen and serve on 0.0.0.0:8080
+	// Listen and server on 0.0.0.0:8080
 	r.Run(":8080")
 }
 ```
@@ -459,7 +461,7 @@ func main() {
 	router.StaticFS("/more_static", http.Dir("my_file_system"))
 	router.StaticFile("/favicon.ico", "./resources/favicon.ico")
 
-	// Listen and serve on 0.0.0.0:8080
+	// Listen and server on 0.0.0.0:8080
 	router.Run(":8080")
 }
 ```
@@ -591,7 +593,7 @@ func main() {
 		log.Println(example)
 	})
 
-	// Listen and serve on 0.0.0.0:8080
+	// Listen and server on 0.0.0.0:8080
 	r.Run(":8080")
 }
 ```
@@ -629,7 +631,7 @@ func main() {
 		}
 	})
 
-	// Listen and serve on 0.0.0.0:8080
+	// Listen and server on 0.0.0.0:8080
 	r.Run(":8080")
 }
 ```
@@ -662,7 +664,7 @@ func main() {
 		log.Println("Done! in path " + c.Request.URL.Path)
 	})
 
-	// Listen and serve on 0.0.0.0:8080
+	// Listen and server on 0.0.0.0:8080
 	r.Run(":8080")
 }
 ```
@@ -712,19 +714,6 @@ An alternative to endless:
 
 * [manners](https://github.com/braintree/manners): A polite Go HTTP server that shuts down gracefully.
 
-## Contributing 
-
-- With issues:
-  - Use the search tool before opening a new issue.
-  - Please provide source code and commit sha if you found a bug.
-  - Review existing issues and provide feedback or react to them.
-- With pull requests:
-  - Open your pull request against develop
-  - Your pull request should have no more than two commits, if not you should squash them.
-  - It should pass all tests in the available continuous integrations systems such as TravisCI.
-  - You should add/modify tests to cover your proposed code changes.
-  - If your pull request contains a new feature, please document it on the README.
-
 ## Example
 
 Awesome project lists using [Gin](https://github.com/gin-gonic/gin) web framework.
diff --git a/codecov.yml b/codecov.yml
deleted file mode 100644
index c9c9a52..0000000
--- a/codecov.yml
+++ /dev/null
@@ -1,5 +0,0 @@
-coverage:
-  notify:
-    gitter:
-      default:
-        url: https://webhooks.gitter.im/e/d90dcdeeab2f1e357165
diff --git a/context.go b/context.go
index df001a4..5d3b6a4 100644
--- a/context.go
+++ b/context.go
@@ -230,27 +230,11 @@ func (c *Context) DefaultQuery(key, defaultValue string) string {
 // 		("", false) == c.GetQuery("id")
 // 		("", true) == c.GetQuery("lastname")
 func (c *Context) GetQuery(key string) (string, bool) {
-	if values, ok := c.GetQueryArray(key); ok {
-		return values[0], ok
-	}
-	return "", false
-}
-
-// QueryArray returns a slice of strings for a given query key.
-// The length of the slice depends on the number of params with the given key.
-func (c *Context) QueryArray(key string) []string {
-	values, _ := c.GetQueryArray(key)
-	return values
-}
-
-// GetQueryArray returns a slice of strings for a given query key, plus
-// a boolean value whether at least one value exists for the given key.
-func (c *Context) GetQueryArray(key string) ([]string, bool) {
 	req := c.Request
 	if values, ok := req.URL.Query()[key]; ok && len(values) > 0 {
-		return values, true
+		return values[0], true
 	}
-	return []string{}, false
+	return "", false
 }
 
 // PostForm returns the specified key from a POST urlencoded form or multipart form
@@ -278,34 +262,17 @@ func (c *Context) DefaultPostForm(key, defaultValue string) string {
 // 		email=  			  	-->  ("", true) := GetPostForm("email") // set email to ""
 //							 	-->  ("", false) := GetPostForm("email") // do nothing with email
 func (c *Context) GetPostForm(key string) (string, bool) {
-	if values, ok := c.GetPostFormArray(key); ok {
-		return values[0], ok
-	}
-	return "", false
-}
-
-// PostFormArray returns a slice of strings for a given form key.
-// The length of the slice depends on the number of params with the given key.
-func (c *Context) PostFormArray(key string) []string {
-	values, _ := c.GetPostFormArray(key)
-	return values
-}
-
-// GetPostFormArray returns a slice of strings for a given form key, plus
-// a boolean value whether at least one value exists for the given key.
-func (c *Context) GetPostFormArray(key string) ([]string, bool) {
 	req := c.Request
-	req.ParseForm()
 	req.ParseMultipartForm(32 << 20) // 32 MB
 	if values := req.PostForm[key]; len(values) > 0 {
-		return values, true
+		return values[0], true
 	}
 	if req.MultipartForm != nil && req.MultipartForm.File != nil {
 		if values := req.MultipartForm.Value[key]; len(values) > 0 {
-			return values, true
+			return values[0], true
 		}
 	}
-	return []string{}, false
+	return "", false
 }
 
 // Bind checks the Content-Type to select a binding engine automatically,
diff --git a/context_test.go b/context_test.go
index 01ee6b8..97d4957 100644
--- a/context_test.go
+++ b/context_test.go
@@ -251,22 +251,6 @@ func TestContextQueryAndPostForm(t *testing.T) {
 	assert.Equal(t, obj.Page, 11)
 	assert.Equal(t, obj.Both, "")
 	assert.Equal(t, obj.Array, []string{"first", "second"})
-
-	values, ok := c.GetQueryArray("array[]")
-	assert.True(t, ok)
-	assert.Equal(t, "first", values[0])
-	assert.Equal(t, "second", values[1])
-
-	values = c.QueryArray("array[]")
-	assert.Equal(t, "first", values[0])
-	assert.Equal(t, "second", values[1])
-
-	values = c.QueryArray("nokey")
-	assert.Equal(t, 0, len(values))
-
-	values = c.QueryArray("both")
-	assert.Equal(t, 1, len(values))
-	assert.Equal(t, "GET", values[0])
 }
 
 func TestContextPostFormMultipart(t *testing.T) {
@@ -315,22 +299,6 @@ func TestContextPostFormMultipart(t *testing.T) {
 	assert.False(t, ok)
 	assert.Empty(t, value)
 	assert.Equal(t, c.DefaultPostForm("nokey", "nothing"), "nothing")
-
-	values, ok := c.GetPostFormArray("array")
-	assert.True(t, ok)
-	assert.Equal(t, "first", values[0])
-	assert.Equal(t, "second", values[1])
-
-	values = c.PostFormArray("array")
-	assert.Equal(t, "first", values[0])
-	assert.Equal(t, "second", values[1])
-
-	values = c.PostFormArray("nokey")
-	assert.Equal(t, 0, len(values))
-
-	values = c.PostFormArray("foo")
-	assert.Equal(t, 1, len(values))
-	assert.Equal(t, "bar", values[0])
 }
 
 func TestContextSetCookie(t *testing.T) {
diff --git a/logger.go b/logger.go
index b4743a7..d56bc62 100644
--- a/logger.go
+++ b/logger.go
@@ -7,10 +7,7 @@ package gin
 import (
 	"fmt"
 	"io"
-	"os"
 	"time"
-
-	"golang.org/x/crypto/ssh/terminal"
 )
 
 var (
@@ -47,11 +44,6 @@ func Logger() HandlerFunc {
 // LoggerWithWriter instance a Logger middleware with the specified writter buffer.
 // Example: os.Stdout, a file opened in write mode, a socket...
 func LoggerWithWriter(out io.Writer, notlogged ...string) HandlerFunc {
-	isTerm := true
-	if outFile, ok := out.(*os.File); ok {
-		isTerm = terminal.IsTerminal(int(outFile.Fd()))
-	}
-
 	var skip map[string]struct{}
 
 	if length := len(notlogged); length > 0 {
@@ -79,11 +71,8 @@ func LoggerWithWriter(out io.Writer, notlogged ...string) HandlerFunc {
 			clientIP := c.ClientIP()
 			method := c.Request.Method
 			statusCode := c.Writer.Status()
-			var statusColor, methodColor string
-			if isTerm {
-				statusColor = colorForStatus(statusCode)
-				methodColor = colorForMethod(method)
-			}
+			statusColor := colorForStatus(statusCode)
+			methodColor := colorForMethod(method)
 			comment := c.Errors.ByType(ErrorTypePrivate).String()
 
 			fmt.Fprintf(out, "[GIN] %v |%s %3d %s| %13v | %s |%s  %s %-7s %s\n%s",
diff --git a/mode.go b/mode.go
index c600b7b..f44b071 100644
--- a/mode.go
+++ b/mode.go
@@ -20,8 +20,8 @@ const (
 )
 const (
 	debugCode   = iota
-	releaseCode 
-	testCode  
+	releaseCode = iota
+	testCode    = iota
 )
 
 // DefaultWriter is the default io.Writer used the Gin for debug output and
