diff --git a/_examples/rest/main.go b/_examples/rest/main.go
index 3c9701f..a311e7d 100644
--- a/_examples/rest/main.go
+++ b/_examples/rest/main.go
@@ -89,8 +89,11 @@ func main() {
 
 	// RESTy routes for "articles" resource
 	r.Route("/articles", func(r chi.Router) {
-		r.Get("/", chi.Use(paginate).Handler(listArticles)) // GET /articles
-		r.Post("/", createArticle)                          // POST /articles
+		r.Group(func(r chi.Router) {
+			r.Use(paginate)
+			r.Get("/", listArticles) // GET /articles
+		})
+		r.Post("/", createArticle) // POST /articles
 
 		r.Route("/:articleID", func(r chi.Router) {
 			r.Use(ArticleCtx)
@@ -219,7 +222,7 @@ func paginate(next http.Handler) http.Handler {
 }
 
 // A completely separate router for administrator routes
-func adminRouter() chi.Router {
+func adminRouter() http.Handler { // or chi.Router {
 	r := chi.NewRouter()
 	r.Use(AdminOnly)
 	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
diff --git a/_examples/simple/main.go b/_examples/simple/main.go
index ea6f890..af07134 100644
--- a/_examples/simple/main.go
+++ b/_examples/simple/main.go
@@ -31,7 +31,7 @@ func main() {
 	http.ListenAndServe(":3333", r)
 }
 
-func accountsRouter() chi.Router {
+func accountsRouter() chi.Router { // or http.Handler
 	r := chi.NewRouter()
 
 	r.Use(sup1)
diff --git a/_examples/todos-resource/main.go b/_examples/todos-resource/main.go
deleted file mode 100644
index 10100e3..0000000
--- a/_examples/todos-resource/main.go
+++ /dev/null
@@ -1,46 +0,0 @@
-package main
-
-import (
-	"net/http"
-
-	"github.com/pressly/chi"
-	"github.com/pressly/chi/middleware"
-)
-
-func main() {
-	r := chi.NewRouter()
-
-	r.Use(middleware.RequestID)
-	r.Use(middleware.RealIP)
-	r.Use(middleware.Logger)
-	r.Use(middleware.Recoverer)
-
-	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte("."))
-	})
-
-	r.Mount("/", usersResource{}.Routes())
-	r.Mount("/", todosResource{}.Routes())
-
-	// r.Mount("/",
-	// 	usersResource{}.Routes(),
-	// 	todosResource{}.Routes(),
-	// )
-
-	// r.Mount(chi.Route("/users", router))
-
-	// r.Route("/", chi.RouterFunc(usersResource{}.Routes()))
-
-	// r.Mount(usersResource{}.Routes())
-
-	// r.Mount("/",
-	// 	usersResource{}.Routes(),
-	// 	todosResource{}.Routes(),
-	// )
-
-	// hmmm.. perhaps r.Mount() will actually add to the existing tree..?
-	// instead of making a real subrouter and joining with a middleware......?
-	// effectively, joining 2 trees...
-
-	http.ListenAndServe(":3333", r)
-}
diff --git a/_examples/todos-resource/todos.go b/_examples/todos-resource/todos.go
deleted file mode 100644
index 0cafcaf..0000000
--- a/_examples/todos-resource/todos.go
+++ /dev/null
@@ -1,56 +0,0 @@
-package main
-
-import (
-	"net/http"
-
-	"github.com/pressly/chi"
-)
-
-type todosResource struct{}
-
-// Routes creates a REST router for the todos resource
-func (rs todosResource) Routes() chi.Router {
-	r := chi.NewRouter()
-
-	// r.Use() // some middleware..
-
-	r.Route("/todos", func(r chi.Router) {
-		r.Get("/", rs.List)    // GET /todos - read a list of todos
-		r.Post("/", rs.Create) // POST /todos - create a new todo and persist it
-		r.Put("/", rs.Delete)
-
-		r.Route("/:id", func(r chi.Router) {
-			// r.Use(rs.TodoCtx) // lets have a todos map, and lets actually load/manipulate
-			r.Get("/", rs.Get)       // GET /todos/:id - read a single todo by :id
-			r.Put("/", rs.Update)    // PUT /todos/:id - update a single todo by :id
-			r.Delete("/", rs.Delete) // DELETE /todos/:id - delete a single todo by :id
-			r.Get("/sync", rs.Sync)
-		})
-	})
-
-	return r
-}
-
-func (rs todosResource) List(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("todos list of stuff.."))
-}
-
-func (rs todosResource) Create(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("todos create"))
-}
-
-func (rs todosResource) Get(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("todo get"))
-}
-
-func (rs todosResource) Update(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("todo update"))
-}
-
-func (rs todosResource) Delete(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("todo delete"))
-}
-
-func (rs todosResource) Sync(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("todo sync"))
-}
diff --git a/_examples/todos-resource/users.go b/_examples/todos-resource/users.go
deleted file mode 100644
index 5a541d9..0000000
--- a/_examples/todos-resource/users.go
+++ /dev/null
@@ -1,51 +0,0 @@
-package main
-
-import (
-	"net/http"
-
-	"github.com/pressly/chi"
-)
-
-type usersResource struct{}
-
-// Routes creates a REST router for the todos resource
-func (rs usersResource) Routes() chi.Router {
-	r := chi.NewRouter()
-
-	// r.Use() // some middleware..
-
-	r.Route("/users", func(r chi.Router) {
-		r.Get("/", rs.List)    // GET /todos - read a list of todos
-		r.Post("/", rs.Create) // POST /todos - create a new todo and persist it
-		r.Put("/", rs.Delete)
-
-		r.Route("/:id", func(r chi.Router) {
-			// r.Use(rs.TodoCtx) // lets have a todos map, and lets actually load/manipulate
-			r.Get("/", rs.Get)       // GET /todos/:id - read a single todo by :id
-			r.Put("/", rs.Update)    // PUT /todos/:id - update a single todo by :id
-			r.Delete("/", rs.Delete) // DELETE /todos/:id - delete a single todo by :id
-		})
-	})
-
-	return r
-}
-
-func (rs usersResource) List(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("aaa list of stuff.."))
-}
-
-func (rs usersResource) Create(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("aaa create"))
-}
-
-func (rs usersResource) Get(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("aaa get"))
-}
-
-func (rs usersResource) Update(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("aaa update"))
-}
-
-func (rs usersResource) Delete(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte("aaa delete"))
-}
diff --git a/chi.go b/chi.go
index 1b9fbca..b42c969 100644
--- a/chi.go
+++ b/chi.go
@@ -14,15 +14,14 @@ type Router interface {
 
 	Use(middlewares ...func(http.Handler) http.Handler)
 
-	Group(fn func(r Router)) Router
 	Route(pattern string, fn func(r Router)) Router
-	Mount(pattern string, rs Router)
+	Group(fn func(r Router)) Router
 
+	Mount(pattern string, h http.Handler)
 	Handle(pattern string, h http.Handler)
 	HandleFunc(pattern string, h http.HandlerFunc)
 	NotFound(h http.HandlerFunc)
 
-	// Any(pattern string, h.HandlerFunc) // ???
 	Connect(pattern string, h http.HandlerFunc)
 	Head(pattern string, h http.HandlerFunc)
 	Get(pattern string, h http.HandlerFunc)
@@ -32,8 +31,6 @@ type Router interface {
 	Delete(pattern string, h http.HandlerFunc)
 	Trace(pattern string, h http.HandlerFunc)
 	Options(pattern string, h http.HandlerFunc)
-
-	// GetMux() *Mux
 }
 
 type Middlewares []func(http.Handler) http.Handler
diff --git a/context.go b/context.go
index 1408688..ea15cd9 100644
--- a/context.go
+++ b/context.go
@@ -21,10 +21,6 @@ type Context struct {
 
 	// Routing path override used by subrouters
 	RoutePath string
-
-	// Routing pattern that matches the request
-	// TODO: ..
-	RoutePattern string
 }
 
 // NewRouteContext returns a new routing context object.
@@ -67,46 +63,13 @@ func URLParamFromCtx(ctx context.Context, key string) string {
 	return ""
 }
 
-type param struct {
-	Key, Value string
-}
-
-type params []param
-
-func (ps *params) Add(key string, value string) {
-	*ps = append(*ps, param{key, value})
-}
-
-func (ps params) Get(key string) string {
-	for _, p := range ps {
-		if p.Key == key {
-			return p.Value
-		}
-	}
-	return ""
-}
-
-func (ps *params) Set(key string, value string) {
-	idx := -1
-	for i, p := range *ps {
-		if p.Key == key {
-			idx = i
-			break
-		}
-	}
-	if idx < 0 {
-		(*ps).Add(key, value)
-	} else {
-		(*ps)[idx] = param{key, value}
-	}
+// contextKey is a value for use with context.WithValue. It's used as
+// a pointer so it fits in an interface{} without allocation. This technique
+// for defining context keys was copied from Go 1.7's new use of context in net/http.
+type contextKey struct {
+	name string
 }
 
-func (ps *params) Del(key string) string {
-	for i, p := range *ps {
-		if p.Key == key {
-			*ps = append((*ps)[:i], (*ps)[i+1:]...)
-			return p.Value
-		}
-	}
-	return ""
+func (k *contextKey) String() string {
+	return "chi context value " + k.name
 }
diff --git a/middleware/strip_test.go b/middleware/strip_test.go
index a1ff0e4..e51c74c 100644
--- a/middleware/strip_test.go
+++ b/middleware/strip_test.go
@@ -64,10 +64,6 @@ func TestStripSlashesInRoute(t *testing.T) {
 	})
 
 	r.Route("/accounts/:accountID", func(r chi.Router) {
-		// TODO: this is failing because subrouters search for a matching route
-		// before they execute the middleware stack because for a subrouter,
-		// the middlewares are chained and put onto the endpoint .. perhaps
-		// we can improve this later.
 		r.Use(StripSlashes)
 		r.Get("/query", func(w http.ResponseWriter, r *http.Request) {
 			accountID := chi.URLParam(r, "accountID")
@@ -87,10 +83,9 @@ func TestStripSlashesInRoute(t *testing.T) {
 	if _, resp := testRequest(t, ts, "GET", "/accounts/admin/query", nil); resp != "admin" {
 		t.Fatalf(resp)
 	}
-	// TODO: commented out for now related to the above issue.
-	// if _, resp := testRequest(t, ts, "GET", "/accounts/admin/query/", nil); resp != "admin" {
-	// 	t.Fatalf(resp)
-	// }
+	if _, resp := testRequest(t, ts, "GET", "/accounts/admin/query/", nil); resp != "admin" {
+		t.Fatalf(resp)
+	}
 }
 
 func TestRedirectSlashes(t *testing.T) {
diff --git a/mux.go b/mux.go
index b5753c4..cf72a62 100644
--- a/mux.go
+++ b/mux.go
@@ -17,41 +17,55 @@ var _ Router = &Mux{}
 // for writing large REST API services that break a handler into many smaller
 // parts composed of middlewares and end handlers.
 type Mux struct {
-	// The radix trie router
-	router *tree
-
 	// The middleware stack
 	middlewares []func(http.Handler) http.Handler
 
-	// The computed mux handler made of the chained middleware stack and
-	// the tree router
-	handler http.Handler
-
-	// A reference to the parent mux used by subrouters when mounting
-	// to a parent mux
-	parent *Mux
+	// The radix trie router
+	router *treeRouter
 
-	// The mounting pattern used by subrouters used to build subsequent
-	// routes as other routers mount together
-	mountPattern string
+	// The mux handler, chained middleware stack and tree router
+	handler http.Handler
 
 	// Controls the behaviour of middleware chain generation when a mux
-	// is registered as an inline group inside another mux
+	// is registered as an inline group inside another mux.
 	inline bool
 
 	// Routing context pool
 	pool sync.Pool
+}
 
-	// Custom route not found handler
-	notFoundHandler http.HandlerFunc
+type methodTyp int
+
+const (
+	mCONNECT methodTyp = 1 << iota
+	mDELETE
+	mGET
+	mHEAD
+	mOPTIONS
+	mPATCH
+	mPOST
+	mPUT
+	mTRACE
+
+	mALL methodTyp = mCONNECT | mDELETE | mGET | mHEAD | mOPTIONS |
+		mPATCH | mPOST | mPUT | mTRACE
+)
+
+var methodMap = map[string]methodTyp{
+	"CONNECT": mCONNECT,
+	"DELETE":  mDELETE,
+	"GET":     mGET,
+	"HEAD":    mHEAD,
+	"OPTIONS": mOPTIONS,
+	"PATCH":   mPATCH,
+	"POST":    mPOST,
+	"PUT":     mPUT,
+	"TRACE":   mTRACE,
 }
 
 // NewMux returns a new Mux object with an optional parent context.
 func NewMux() *Mux {
-	mux := &Mux{
-		router:          &tree{root: &node{}},
-		notFoundHandler: http.NotFound,
-	}
+	mux := &Mux{router: newTreeRouter(), handler: nil}
 	mux.pool.New = func() interface{} {
 		return NewRouteContext()
 	}
@@ -129,18 +143,63 @@ func (mx *Mux) Options(pattern string, handlerFn http.HandlerFunc) {
 
 // NotFound sets a custom http.HandlerFunc for missing routes on the treeRouter.
 func (mx *Mux) NotFound(handlerFn http.HandlerFunc) {
-	mx.notFoundHandler = handlerFn
+	mx.router.notFoundHandler = &handlerFn
+}
+
+// FileServer conveniently sets up a http.FileServer handler to serve
+// static files from a http.FileSystem.
+func (mx *Mux) FileServer(path string, root http.FileSystem) {
+	fs := http.StripPrefix(path, http.FileServer(root))
+	mx.Get(path+"*", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		fs.ServeHTTP(w, r)
+	}))
+}
+
+// handle creates a chi.Handler from a chain of middlewares and an end handler,
+// and then registers the route in the router.
+func (mx *Mux) handle(method methodTyp, pattern string, handler http.Handler) {
+	if len(pattern) == 0 || pattern[0] != '/' {
+		panic(fmt.Sprintf("chi: routing pattern must begin with '/' in '%s'", pattern))
+	}
+
+	// Build the single mux handler that is a chain of the middleware stack, as
+	// defined by calls to Use(), and the tree router (mux) itself. After this point,
+	// no other middlewares can be registered on this mux's stack. But you can still
+	// use inline middlewares via Group()'s and other routes that only execute after
+	// a matched pattern on the treeRouter.
+	if !mx.inline && mx.handler == nil {
+		// TODO: we may remove the treeRouter type and collapse it into the Mux{},
+		// at that point, we'd chain to just mx instead of mx.router, or consider
+		// some other ideas..
+		mx.handler = chain(mx.middlewares, mx.router)
+	}
+
+	// Build endpoint handler with inline middlewares for the route
+	var endpoint http.Handler
+	if mx.inline {
+		mx.handler = mx.router // TODO: just mx ...?
+		endpoint = chain(mx.middlewares, handler)
+	} else {
+		endpoint = handler
+	}
+
+	// Set the route for the respective HTTP methods
+	for _, mt := range methodMap {
+		m := method & mt
+		if m > 0 {
+			mx.router.routes[m].Insert(pattern, endpoint)
+		}
+	}
 }
 
 // Group creates a new inline-Mux with a fresh middleware stack. It's useful
 // for a group of handlers along the same routing path that use the same
 // middleware(s). See _examples/ for an example usage.
 func (mx *Mux) Group(fn func(r Router)) Router {
-	// Similarly as in handle(), we must build the final mux handler from the tree
-	// and the middleware stack. Further middleware additions will be ignored,
-	// after this point.
+	// Similarly as in handle(), we must build the mux handler once further
+	// middleware registration isn't allowed for this stack, like now.
 	if !mx.inline && mx.handler == nil {
-		mx.handler = chain(mx.middlewares, http.HandlerFunc(mx.routeHTTP))
+		mx.handler = chain(mx.middlewares, mx.router)
 	}
 
 	// Make a new inline mux and run the router functions over it.
@@ -155,134 +214,111 @@ func (mx *Mux) Group(fn func(r Router)) Router {
 // along the `pattern` as a subrouter. This is very similar to Group, but attaches
 // the group along a new routing path. See _examples/ for example usage.
 func (mx *Mux) Route(pattern string, fn func(r Router)) Router {
-	subrouter := NewRouter()
+	subRouter := NewRouter()
+	mx.Mount(pattern, subRouter)
 	if fn != nil {
-		fn(subrouter)
+		fn(subRouter)
 	}
-	mx.Mount(pattern, subrouter)
-	return subrouter
+	return subRouter
 }
 
 // Mount attaches another chi Router as a subrouter along a routing path. It's very
 // useful to split up a large API as many independent routers and compose them as
 // a single service using Mount. See _examples/ for example usage.
-func (mx *Mux) Mount(pattern string, subrouter Router) {
-
-	// TODO: this will panic, but we'll solve it right later.
-	smx, ok := subrouter.(*Mux)
-	if !ok {
-		panic("subrouter is not a Mux.")
+func (mx *Mux) Mount(path string, handler http.Handler) {
+	// Assign sub-Router's with the parent not found handler if not specified.
+	if sr, ok := handler.(*Mux); ok {
+		if sr.router.notFoundHandler == nil && mx.router.notFoundHandler != nil {
+			sr.NotFound(*mx.router.notFoundHandler)
+		}
 	}
 
-	// TODO: change mx.parent to type Router
-
-	// TODO: switch methods to strings ... okay...
-
-	// TODO: add Router method Handle(method, pattern, handler)
-
-	// XXX: FINALLY .... how do we set the damn parent....? and mountPattern ...?
-	// XXX: how do we get the parent and mountPattern ...?
-
-	// TODO: Routes() will let us walk a router..
-
-	// IDEA: is it possible to set the parent Mux, and mountingPattern in the actual
-	// tree, and get it back from walking...? or get the Mux from walking..?
-
-	smx.parent = mx
-	smx.mountPattern = pattern
+	// Wrap the sub-router in a handlerFunc to scope the request path for routing.
+	subHandler := func(w http.ResponseWriter, r *http.Request) {
+		rctx := RouteContext(r.Context())
+		rctx.RoutePath = "/" + rctx.Params.Del("*")
+		handler.ServeHTTP(w, r)
+	}
 
-	rt := mx
-	if rt.parent != nil {
-		rt = mx.parent
+	if path == "" || path[len(path)-1] != '/' {
+		mx.HandleFunc(path, subHandler)
+		mx.HandleFunc(path+"/", mx.router.NotFoundHandler())
+		path += "/"
 	}
+	mx.HandleFunc(path+"*", subHandler)
+}
 
-	if mx.mountPattern != "/" {
-		pattern = mx.mountPattern + pattern
+// ServeHTTP is the single method of the http.Handler interface that makes
+// Mux interoperable with the standard library. It uses a sync.Pool to get and
+// reuse routing contexts for each request.
+func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	// Ensure the mux has some routes defined on the mux
+	if mx.handler == nil {
+		panic("chi: attempting to route to a mux with no handlers.")
 	}
 
-	// Re-inserting the routes from the passed router to our new sub router.
-	// The subrouter is already pointing at the base router to insert the routes.
-	smx.router.Walk(func(route string, handlers methodHandlers) bool {
-		if route == "/" {
-			route = pattern
-		} else if pattern[len(pattern)-1] == '/' && route[0] == '/' {
-			route = pattern + route[1:]
-		} else if pattern != "/" {
-			route = pattern + route
-		}
+	//ctx := mx.pool.Get().(*Context)
+	//r = r.WithContext(ctx)
+	//mx.routeHTTP(w, r)
+	//ctx.reset()
+	//mx.pool.Put(ctx)
 
-		for m, h := range handlers {
-			rt.handle(m, route, chain(smx.middlewares, h))
-		}
+	// TODO: do we care about zero-alloc routing? test actual
+	// throughput, if not, switch the params to map[string]string
 
-		return false
-	})
+	ctx := r.Context()
+	rctx, ok := ctx.(*Context)
+	if !ok || rctx == nil {
+		rctx, ok = ctx.Value(RouteCtxKey).(*Context)
+		if !ok {
+			//fmt.Println("We're making a new context!!")
+			rctx = NewRouteContext()
+			r = r.WithContext(rctx)
+		}
+	}
+	mx.handler.ServeHTTP(w, r)
 }
 
-// FileServer conveniently sets up a http.FileServer handler to serve
-// static files from a http.FileSystem.
-func (mx *Mux) FileServer(path string, root http.FileSystem) {
-	fs := http.StripPrefix(path, http.FileServer(root))
-	mx.Get(path+"*", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		fs.ServeHTTP(w, r)
-	}))
+func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
+	mx.handler.ServeHTTP(w, r)
 }
 
-// handle creates a chi.Handler from a chain of middlewares and an end handler,
-// and then registers the route in the router.
-func (mx *Mux) handle(method methodTyp, pattern string, handler http.Handler) {
-	if len(pattern) == 0 || pattern[0] != '/' {
-		panic(fmt.Sprintf("chi: routing pattern must begin with '/' in '%s'", pattern))
-	}
+// A treeRouter manages a radix trie prefix-router for each HTTP method and passes
+// each request via its chi.Handler method.
+type treeRouter struct {
+	// Routing tree by method type
+	routes map[methodTyp]*tree
 
-	// TOOD: add a validation method to check the route and that params
-	// dont conflict.
+	// Custom route not found handler
+	notFoundHandler *http.HandlerFunc
+}
 
-	// Build the single mux handler that is a chain of the middleware stack, as
-	// defined by calls to Use(), and the tree router (mux) itself. After this point,
-	// no other middlewares can be registered on this mux's stack. But you can still
-	// use inline middlewares via Group()'s and other routes that only execute after
-	// a matched pattern on the treeRouter.
-	if !mx.inline && mx.handler == nil {
-		mx.handler = chain(mx.middlewares, http.HandlerFunc(mx.routeHTTP))
+// newTreeRouter creates a new treeRouter object and initializes the trees for
+// each http method.
+func newTreeRouter() *treeRouter {
+	tr := &treeRouter{
+		routes:          make(map[methodTyp]*tree, len(methodMap)),
+		notFoundHandler: nil,
 	}
-
-	// Build endpoint handler with inline middlewares for the route
-	var endpoint http.Handler
-	if mx.inline {
-		mx.handler = http.HandlerFunc(mx.routeHTTP)
-		endpoint = chain(mx.middlewares, handler)
-	} else {
-		endpoint = handler
+	for _, v := range methodMap {
+		tr.routes[v] = &tree{root: &node{}}
 	}
-
-	// ... TODO: comment..
-	mx.router.Insert(method, pattern, endpoint)
+	return tr
 }
 
-// ServeHTTP is the single method of the http.Handler interface that makes
-// Mux interoperable with the standard library. It uses a sync.Pool to get and
-// reuse routing contexts for each request.
-func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	// Ensure the mux has some routes defined on the mux
-	if mx.handler == nil {
-		panic("chi: attempting to route to a mux with no handlers.")
+// NotFoundHandlerFn returns the HandlerFunc setup on the tree.
+func (tr treeRouter) NotFoundHandler() http.HandlerFunc {
+	if tr.notFoundHandler != nil {
+		return *tr.notFoundHandler
 	}
-
-	// Fetch a RouteContext object from the sync pool, and call the computed
-	// mx.handler that is comprised of mx.middlewares + mx.routeHTTP.
-	// Once the request is finsihed, reset the routing context and put it back
-	// into the pool for reuse from another request.
-	rctx := mx.pool.Get().(*Context)
-	r = r.WithContext(rctx)
-	mx.handler.ServeHTTP(w, r)
-	rctx.reset()
-	mx.pool.Put(rctx)
+	return http.NotFound
 }
 
-func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
-	// Grab the root context object
+// ServeHTTP is the main routing method for each request.
+func (tr treeRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 	ctx := r.Context()
+
+	// Grab the root context object
 	rctx, _ := ctx.(*Context)
 	if rctx == nil {
 		rctx = ctx.Value(RouteCtxKey).(*Context)
@@ -301,22 +337,14 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
-	// Find the route
-	// TODO: any point in giving the method..? maybe later..
-	// TODO: if we switch method to string.. then, we can simplify this code..
-	hs := mx.router.Find(rctx, method, routePath)
+	// Find the handler in the router
+	cxh := tr.routes[method].Find(rctx, routePath)
 
-	if hs == nil {
-		mx.notFoundHandler(w, r)
-		return
-	}
-
-	h, ok := hs[method]
-	if !ok {
-		methodNotAllowedHandler(w, r)
+	if cxh == nil {
+		tr.NotFoundHandler().ServeHTTP(w, r)
 		return
 	}
 
-	// Serve it up
-	h.ServeHTTP(w, r)
+	// Serve it
+	cxh.ServeHTTP(w, r)
 }
diff --git a/mux_test.go b/mux_test.go
index 5aba578..561afdb 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -7,7 +7,6 @@ import (
 	"fmt"
 	"io"
 	"io/ioutil"
-	"log"
 	"net/http"
 	"net/http/httptest"
 	"os"
@@ -15,136 +14,7 @@ import (
 	"time"
 )
 
-// TODO: mux test..
-/*
-
-r.Route("/todos", func(r chi.Router) {
-	r.Get("/", rs.List)    // GET /todos - read a list of todos
-	r.Post("/", rs.Create) // POST /todos - create a new todo and persist it
-	// r.Put("/", rs.Delete) // ******** BUG <----<< this route matches the empty /:id PUT ..
-
-	r.Route("/:id", func(r chi.Router) {
-		// r.Use(rs.TodoCtx) // lets have a todos map, and lets actually load/manipulate
-		r.Get("/", rs.Get)       // GET /todos/:id - read a single todo by :id
-		r.Put("/", rs.Update)    // PUT /todos/:id - update a single todo by :id
-		r.Delete("/", rs.Delete) // DELETE /todos/:id - delete a single todo by :id
-	})
-})
-
-*/
-
-func TestOneMuxTree(t *testing.T) {
-	h1index := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h1index")) }
-	h1a := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h1a")) }
-	h1b := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h1b")) }
-	h2index := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h2index")) }
-	h2a := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h2a")) }
-	h2b := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h2b")) }
-	h3index := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h3index")) }
-	h3a := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h3a")) }
-	h3b := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h3b")) }
-	h4index := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h4index")) }
-	h4a := func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("h4a")) }
-
-	r1 := NewRouter()
-	r1.Get("/", h1index)
-	r1.Get("/h1a", h1a)
-	r1.Get("/h1b", h1b)
-
-	r2 := NewRouter()
-	r2.Get("/", h2index)
-	r2.Get("/h2a", h2a)
-	r2.Get("/h2b", h2b)
-
-	r3 := NewRouter()
-	r3.Get("/", h3index)
-	r3.Get("/h3a", h3a)
-	r3.Get("/h3b", h3b)
-
-	r4 := NewRouter()
-	r4.Get("/", h4index)
-	r4.Get("/h4a", h4a)
-
-	r1.Mount("/r2", r2)
-	r2.Mount("/r3", r3)
-	r2.Mount("/r3", r4) // will override the / path and add another
-
-	r1.Mount("/r2b", r2)
-
-	ts := httptest.NewServer(r1)
-	defer ts.Close()
-
-	if _, body := testRequest(t, ts, "GET", "/", nil); body != "h1index" {
-		t.Fatalf(fmt.Sprintf("GET / got:%s", body))
-	}
-	if _, body := testRequest(t, ts, "GET", "/h1a", nil); body != "h1a" {
-		t.Fatalf(fmt.Sprintf("GET /h1a got:%s", body))
-	}
-	if _, body := testRequest(t, ts, "GET", "/h1b", nil); body != "h1b" {
-		t.Fatalf(fmt.Sprintf("GET /h1b got:%s", body))
-	}
-	if _, body := testRequest(t, ts, "GET", "/not-here", nil); body != "404 page not found\n" {
-		t.Fatalf(fmt.Sprintf("GET /not-here got:%s", body))
-	}
-
-	if _, body := testRequest(t, ts, "GET", "/r2", nil); body != "h2index" {
-		t.Fatalf(fmt.Sprintf("GET /r2 got:%s", body))
-	}
-	// if _, body := testRequest(t, ts, "GET", "/r2/", nil); body != "h2index" { // ?? TODO ... should work, or not..?
-	// 	t.Fatalf(fmt.Sprintf("GET /r2/ got:%s", body))
-	// }
-	if _, body := testRequest(t, ts, "GET", "/r2/h2a", nil); body != "h2a" {
-		t.Fatalf(fmt.Sprintf("GET /r2/h2a got:%s", body))
-	}
-	if _, body := testRequest(t, ts, "GET", "/r2/h2b", nil); body != "h2b" {
-		t.Fatalf(fmt.Sprintf("GET /r2/h2b got:%s", body))
-	}
-
-	if _, body := testRequest(t, ts, "GET", "/r2/r3", nil); body != "h4index" {
-		t.Fatalf(fmt.Sprintf("GET /r2/r3 got:%s", body))
-	}
-	// if _, body := testRequest(t, ts, "GET", "/r2/r3/", nil); body != "h3index" { // ?? TODO ... should work, or not..?
-	// 	t.Fatalf(fmt.Sprintf("GET /r2/r3/ got:%s", body))
-	// }
-	if _, body := testRequest(t, ts, "GET", "/r2/r3/h3a", nil); body != "h3a" {
-		t.Fatalf(fmt.Sprintf("GET /r2/r3/h3a got:%s", body))
-	}
-	if _, body := testRequest(t, ts, "GET", "/r2/r3/h3b", nil); body != "h3b" {
-		t.Fatalf(fmt.Sprintf("GET /r2/r3/h3b got:%s", body))
-	}
-
-	if _, body := testRequest(t, ts, "GET", "/r2/r3/h4a", nil); body != "h4a" {
-		t.Fatalf(fmt.Sprintf("GET /r2/r3/h4a got:%s", body))
-	}
-
-}
-
-//---
-
-// type ACLMux struct {
-// 	*Mux
-// 	XX string
-// }
-//
-// func NewACLMux() *ACLMux {
-// 	return &ACLMux{Mux: NewRouter(), XX: "hihi"}
-// }
-//
-// // TODO: this should be supported...
-// func TestWoot(t *testing.T) {
-// 	var r Router = NewRouter()
-//
-// 	var r2 Router = NewACLMux() //NewRouter()
-// 	r2.Get("/hi", func(w http.ResponseWriter, r *http.Request) {
-// 		w.Write([]byte("hi"))
-// 	})
-//
-// 	r.Mount("/", r2)
-// }
-
-//---
-
-func TestMuxBasic(t *testing.T) {
+func TestMux(t *testing.T) {
 	var count uint64
 	countermw := func(next http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
@@ -246,7 +116,7 @@ func TestMuxBasic(t *testing.T) {
 
 	m.Head("/ping", headPing)
 	m.Post("/ping", createPing)
-	m.Get("/ping/:id", pingWoop)
+	m.Get("/ping/:id", pingOne)
 	m.Get("/ping/:id", pingOne) // should overwrite.. and just be 1
 	m.Get("/ping/:id/woop", pingWoop)
 	m.HandleFunc("/admin/*", catchAll)
@@ -256,8 +126,8 @@ func TestMuxBasic(t *testing.T) {
 	defer ts.Close()
 
 	// GET /
-	if _, body := testRequest(t, ts, "GET", "/", nil); body != "hi peter" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/", nil); resp != "hi peter" {
+		t.Fatalf(resp)
 	}
 	tlogmsg, _ := logbuf.ReadString(0)
 	if tlogmsg != logmsg {
@@ -265,38 +135,38 @@ func TestMuxBasic(t *testing.T) {
 	}
 
 	// GET /ping
-	if _, body := testRequest(t, ts, "GET", "/ping", nil); body != "." {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/ping", nil); resp != "." {
+		t.Fatalf(resp)
 	}
 
 	// GET /pingall
-	if _, body := testRequest(t, ts, "GET", "/pingall", nil); body != "ping all" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/pingall", nil); resp != "ping all" {
+		t.Fatalf(resp)
 	}
 
 	// GET /ping/all
-	if _, body := testRequest(t, ts, "GET", "/ping/all", nil); body != "ping all" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/ping/all", nil); resp != "ping all" {
+		t.Fatalf(resp)
 	}
 
 	// GET /ping/all2
-	if _, body := testRequest(t, ts, "GET", "/ping/all2", nil); body != "ping all2" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/ping/all2", nil); resp != "ping all2" {
+		t.Fatalf(resp)
 	}
 
 	// GET /ping/123
-	if _, body := testRequest(t, ts, "GET", "/ping/123", nil); body != "ping one id: 123" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/ping/123", nil); resp != "ping one id: 123" {
+		t.Fatalf(resp)
 	}
 
 	// GET /ping/allan
-	if _, body := testRequest(t, ts, "GET", "/ping/allan", nil); body != "ping one id: allan" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/ping/allan", nil); resp != "ping one id: allan" {
+		t.Fatalf(resp)
 	}
 
 	// GET /ping/1/woop
-	if _, body := testRequest(t, ts, "GET", "/ping/1/woop", nil); body != "woop." {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/ping/1/woop", nil); resp != "woop." {
+		t.Fatalf(resp)
 	}
 
 	// HEAD /ping
@@ -312,9 +182,8 @@ func TestMuxBasic(t *testing.T) {
 	}
 
 	// GET /admin/catch-this
-	if _, body := testRequest(t, ts, "GET", "/admin/catch-thazzzzz", nil); body != "catchall" {
-		log.Println("nada...")
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/admin/catch-thazzzzz", nil); resp != "catchall" {
+		t.Fatalf(resp)
 	}
 
 	// POST /admin/catch-this
@@ -338,8 +207,8 @@ func TestMuxBasic(t *testing.T) {
 	}
 
 	// Custom http method DIE /ping/1/woop
-	if resp, body := testRequest(t, ts, "DIE", "/ping/1/woop", nil); body != "" || resp.StatusCode != 405 {
-		t.Fatalf(fmt.Sprintf("expecting 405 status and empty body, got %d '%s'", resp.StatusCode, body))
+	if resp := testRequest(t, ts, "DIE", "/ping/1/woop", nil); resp != "Method Not Allowed" {
+		t.Fatalf(resp)
 	}
 }
 
@@ -356,11 +225,11 @@ func TestMuxPlain(t *testing.T) {
 	ts := httptest.NewServer(r)
 	defer ts.Close()
 
-	if _, body := testRequest(t, ts, "GET", "/hi", nil); body != "bye" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/hi", nil); resp != "bye" {
+		t.Fatalf(resp)
 	}
-	if _, body := testRequest(t, ts, "GET", "/nothing-here", nil); body != "nothing here" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/nothing-here", nil); resp != "nothing here" {
+		t.Fatalf(resp)
 	}
 }
 
@@ -372,8 +241,8 @@ func TestMuxEmptyRoutes(t *testing.T) {
 
 	mux.Handle("/api*", apiRouter)
 
-	if _, body := testHandler(t, mux, "GET", "/", nil); body != "404 page not found\n" {
-		t.Fatalf(body)
+	if resp := testHandler(t, mux, "GET", "/", nil); resp != "404 page not found\n" {
+		t.Fatalf(resp)
 	}
 
 	func() {
@@ -385,8 +254,8 @@ func TestMuxEmptyRoutes(t *testing.T) {
 			}
 		}()
 
-		_, body := testHandler(t, mux, "GET", "/api", nil)
-		t.Fatalf("oops, we are expecting a panic instead of getting resp: %s", body)
+		resp := testHandler(t, mux, "GET", "/api", nil)
+		t.Fatalf("oops, we are expecting a panic instead of getting resp: %s", resp)
 	}()
 
 	func() {
@@ -398,8 +267,8 @@ func TestMuxEmptyRoutes(t *testing.T) {
 			}
 		}()
 
-		_, body := testHandler(t, mux, "GET", "/api/abc", nil)
-		t.Fatalf("oops, we are expecting a panic instead of getting resp: %s", body)
+		resp := testHandler(t, mux, "GET", "/api/abc", nil)
+		t.Fatalf("oops, we are expecting a panic instead of getting resp: %s", resp)
 	}()
 }
 
@@ -425,14 +294,14 @@ func TestMuxTrailingSlash(t *testing.T) {
 	ts := httptest.NewServer(r)
 	defer ts.Close()
 
-	if _, body := testRequest(t, ts, "GET", "/accounts/admin", nil); body != "admin" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/accounts/admin", nil); resp != "admin" {
+		t.Fatalf(resp)
 	}
-	if _, body := testRequest(t, ts, "GET", "/accounts/admin/", nil); body != "admin" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/accounts/admin/", nil); resp != "admin" {
+		t.Fatalf(resp)
 	}
-	if _, body := testRequest(t, ts, "GET", "/nothing-here", nil); body != "nothing here" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/nothing-here", nil); resp != "nothing here" {
+		t.Fatalf(resp)
 	}
 }
 
@@ -446,8 +315,6 @@ func TestMuxNestedNotFound(t *testing.T) {
 		w.Write([]byte("root 404"))
 	})
 
-	// NOTE: as of chi v2, we have just a single NotFound handler that defined
-	// on the root mux.
 	sr1 := NewRouter()
 	sr1.Get("/sub", func(w http.ResponseWriter, r *http.Request) {
 		w.Write([]byte("sub"))
@@ -468,26 +335,27 @@ func TestMuxNestedNotFound(t *testing.T) {
 	ts := httptest.NewServer(r)
 	defer ts.Close()
 
-	if _, body := testRequest(t, ts, "GET", "/hi", nil); body != "bye" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/hi", nil); resp != "bye" {
+		t.Fatalf(resp)
 	}
-	if _, body := testRequest(t, ts, "GET", "/nothing-here", nil); body != "root 404" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/nothing-here", nil); resp != "root 404" {
+		t.Fatalf(resp)
 	}
-	if _, body := testRequest(t, ts, "GET", "/admin1/sub", nil); body != "sub" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/admin1/sub", nil); resp != "sub" {
+		t.Fatalf(resp)
 	}
-	if _, body := testRequest(t, ts, "GET", "/admin1/nope", nil); body != "root 404" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/admin1/nope", nil); resp != "sub 404" {
+		t.Fatalf(resp)
 	}
-	if _, body := testRequest(t, ts, "GET", "/admin2/sub", nil); body != "sub2" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/admin2/sub", nil); resp != "sub2" {
+		t.Fatalf(resp)
 	}
 
 	// Not found pages should bubble up to the root.
-	if _, body := testRequest(t, ts, "GET", "/admin2/nope", nil); body != "root 404" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/admin2/nope", nil); resp != "root 404" {
+		t.Fatalf(resp)
 	}
+
 }
 
 func TestMuxMiddlewareStack(t *testing.T) {
@@ -526,6 +394,17 @@ func TestMuxMiddlewareStack(t *testing.T) {
 	r := NewRouter()
 	r.Use(stdmw)
 	r.Use(ctxmw)
+	r.Use(func(next http.Handler) http.Handler {
+		// log.Println("std, inline mw init")
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			next.ServeHTTP(w, r)
+		})
+	})
+	// r.Use(func(next http.Handler) http.Handler {
+	// 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+	// 		next.ServeHTTP(w, r)
+	// 	})
+	// })
 	r.Use(func(next http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 			if r.URL.Path == "/ping" {
@@ -554,17 +433,17 @@ func TestMuxMiddlewareStack(t *testing.T) {
 
 	// log.Println("routes set.")
 
-	var body string
-	_, body = testRequest(t, ts, "GET", "/", nil)
-	_, body = testRequest(t, ts, "GET", "/", nil)
-	_, body = testRequest(t, ts, "GET", "/", nil)
-	if body != "inits:1 reqs:3 ctxValue:3" {
-		t.Fatalf("got: '%s'", body)
+	var resp string
+	resp = testRequest(t, ts, "GET", "/", nil)
+	resp = testRequest(t, ts, "GET", "/", nil)
+	resp = testRequest(t, ts, "GET", "/", nil)
+	if resp != "inits:1 reqs:3 ctxValue:3" {
+		t.Fatalf("got: '%s'", resp)
 	}
 
-	_, body = testRequest(t, ts, "GET", "/ping", nil)
-	if body != "pong" {
-		t.Fatalf("got: '%s'", body)
+	resp = testRequest(t, ts, "GET", "/ping", nil)
+	if resp != "pong" {
+		t.Fatalf("got: '%s'", resp)
 	}
 }
 
@@ -573,12 +452,26 @@ func TestMuxRootGroup(t *testing.T) {
 	stdmw := func(next http.Handler) http.Handler {
 		stdmwInit++
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			// log.Println("$$$$$ stdmw handlerfunc here!")
 			stdmwHandler++
 			next.ServeHTTP(w, r)
 		})
 	}
+	// stdmw := func(next Handler) Handler {
+	// 	stdmwInit++
+	// 	return HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+	// 		log.Println("$$$$$ stdmw handlerfunc here!")
+	// 		stdmwHandler++
+	// 		next.ServeHTTPC(ctx, w, r)
+	// 	})
+	// }
 
 	r := NewRouter()
+	// r.Use(func(next Handler) Handler {
+	// 	return HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+	// 		next.ServeHTTPC(ctx, w, r)
+	// 	})
+	// })
 	r.Group(func(r Router) {
 		r.Use(stdmw)
 		r.Get("/group", func(w http.ResponseWriter, r *http.Request) {
@@ -590,9 +483,9 @@ func TestMuxRootGroup(t *testing.T) {
 	defer ts.Close()
 
 	// GET /group
-	_, body := testRequest(t, ts, "GET", "/group", nil)
-	if body != "root group" {
-		t.Fatalf("got: '%s'", body)
+	resp := testRequest(t, ts, "GET", "/group", nil)
+	if resp != "root group" {
+		t.Fatalf("got: '%s'", resp)
 	}
 	if stdmwInit != 1 || stdmwHandler != 1 {
 		t.Fatalf("stdmw counters failed, should be 1:1, got %d:%d", stdmwInit, stdmwHandler)
@@ -604,20 +497,22 @@ func TestMuxBig(t *testing.T) {
 	r = NewRouter()
 	r.Use(func(next http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			ctx := context.WithValue(r.Context(), "requestID", "1")
-			next.ServeHTTP(w, r.WithContext(ctx))
+			ctx := r.Context()
+			ctx = context.WithValue(ctx, "requestID", "1")
+			r = r.WithContext(ctx)
+			next.ServeHTTP(w, r)
 		})
 	})
 	r.Use(func(next http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			// log.Println("request:", r.URL.Path) // TODO: put in buffer..
 			next.ServeHTTP(w, r)
 		})
 	})
 	r.Group(func(r Router) {
 		r.Use(func(next http.Handler) http.Handler {
 			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-				ctx := context.WithValue(r.Context(), "session.user", "anonymous")
-				next.ServeHTTP(w, r.WithContext(ctx))
+				next.ServeHTTP(w, r)
 			})
 		})
 		r.Get("/favicon.ico", func(w http.ResponseWriter, r *http.Request) {
@@ -625,22 +520,23 @@ func TestMuxBig(t *testing.T) {
 		})
 		r.Get("/hubs/:hubID/view", func(w http.ResponseWriter, r *http.Request) {
 			ctx := r.Context()
-			s := fmt.Sprintf("/hubs/%s/view reqid:%s session:%s", URLParam(r, "hubID"),
-				ctx.Value("requestID"), ctx.Value("session.user"))
+			s := fmt.Sprintf("/hubs/%s/view reqid:%s", URLParam(r, "hubID"), ctx.Value("requestID"))
 			w.Write([]byte(s))
 		})
 		r.Get("/hubs/:hubID/view/*", func(w http.ResponseWriter, r *http.Request) {
 			ctx := r.Context()
-			s := fmt.Sprintf("/hubs/%s/view/%s reqid:%s session:%s", URLParamFromCtx(ctx, "hubID"),
-				URLParam(r, "*"), ctx.Value("requestID"), ctx.Value("session.user"))
+			s := fmt.Sprintf("/hubs/%s/view/%s reqid:%s", URLParamFromCtx(ctx, "hubID"), URLParam(r, "*"),
+				ctx.Value("requestID"))
 			w.Write([]byte(s))
 		})
 	})
 	r.Group(func(r Router) {
 		r.Use(func(next http.Handler) http.Handler {
 			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-				ctx := context.WithValue(r.Context(), "session.user", "elvis")
-				next.ServeHTTP(w, r.WithContext(ctx))
+				ctx := r.Context()
+				ctx = context.WithValue(ctx, "session.user", "elvis")
+				r = r.WithContext(ctx)
+				next.ServeHTTP(w, r)
 			})
 		})
 		r.Get("/", func(w http.ResponseWriter, r *http.Request) {
@@ -756,64 +652,64 @@ func TestMuxBig(t *testing.T) {
 	ts := httptest.NewServer(r)
 	defer ts.Close()
 
-	var body, expected string
+	var resp, expected string
 
-	_, body = testRequest(t, ts, "GET", "/favicon.ico", nil)
-	if body != "fav" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/favicon.ico", nil)
+	if resp != "fav" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/hubs/4/view", nil)
-	if body != "/hubs/4/view reqid:1 session:anonymous" {
-		t.Fatalf("got '%v'", body)
+	resp = testRequest(t, ts, "GET", "/hubs/4/view", nil)
+	if resp != "/hubs/4/view reqid:1" {
+		t.Fatalf("got '%v'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/hubs/4/view/index.html", nil)
-	if body != "/hubs/4/view/index.html reqid:1 session:anonymous" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/hubs/4/view/index.html", nil)
+	if resp != "/hubs/4/view/index.html reqid:1" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/", nil)
-	if body != "/ reqid:1 session:elvis" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/", nil)
+	if resp != "/ reqid:1 session:elvis" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/suggestions", nil)
-	if body != "/suggestions reqid:1 session:elvis" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/suggestions", nil)
+	if resp != "/suggestions reqid:1 session:elvis" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/woot/444/hiiii", nil)
-	if body != "/woot/444/hiiii" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/woot/444/hiiii", nil)
+	if resp != "/woot/444/hiiii" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/hubs/123", nil)
+	resp = testRequest(t, ts, "GET", "/hubs/123", nil)
 	expected = "/hubs/123 reqid:1 session:elvis"
-	if body != expected {
-		t.Fatalf("expected:%s got:%s", expected, body)
+	if resp != expected {
+		t.Fatalf("expected:%s got:%s", expected, resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/hubs/123/touch", nil)
-	if body != "/hubs/123/touch reqid:1 session:elvis" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/hubs/123/touch", nil)
+	if resp != "/hubs/123/touch reqid:1 session:elvis" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/hubs/123/webhooks", nil)
-	if body != "/hubs/123/webhooks reqid:1 session:elvis" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/hubs/123/webhooks", nil)
+	if resp != "/hubs/123/webhooks reqid:1 session:elvis" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/hubs/123/posts", nil)
-	if body != "/hubs/123/posts reqid:1 session:elvis" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/hubs/123/posts", nil)
+	if resp != "/hubs/123/posts reqid:1 session:elvis" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/folders", nil)
-	if body != "404 page not found\n" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/folders", nil)
+	if resp != "404 page not found\n" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/folders/", nil)
-	if body != "/folders/ reqid:1 session:elvis" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/folders/", nil)
+	if resp != "/folders/ reqid:1 session:elvis" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/folders/public", nil)
-	if body != "/folders/public reqid:1 session:elvis" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/folders/public", nil)
+	if resp != "/folders/public reqid:1 session:elvis" {
+		t.Fatalf("got '%s'", resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/folders/nothing", nil)
-	if body != "404 page not found\n" {
-		t.Fatalf("got '%s'", body)
+	resp = testRequest(t, ts, "GET", "/folders/nothing", nil)
+	if resp != "404 page not found\n" {
+		t.Fatalf("got '%s'", resp)
 	}
 }
 
@@ -852,40 +748,62 @@ func TestMuxSubroutes(t *testing.T) {
 		r.Mount("/", sr3)
 	})
 
-	// This is the same as the r.Route() call mounted on sr2
-	// sr2 := NewRouter()
-	// sr2.Mount("/", sr3)
-	// r.Mount("/accounts/:accountID", sr2)
+	// TODO: support overriding the index method on a mount like:
+	// r.Get("/users", UIndex)
+	// r.Mount("/users", U) // assuming U router doesn't implement index route
+	// .. currently for this to work, the index route must be defined separately
+
+	// log.Println("")
+	// log.Println("~~router:")
+	// debugPrintTree(0, 0, r.router[mGET].root, 0)
+	//
+	// log.Println("")
+	// log.Println("~~subrouter1:")
+	// debugPrintTree(0, 0, sr.router[mGET].root, 0)
+	// log.Println("")
+	// log.Println("")
+	//
+	// log.Println("")
+	// log.Println("~~subrouter2:")
+	// debugPrintTree(0, 0, sr2.router[mGET].root, 0)
+	// log.Println("")
+	// log.Println("")
+	//
+	// log.Println("")
+	// log.Println("~~subrouter3:")
+	// debugPrintTree(0, 0, sr3.router[mGET].root, 0)
+	// log.Println("")
+	// log.Println("")
 
 	ts := httptest.NewServer(r)
 	defer ts.Close()
 
-	var body, expected string
+	var resp, expected string
 
-	_, body = testRequest(t, ts, "GET", "/hubs/123/view", nil)
+	resp = testRequest(t, ts, "GET", "/hubs/123/view", nil)
 	expected = "hub1"
-	if body != expected {
-		t.Fatalf("expected:%s got:%s", expected, body)
+	if resp != expected {
+		t.Fatalf("expected:%s got:%s", expected, resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/hubs/123/view/index.html", nil)
+	resp = testRequest(t, ts, "GET", "/hubs/123/view/index.html", nil)
 	expected = "hub2"
-	if body != expected {
-		t.Fatalf("expected:%s got:%s", expected, body)
+	if resp != expected {
+		t.Fatalf("expected:%s got:%s", expected, resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/hubs/123/users", nil)
+	resp = testRequest(t, ts, "GET", "/hubs/123/users", nil)
 	expected = "hub3"
-	if body != expected {
-		t.Fatalf("expected:%s got:%s", expected, body)
+	if resp != expected {
+		t.Fatalf("expected:%s got:%s", expected, resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/accounts/44", nil)
+	resp = testRequest(t, ts, "GET", "/accounts/44", nil)
 	expected = "account1"
-	if body != expected {
-		t.Fatalf("request:%s expected:%s got:%s", "GET /accounts/44", expected, body)
+	if resp != expected {
+		t.Fatalf("request:%s expected:%s got:%s", "GET /accounts/44", expected, resp)
 	}
-	_, body = testRequest(t, ts, "GET", "/accounts/44/hi", nil)
+	resp = testRequest(t, ts, "GET", "/accounts/44/hi", nil)
 	expected = "account2"
-	if body != expected {
-		t.Fatalf("expected:%s got:%s", expected, body)
+	if resp != expected {
+		t.Fatalf("expected:%s got:%s", expected, resp)
 	}
 }
 
@@ -907,10 +825,10 @@ func TestSingleHandler(t *testing.T) {
 	w := httptest.NewRecorder()
 	h.ServeHTTP(w, r)
 
-	body := string(w.Body.Bytes())
+	resp := string(w.Body.Bytes())
 	expected := "hi joe"
-	if body != expected {
-		t.Fatalf("expected:%s got:%s", expected, body)
+	if resp != expected {
+		t.Fatalf("expected:%s got:%s", expected, resp)
 	}
 }
 
@@ -945,51 +863,51 @@ func TestMuxFileServer(t *testing.T) {
 	ts := httptest.NewServer(r)
 	defer ts.Close()
 
-	if _, body := testRequest(t, ts, "GET", "/hi", nil); body != "bye" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/hi", nil); resp != "bye" {
+		t.Fatalf(resp)
 	}
 
 	// HEADS UP: net/http notfoundhandler will kick-in for static assets
-	if _, body := testRequest(t, ts, "GET", "/mounted/nothing-here", nil); body == "nothing here" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/mounted/nothing-here", nil); resp == "nothing here" {
+		t.Fatalf(resp)
 	}
 
-	if _, body := testRequest(t, ts, "GET", "/nothing-here", nil); body == "nothing here" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/nothing-here", nil); resp == "nothing here" {
+		t.Fatalf(resp)
 	}
 
-	if _, body := testRequest(t, ts, "GET", "/mounted-nothing-here", nil); body == "nothing here" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/mounted-nothing-here", nil); resp == "nothing here" {
+		t.Fatalf(resp)
 	}
 
-	if _, body := testRequest(t, ts, "GET", "/hi", nil); body != "bye" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/hi", nil); resp != "bye" {
+		t.Fatalf(resp)
 	}
 
-	if _, body := testRequest(t, ts, "GET", "/ok", nil); body != "ok\n" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/ok", nil); resp != "ok\n" {
+		t.Fatalf(resp)
 	}
 
-	if _, body := testRequest(t, ts, "GET", "/mounted/ok", nil); body != "ok\n" {
-		t.Fatalf(body)
+	if resp := testRequest(t, ts, "GET", "/mounted/ok", nil); resp != "ok\n" {
+		t.Fatalf(resp)
 	}
 
 	// TODO/FIX: testFileSystem mock struct.. it struggles to pass this since it gets
 	// into a redirect loop, however, it does work with http.Dir() using the disk.
-	// if _, body := testRequest(t, ts, "GET", "/index.html", nil); body != "index\n" {
-	// 	t.Fatalf(body)
+	// if resp := testRequest(t, ts, "GET", "/index.html", nil); resp != "index\n" {
+	// 	t.Fatalf(resp)
 	// }
 
-	// if _, body := testRequest(t, ts, "GET", "/", nil); body != "index\n" {
-	// 	t.Fatalf(body)
+	// if resp := testRequest(t, ts, "GET", "/", nil); resp != "index\n" {
+	// 	t.Fatalf(resp)
 	// }
 
-	// if _, body := testRequest(t, ts, "GET", "/mounted", nil); body != "index\n" {
-	// 	t.Fatalf(body)
+	// if resp := testRequest(t, ts, "GET", "/mounted", nil); resp != "index\n" {
+	// 	t.Fatalf(resp)
 	// }
 
-	// if _, body := testRequest(t, ts, "GET", "/mounted/", nil); body != "index\n" {
-	// 	t.Fatalf(body)
+	// if resp := testRequest(t, ts, "GET", "/mounted/", nil); resp != "index\n" {
+	// 	t.Fatalf(resp)
 	// }
 }
 
@@ -1004,34 +922,34 @@ func urlParams(ctx context.Context) map[string]string {
 	return nil
 }
 
-func testRequest(t *testing.T, ts *httptest.Server, method, path string, body io.Reader) (*http.Response, string) {
+func testRequest(t *testing.T, ts *httptest.Server, method, path string, body io.Reader) string {
 	req, err := http.NewRequest(method, ts.URL+path, body)
 	if err != nil {
 		t.Fatal(err)
-		return nil, ""
+		return ""
 	}
 
 	resp, err := http.DefaultClient.Do(req)
 	if err != nil {
 		t.Fatal(err)
-		return nil, ""
+		return ""
 	}
 
 	respBody, err := ioutil.ReadAll(resp.Body)
 	if err != nil {
 		t.Fatal(err)
-		return nil, ""
+		return ""
 	}
 	defer resp.Body.Close()
 
-	return resp, string(respBody)
+	return string(respBody)
 }
 
-func testHandler(t *testing.T, h http.Handler, method, path string, body io.Reader) (*http.Response, string) {
+func testHandler(t *testing.T, h http.Handler, method, path string, body io.Reader) string {
 	r, _ := http.NewRequest(method, path, body)
 	w := httptest.NewRecorder()
 	h.ServeHTTP(w, r)
-	return w.Result(), string(w.Body.Bytes())
+	return string(w.Body.Bytes())
 }
 
 type testFileSystem struct {
diff --git a/tree.go b/tree.go
index e749ade..6f2b347 100644
--- a/tree.go
+++ b/tree.go
@@ -5,42 +5,11 @@ package chi
 // (MIT licensed)
 
 import (
-	"net/http"
 	"sort"
 	"strings"
+	"net/http"
 )
 
-// TODO: set the RoutePattern on the RouteContext
-
-type methodTyp int
-
-const (
-	mCONNECT methodTyp = 1 << iota
-	mDELETE
-	mGET
-	mHEAD
-	mOPTIONS
-	mPATCH
-	mPOST
-	mPUT
-	mTRACE
-
-	mALL methodTyp = mCONNECT | mDELETE | mGET | mHEAD | mOPTIONS |
-		mPATCH | mPOST | mPUT | mTRACE
-)
-
-var methodMap = map[string]methodTyp{
-	"CONNECT": mCONNECT,
-	"DELETE":  mDELETE,
-	"GET":     mGET,
-	"HEAD":    mHEAD,
-	"OPTIONS": mOPTIONS,
-	"PATCH":   mPATCH,
-	"POST":    mPOST,
-	"PUT":     mPUT,
-	"TRACE":   mTRACE,
-}
-
 type nodeTyp uint8
 
 const (
@@ -50,19 +19,10 @@ const (
 	ntCatchAll                // /api/v1/*
 )
 
-// TODO: comment
-// TODO: if WalkFn is exported, this needs to be as well, which its better not to.
-// I have a few ideas, will massage it later.
-type methodHandlers map[methodTyp]http.Handler
-
 // WalkFn is used when walking the tree. Takes a
 // key and value, returning if iteration should
 // be terminated.
-
-// TODO: .. lets leave it like this for now..
-// but we could also just make it
-// type WalkFn func(method string, pattern string, handler http.Handler) bool
-type WalkFn func(path string, handlers methodHandlers) bool
+type WalkFn func(path string, handler http.Handler) bool
 
 // edge is used to represent an edge node
 type edge struct {
@@ -77,8 +37,7 @@ type node struct {
 	prefix string
 
 	// HTTP handler on the leaf node
-	// handler http.Handler
-	handlers methodHandlers
+	handler http.Handler
 
 	// Edges should be stored in-order for iteration,
 	// in groups of the node type.
@@ -86,7 +45,7 @@ type node struct {
 }
 
 func (n *node) isLeaf() bool {
-	return n.handlers != nil
+	return n.handler != nil
 }
 
 func (n *node) addEdge(e edge) {
@@ -109,7 +68,7 @@ func (n *node) addEdge(e edge) {
 	if p == 0 {
 		// Path starts with a wildcard
 
-		handlers := e.node.handlers
+		handler := e.node.handler
 		e.node.typ = ntyp
 
 		if ntyp == ntCatchAll {
@@ -124,15 +83,15 @@ func (n *node) addEdge(e edge) {
 
 		if p != len(search) {
 			// add edge for the remaining part, split the end.
-			e.node.handlers = nil
+			e.node.handler = nil
 
 			search = search[p:]
 			e2 := edge{
 				label: search[0], // this will always start with /
 				node: &node{
-					typ:      ntStatic,
-					prefix:   search,
-					handlers: handlers,
+					typ:     ntStatic,
+					prefix:  search,
+					handler: handler,
 				},
 			}
 			e.node.addEdge(e2)
@@ -142,10 +101,10 @@ func (n *node) addEdge(e edge) {
 		// Path has some wildcard
 
 		// starts with a static segment
-		handlers := e.node.handlers
+		handler := e.node.handler
 		e.node.typ = ntStatic
 		e.node.prefix = search[:p]
-		e.node.handlers = nil
+		e.node.handler = nil
 
 		// add the wild edge node
 		search = search[p:]
@@ -153,9 +112,9 @@ func (n *node) addEdge(e edge) {
 		e2 := edge{
 			label: search[0],
 			node: &node{
-				typ:      ntyp,
-				prefix:   search,
-				handlers: handlers,
+				typ:     ntyp,
+				prefix:  search,
+				handler: handler,
 			},
 		}
 		e.node.addEdge(e2)
@@ -225,7 +184,7 @@ func (n *node) findEdge(ntyp nodeTyp, label byte) *node {
 
 // Recursive edge traversal by checking all nodeTyp groups along the way.
 // It's like searching through a three-dimensional radix trie.
-func (n *node) findNode(ctx *Context, method methodTyp, path string) *node {
+func (n *node) findNode(ctx *Context, path string) *node {
 	nn := n
 	search := path
 
@@ -278,35 +237,25 @@ func (n *node) findNode(ctx *Context, method methodTyp, path string) *node {
 		}
 
 		// recursively find the next node..
-		fin := xn.findNode(ctx, method, xsearch)
+		fin := xn.findNode(ctx, xsearch)
 		if fin != nil {
 			// found a node, return it
 			return fin
 		}
 
 		// Did not found final handler, let's remove the param here if it was set
-		// TODO: can we do even better now though...?
-		if xn.typ > ntStatic && xn.typ < ntCatchAll {
-			ctx.Params.Del(xn.prefix[1:])
+		if xn.typ > ntStatic {
+			if xn.typ == ntCatchAll {
+				ctx.Params.Del("*")
+			} else {
+				ctx.Params.Del(xn.prefix[1:])
+			}
 		}
 	}
 
 	return nil
 }
 
-func (n *node) setHandler(method methodTyp, handler http.Handler) {
-	if n.handlers == nil {
-		n.handlers = make(methodHandlers, 0)
-	}
-	if method == mALL {
-		for _, m := range methodMap {
-			n.handlers[m] = handler
-		}
-	} else {
-		n.handlers[method] = handler
-	}
-}
-
 type edges []edge
 
 // Sort the list of edges by label
@@ -323,7 +272,7 @@ type tree struct {
 	root *node
 }
 
-func (t *tree) Insert(method methodTyp, pattern string, handler http.Handler) {
+func (t *tree) Insert(pattern string, handler http.Handler) {
 	var parent *node
 	n := t.root
 	search := pattern
@@ -332,8 +281,7 @@ func (t *tree) Insert(method methodTyp, pattern string, handler http.Handler) {
 		// Handle key exhaustion
 		if len(search) == 0 {
 			// Insert or update the node's leaf handler
-			// n.handler = handler
-			n.setHandler(method, handler)
+			n.handler = handler
 			return
 		}
 
@@ -346,11 +294,10 @@ func (t *tree) Insert(method methodTyp, pattern string, handler http.Handler) {
 			e := edge{
 				label: search[0],
 				node: &node{
-					prefix: search,
-					// handler: handler,
+					prefix:  search,
+					handler: handler,
 				},
 			}
-			e.node.setHandler(method, handler)
 			parent.addEdge(e)
 			return
 		}
@@ -396,53 +343,48 @@ func (t *tree) Insert(method methodTyp, pattern string, handler http.Handler) {
 		// If the new key is a subset, add to to this node
 		search = search[commonPrefix:]
 		if len(search) == 0 {
-			// child.handler = handler
-			child.setHandler(method, handler)
+			child.handler = handler
 			return
 		}
 
 		// Create a new edge for the node
-		e := edge{
+		child.addEdge(edge{
 			label: search[0],
 			node: &node{
-				typ:    ntStatic,
-				prefix: search,
-				// handler: handler,
+				typ:     ntStatic,
+				prefix:  search,
+				handler: handler,
 			},
-		}
-		e.node.setHandler(method, handler)
-		child.addEdge(e)
+		})
 		return
 	}
 }
 
-func (t *tree) Find(ctx *Context, method methodTyp, path string) methodHandlers {
-	node := t.root.findNode(ctx, method, path)
+func (t *tree) Find(ctx *Context, path string) http.Handler {
+	node := t.root.findNode(ctx, path)
 	if node == nil {
 		return nil
 	}
-	return node.handlers
+	return node.handler
 }
 
 // Walk is used to walk the tree
 func (t *tree) Walk(fn WalkFn) {
-	t.recursiveWalk(t.root.prefix, t.root, fn)
+	t.recursiveWalk(t.root, fn)
 }
 
 // recursiveWalk is used to do a pre-order walk of a node
 // recursively. Returns true if the walk should be aborted
-func (t *tree) recursiveWalk(pattern string, n *node, fn WalkFn) bool {
-	pattern += n.prefix
-
+func (t *tree) recursiveWalk(n *node, fn WalkFn) bool {
 	// Visit the leaf values if any
-	if n.handlers != nil && fn(pattern, n.handlers) {
+	if n.handler != nil && fn(n.prefix, n.handler) {
 		return true
 	}
 
 	// Recurse on the children
 	for _, edges := range n.edges {
 		for _, e := range edges {
-			if t.recursiveWalk(pattern, e.node, fn) {
+			if t.recursiveWalk(e.node, fn) {
 				return true
 			}
 		}
@@ -465,3 +407,47 @@ func (t *tree) longestPrefix(k1, k2 string) int {
 	}
 	return i
 }
+
+type param struct {
+	Key, Value string
+}
+
+type params []param // TODO: change to map[string]string ?
+
+func (ps *params) Add(key string, value string) {
+	*ps = append(*ps, param{key, value})
+}
+
+func (ps params) Get(key string) string {
+	for _, p := range ps {
+		if p.Key == key {
+			return p.Value
+		}
+	}
+	return ""
+}
+
+func (ps *params) Set(key string, value string) {
+	idx := -1
+	for i, p := range *ps {
+		if p.Key == key {
+			idx = i
+			break
+		}
+	}
+	if idx < 0 {
+		(*ps).Add(key, value)
+	} else {
+		(*ps)[idx] = param{key, value}
+	}
+}
+
+func (ps *params) Del(key string) string {
+	for i, p := range *ps {
+		if p.Key == key {
+			*ps = append((*ps)[:i], (*ps)[i+1:]...)
+			return p.Value
+		}
+	}
+	return ""
+}
diff --git a/tree_test.go b/tree_test.go
index 37cac20..f297bb3 100644
--- a/tree_test.go
+++ b/tree_test.go
@@ -2,6 +2,7 @@ package chi
 
 import (
 	"fmt"
+	"log"
 	"net/http"
 	"reflect"
 	"testing"
@@ -36,51 +37,51 @@ func TestTree(t *testing.T) {
 
 	tr := &tree{root: &node{}}
 
-	tr.Insert(mGET, "/", hIndex)
-	tr.Insert(mGET, "/favicon.ico", hFavicon)
+	tr.Insert("/", hIndex)
+	tr.Insert("/favicon.ico", hFavicon)
 
-	tr.Insert(mGET, "/pages/*", hStub)
+	tr.Insert("/pages/*", hStub)
 
-	tr.Insert(mGET, "/article", hArticleList)
-	tr.Insert(mGET, "/article/", hArticleList) // redirect..?
+	tr.Insert("/article", hArticleList)
+	tr.Insert("/article/", hArticleList) // redirect..?
 
-	tr.Insert(mGET, "/article/near", hArticleNear)
+	tr.Insert("/article/near", hArticleNear)
 	// tr.Insert("/article/:sup", hStub) // will get overwritten as :id param TODO -- what does goji do..?
-	tr.Insert(mGET, "/article/:id", hStub)
-	tr.Insert(mGET, "/article/:id", hArticleShow)
-	tr.Insert(mGET, "/article/:id", hArticleShow) // duplicate will have no effect
-	tr.Insert(mGET, "/article/@:user", hArticleByUser)
+	tr.Insert("/article/:id", hStub)
+	tr.Insert("/article/:id", hArticleShow)
+	tr.Insert("/article/:id", hArticleShow) // duplicate will have no effect
+	tr.Insert("/article/@:user", hArticleByUser)
 
-	tr.Insert(mGET, "/article/:sup/:opts", hArticleShowOpts) // TODO: and what if someone adds this?
-	tr.Insert(mGET, "/article/:id/:opts", hArticleShowOpts)
+	tr.Insert("/article/:sup/:opts", hArticleShowOpts) // TODO: and what if someone adds this?
+	tr.Insert("/article/:id/:opts", hArticleShowOpts)
 
-	tr.Insert(mGET, "/article/:iffd/edit", hStub)
-	tr.Insert(mGET, "/article/:id//related", hArticleShowRelated)
-	tr.Insert(mGET, "/article/slug/:month/-/:day/:year", hArticleSlug)
+	tr.Insert("/article/:iffd/edit", hStub)
+	tr.Insert("/article/:id//related", hArticleShowRelated)
+	tr.Insert("/article/slug/:month/-/:day/:year", hArticleSlug)
 
-	tr.Insert(mGET, "/admin/user", hUserList)
-	tr.Insert(mGET, "/admin/user/", hStub) // will get replaced by next route
-	tr.Insert(mGET, "/admin/user/", hUserList)
+	tr.Insert("/admin/user", hUserList)
+	tr.Insert("/admin/user/", hStub) // will get replaced by next route
+	tr.Insert("/admin/user/", hUserList)
 
-	tr.Insert(mGET, "/admin/user//:id", hUserShow)
-	tr.Insert(mGET, "/admin/user/:id", hUserShow) // TODO: how does goji handle those segments?
+	tr.Insert("/admin/user//:id", hUserShow)
+	tr.Insert("/admin/user/:id", hUserShow) // TODO: how does goji handle those segments?
 
-	tr.Insert(mGET, "/admin/apps/:id", hAdminAppShow)
-	tr.Insert(mGET, "/admin/apps/:id/*ff", hAdminAppShowCatchall)
+	tr.Insert("/admin/apps/:id", hAdminAppShow)
+	tr.Insert("/admin/apps/:id/*ff", hAdminAppShowCatchall)
 
-	tr.Insert(mGET, "/admin/*ff", hStub) // catchall segment will get replaced by next route
-	tr.Insert(mGET, "/admin/*", hAdminCatchall)
+	tr.Insert("/admin/*ff", hStub) // catchall segment will get replaced by next route
+	tr.Insert("/admin/*", hAdminCatchall)
 
-	tr.Insert(mGET, "/users/:userID/profile", hUserProfile)
-	tr.Insert(mGET, "/users/super/*", hUserSuper)
-	tr.Insert(mGET, "/users/*", hUserAll)
+	tr.Insert("/users/:userID/profile", hUserProfile)
+	tr.Insert("/users/super/*", hUserSuper)
+	tr.Insert("/users/*", hUserAll)
 
-	tr.Insert(mGET, "/hubs/:hubID/view", hHubView1)
-	tr.Insert(mGET, "/hubs/:hubID/view/*", hHubView2)
+	tr.Insert("/hubs/:hubID/view", hHubView1)
+	tr.Insert("/hubs/:hubID/view/*", hHubView2)
 	sr := NewRouter()
 	sr.Get("/users", hHubView3)
-	tr.Insert(mGET, "/hubs/:hubID/*", sr)
-	tr.Insert(mGET, "/hubs/:hubID/users", hHubView3)
+	tr.Insert("/hubs/:hubID/*", sr)
+	tr.Insert("/hubs/:hubID/users", hHubView3)
 
 	// tr.Insert("/debug*", hStub) // TODO: should we support this..?
 
@@ -140,12 +141,8 @@ func TestTree(t *testing.T) {
 	for i, tt := range tests {
 		// params := make(map[string]string, 0)
 		rctx := NewRouteContext()
-
-		handlers := tr.Find(rctx, mGET, tt.r) //, params)
-		handler, _ := handlers[mGET]
-
+		handler := tr.Find(rctx, tt.r) //, params)
 		params := urlParams(rctx)
-
 		if fmt.Sprintf("%v", tt.h) != fmt.Sprintf("%v", handler) {
 			t.Errorf("input [%d]: find '%s' expecting handler:%v , got:%v", i, tt.r, tt.h, handler)
 		}
@@ -155,43 +152,43 @@ func TestTree(t *testing.T) {
 	}
 }
 
-// func debugPrintTree(parent int, i int, n *node, label byte) bool {
-// 	numEdges := 0
-// 	for _, edges := range n.edges {
-// 		numEdges += len(edges)
-// 	}
-//
-// 	if n.handler != nil {
-// 		log.Printf("[node %d parent:%d] typ:%d prefix:%s label:%s numEdges:%d isLeaf:%v handler:%v\n", i, parent, n.typ, n.prefix, string(label), numEdges, n.isLeaf(), n.handler)
-// 	} else {
-// 		log.Printf("[node %d parent:%d] typ:%d prefix:%s label:%s numEdges:%d isLeaf:%v\n", i, parent, n.typ, n.prefix, string(label), numEdges, n.isLeaf())
-// 	}
-//
-// 	parent = i
-// 	for _, edges := range n.edges {
-// 		for _, e := range edges {
-// 			i++
-// 			if debugPrintTree(parent, i, e.node, e.label) {
-// 				return true
-// 			}
-// 		}
-// 	}
-// 	return false
-// }
+func debugPrintTree(parent int, i int, n *node, label byte) bool {
+	numEdges := 0
+	for _, edges := range n.edges {
+		numEdges += len(edges)
+	}
+
+	if n.handler != nil {
+		log.Printf("[node %d parent:%d] typ:%d prefix:%s label:%s numEdges:%d isLeaf:%v handler:%v\n", i, parent, n.typ, n.prefix, string(label), numEdges, n.isLeaf(), n.handler)
+	} else {
+		log.Printf("[node %d parent:%d] typ:%d prefix:%s label:%s numEdges:%d isLeaf:%v\n", i, parent, n.typ, n.prefix, string(label), numEdges, n.isLeaf())
+	}
+
+	parent = i
+	for _, edges := range n.edges {
+		for _, e := range edges {
+			i++
+			if debugPrintTree(parent, i, e.node, e.label) {
+				return true
+			}
+		}
+	}
+	return false
+}
 
 func BenchmarkTreeGet(b *testing.B) {
 	h1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})
 	h2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})
 
 	tr := &tree{root: &node{}}
-	tr.Insert(mGET, "/", h1)
-	tr.Insert(mGET, "/ping", h2)
-	tr.Insert(mGET, "/pingall", h2)
-	tr.Insert(mGET, "/ping/:id", h2)
-	tr.Insert(mGET, "/ping/:id/woop", h2)
-	tr.Insert(mGET, "/ping/:id/:opt", h2)
-	tr.Insert(mGET, "/pinggggg", h2)
-	tr.Insert(mGET, "/hello", h1)
+	tr.Insert("/", h1)
+	tr.Insert("/ping", h2)
+	tr.Insert("/pingall", h2)
+	tr.Insert("/ping/:id", h2)
+	tr.Insert("/ping/:id/woop", h2)
+	tr.Insert("/ping/:id/:opt", h2)
+	tr.Insert("/pinggggg", h2)
+	tr.Insert("/hello", h1)
 
 	b.ReportAllocs()
 	b.ResetTimer()
@@ -199,7 +196,7 @@ func BenchmarkTreeGet(b *testing.B) {
 	for i := 0; i < b.N; i++ {
 		// params := map[string]string{}
 		mctx := NewRouteContext()
-		tr.Find(mctx, mGET, "/ping/123/456")
+		tr.Find(mctx, "/ping/123/456")
 		// tr.Find("/pingggg", params)
 	}
 }
diff --git a/util.go b/util.go
index 04d00ce..3d897df 100644
--- a/util.go
+++ b/util.go
@@ -2,17 +2,6 @@ package chi
 
 import "net/http"
 
-// contextKey is a value for use with context.WithValue. It's used as
-// a pointer so it fits in an interface{} without allocation. This technique
-// for defining context keys was copied from Go 1.7's new use of context in net/http.
-type contextKey struct {
-	name string
-}
-
-func (k *contextKey) String() string {
-	return "chi context value " + k.name
-}
-
 // chain builds a http.Handler composed of middlewares and endpoint handler in the
 // order they are passed.
 func chain(middlewares []func(http.Handler) http.Handler, endpoint http.Handler) http.Handler {
@@ -34,5 +23,5 @@ func chain(middlewares []func(http.Handler) http.Handler, endpoint http.Handler)
 // 405 Method not allowed.
 func methodNotAllowedHandler(w http.ResponseWriter, r *http.Request) {
 	w.WriteHeader(405)
-	w.Write(nil)
+	w.Write([]byte(http.StatusText(405)))
 }
