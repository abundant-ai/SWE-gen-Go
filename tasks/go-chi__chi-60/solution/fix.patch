diff --git a/_examples/rest/main.go b/_examples/rest/main.go
index a311e7d..3c9701f 100644
--- a/_examples/rest/main.go
+++ b/_examples/rest/main.go
@@ -89,11 +89,8 @@ func main() {
 
 	// RESTy routes for "articles" resource
 	r.Route("/articles", func(r chi.Router) {
-		r.Group(func(r chi.Router) {
-			r.Use(paginate)
-			r.Get("/", listArticles) // GET /articles
-		})
-		r.Post("/", createArticle) // POST /articles
+		r.Get("/", chi.Use(paginate).Handler(listArticles)) // GET /articles
+		r.Post("/", createArticle)                          // POST /articles
 
 		r.Route("/:articleID", func(r chi.Router) {
 			r.Use(ArticleCtx)
@@ -222,7 +219,7 @@ func paginate(next http.Handler) http.Handler {
 }
 
 // A completely separate router for administrator routes
-func adminRouter() http.Handler { // or chi.Router {
+func adminRouter() chi.Router {
 	r := chi.NewRouter()
 	r.Use(AdminOnly)
 	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
diff --git a/_examples/simple/main.go b/_examples/simple/main.go
index af07134..ea6f890 100644
--- a/_examples/simple/main.go
+++ b/_examples/simple/main.go
@@ -31,7 +31,7 @@ func main() {
 	http.ListenAndServe(":3333", r)
 }
 
-func accountsRouter() chi.Router { // or http.Handler
+func accountsRouter() chi.Router {
 	r := chi.NewRouter()
 
 	r.Use(sup1)
diff --git a/_examples/todos-resource/main.go b/_examples/todos-resource/main.go
new file mode 100644
index 0000000..10100e3
--- /dev/null
+++ b/_examples/todos-resource/main.go
@@ -0,0 +1,46 @@
+package main
+
+import (
+	"net/http"
+
+	"github.com/pressly/chi"
+	"github.com/pressly/chi/middleware"
+)
+
+func main() {
+	r := chi.NewRouter()
+
+	r.Use(middleware.RequestID)
+	r.Use(middleware.RealIP)
+	r.Use(middleware.Logger)
+	r.Use(middleware.Recoverer)
+
+	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte("."))
+	})
+
+	r.Mount("/", usersResource{}.Routes())
+	r.Mount("/", todosResource{}.Routes())
+
+	// r.Mount("/",
+	// 	usersResource{}.Routes(),
+	// 	todosResource{}.Routes(),
+	// )
+
+	// r.Mount(chi.Route("/users", router))
+
+	// r.Route("/", chi.RouterFunc(usersResource{}.Routes()))
+
+	// r.Mount(usersResource{}.Routes())
+
+	// r.Mount("/",
+	// 	usersResource{}.Routes(),
+	// 	todosResource{}.Routes(),
+	// )
+
+	// hmmm.. perhaps r.Mount() will actually add to the existing tree..?
+	// instead of making a real subrouter and joining with a middleware......?
+	// effectively, joining 2 trees...
+
+	http.ListenAndServe(":3333", r)
+}
diff --git a/_examples/todos-resource/todos.go b/_examples/todos-resource/todos.go
new file mode 100644
index 0000000..0cafcaf
--- /dev/null
+++ b/_examples/todos-resource/todos.go
@@ -0,0 +1,56 @@
+package main
+
+import (
+	"net/http"
+
+	"github.com/pressly/chi"
+)
+
+type todosResource struct{}
+
+// Routes creates a REST router for the todos resource
+func (rs todosResource) Routes() chi.Router {
+	r := chi.NewRouter()
+
+	// r.Use() // some middleware..
+
+	r.Route("/todos", func(r chi.Router) {
+		r.Get("/", rs.List)    // GET /todos - read a list of todos
+		r.Post("/", rs.Create) // POST /todos - create a new todo and persist it
+		r.Put("/", rs.Delete)
+
+		r.Route("/:id", func(r chi.Router) {
+			// r.Use(rs.TodoCtx) // lets have a todos map, and lets actually load/manipulate
+			r.Get("/", rs.Get)       // GET /todos/:id - read a single todo by :id
+			r.Put("/", rs.Update)    // PUT /todos/:id - update a single todo by :id
+			r.Delete("/", rs.Delete) // DELETE /todos/:id - delete a single todo by :id
+			r.Get("/sync", rs.Sync)
+		})
+	})
+
+	return r
+}
+
+func (rs todosResource) List(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("todos list of stuff.."))
+}
+
+func (rs todosResource) Create(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("todos create"))
+}
+
+func (rs todosResource) Get(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("todo get"))
+}
+
+func (rs todosResource) Update(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("todo update"))
+}
+
+func (rs todosResource) Delete(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("todo delete"))
+}
+
+func (rs todosResource) Sync(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("todo sync"))
+}
diff --git a/_examples/todos-resource/users.go b/_examples/todos-resource/users.go
new file mode 100644
index 0000000..5a541d9
--- /dev/null
+++ b/_examples/todos-resource/users.go
@@ -0,0 +1,51 @@
+package main
+
+import (
+	"net/http"
+
+	"github.com/pressly/chi"
+)
+
+type usersResource struct{}
+
+// Routes creates a REST router for the todos resource
+func (rs usersResource) Routes() chi.Router {
+	r := chi.NewRouter()
+
+	// r.Use() // some middleware..
+
+	r.Route("/users", func(r chi.Router) {
+		r.Get("/", rs.List)    // GET /todos - read a list of todos
+		r.Post("/", rs.Create) // POST /todos - create a new todo and persist it
+		r.Put("/", rs.Delete)
+
+		r.Route("/:id", func(r chi.Router) {
+			// r.Use(rs.TodoCtx) // lets have a todos map, and lets actually load/manipulate
+			r.Get("/", rs.Get)       // GET /todos/:id - read a single todo by :id
+			r.Put("/", rs.Update)    // PUT /todos/:id - update a single todo by :id
+			r.Delete("/", rs.Delete) // DELETE /todos/:id - delete a single todo by :id
+		})
+	})
+
+	return r
+}
+
+func (rs usersResource) List(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("aaa list of stuff.."))
+}
+
+func (rs usersResource) Create(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("aaa create"))
+}
+
+func (rs usersResource) Get(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("aaa get"))
+}
+
+func (rs usersResource) Update(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("aaa update"))
+}
+
+func (rs usersResource) Delete(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte("aaa delete"))
+}
diff --git a/chi.go b/chi.go
index b42c969..1b9fbca 100644
--- a/chi.go
+++ b/chi.go
@@ -14,14 +14,15 @@ type Router interface {
 
 	Use(middlewares ...func(http.Handler) http.Handler)
 
-	Route(pattern string, fn func(r Router)) Router
 	Group(fn func(r Router)) Router
+	Route(pattern string, fn func(r Router)) Router
+	Mount(pattern string, rs Router)
 
-	Mount(pattern string, h http.Handler)
 	Handle(pattern string, h http.Handler)
 	HandleFunc(pattern string, h http.HandlerFunc)
 	NotFound(h http.HandlerFunc)
 
+	// Any(pattern string, h.HandlerFunc) // ???
 	Connect(pattern string, h http.HandlerFunc)
 	Head(pattern string, h http.HandlerFunc)
 	Get(pattern string, h http.HandlerFunc)
@@ -31,6 +32,8 @@ type Router interface {
 	Delete(pattern string, h http.HandlerFunc)
 	Trace(pattern string, h http.HandlerFunc)
 	Options(pattern string, h http.HandlerFunc)
+
+	// GetMux() *Mux
 }
 
 type Middlewares []func(http.Handler) http.Handler
diff --git a/context.go b/context.go
index ea15cd9..1408688 100644
--- a/context.go
+++ b/context.go
@@ -21,6 +21,10 @@ type Context struct {
 
 	// Routing path override used by subrouters
 	RoutePath string
+
+	// Routing pattern that matches the request
+	// TODO: ..
+	RoutePattern string
 }
 
 // NewRouteContext returns a new routing context object.
@@ -63,13 +67,46 @@ func URLParamFromCtx(ctx context.Context, key string) string {
 	return ""
 }
 
-// contextKey is a value for use with context.WithValue. It's used as
-// a pointer so it fits in an interface{} without allocation. This technique
-// for defining context keys was copied from Go 1.7's new use of context in net/http.
-type contextKey struct {
-	name string
+type param struct {
+	Key, Value string
+}
+
+type params []param
+
+func (ps *params) Add(key string, value string) {
+	*ps = append(*ps, param{key, value})
+}
+
+func (ps params) Get(key string) string {
+	for _, p := range ps {
+		if p.Key == key {
+			return p.Value
+		}
+	}
+	return ""
+}
+
+func (ps *params) Set(key string, value string) {
+	idx := -1
+	for i, p := range *ps {
+		if p.Key == key {
+			idx = i
+			break
+		}
+	}
+	if idx < 0 {
+		(*ps).Add(key, value)
+	} else {
+		(*ps)[idx] = param{key, value}
+	}
 }
 
-func (k *contextKey) String() string {
-	return "chi context value " + k.name
+func (ps *params) Del(key string) string {
+	for i, p := range *ps {
+		if p.Key == key {
+			*ps = append((*ps)[:i], (*ps)[i+1:]...)
+			return p.Value
+		}
+	}
+	return ""
 }
diff --git a/mux.go b/mux.go
index cf72a62..b5753c4 100644
--- a/mux.go
+++ b/mux.go
@@ -17,55 +17,41 @@ var _ Router = &Mux{}
 // for writing large REST API services that break a handler into many smaller
 // parts composed of middlewares and end handlers.
 type Mux struct {
+	// The radix trie router
+	router *tree
+
 	// The middleware stack
 	middlewares []func(http.Handler) http.Handler
 
-	// The radix trie router
-	router *treeRouter
-
-	// The mux handler, chained middleware stack and tree router
+	// The computed mux handler made of the chained middleware stack and
+	// the tree router
 	handler http.Handler
 
+	// A reference to the parent mux used by subrouters when mounting
+	// to a parent mux
+	parent *Mux
+
+	// The mounting pattern used by subrouters used to build subsequent
+	// routes as other routers mount together
+	mountPattern string
+
 	// Controls the behaviour of middleware chain generation when a mux
-	// is registered as an inline group inside another mux.
+	// is registered as an inline group inside another mux
 	inline bool
 
 	// Routing context pool
 	pool sync.Pool
-}
 
-type methodTyp int
-
-const (
-	mCONNECT methodTyp = 1 << iota
-	mDELETE
-	mGET
-	mHEAD
-	mOPTIONS
-	mPATCH
-	mPOST
-	mPUT
-	mTRACE
-
-	mALL methodTyp = mCONNECT | mDELETE | mGET | mHEAD | mOPTIONS |
-		mPATCH | mPOST | mPUT | mTRACE
-)
-
-var methodMap = map[string]methodTyp{
-	"CONNECT": mCONNECT,
-	"DELETE":  mDELETE,
-	"GET":     mGET,
-	"HEAD":    mHEAD,
-	"OPTIONS": mOPTIONS,
-	"PATCH":   mPATCH,
-	"POST":    mPOST,
-	"PUT":     mPUT,
-	"TRACE":   mTRACE,
+	// Custom route not found handler
+	notFoundHandler http.HandlerFunc
 }
 
 // NewMux returns a new Mux object with an optional parent context.
 func NewMux() *Mux {
-	mux := &Mux{router: newTreeRouter(), handler: nil}
+	mux := &Mux{
+		router:          &tree{root: &node{}},
+		notFoundHandler: http.NotFound,
+	}
 	mux.pool.New = func() interface{} {
 		return NewRouteContext()
 	}
@@ -143,63 +129,18 @@ func (mx *Mux) Options(pattern string, handlerFn http.HandlerFunc) {
 
 // NotFound sets a custom http.HandlerFunc for missing routes on the treeRouter.
 func (mx *Mux) NotFound(handlerFn http.HandlerFunc) {
-	mx.router.notFoundHandler = &handlerFn
-}
-
-// FileServer conveniently sets up a http.FileServer handler to serve
-// static files from a http.FileSystem.
-func (mx *Mux) FileServer(path string, root http.FileSystem) {
-	fs := http.StripPrefix(path, http.FileServer(root))
-	mx.Get(path+"*", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		fs.ServeHTTP(w, r)
-	}))
-}
-
-// handle creates a chi.Handler from a chain of middlewares and an end handler,
-// and then registers the route in the router.
-func (mx *Mux) handle(method methodTyp, pattern string, handler http.Handler) {
-	if len(pattern) == 0 || pattern[0] != '/' {
-		panic(fmt.Sprintf("chi: routing pattern must begin with '/' in '%s'", pattern))
-	}
-
-	// Build the single mux handler that is a chain of the middleware stack, as
-	// defined by calls to Use(), and the tree router (mux) itself. After this point,
-	// no other middlewares can be registered on this mux's stack. But you can still
-	// use inline middlewares via Group()'s and other routes that only execute after
-	// a matched pattern on the treeRouter.
-	if !mx.inline && mx.handler == nil {
-		// TODO: we may remove the treeRouter type and collapse it into the Mux{},
-		// at that point, we'd chain to just mx instead of mx.router, or consider
-		// some other ideas..
-		mx.handler = chain(mx.middlewares, mx.router)
-	}
-
-	// Build endpoint handler with inline middlewares for the route
-	var endpoint http.Handler
-	if mx.inline {
-		mx.handler = mx.router // TODO: just mx ...?
-		endpoint = chain(mx.middlewares, handler)
-	} else {
-		endpoint = handler
-	}
-
-	// Set the route for the respective HTTP methods
-	for _, mt := range methodMap {
-		m := method & mt
-		if m > 0 {
-			mx.router.routes[m].Insert(pattern, endpoint)
-		}
-	}
+	mx.notFoundHandler = handlerFn
 }
 
 // Group creates a new inline-Mux with a fresh middleware stack. It's useful
 // for a group of handlers along the same routing path that use the same
 // middleware(s). See _examples/ for an example usage.
 func (mx *Mux) Group(fn func(r Router)) Router {
-	// Similarly as in handle(), we must build the mux handler once further
-	// middleware registration isn't allowed for this stack, like now.
+	// Similarly as in handle(), we must build the final mux handler from the tree
+	// and the middleware stack. Further middleware additions will be ignored,
+	// after this point.
 	if !mx.inline && mx.handler == nil {
-		mx.handler = chain(mx.middlewares, mx.router)
+		mx.handler = chain(mx.middlewares, http.HandlerFunc(mx.routeHTTP))
 	}
 
 	// Make a new inline mux and run the router functions over it.
@@ -214,111 +155,134 @@ func (mx *Mux) Group(fn func(r Router)) Router {
 // along the `pattern` as a subrouter. This is very similar to Group, but attaches
 // the group along a new routing path. See _examples/ for example usage.
 func (mx *Mux) Route(pattern string, fn func(r Router)) Router {
-	subRouter := NewRouter()
-	mx.Mount(pattern, subRouter)
+	subrouter := NewRouter()
 	if fn != nil {
-		fn(subRouter)
+		fn(subrouter)
 	}
-	return subRouter
+	mx.Mount(pattern, subrouter)
+	return subrouter
 }
 
 // Mount attaches another chi Router as a subrouter along a routing path. It's very
 // useful to split up a large API as many independent routers and compose them as
 // a single service using Mount. See _examples/ for example usage.
-func (mx *Mux) Mount(path string, handler http.Handler) {
-	// Assign sub-Router's with the parent not found handler if not specified.
-	if sr, ok := handler.(*Mux); ok {
-		if sr.router.notFoundHandler == nil && mx.router.notFoundHandler != nil {
-			sr.NotFound(*mx.router.notFoundHandler)
-		}
-	}
+func (mx *Mux) Mount(pattern string, subrouter Router) {
 
-	// Wrap the sub-router in a handlerFunc to scope the request path for routing.
-	subHandler := func(w http.ResponseWriter, r *http.Request) {
-		rctx := RouteContext(r.Context())
-		rctx.RoutePath = "/" + rctx.Params.Del("*")
-		handler.ServeHTTP(w, r)
+	// TODO: this will panic, but we'll solve it right later.
+	smx, ok := subrouter.(*Mux)
+	if !ok {
+		panic("subrouter is not a Mux.")
 	}
 
-	if path == "" || path[len(path)-1] != '/' {
-		mx.HandleFunc(path, subHandler)
-		mx.HandleFunc(path+"/", mx.router.NotFoundHandler())
-		path += "/"
-	}
-	mx.HandleFunc(path+"*", subHandler)
-}
+	// TODO: change mx.parent to type Router
 
-// ServeHTTP is the single method of the http.Handler interface that makes
-// Mux interoperable with the standard library. It uses a sync.Pool to get and
-// reuse routing contexts for each request.
-func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	// Ensure the mux has some routes defined on the mux
-	if mx.handler == nil {
-		panic("chi: attempting to route to a mux with no handlers.")
+	// TODO: switch methods to strings ... okay...
+
+	// TODO: add Router method Handle(method, pattern, handler)
+
+	// XXX: FINALLY .... how do we set the damn parent....? and mountPattern ...?
+	// XXX: how do we get the parent and mountPattern ...?
+
+	// TODO: Routes() will let us walk a router..
+
+	// IDEA: is it possible to set the parent Mux, and mountingPattern in the actual
+	// tree, and get it back from walking...? or get the Mux from walking..?
+
+	smx.parent = mx
+	smx.mountPattern = pattern
+
+	rt := mx
+	if rt.parent != nil {
+		rt = mx.parent
 	}
 
-	//ctx := mx.pool.Get().(*Context)
-	//r = r.WithContext(ctx)
-	//mx.routeHTTP(w, r)
-	//ctx.reset()
-	//mx.pool.Put(ctx)
+	if mx.mountPattern != "/" {
+		pattern = mx.mountPattern + pattern
+	}
 
-	// TODO: do we care about zero-alloc routing? test actual
-	// throughput, if not, switch the params to map[string]string
+	// Re-inserting the routes from the passed router to our new sub router.
+	// The subrouter is already pointing at the base router to insert the routes.
+	smx.router.Walk(func(route string, handlers methodHandlers) bool {
+		if route == "/" {
+			route = pattern
+		} else if pattern[len(pattern)-1] == '/' && route[0] == '/' {
+			route = pattern + route[1:]
+		} else if pattern != "/" {
+			route = pattern + route
+		}
 
-	ctx := r.Context()
-	rctx, ok := ctx.(*Context)
-	if !ok || rctx == nil {
-		rctx, ok = ctx.Value(RouteCtxKey).(*Context)
-		if !ok {
-			//fmt.Println("We're making a new context!!")
-			rctx = NewRouteContext()
-			r = r.WithContext(rctx)
+		for m, h := range handlers {
+			rt.handle(m, route, chain(smx.middlewares, h))
 		}
-	}
-	mx.handler.ServeHTTP(w, r)
+
+		return false
+	})
 }
 
-func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
-	mx.handler.ServeHTTP(w, r)
+// FileServer conveniently sets up a http.FileServer handler to serve
+// static files from a http.FileSystem.
+func (mx *Mux) FileServer(path string, root http.FileSystem) {
+	fs := http.StripPrefix(path, http.FileServer(root))
+	mx.Get(path+"*", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		fs.ServeHTTP(w, r)
+	}))
 }
 
-// A treeRouter manages a radix trie prefix-router for each HTTP method and passes
-// each request via its chi.Handler method.
-type treeRouter struct {
-	// Routing tree by method type
-	routes map[methodTyp]*tree
+// handle creates a chi.Handler from a chain of middlewares and an end handler,
+// and then registers the route in the router.
+func (mx *Mux) handle(method methodTyp, pattern string, handler http.Handler) {
+	if len(pattern) == 0 || pattern[0] != '/' {
+		panic(fmt.Sprintf("chi: routing pattern must begin with '/' in '%s'", pattern))
+	}
 
-	// Custom route not found handler
-	notFoundHandler *http.HandlerFunc
-}
+	// TOOD: add a validation method to check the route and that params
+	// dont conflict.
 
-// newTreeRouter creates a new treeRouter object and initializes the trees for
-// each http method.
-func newTreeRouter() *treeRouter {
-	tr := &treeRouter{
-		routes:          make(map[methodTyp]*tree, len(methodMap)),
-		notFoundHandler: nil,
+	// Build the single mux handler that is a chain of the middleware stack, as
+	// defined by calls to Use(), and the tree router (mux) itself. After this point,
+	// no other middlewares can be registered on this mux's stack. But you can still
+	// use inline middlewares via Group()'s and other routes that only execute after
+	// a matched pattern on the treeRouter.
+	if !mx.inline && mx.handler == nil {
+		mx.handler = chain(mx.middlewares, http.HandlerFunc(mx.routeHTTP))
 	}
-	for _, v := range methodMap {
-		tr.routes[v] = &tree{root: &node{}}
+
+	// Build endpoint handler with inline middlewares for the route
+	var endpoint http.Handler
+	if mx.inline {
+		mx.handler = http.HandlerFunc(mx.routeHTTP)
+		endpoint = chain(mx.middlewares, handler)
+	} else {
+		endpoint = handler
 	}
-	return tr
+
+	// ... TODO: comment..
+	mx.router.Insert(method, pattern, endpoint)
 }
 
-// NotFoundHandlerFn returns the HandlerFunc setup on the tree.
-func (tr treeRouter) NotFoundHandler() http.HandlerFunc {
-	if tr.notFoundHandler != nil {
-		return *tr.notFoundHandler
+// ServeHTTP is the single method of the http.Handler interface that makes
+// Mux interoperable with the standard library. It uses a sync.Pool to get and
+// reuse routing contexts for each request.
+func (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	// Ensure the mux has some routes defined on the mux
+	if mx.handler == nil {
+		panic("chi: attempting to route to a mux with no handlers.")
 	}
-	return http.NotFound
-}
 
-// ServeHTTP is the main routing method for each request.
-func (tr treeRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-	ctx := r.Context()
+	// Fetch a RouteContext object from the sync pool, and call the computed
+	// mx.handler that is comprised of mx.middlewares + mx.routeHTTP.
+	// Once the request is finsihed, reset the routing context and put it back
+	// into the pool for reuse from another request.
+	rctx := mx.pool.Get().(*Context)
+	r = r.WithContext(rctx)
+	mx.handler.ServeHTTP(w, r)
+	rctx.reset()
+	mx.pool.Put(rctx)
+}
 
+func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	// Grab the root context object
+	ctx := r.Context()
 	rctx, _ := ctx.(*Context)
 	if rctx == nil {
 		rctx = ctx.Value(RouteCtxKey).(*Context)
@@ -337,14 +301,22 @@ func (tr treeRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
-	// Find the handler in the router
-	cxh := tr.routes[method].Find(rctx, routePath)
+	// Find the route
+	// TODO: any point in giving the method..? maybe later..
+	// TODO: if we switch method to string.. then, we can simplify this code..
+	hs := mx.router.Find(rctx, method, routePath)
 
-	if cxh == nil {
-		tr.NotFoundHandler().ServeHTTP(w, r)
+	if hs == nil {
+		mx.notFoundHandler(w, r)
+		return
+	}
+
+	h, ok := hs[method]
+	if !ok {
+		methodNotAllowedHandler(w, r)
 		return
 	}
 
-	// Serve it
-	cxh.ServeHTTP(w, r)
+	// Serve it up
+	h.ServeHTTP(w, r)
 }
diff --git a/tree.go b/tree.go
index 6f2b347..e749ade 100644
--- a/tree.go
+++ b/tree.go
@@ -5,11 +5,42 @@ package chi
 // (MIT licensed)
 
 import (
+	"net/http"
 	"sort"
 	"strings"
-	"net/http"
 )
 
+// TODO: set the RoutePattern on the RouteContext
+
+type methodTyp int
+
+const (
+	mCONNECT methodTyp = 1 << iota
+	mDELETE
+	mGET
+	mHEAD
+	mOPTIONS
+	mPATCH
+	mPOST
+	mPUT
+	mTRACE
+
+	mALL methodTyp = mCONNECT | mDELETE | mGET | mHEAD | mOPTIONS |
+		mPATCH | mPOST | mPUT | mTRACE
+)
+
+var methodMap = map[string]methodTyp{
+	"CONNECT": mCONNECT,
+	"DELETE":  mDELETE,
+	"GET":     mGET,
+	"HEAD":    mHEAD,
+	"OPTIONS": mOPTIONS,
+	"PATCH":   mPATCH,
+	"POST":    mPOST,
+	"PUT":     mPUT,
+	"TRACE":   mTRACE,
+}
+
 type nodeTyp uint8
 
 const (
@@ -19,10 +50,19 @@ const (
 	ntCatchAll                // /api/v1/*
 )
 
+// TODO: comment
+// TODO: if WalkFn is exported, this needs to be as well, which its better not to.
+// I have a few ideas, will massage it later.
+type methodHandlers map[methodTyp]http.Handler
+
 // WalkFn is used when walking the tree. Takes a
 // key and value, returning if iteration should
 // be terminated.
-type WalkFn func(path string, handler http.Handler) bool
+
+// TODO: .. lets leave it like this for now..
+// but we could also just make it
+// type WalkFn func(method string, pattern string, handler http.Handler) bool
+type WalkFn func(path string, handlers methodHandlers) bool
 
 // edge is used to represent an edge node
 type edge struct {
@@ -37,7 +77,8 @@ type node struct {
 	prefix string
 
 	// HTTP handler on the leaf node
-	handler http.Handler
+	// handler http.Handler
+	handlers methodHandlers
 
 	// Edges should be stored in-order for iteration,
 	// in groups of the node type.
@@ -45,7 +86,7 @@ type node struct {
 }
 
 func (n *node) isLeaf() bool {
-	return n.handler != nil
+	return n.handlers != nil
 }
 
 func (n *node) addEdge(e edge) {
@@ -68,7 +109,7 @@ func (n *node) addEdge(e edge) {
 	if p == 0 {
 		// Path starts with a wildcard
 
-		handler := e.node.handler
+		handlers := e.node.handlers
 		e.node.typ = ntyp
 
 		if ntyp == ntCatchAll {
@@ -83,15 +124,15 @@ func (n *node) addEdge(e edge) {
 
 		if p != len(search) {
 			// add edge for the remaining part, split the end.
-			e.node.handler = nil
+			e.node.handlers = nil
 
 			search = search[p:]
 			e2 := edge{
 				label: search[0], // this will always start with /
 				node: &node{
-					typ:     ntStatic,
-					prefix:  search,
-					handler: handler,
+					typ:      ntStatic,
+					prefix:   search,
+					handlers: handlers,
 				},
 			}
 			e.node.addEdge(e2)
@@ -101,10 +142,10 @@ func (n *node) addEdge(e edge) {
 		// Path has some wildcard
 
 		// starts with a static segment
-		handler := e.node.handler
+		handlers := e.node.handlers
 		e.node.typ = ntStatic
 		e.node.prefix = search[:p]
-		e.node.handler = nil
+		e.node.handlers = nil
 
 		// add the wild edge node
 		search = search[p:]
@@ -112,9 +153,9 @@ func (n *node) addEdge(e edge) {
 		e2 := edge{
 			label: search[0],
 			node: &node{
-				typ:     ntyp,
-				prefix:  search,
-				handler: handler,
+				typ:      ntyp,
+				prefix:   search,
+				handlers: handlers,
 			},
 		}
 		e.node.addEdge(e2)
@@ -184,7 +225,7 @@ func (n *node) findEdge(ntyp nodeTyp, label byte) *node {
 
 // Recursive edge traversal by checking all nodeTyp groups along the way.
 // It's like searching through a three-dimensional radix trie.
-func (n *node) findNode(ctx *Context, path string) *node {
+func (n *node) findNode(ctx *Context, method methodTyp, path string) *node {
 	nn := n
 	search := path
 
@@ -237,25 +278,35 @@ func (n *node) findNode(ctx *Context, path string) *node {
 		}
 
 		// recursively find the next node..
-		fin := xn.findNode(ctx, xsearch)
+		fin := xn.findNode(ctx, method, xsearch)
 		if fin != nil {
 			// found a node, return it
 			return fin
 		}
 
 		// Did not found final handler, let's remove the param here if it was set
-		if xn.typ > ntStatic {
-			if xn.typ == ntCatchAll {
-				ctx.Params.Del("*")
-			} else {
-				ctx.Params.Del(xn.prefix[1:])
-			}
+		// TODO: can we do even better now though...?
+		if xn.typ > ntStatic && xn.typ < ntCatchAll {
+			ctx.Params.Del(xn.prefix[1:])
 		}
 	}
 
 	return nil
 }
 
+func (n *node) setHandler(method methodTyp, handler http.Handler) {
+	if n.handlers == nil {
+		n.handlers = make(methodHandlers, 0)
+	}
+	if method == mALL {
+		for _, m := range methodMap {
+			n.handlers[m] = handler
+		}
+	} else {
+		n.handlers[method] = handler
+	}
+}
+
 type edges []edge
 
 // Sort the list of edges by label
@@ -272,7 +323,7 @@ type tree struct {
 	root *node
 }
 
-func (t *tree) Insert(pattern string, handler http.Handler) {
+func (t *tree) Insert(method methodTyp, pattern string, handler http.Handler) {
 	var parent *node
 	n := t.root
 	search := pattern
@@ -281,7 +332,8 @@ func (t *tree) Insert(pattern string, handler http.Handler) {
 		// Handle key exhaustion
 		if len(search) == 0 {
 			// Insert or update the node's leaf handler
-			n.handler = handler
+			// n.handler = handler
+			n.setHandler(method, handler)
 			return
 		}
 
@@ -294,10 +346,11 @@ func (t *tree) Insert(pattern string, handler http.Handler) {
 			e := edge{
 				label: search[0],
 				node: &node{
-					prefix:  search,
-					handler: handler,
+					prefix: search,
+					// handler: handler,
 				},
 			}
+			e.node.setHandler(method, handler)
 			parent.addEdge(e)
 			return
 		}
@@ -343,48 +396,53 @@ func (t *tree) Insert(pattern string, handler http.Handler) {
 		// If the new key is a subset, add to to this node
 		search = search[commonPrefix:]
 		if len(search) == 0 {
-			child.handler = handler
+			// child.handler = handler
+			child.setHandler(method, handler)
 			return
 		}
 
 		// Create a new edge for the node
-		child.addEdge(edge{
+		e := edge{
 			label: search[0],
 			node: &node{
-				typ:     ntStatic,
-				prefix:  search,
-				handler: handler,
+				typ:    ntStatic,
+				prefix: search,
+				// handler: handler,
 			},
-		})
+		}
+		e.node.setHandler(method, handler)
+		child.addEdge(e)
 		return
 	}
 }
 
-func (t *tree) Find(ctx *Context, path string) http.Handler {
-	node := t.root.findNode(ctx, path)
+func (t *tree) Find(ctx *Context, method methodTyp, path string) methodHandlers {
+	node := t.root.findNode(ctx, method, path)
 	if node == nil {
 		return nil
 	}
-	return node.handler
+	return node.handlers
 }
 
 // Walk is used to walk the tree
 func (t *tree) Walk(fn WalkFn) {
-	t.recursiveWalk(t.root, fn)
+	t.recursiveWalk(t.root.prefix, t.root, fn)
 }
 
 // recursiveWalk is used to do a pre-order walk of a node
 // recursively. Returns true if the walk should be aborted
-func (t *tree) recursiveWalk(n *node, fn WalkFn) bool {
+func (t *tree) recursiveWalk(pattern string, n *node, fn WalkFn) bool {
+	pattern += n.prefix
+
 	// Visit the leaf values if any
-	if n.handler != nil && fn(n.prefix, n.handler) {
+	if n.handlers != nil && fn(pattern, n.handlers) {
 		return true
 	}
 
 	// Recurse on the children
 	for _, edges := range n.edges {
 		for _, e := range edges {
-			if t.recursiveWalk(e.node, fn) {
+			if t.recursiveWalk(pattern, e.node, fn) {
 				return true
 			}
 		}
@@ -407,47 +465,3 @@ func (t *tree) longestPrefix(k1, k2 string) int {
 	}
 	return i
 }
-
-type param struct {
-	Key, Value string
-}
-
-type params []param // TODO: change to map[string]string ?
-
-func (ps *params) Add(key string, value string) {
-	*ps = append(*ps, param{key, value})
-}
-
-func (ps params) Get(key string) string {
-	for _, p := range ps {
-		if p.Key == key {
-			return p.Value
-		}
-	}
-	return ""
-}
-
-func (ps *params) Set(key string, value string) {
-	idx := -1
-	for i, p := range *ps {
-		if p.Key == key {
-			idx = i
-			break
-		}
-	}
-	if idx < 0 {
-		(*ps).Add(key, value)
-	} else {
-		(*ps)[idx] = param{key, value}
-	}
-}
-
-func (ps *params) Del(key string) string {
-	for i, p := range *ps {
-		if p.Key == key {
-			*ps = append((*ps)[:i], (*ps)[i+1:]...)
-			return p.Value
-		}
-	}
-	return ""
-}
diff --git a/util.go b/util.go
index 3d897df..04d00ce 100644
--- a/util.go
+++ b/util.go
@@ -2,6 +2,17 @@ package chi
 
 import "net/http"
 
+// contextKey is a value for use with context.WithValue. It's used as
+// a pointer so it fits in an interface{} without allocation. This technique
+// for defining context keys was copied from Go 1.7's new use of context in net/http.
+type contextKey struct {
+	name string
+}
+
+func (k *contextKey) String() string {
+	return "chi context value " + k.name
+}
+
 // chain builds a http.Handler composed of middlewares and endpoint handler in the
 // order they are passed.
 func chain(middlewares []func(http.Handler) http.Handler, endpoint http.Handler) http.Handler {
@@ -23,5 +34,5 @@ func chain(middlewares []func(http.Handler) http.Handler, endpoint http.Handler)
 // 405 Method not allowed.
 func methodNotAllowedHandler(w http.ResponseWriter, r *http.Request) {
 	w.WriteHeader(405)
-	w.Write([]byte(http.StatusText(405)))
+	w.Write(nil)
 }
