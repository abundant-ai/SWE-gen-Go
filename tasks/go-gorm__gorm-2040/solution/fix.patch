diff --git a/model_struct.go b/model_struct.go
index 8506fe8..5b5be61 100644
--- a/model_struct.go
+++ b/model_struct.go
@@ -34,7 +34,7 @@ func (s *ModelStruct) TableName(db *DB) string {
 		if tabler, ok := reflect.New(s.ModelType).Interface().(tabler); ok {
 			s.defaultTableName = tabler.TableName()
 		} else {
-			tableName := ToDBName(s.ModelType.Name())
+			tableName := ToTableName(s.ModelType.Name())
 			if db == nil || !db.parent.singularTable {
 				tableName = inflection.Plural(tableName)
 			}
@@ -105,7 +105,7 @@ type Relationship struct {
 
 func getForeignField(column string, fields []*StructField) *StructField {
 	for _, field := range fields {
-		if field.Name == column || field.DBName == column || field.DBName == ToDBName(column) {
+		if field.Name == column || field.DBName == column || field.DBName == ToColumnName(column) {
 			return field
 		}
 	}
@@ -269,7 +269,7 @@ func (scope *Scope) GetModelStruct() *ModelStruct {
 													// if defined join table's foreign key
 													relationship.ForeignDBNames = append(relationship.ForeignDBNames, joinTableDBNames[idx])
 												} else {
-													defaultJointableForeignKey := ToDBName(reflectType.Name()) + "_" + foreignField.DBName
+													defaultJointableForeignKey := ToColumnName(reflectType.Name()) + "_" + foreignField.DBName
 													relationship.ForeignDBNames = append(relationship.ForeignDBNames, defaultJointableForeignKey)
 												}
 											}
@@ -300,7 +300,7 @@ func (scope *Scope) GetModelStruct() *ModelStruct {
 													relationship.AssociationForeignDBNames = append(relationship.AssociationForeignDBNames, associationJoinTableDBNames[idx])
 												} else {
 													// join table foreign keys for association
-													joinTableDBName := ToDBName(elemType.Name()) + "_" + field.DBName
+													joinTableDBName := ToColumnName(elemType.Name()) + "_" + field.DBName
 													relationship.AssociationForeignDBNames = append(relationship.AssociationForeignDBNames, joinTableDBName)
 												}
 											}
@@ -308,7 +308,7 @@ func (scope *Scope) GetModelStruct() *ModelStruct {
 									}
 
 									joinTableHandler := JoinTableHandler{}
-									joinTableHandler.Setup(relationship, many2many, reflectType, elemType)
+									joinTableHandler.Setup(relationship, ToTableName(many2many), reflectType, elemType)
 									relationship.JoinTableHandler = &joinTableHandler
 									field.Relationship = relationship
 								} else {
@@ -566,7 +566,7 @@ func (scope *Scope) GetModelStruct() *ModelStruct {
 			if value, ok := field.TagSettings["COLUMN"]; ok {
 				field.DBName = value
 			} else {
-				field.DBName = ToDBName(fieldStruct.Name)
+				field.DBName = ToColumnName(fieldStruct.Name)
 			}
 
 			modelStruct.StructFields = append(modelStruct.StructFields, field)
diff --git a/naming.go b/naming.go
new file mode 100644
index 0000000..6b0a4fd
--- /dev/null
+++ b/naming.go
@@ -0,0 +1,124 @@
+package gorm
+
+import (
+	"bytes"
+	"strings"
+)
+
+// Namer is a function type which is given a string and return a string
+type Namer func(string) string
+
+// NamingStrategy represents naming strategies
+type NamingStrategy struct {
+	DB     Namer
+	Table  Namer
+	Column Namer
+}
+
+// TheNamingStrategy is being initialized with defaultNamingStrategy
+var TheNamingStrategy = &NamingStrategy{
+	DB:     defaultNamer,
+	Table:  defaultNamer,
+	Column: defaultNamer,
+}
+
+// AddNamingStrategy sets the naming strategy
+func AddNamingStrategy(ns *NamingStrategy) {
+	if ns.DB == nil {
+		ns.DB = defaultNamer
+	}
+	if ns.Table == nil {
+		ns.Table = defaultNamer
+	}
+	if ns.Column == nil {
+		ns.Column = defaultNamer
+	}
+	TheNamingStrategy = ns
+}
+
+// DBName alters the given name by DB
+func (ns *NamingStrategy) DBName(name string) string {
+	return ns.DB(name)
+}
+
+// TableName alters the given name by Table
+func (ns *NamingStrategy) TableName(name string) string {
+	return ns.Table(name)
+}
+
+// ColumnName alters the given name by Column
+func (ns *NamingStrategy) ColumnName(name string) string {
+	return ns.Column(name)
+}
+
+// ToDBName convert string to db name
+func ToDBName(name string) string {
+	return TheNamingStrategy.DBName(name)
+}
+
+// ToTableName convert string to table name
+func ToTableName(name string) string {
+	return TheNamingStrategy.TableName(name)
+}
+
+// ToColumnName convert string to db name
+func ToColumnName(name string) string {
+	return TheNamingStrategy.ColumnName(name)
+}
+
+var smap = newSafeMap()
+
+func defaultNamer(name string) string {
+	const (
+		lower = false
+		upper = true
+	)
+
+	if v := smap.Get(name); v != "" {
+		return v
+	}
+
+	if name == "" {
+		return ""
+	}
+
+	var (
+		value                                    = commonInitialismsReplacer.Replace(name)
+		buf                                      = bytes.NewBufferString("")
+		lastCase, currCase, nextCase, nextNumber bool
+	)
+
+	for i, v := range value[:len(value)-1] {
+		nextCase = bool(value[i+1] >= 'A' && value[i+1] <= 'Z')
+		nextNumber = bool(value[i+1] >= '0' && value[i+1] <= '9')
+
+		if i > 0 {
+			if currCase == upper {
+				if lastCase == upper && (nextCase == upper || nextNumber == upper) {
+					buf.WriteRune(v)
+				} else {
+					if value[i-1] != '_' && value[i+1] != '_' {
+						buf.WriteRune('_')
+					}
+					buf.WriteRune(v)
+				}
+			} else {
+				buf.WriteRune(v)
+				if i == len(value)-2 && (nextCase == upper && nextNumber == lower) {
+					buf.WriteRune('_')
+				}
+			}
+		} else {
+			currCase = upper
+			buf.WriteRune(v)
+		}
+		lastCase = currCase
+		currCase = nextCase
+	}
+
+	buf.WriteByte(value[len(value)-1])
+
+	s := strings.ToLower(buf.String())
+	smap.Set(name, s)
+	return s
+}
diff --git a/scope.go b/scope.go
index ca861d8..fbf7634 100644
--- a/scope.go
+++ b/scope.go
@@ -134,7 +134,7 @@ func (scope *Scope) Fields() []*Field {
 // FieldByName find `gorm.Field` with field name or db name
 func (scope *Scope) FieldByName(name string) (field *Field, ok bool) {
 	var (
-		dbName           = ToDBName(name)
+		dbName           = ToColumnName(name)
 		mostMatchedField *Field
 	)
 
@@ -880,7 +880,7 @@ func convertInterfaceToMap(values interface{}, withIgnoredField bool) map[string
 		switch reflectValue.Kind() {
 		case reflect.Map:
 			for _, key := range reflectValue.MapKeys() {
-				attrs[ToDBName(key.Interface().(string))] = reflectValue.MapIndex(key).Interface()
+				attrs[ToColumnName(key.Interface().(string))] = reflectValue.MapIndex(key).Interface()
 			}
 		default:
 			for _, field := range (&Scope{Value: values}).Fields() {
diff --git a/utils.go b/utils.go
index 99b532c..ad700b9 100644
--- a/utils.go
+++ b/utils.go
@@ -1,7 +1,6 @@
 package gorm
 
 import (
-	"bytes"
 	"database/sql/driver"
 	"fmt"
 	"reflect"
@@ -58,66 +57,6 @@ func newSafeMap() *safeMap {
 	return &safeMap{l: new(sync.RWMutex), m: make(map[string]string)}
 }
 
-var smap = newSafeMap()
-
-type strCase bool
-
-const (
-	lower strCase = false
-	upper strCase = true
-)
-
-// ToDBName convert string to db name
-func ToDBName(name string) string {
-	if v := smap.Get(name); v != "" {
-		return v
-	}
-
-	if name == "" {
-		return ""
-	}
-
-	var (
-		value                                    = commonInitialismsReplacer.Replace(name)
-		buf                                      = bytes.NewBufferString("")
-		lastCase, currCase, nextCase, nextNumber strCase
-	)
-
-	for i, v := range value[:len(value)-1] {
-		nextCase = strCase(value[i+1] >= 'A' && value[i+1] <= 'Z')
-		nextNumber = strCase(value[i+1] >= '0' && value[i+1] <= '9')
-
-		if i > 0 {
-			if currCase == upper {
-				if lastCase == upper && (nextCase == upper || nextNumber == upper) {
-					buf.WriteRune(v)
-				} else {
-					if value[i-1] != '_' && value[i+1] != '_' {
-						buf.WriteRune('_')
-					}
-					buf.WriteRune(v)
-				}
-			} else {
-				buf.WriteRune(v)
-				if i == len(value)-2 && (nextCase == upper && nextNumber == lower) {
-					buf.WriteRune('_')
-				}
-			}
-		} else {
-			currCase = upper
-			buf.WriteRune(v)
-		}
-		lastCase = currCase
-		currCase = nextCase
-	}
-
-	buf.WriteByte(value[len(value)-1])
-
-	s := strings.ToLower(buf.String())
-	smap.Set(name, s)
-	return s
-}
-
 // SQL expression
 type expr struct {
 	expr string
