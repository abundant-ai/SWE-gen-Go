diff --git a/assert/assertion_format.go b/assert/assertion_format.go
index ad39523..c40f423 100644
--- a/assert/assertion_format.go
+++ b/assert/assertion_format.go
@@ -568,23 +568,6 @@ func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, a
 	return NotContains(t, s, contains, append([]interface{}{msg}, args...)...)
 }
 
-// NotElementsMatchf asserts that the specified listA(array, slice...) is NOT equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should not match.
-// This is an inverse of ElementsMatch.
-//
-// assert.NotElementsMatchf(t, [1, 1, 2, 3], [1, 1, 2, 3], "error message %s", "formatted") -> false
-//
-// assert.NotElementsMatchf(t, [1, 1, 2, 3], [1, 2, 3], "error message %s", "formatted") -> true
-//
-// assert.NotElementsMatchf(t, [1, 2, 3], [1, 2, 4], "error message %s", "formatted") -> true
-func NotElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) bool {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	return NotElementsMatch(t, listA, listB, append([]interface{}{msg}, args...)...)
-}
-
 // NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
 // a slice or a channel with len == 0.
 //
diff --git a/assert/assertion_forward.go b/assert/assertion_forward.go
index d90c65d..185e026 100644
--- a/assert/assertion_forward.go
+++ b/assert/assertion_forward.go
@@ -1128,40 +1128,6 @@ func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg strin
 	return NotContainsf(a.t, s, contains, msg, args...)
 }
 
-// NotElementsMatch asserts that the specified listA(array, slice...) is NOT equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should not match.
-// This is an inverse of ElementsMatch.
-//
-// a.NotElementsMatch([1, 1, 2, 3], [1, 1, 2, 3]) -> false
-//
-// a.NotElementsMatch([1, 1, 2, 3], [1, 2, 3]) -> true
-//
-// a.NotElementsMatch([1, 2, 3], [1, 2, 4]) -> true
-func (a *Assertions) NotElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) bool {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	return NotElementsMatch(a.t, listA, listB, msgAndArgs...)
-}
-
-// NotElementsMatchf asserts that the specified listA(array, slice...) is NOT equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should not match.
-// This is an inverse of ElementsMatch.
-//
-// a.NotElementsMatchf([1, 1, 2, 3], [1, 1, 2, 3], "error message %s", "formatted") -> false
-//
-// a.NotElementsMatchf([1, 1, 2, 3], [1, 2, 3], "error message %s", "formatted") -> true
-//
-// a.NotElementsMatchf([1, 2, 3], [1, 2, 4], "error message %s", "formatted") -> true
-func (a *Assertions) NotElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) bool {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	return NotElementsMatchf(a.t, listA, listB, msg, args...)
-}
-
 // NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
 // a slice or a channel with len == 0.
 //
diff --git a/assert/assertions.go b/assert/assertions.go
index 7f16cb8..16d21e7 100644
--- a/assert/assertions.go
+++ b/assert/assertions.go
@@ -1176,39 +1176,6 @@ func formatListDiff(listA, listB interface{}, extraA, extraB []interface{}) stri
 	return msg.String()
 }
 
-// NotElementsMatch asserts that the specified listA(array, slice...) is NOT equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should not match.
-// This is an inverse of ElementsMatch.
-//
-// assert.NotElementsMatch(t, [1, 1, 2, 3], [1, 1, 2, 3]) -> false
-//
-// assert.NotElementsMatch(t, [1, 1, 2, 3], [1, 2, 3]) -> true
-//
-// assert.NotElementsMatch(t, [1, 2, 3], [1, 2, 4]) -> true
-func NotElementsMatch(t TestingT, listA, listB interface{}, msgAndArgs ...interface{}) (ok bool) {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	if isEmpty(listA) && isEmpty(listB) {
-		return Fail(t, "listA and listB contain the same elements", msgAndArgs)
-	}
-
-	if !isList(t, listA, msgAndArgs...) {
-		return Fail(t, "listA is not a list type", msgAndArgs...)
-	}
-	if !isList(t, listB, msgAndArgs...) {
-		return Fail(t, "listB is not a list type", msgAndArgs...)
-	}
-
-	extraA, extraB := diffLists(listA, listB)
-	if len(extraA) == 0 && len(extraB) == 0 {
-		return Fail(t, "listA and listB contain the same elements", msgAndArgs)
-	}
-
-	return true
-}
-
 // Condition uses a Comparison to assert a complex condition.
 func Condition(t TestingT, comp Comparison, msgAndArgs ...interface{}) bool {
 	if h, ok := t.(tHelper); ok {
diff --git a/assert/assertions_test.go b/assert/assertions_test.go
index 8b87727..fa68fe2 100644
--- a/assert/assertions_test.go
+++ b/assert/assertions_test.go
@@ -1319,52 +1319,6 @@ func TestDiffLists(t *testing.T) {
 	}
 }
 
-func TestNotElementsMatch(t *testing.T) {
-	mockT := new(testing.T)
-
-	cases := []struct {
-		expected interface{}
-		actual   interface{}
-		result   bool
-	}{
-		// not mathing
-		{[]int{1}, []int{}, true},
-		{[]int{}, []int{2}, true},
-		{[]int{1}, []int{2}, true},
-		{[]int{1}, []int{1, 1}, true},
-		{[]int{1, 2}, []int{3, 4}, true},
-		{[]int{3, 4}, []int{1, 2}, true},
-		{[]int{1, 1, 2, 3}, []int{1, 2, 3}, true},
-		{[]string{"hello"}, []string{"world"}, true},
-		{[]string{"hello", "hello"}, []string{"world", "world"}, true},
-		{[3]string{"hello", "hello", "hello"}, [3]string{"world", "world", "world"}, true},
-
-		// matching
-		{nil, nil, false},
-		{[]int{}, nil, false},
-		{[]int{}, []int{}, false},
-		{[]int{1}, []int{1}, false},
-		{[]int{1, 1}, []int{1, 1}, false},
-		{[]int{1, 2}, []int{2, 1}, false},
-		{[2]int{1, 2}, [2]int{2, 1}, false},
-		{[]int{1, 1, 2}, []int{1, 2, 1}, false},
-		{[]string{"hello", "world"}, []string{"world", "hello"}, false},
-		{[]string{"hello", "hello"}, []string{"hello", "hello"}, false},
-		{[]string{"hello", "hello", "world"}, []string{"hello", "world", "hello"}, false},
-		{[3]string{"hello", "hello", "world"}, [3]string{"hello", "world", "hello"}, false},
-	}
-
-	for _, c := range cases {
-		t.Run(fmt.Sprintf("NotElementsMatch(%#v, %#v)", c.expected, c.actual), func(t *testing.T) {
-			res := NotElementsMatch(mockT, c.actual, c.expected)
-
-			if res != c.result {
-				t.Errorf("NotElementsMatch(%#v, %#v) should return %v", c.actual, c.expected, c.result)
-			}
-		})
-	}
-}
-
 func TestCondition(t *testing.T) {
 	mockT := new(testing.T)
 
diff --git a/require/require.go b/require/require.go
index 59b87c8..9290bcd 100644
--- a/require/require.go
+++ b/require/require.go
@@ -1429,46 +1429,6 @@ func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, a
 	t.FailNow()
 }
 
-// NotElementsMatch asserts that the specified listA(array, slice...) is NOT equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should not match.
-// This is an inverse of ElementsMatch.
-//
-// assert.NotElementsMatch(t, [1, 1, 2, 3], [1, 1, 2, 3]) -> false
-//
-// assert.NotElementsMatch(t, [1, 1, 2, 3], [1, 2, 3]) -> true
-//
-// assert.NotElementsMatch(t, [1, 2, 3], [1, 2, 4]) -> true
-func NotElementsMatch(t TestingT, listA interface{}, listB interface{}, msgAndArgs ...interface{}) {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	if assert.NotElementsMatch(t, listA, listB, msgAndArgs...) {
-		return
-	}
-	t.FailNow()
-}
-
-// NotElementsMatchf asserts that the specified listA(array, slice...) is NOT equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should not match.
-// This is an inverse of ElementsMatch.
-//
-// assert.NotElementsMatchf(t, [1, 1, 2, 3], [1, 1, 2, 3], "error message %s", "formatted") -> false
-//
-// assert.NotElementsMatchf(t, [1, 1, 2, 3], [1, 2, 3], "error message %s", "formatted") -> true
-//
-// assert.NotElementsMatchf(t, [1, 2, 3], [1, 2, 4], "error message %s", "formatted") -> true
-func NotElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) {
-	if h, ok := t.(tHelper); ok {
-		h.Helper()
-	}
-	if assert.NotElementsMatchf(t, listA, listB, msg, args...) {
-		return
-	}
-	t.FailNow()
-}
-
 // NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
 // a slice or a channel with len == 0.
 //
diff --git a/require/require_forward.go b/require/require_forward.go
index 389de9a..f8302a1 100644
--- a/require/require_forward.go
+++ b/require/require_forward.go
@@ -1129,40 +1129,6 @@ func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg strin
 	NotContainsf(a.t, s, contains, msg, args...)
 }
 
-// NotElementsMatch asserts that the specified listA(array, slice...) is NOT equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should not match.
-// This is an inverse of ElementsMatch.
-//
-// a.NotElementsMatch([1, 1, 2, 3], [1, 1, 2, 3]) -> false
-//
-// a.NotElementsMatch([1, 1, 2, 3], [1, 2, 3]) -> true
-//
-// a.NotElementsMatch([1, 2, 3], [1, 2, 4]) -> true
-func (a *Assertions) NotElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	NotElementsMatch(a.t, listA, listB, msgAndArgs...)
-}
-
-// NotElementsMatchf asserts that the specified listA(array, slice...) is NOT equal to specified
-// listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
-// the number of appearances of each of them in both lists should not match.
-// This is an inverse of ElementsMatch.
-//
-// a.NotElementsMatchf([1, 1, 2, 3], [1, 1, 2, 3], "error message %s", "formatted") -> false
-//
-// a.NotElementsMatchf([1, 1, 2, 3], [1, 2, 3], "error message %s", "formatted") -> true
-//
-// a.NotElementsMatchf([1, 2, 3], [1, 2, 4], "error message %s", "formatted") -> true
-func (a *Assertions) NotElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) {
-	if h, ok := a.t.(tHelper); ok {
-		h.Helper()
-	}
-	NotElementsMatchf(a.t, listA, listB, msg, args...)
-}
-
 // NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
 // a slice or a channel with len == 0.
 //
