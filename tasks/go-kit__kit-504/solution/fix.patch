diff --git a/circle.yml b/circle.yml
index 0c35bb2..a5acd9c 100644
--- a/circle.yml
+++ b/circle.yml
@@ -24,3 +24,4 @@ test:
           ETCD_ADDR: http://localhost:2379
           CONSUL_ADDR: localhost:8500
           ZK_ADDR: localhost:2181
+          EUREKA_ADDR: http://localhost:8761/eureka
diff --git a/docker-compose-integration.yml b/docker-compose-integration.yml
index f316a13..287d97d 100644
--- a/docker-compose-integration.yml
+++ b/docker-compose-integration.yml
@@ -14,3 +14,9 @@ services:
     image: zookeeper
     ports:
       - "2181:2181"
+  eureka:
+    image: springcloud/eureka
+    environment:
+      eureka.server.responseCacheUpdateIntervalMs: 1000
+    ports:
+      - "8761:8761"
diff --git a/sd/eureka/doc.go b/sd/eureka/doc.go
new file mode 100644
index 0000000..d41c352
--- /dev/null
+++ b/sd/eureka/doc.go
@@ -0,0 +1,2 @@
+// Package eureka provides subscriber and registrar implementations for Netflix OSS's Eureka
+package eureka
diff --git a/sd/eureka/registrar.go b/sd/eureka/registrar.go
new file mode 100644
index 0000000..99fef7c
--- /dev/null
+++ b/sd/eureka/registrar.go
@@ -0,0 +1,127 @@
+package eureka
+
+import (
+	"fmt"
+	"net/http"
+	"sync"
+	"time"
+
+	"github.com/hudl/fargo"
+
+	"github.com/go-kit/kit/log"
+	"github.com/go-kit/kit/sd"
+)
+
+// Matches official Netflix Java client default.
+const defaultRenewalInterval = 30 * time.Second
+
+// The methods of fargo.Connection used in this package.
+type fargoConnection interface {
+	RegisterInstance(instance *fargo.Instance) error
+	DeregisterInstance(instance *fargo.Instance) error
+	ReregisterInstance(instance *fargo.Instance) error
+	HeartBeatInstance(instance *fargo.Instance) error
+	ScheduleAppUpdates(name string, await bool, done <-chan struct{}) <-chan fargo.AppUpdate
+	GetApp(name string) (*fargo.Application, error)
+}
+
+type fargoUnsuccessfulHTTPResponse struct {
+	statusCode    int
+	messagePrefix string
+}
+
+// Registrar maintains service instance liveness information in Eureka.
+type Registrar struct {
+	conn     fargoConnection
+	instance *fargo.Instance
+	logger   log.Logger
+	quitc    chan chan struct{}
+	sync.Mutex
+}
+
+var _ sd.Registrar = (*Registrar)(nil)
+
+// NewRegistrar returns an Eureka Registrar acting on behalf of the provided
+// Fargo connection and instance. See the integration test for usage examples.
+func NewRegistrar(conn fargoConnection, instance *fargo.Instance, logger log.Logger) *Registrar {
+	return &Registrar{
+		conn:     conn,
+		instance: instance,
+		logger:   log.With(logger, "service", instance.App, "address", fmt.Sprintf("%s:%d", instance.IPAddr, instance.Port)),
+	}
+}
+
+// Register implements sd.Registrar.
+func (r *Registrar) Register() {
+	r.Lock()
+	defer r.Unlock()
+
+	if r.quitc != nil {
+		return // Already in the registration loop.
+	}
+
+	if err := r.conn.RegisterInstance(r.instance); err != nil {
+		r.logger.Log("during", "Register", "err", err)
+	}
+
+	r.quitc = make(chan chan struct{})
+	go r.loop()
+}
+
+// Deregister implements sd.Registrar.
+func (r *Registrar) Deregister() {
+	r.Lock()
+	defer r.Unlock()
+
+	if r.quitc == nil {
+		return // Already deregistered.
+	}
+
+	q := make(chan struct{})
+	r.quitc <- q
+	<-q
+	r.quitc = nil
+}
+
+func (r *Registrar) loop() {
+	var renewalInterval time.Duration
+	if r.instance.LeaseInfo.RenewalIntervalInSecs > 0 {
+		renewalInterval = time.Duration(r.instance.LeaseInfo.RenewalIntervalInSecs) * time.Second
+	} else {
+		renewalInterval = defaultRenewalInterval
+	}
+	ticker := time.NewTicker(renewalInterval)
+	defer ticker.Stop()
+
+	for {
+		select {
+		case <-ticker.C:
+			if err := r.heartbeat(); err != nil {
+				r.logger.Log("during", "heartbeat", "err", err)
+			}
+
+		case q := <-r.quitc:
+			if err := r.conn.DeregisterInstance(r.instance); err != nil {
+				r.logger.Log("during", "Deregister", "err", err)
+			}
+			close(q)
+			return
+		}
+	}
+}
+
+func (r *Registrar) heartbeat() error {
+	err := r.conn.HeartBeatInstance(r.instance)
+	if err != nil {
+		if u, ok := err.(*fargoUnsuccessfulHTTPResponse); ok && u.statusCode == http.StatusNotFound {
+			// Instance expired (e.g. network partition). Re-register.
+			r.logger.Log("during", "heartbeat", err.Error())
+			return r.conn.ReregisterInstance(r.instance)
+		}
+	}
+	return err
+}
+
+func (u *fargoUnsuccessfulHTTPResponse) Error() string {
+	return fmt.Sprintf("err=%s code=%d", u.messagePrefix, u.statusCode)
+}
diff --git a/sd/eureka/subscriber.go b/sd/eureka/subscriber.go
new file mode 100644
index 0000000..0300d0d
--- /dev/null
+++ b/sd/eureka/subscriber.go
@@ -0,0 +1,106 @@
+package eureka
+
+import (
+	"fmt"
+
+	"github.com/hudl/fargo"
+
+	"github.com/go-kit/kit/endpoint"
+	"github.com/go-kit/kit/log"
+	"github.com/go-kit/kit/sd"
+	"github.com/go-kit/kit/sd/cache"
+)
+
+// Subscriber yields endpoints stored in the Eureka registry for the given app.
+// Changes in that app are watched and will update the Subscriber endpoints.
+type Subscriber struct {
+	conn    fargoConnection
+	app     string
+	factory sd.Factory
+	logger  log.Logger
+	cache   *cache.Cache
+	quitc   chan chan struct{}
+}
+
+var _ sd.Subscriber = (*Subscriber)(nil)
+
+// NewSubscriber returns a Eureka subscriber. It will start watching the given
+// app string for changes, and update the endpoints accordingly.
+func NewSubscriber(conn fargoConnection, app string, factory sd.Factory, logger log.Logger) *Subscriber {
+	logger = log.With(logger, "app", app)
+
+	s := &Subscriber{
+		conn:    conn,
+		app:     app,
+		factory: factory,
+		logger:  logger,
+		cache:   cache.New(factory, logger),
+		quitc:   make(chan chan struct{}),
+	}
+
+	instances, err := s.getInstances()
+	if err == nil {
+		s.logger.Log("instances", len(instances))
+	} else {
+		s.logger.Log("during", "getInstances", "err", err)
+	}
+
+	s.cache.Update(instances)
+	go s.loop()
+	return s
+}
+
+// Endpoints implements the Subscriber interface.
+func (s *Subscriber) Endpoints() ([]endpoint.Endpoint, error) {
+	return s.cache.Endpoints(), nil
+}
+
+// Stop terminates the subscriber.
+func (s *Subscriber) Stop() {
+	q := make(chan struct{})
+	s.quitc <- q
+	<-q
+	s.quitc = nil
+}
+
+func (s *Subscriber) loop() {
+	var (
+		await   = false
+		done    = make(chan struct{})
+		updatec = s.conn.ScheduleAppUpdates(s.app, await, done)
+	)
+	defer close(done)
+
+	for {
+		select {
+		case update := <-updatec:
+			if update.Err != nil {
+				s.logger.Log("during", "Update", "err", update.Err)
+				continue
+			}
+			instances := convertFargoAppToInstances(update.App)
+			s.logger.Log("instances", len(instances))
+			s.cache.Update(instances)
+
+		case q := <-s.quitc:
+			close(q)
+			return
+		}
+	}
+}
+
+func (s *Subscriber) getInstances() ([]string, error) {
+	app, err := s.conn.GetApp(s.app)
+	if err != nil {
+		return nil, err
+	}
+	return convertFargoAppToInstances(app), nil
+}
+
+func convertFargoAppToInstances(app *fargo.Application) []string {
+	instances := make([]string, len(app.Instances))
+	for i, inst := range app.Instances {
+		instances[i] = fmt.Sprintf("%s:%d", inst.IPAddr, inst.Port)
+	}
+	return instances
+}
