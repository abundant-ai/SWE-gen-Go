diff --git a/database/dialect.go b/database/dialect.go
index d4b3529..8767db0 100644
--- a/database/dialect.go
+++ b/database/dialect.go
@@ -21,23 +21,16 @@ const (
 	DialectTiDB       Dialect = "tidb"
 	DialectVertica    Dialect = "vertica"
 	DialectYdB        Dialect = "ydb"
-
-	// DialectCustom is a special dialect that allows users to provide their own [Store]
-	// implementation when constructing a [goose.Provider].
-	DialectCustom Dialect = "custom"
 )
 
-// NewStore returns a new [Store] backed by the given dialect.
+// NewStore returns a new [Store] implementation for the given dialect.
 func NewStore(dialect Dialect, tablename string) (Store, error) {
 	if tablename == "" {
-		return nil, errors.New("tablename must not be empty")
+		return nil, errors.New("table name must not be empty")
 	}
 	if dialect == "" {
 		return nil, errors.New("dialect must not be empty")
 	}
-	if dialect == DialectCustom {
-		return nil, errors.New("dialect must not be custom")
-	}
 	lookup := map[Dialect]dialectquery.Querier{
 		DialectClickHouse: &dialectquery.Clickhouse{},
 		DialectMSSQL:      &dialectquery.Sqlserver{},
@@ -66,6 +59,12 @@ type store struct {
 
 var _ Store = (*store)(nil)
 
+func (s *store) private() {}
+
+func (s *store) Tablename() string {
+	return s.tablename
+}
+
 func (s *store) CreateVersionTable(ctx context.Context, db DBTxConn) error {
 	q := s.querier.CreateTable(s.tablename)
 	if _, err := db.ExecContext(ctx, q); err != nil {
@@ -74,14 +73,15 @@ func (s *store) CreateVersionTable(ctx context.Context, db DBTxConn) error {
 	return nil
 }
 
-func (s *store) InsertOrDelete(ctx context.Context, db DBTxConn, direction bool, version int64) error {
-	if direction {
-		q := s.querier.InsertVersion(s.tablename)
-		if _, err := db.ExecContext(ctx, q, version, true); err != nil {
-			return fmt.Errorf("failed to insert version %d: %w", version, err)
-		}
-		return nil
+func (s *store) Insert(ctx context.Context, db DBTxConn, req InsertRequest) error {
+	q := s.querier.InsertVersion(s.tablename)
+	if _, err := db.ExecContext(ctx, q, req.Version, true); err != nil {
+		return fmt.Errorf("failed to insert version %d: %w", req.Version, err)
 	}
+	return nil
+}
+
+func (s *store) Delete(ctx context.Context, db DBTxConn, version int64) error {
 	q := s.querier.DeleteVersion(s.tablename)
 	if _, err := db.ExecContext(ctx, q, version); err != nil {
 		return fmt.Errorf("failed to delete version %d: %w", version, err)
diff --git a/database/store.go b/database/store.go
index 4e2ff0c..fe496bb 100644
--- a/database/store.go
+++ b/database/store.go
@@ -11,13 +11,18 @@ import (
 // Each database dialect requires a specific implementation of this interface. A dialect represents
 // a set of SQL statements specific to a particular database system.
 type Store interface {
+	// Tablename is the version table used to record applied migrations. Must not be empty.
+	Tablename() string
+
 	// CreateVersionTable creates the version table. This table is used to record applied
 	// migrations.
 	CreateVersionTable(ctx context.Context, db DBTxConn) error
 
-	// InsertOrDelete inserts or deletes a version id from the version table. If direction is true,
-	// insert the version id. If direction is false, delete the version id.
-	InsertOrDelete(ctx context.Context, db DBTxConn, direction bool, version int64) error
+	// Insert inserts a version id into the version table.
+	Insert(ctx context.Context, db DBTxConn, req InsertRequest) error
+
+	// Delete deletes a version id from the version table.
+	Delete(ctx context.Context, db DBTxConn, version int64) error
 
 	// GetMigration retrieves a single migration by version id. This method may return the raw sql
 	// error if the query fails so the caller can assert for errors such as [sql.ErrNoRows].
@@ -26,6 +31,18 @@ type Store interface {
 	// ListMigrations retrieves all migrations sorted in descending order by id or timestamp. If
 	// there are no migrations, return empty slice with no error.
 	ListMigrations(ctx context.Context, db DBTxConn) ([]*ListMigrationsResult, error)
+
+	// TODO(mf): remove this method once the Provider is public and a custom Store can be used.
+	private()
+}
+
+type InsertRequest struct {
+	Version int64
+
+	// TODO(mf): in the future, we maybe want to expand this struct so implementors can store
+	// additional information. See the following issues for more information:
+	//  - https://github.com/pressly/goose/issues/422
+	//  - https://github.com/pressly/goose/issues/288
 }
 
 type GetMigrationResult struct {
diff --git a/internal/provider/provider.go b/internal/provider/provider.go
index c2e081c..89c7444 100644
--- a/internal/provider/provider.go
+++ b/internal/provider/provider.go
@@ -16,7 +16,9 @@ import (
 //
 // The caller is responsible for matching the database dialect with the database/sql driver. For
 // example, if the database dialect is "postgres", the database/sql driver could be
-// github.com/lib/pq or github.com/jackc/pgx.
+// github.com/lib/pq or github.com/jackc/pgx. Each dialect has a corresponding [database.Dialect]
+// constant backed by a default [database.Store] implementation. For more advanced use cases, such
+// as using a custom table name or supplying a custom store implementation, see [WithStore].
 //
 // fsys is the filesystem used to read the migration files, but may be nil. Most users will want to
 // use [os.DirFS], os.DirFS("path/to/migrations"), to read migrations from the local filesystem.
@@ -44,13 +46,24 @@ func NewProvider(dialect database.Dialect, db *sql.DB, fsys fs.FS, opts ...Provi
 			return nil, err
 		}
 	}
-	// Set defaults after applying user-supplied options so option funcs can check for empty values.
-	if cfg.tableName == "" {
-		cfg.tableName = DefaultTablename
+	if dialect == "" && cfg.store == nil {
+		return nil, errors.New("dialect must not be empty")
 	}
-	store, err := database.NewStore(dialect, cfg.tableName)
-	if err != nil {
-		return nil, err
+	if dialect != "" && cfg.store != nil {
+		return nil, errors.New("cannot set both dialect and store")
+	}
+	var store database.Store
+	if dialect != "" {
+		var err error
+		store, err = database.NewStore(dialect, DefaultTablename)
+		if err != nil {
+			return nil, err
+		}
+	} else {
+		store = cfg.store
+	}
+	if store.Tablename() == "" {
+		return nil, errors.New("invalid store implementation: table name must not be empty")
 	}
 	// Collect migrations from the filesystem and merge with registered migrations.
 	//
diff --git a/internal/provider/provider_options.go b/internal/provider/provider_options.go
index 5f069d4..50b4d3f 100644
--- a/internal/provider/provider_options.go
+++ b/internal/provider/provider_options.go
@@ -6,6 +6,7 @@ import (
 	"errors"
 	"fmt"
 
+	"github.com/pressly/goose/v3/database"
 	"github.com/pressly/goose/v3/lock"
 )
 
@@ -21,18 +22,36 @@ type ProviderOption interface {
 	apply(*config) error
 }
 
-// WithTableName sets the name of the database table used to track history of applied migrations.
+// WithStore configures the provider with a custom [database.Store] implementation.
 //
-// If WithTableName is not called, the default value is "goose_db_version".
-func WithTableName(name string) ProviderOption {
+// By default, the provider uses the [database.NewStore] function to create a store backed by the
+// given dialect. However, this option allows users to provide their own implementation or call
+// [database.NewStore] with custom options, such as setting the table name.
+//
+// Example:
+//
+//	// Create a store with a custom table name.
+//	store, err := database.NewStore(database.DialectPostgres, "my_custom_table_name")
+//	if err != nil {
+//	    return err
+//	}
+//	// Create a provider with the custom store.
+//	provider, err := goose.NewProvider("", db, nil, goose.WithStore(store))
+//	if err != nil {
+//	    return err
+//	}
+func WithStore(store database.Store) ProviderOption {
 	return configFunc(func(c *config) error {
-		if c.tableName != "" {
-			return fmt.Errorf("table already set to %q", c.tableName)
+		if c.store != nil {
+			return fmt.Errorf("store already set: %T", c.store)
 		}
-		if name == "" {
-			return errors.New("table must not be empty")
+		if store == nil {
+			return errors.New("store must not be nil")
 		}
-		c.tableName = name
+		if store.Tablename() == "" {
+			return errors.New("store implementation must set the table name")
+		}
+		c.store = store
 		return nil
 	})
 }
@@ -148,9 +167,10 @@ func WithNoVersioning(b bool) ProviderOption {
 }
 
 type config struct {
-	tableName string
-	verbose   bool
-	excludes  map[string]bool
+	store database.Store
+
+	verbose  bool
+	excludes map[string]bool
 
 	// Go migrations registered by the user. These will be merged/resolved with migrations from the
 	// filesystem and init() functions.
diff --git a/internal/provider/run.go b/internal/provider/run.go
index 17edff9..79a1b2c 100644
--- a/internal/provider/run.go
+++ b/internal/provider/run.go
@@ -248,7 +248,10 @@ func (p *Provider) runIndividually(
 			if p.cfg.noVersioning {
 				return nil
 			}
-			return p.store.InsertOrDelete(ctx, tx, direction, m.Source.Version)
+			if direction {
+				return p.store.Insert(ctx, tx, database.InsertRequest{Version: m.Source.Version})
+			}
+			return p.store.Delete(ctx, tx, m.Source.Version)
 		})
 	}
 	// Run the migration outside of a transaction.
@@ -268,7 +271,10 @@ func (p *Provider) runIndividually(
 	if p.cfg.noVersioning {
 		return nil
 	}
-	return p.store.InsertOrDelete(ctx, conn, direction, m.Source.Version)
+	if direction {
+		return p.store.Insert(ctx, conn, database.InsertRequest{Version: m.Source.Version})
+	}
+	return p.store.Delete(ctx, conn, m.Source.Version)
 }
 
 // beginTx begins a transaction and runs the given function. If the function returns an error, the
@@ -367,7 +373,7 @@ func (p *Provider) ensureVersionTable(ctx context.Context, conn *sql.Conn) (retE
 		if p.cfg.noVersioning {
 			return nil
 		}
-		return p.store.InsertOrDelete(ctx, tx, true, 0)
+		return p.store.Insert(ctx, tx, database.InsertRequest{Version: 0})
 	})
 }
 
diff --git a/internal/provider/types.go b/internal/provider/types.go
index 979eac1..3480c74 100644
--- a/internal/provider/types.go
+++ b/internal/provider/types.go
@@ -5,20 +5,6 @@ import (
 	"time"
 )
 
-// Dialect is the type of database dialect.
-type Dialect string
-
-const (
-	DialectClickHouse Dialect = "clickhouse"
-	DialectMSSQL      Dialect = "mssql"
-	DialectMySQL      Dialect = "mysql"
-	DialectPostgres   Dialect = "postgres"
-	DialectRedshift   Dialect = "redshift"
-	DialectSQLite3    Dialect = "sqlite3"
-	DialectTiDB       Dialect = "tidb"
-	DialectVertica    Dialect = "vertica"
-)
-
 // MigrationType is the type of migration.
 type MigrationType int
 
