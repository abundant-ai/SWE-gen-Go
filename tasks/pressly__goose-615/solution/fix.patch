diff --git a/Makefile b/Makefile
index 46b444f..8a3a05f 100644
--- a/Makefile
+++ b/Makefile
@@ -33,6 +33,9 @@ tools:
 test-packages:
 	go test $(GO_TEST_FLAGS) $$(go list ./... | grep -v -e /tests -e /bin -e /cmd -e /examples)
 
+test-packages-short:
+	go test -test.short $(GO_TEST_FLAGS) $$(go list ./... | grep -v -e /tests -e /bin -e /cmd -e /examples)
+
 test-e2e: test-e2e-postgres test-e2e-mysql test-e2e-clickhouse test-e2e-vertica
 
 test-e2e-postgres:
diff --git a/internal/provider/collect.go b/internal/provider/collect.go
new file mode 100644
index 0000000..cf12961
--- /dev/null
+++ b/internal/provider/collect.go
@@ -0,0 +1,176 @@
+package provider
+
+import (
+	"errors"
+	"fmt"
+	"io/fs"
+	"path/filepath"
+	"sort"
+	"strings"
+
+	"github.com/pressly/goose/v3"
+	"github.com/pressly/goose/v3/internal/migrate"
+)
+
+// fileSources represents a collection of migration files on the filesystem.
+type fileSources struct {
+	sqlSources []Source
+	goSources  []Source
+}
+
+// collectFileSources scans the file system for migration files that have a numeric prefix (greater
+// than one) followed by an underscore and a file extension of either .go or .sql. fsys may be nil,
+// in which case an empty fileSources is returned.
+//
+// If strict is true, then any error parsing the numeric component of the filename will result in an
+// error. The file is skipped otherwise.
+//
+// This function DOES NOT parse SQL migrations or merge registered Go migrations. It only collects
+// migration sources from the filesystem.
+func collectFileSources(fsys fs.FS, strict bool, excludes map[string]bool) (*fileSources, error) {
+	if fsys == nil {
+		return new(fileSources), nil
+	}
+	sources := new(fileSources)
+	versionToBaseLookup := make(map[int64]string) // map[version]filepath.Base(fullpath)
+	for _, pattern := range []string{
+		"*.sql",
+		"*.go",
+	} {
+		files, err := fs.Glob(fsys, pattern)
+		if err != nil {
+			return nil, fmt.Errorf("failed to glob pattern %q: %w", pattern, err)
+		}
+		for _, fullpath := range files {
+			base := filepath.Base(fullpath)
+			// Skip explicit excludes or Go test files.
+			if excludes[base] || strings.HasSuffix(base, "_test.go") {
+				continue
+			}
+			// If the filename has a valid looking version of the form: NUMBER_.{sql,go}, then use
+			// that as the version. Otherwise, ignore it. This allows users to have arbitrary
+			// filenames, but still have versioned migrations within the same directory. For
+			// example, a user could have a helpers.go file which contains unexported helper
+			// functions for migrations.
+			version, err := goose.NumericComponent(base)
+			if err != nil {
+				if strict {
+					return nil, fmt.Errorf("failed to parse numeric component from %q: %w", base, err)
+				}
+				continue
+			}
+			// Ensure there are no duplicate versions.
+			if existing, ok := versionToBaseLookup[version]; ok {
+				return nil, fmt.Errorf("found duplicate migration version %d:\n\texisting:%v\n\tcurrent:%v",
+					version,
+					existing,
+					base,
+				)
+			}
+			switch filepath.Ext(base) {
+			case ".sql":
+				sources.sqlSources = append(sources.sqlSources, Source{
+					Fullpath: fullpath,
+					Version:  version,
+				})
+			case ".go":
+				sources.goSources = append(sources.goSources, Source{
+					Fullpath: fullpath,
+					Version:  version,
+				})
+			default:
+				// Should never happen since we already filtered out all other file types.
+				return nil, fmt.Errorf("unknown migration type: %s", base)
+			}
+			// Add the version to the lookup map.
+			versionToBaseLookup[version] = base
+		}
+	}
+	return sources, nil
+}
+
+func merge(sources *fileSources, registerd map[int64]*goose.Migration) ([]*migrate.Migration, error) {
+	var migrations []*migrate.Migration
+	migrationLookup := make(map[int64]*migrate.Migration)
+	// Add all SQL migrations to the list of migrations.
+	for _, s := range sources.sqlSources {
+		m := &migrate.Migration{
+			Type:      migrate.TypeSQL,
+			Fullpath:  s.Fullpath,
+			Version:   s.Version,
+			SQLParsed: false,
+		}
+		migrations = append(migrations, m)
+		migrationLookup[s.Version] = m
+	}
+	// If there are no Go files in the filesystem and no registered Go migrations, return early.
+	if len(sources.goSources) == 0 && len(registerd) == 0 {
+		return migrations, nil
+	}
+	// Return an error if the given sources contain a versioned Go migration that has not been
+	// registered. This is a sanity check to ensure users didn't accidentally create a valid looking
+	// Go migration file on disk and forget to register it.
+	//
+	// This is almost always a user error.
+	var unregistered []string
+	for _, s := range sources.goSources {
+		if _, ok := registerd[s.Version]; !ok {
+			unregistered = append(unregistered, s.Fullpath)
+		}
+	}
+	if len(unregistered) > 0 {
+		return nil, unregisteredError(unregistered)
+	}
+	// Add all registered Go migrations to the list of migrations, checking for duplicate versions.
+	//
+	// Important, users can register Go migrations manually via goose.Add_ functions. These
+	// migrations may not have a corresponding file on disk. Which is fine! We include them
+	// wholesale as part of migrations. This allows users to build a custom binary that only embeds
+	// the SQL migration files.
+	for _, r := range registerd {
+		// Ensure there are no duplicate versions.
+		if existing, ok := migrationLookup[r.Version]; ok {
+			return nil, fmt.Errorf("found duplicate migration version %d:\n\texisting:%v\n\tcurrent:%v",
+				r.Version,
+				existing,
+				filepath.Base(r.Source),
+			)
+		}
+		m := &migrate.Migration{
+			Fullpath: r.Source, // May be empty if the migration was registered manually.
+			Version:  r.Version,
+			Type:     migrate.TypeGo,
+			Go: &migrate.Go{
+				UseTx:      r.UseTx,
+				UpFn:       r.UpFnContext,
+				UpFnNoTx:   r.UpFnNoTxContext,
+				DownFn:     r.DownFnContext,
+				DownFnNoTx: r.DownFnNoTxContext,
+			},
+		}
+		migrations = append(migrations, m)
+		migrationLookup[r.Version] = m
+	}
+	// Sort migrations by version in ascending order.
+	sort.Slice(migrations, func(i, j int) bool {
+		return migrations[i].Version < migrations[j].Version
+	})
+	return migrations, nil
+}
+
+func unregisteredError(unregistered []string) error {
+	f := "file"
+	if len(unregistered) > 1 {
+		f += "s"
+	}
+	var b strings.Builder
+
+	b.WriteString(fmt.Sprintf("error: detected %d unregistered Go %s:\n", len(unregistered), f))
+	for _, name := range unregistered {
+		b.WriteString("\t" + name + "\n")
+	}
+	b.WriteString("\n")
+	b.WriteString("go functions must be registered and built into a custom binary see:\nhttps://github.com/pressly/goose/tree/master/examples/go-migrations")
+
+	return errors.New(b.String())
+}
diff --git a/internal/provider/provider.go b/internal/provider/provider.go
index c8d8995..6702f07 100644
--- a/internal/provider/provider.go
+++ b/internal/provider/provider.go
@@ -5,22 +5,29 @@ import (
 	"database/sql"
 	"errors"
 	"io/fs"
+	"os"
 	"time"
 
+	"github.com/pressly/goose/v3/internal/migrate"
 	"github.com/pressly/goose/v3/internal/sqladapter"
 )
 
+var (
+	// ErrNoMigrations is returned by [NewProvider] when no migrations are found.
+	ErrNoMigrations = errors.New("no migrations found")
+)
+
 // NewProvider returns a new goose Provider.
 //
 // The caller is responsible for matching the database dialect with the database/sql driver. For
 // example, if the database dialect is "postgres", the database/sql driver could be
 // github.com/lib/pq or github.com/jackc/pgx.
 //
-// fsys is the filesystem used to read the migration files. Most users will want to use
-// os.DirFS("path/to/migrations") to read migrations from the local filesystem. However, it is
-// possible to use a different filesystem, such as embed.FS.
+// fsys is the filesystem used to read the migration files, but may be nil. Most users will want to
+// use os.DirFS("path/to/migrations") to read migrations from the local filesystem. However, it is
+// possible to use a different filesystem, such as embed.FS or filter out migrations using fs.Sub.
 //
-// Functional options are used to configure the Provider. See [ProviderOption] for more information.
+// See [ProviderOption] for more information on configuring the provider.
 //
 // Unless otherwise specified, all methods on Provider are safe for concurrent use.
 //
@@ -33,7 +40,7 @@ func NewProvider(dialect string, db *sql.DB, fsys fs.FS, opts ...ProviderOption)
 		return nil, errors.New("dialect must not be empty")
 	}
 	if fsys == nil {
-		return nil, errors.New("fsys must not be nil")
+		fsys = noopFS{}
 	}
 	var cfg config
 	for _, opt := range opts {
@@ -41,7 +48,7 @@ func NewProvider(dialect string, db *sql.DB, fsys fs.FS, opts ...ProviderOption)
 			return nil, err
 		}
 	}
-	// Set defaults
+	// Set defaults after applying user-supplied options so option funcs can check for empty values.
 	if cfg.tableName == "" {
 		cfg.tableName = defaultTablename
 	}
@@ -49,41 +56,76 @@ func NewProvider(dialect string, db *sql.DB, fsys fs.FS, opts ...ProviderOption)
 	if err != nil {
 		return nil, err
 	}
-	// TODO(mf): implement the rest of this function - collect sources - merge sources into
-	// migrations
+	// Collect migrations from the filesystem and merge with registered migrations.
+	//
+	// Note, neither of these functions parse SQL migrations by default. SQL migrations are parsed
+	// lazily.
+	//
+	// TODO(mf): we should expose a way to parse SQL migrations eagerly. This would allow us to
+	// return an error if there are any SQL parsing errors. This adds a bit overhead to startup
+	// though, so we should make it optional.
+	sources, err := collectFileSources(fsys, false, cfg.excludes)
+	if err != nil {
+		return nil, err
+	}
+	migrations, err := merge(sources, nil)
+	if err != nil {
+		return nil, err
+	}
+	if len(migrations) == 0 {
+		return nil, ErrNoMigrations
+	}
 	return &Provider{
-		db:    db,
-		fsys:  fsys,
-		cfg:   cfg,
-		store: store,
+		db:         db,
+		fsys:       fsys,
+		cfg:        cfg,
+		store:      store,
+		migrations: migrations,
 	}, nil
 }
 
+type noopFS struct{}
+
+var _ fs.FS = noopFS{}
+
+func (f noopFS) Open(name string) (fs.File, error) {
+	return nil, os.ErrNotExist
+}
+
 // Provider is a goose migration provider.
-// Experimental: This API is experimental and may change in the future.
 type Provider struct {
-	db    *sql.DB
-	fsys  fs.FS
-	cfg   config
-	store sqladapter.Store
+	db         *sql.DB
+	fsys       fs.FS
+	cfg        config
+	store      sqladapter.Store
+	migrations []*migrate.Migration
 }
 
+// State represents the state of a migration.
+type State string
+
+const (
+	// StateUntracked represents a migration that is in the database, but not on the filesystem.
+	StateUntracked State = "untracked"
+	// StatePending represents a migration that is on the filesystem, but not in the database.
+	StatePending State = "pending"
+	// StateApplied represents a migration that is in BOTH the database and on the filesystem.
+	StateApplied State = "applied"
+)
+
 // MigrationStatus represents the status of a single migration.
 type MigrationStatus struct {
-	// State represents the state of the migration. One of "untracked", "pending", "applied".
-	//  - untracked: in the database, but not on the filesystem.
-	//  - pending: on the filesystem, but not in the database.
-	//  - applied: in both the database and on the filesystem.
-	State string
-	// AppliedAt is the time the migration was applied. Only set if state is applied or untracked.
+	// State is the state of the migration.
+	State State
+	// AppliedAt is the time the migration was applied. Only set if state is [StateApplied] or
+	// [StateUntracked].
 	AppliedAt time.Time
-	// Source is the migration source. Only set if the state is pending or applied.
-	Source Source
+	// Source is the migration source. Only set if the state is [StatePending] or [StateApplied].
+	Source *Source
 }
 
 // Status returns the status of all migrations, merging the list of migrations from the database and
 // filesystem. The returned items are ordered by version, in ascending order.
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) Status(ctx context.Context) ([]*MigrationStatus, error) {
 	return nil, errors.New("not implemented")
 }
@@ -91,7 +133,6 @@ func (p *Provider) Status(ctx context.Context) ([]*MigrationStatus, error) {
 // GetDBVersion returns the max version from the database, regardless of the applied order. For
 // example, if migrations 1,4,2,3 were applied, this method returns 4. If no migrations have been
 // applied, it returns 0.
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) GetDBVersion(ctx context.Context) (int64, error) {
 	return 0, errors.New("not implemented")
 }
@@ -111,7 +152,6 @@ const (
 // For SQL migrations, Fullpath will always be set. For Go migrations, Fullpath will will be set if
 // the migration has a corresponding file on disk. It will be empty if the migration was registered
 // manually.
-// Experimental: This API is experimental and may change in the future.
 type Source struct {
 	// Type is the type of migration.
 	Type SourceType
@@ -123,22 +163,34 @@ type Source struct {
 	Version int64
 }
 
-// ListSources returns a list of all available migration sources the provider is aware of.
-// Experimental: This API is experimental and may change in the future.
+// ListSources returns a list of all available migration sources the provider is aware of, sorted in
+// ascending order by version.
 func (p *Provider) ListSources() []*Source {
-	return nil
+	sources := make([]*Source, 0, len(p.migrations))
+	for _, m := range p.migrations {
+		s := &Source{
+			Fullpath: m.Fullpath,
+			Version:  m.Version,
+		}
+		switch m.Type {
+		case migrate.TypeSQL:
+			s.Type = SourceTypeSQL
+		case migrate.TypeGo:
+			s.Type = SourceTypeGo
+		}
+		sources = append(sources, s)
+	}
+	return sources
 }
 
 // Ping attempts to ping the database to verify a connection is available.
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) Ping(ctx context.Context) error {
-	return errors.New("not implemented")
+	return p.db.PingContext(ctx)
 }
 
 // Close closes the database connection.
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) Close() error {
-	return errors.New("not implemented")
+	return p.db.Close()
 }
 
 // MigrationResult represents the result of a single migration.
@@ -150,21 +202,18 @@ type MigrationResult struct{}
 //
 // When direction is true, the up migration is executed, and when direction is false, the down
 // migration is executed.
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) ApplyVersion(ctx context.Context, version int64, direction bool) (*MigrationResult, error) {
 	return nil, errors.New("not implemented")
 }
 
 // Up applies all pending migrations. If there are no new migrations to apply, this method returns
 // empty list and nil error.
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) Up(ctx context.Context) ([]*MigrationResult, error) {
 	return nil, errors.New("not implemented")
 }
 
 // UpByOne applies the next available migration. If there are no migrations to apply, this method
 // returns [ErrNoNextVersion].
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) UpByOne(ctx context.Context) (*MigrationResult, error) {
 	return nil, errors.New("not implemented")
 }
@@ -174,14 +223,12 @@ func (p *Provider) UpByOne(ctx context.Context) (*MigrationResult, error) {
 //
 // For instance, if there are three new migrations (9,10,11) and the current database version is 8
 // with a requested version of 10, only versions 9 and 10 will be applied.
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) UpTo(ctx context.Context, version int64) ([]*MigrationResult, error) {
 	return nil, errors.New("not implemented")
 }
 
 // Down rolls back the most recently applied migration. If there are no migrations to apply, this
 // method returns [ErrNoNextVersion].
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) Down(ctx context.Context) (*MigrationResult, error) {
 	return nil, errors.New("not implemented")
 }
@@ -190,7 +237,6 @@ func (p *Provider) Down(ctx context.Context) (*MigrationResult, error) {
 //
 // For instance, if the current database version is 11, and the requested version is 9, only
 // migrations 11 and 10 will be rolled back.
-// Experimental: This API is experimental and may change in the future.
 func (p *Provider) DownTo(ctx context.Context, version int64) ([]*MigrationResult, error) {
 	return nil, errors.New("not implemented")
 }
diff --git a/internal/provider/provider_options.go b/internal/provider/provider_options.go
index bf7b9f9..d8060c4 100644
--- a/internal/provider/provider_options.go
+++ b/internal/provider/provider_options.go
@@ -60,10 +60,24 @@ func WithSessionLocker(locker lock.SessionLocker) ProviderOption {
 	})
 }
 
+// WithExcludes excludes the given file names from the list of migrations.
+//
+// If WithExcludes is called multiple times, the list of excludes is merged.
+func WithExcludes(excludes []string) ProviderOption {
+	return configFunc(func(c *config) error {
+		for _, name := range excludes {
+			c.excludes[name] = true
+		}
+		return nil
+	})
+}
+
 type config struct {
 	tableName string
 	verbose   bool
+	excludes  map[string]bool
 
+	// Locking options
 	lockEnabled   bool
 	sessionLocker lock.SessionLocker
 }
diff --git a/migration.go b/migration.go
index dcf0c61..619e934 100644
--- a/migration.go
+++ b/migration.go
@@ -218,27 +218,27 @@ func insertOrDeleteVersionNoTx(ctx context.Context, db *sql.DB, version int64, d
 	return store.DeleteVersionNoTx(ctx, db, TableName(), version)
 }
 
-// NumericComponent looks for migration scripts with names in the form:
-// XXX_descriptivename.ext where XXX specifies the version number
-// and ext specifies the type of migration
-func NumericComponent(name string) (int64, error) {
-	base := filepath.Base(name)
-
+// NumericComponent parses the version from the migration file name.
+//
+// XXX_descriptivename.ext where XXX specifies the version number and ext specifies the type of
+// migration, either .sql or .go.
+func NumericComponent(filename string) (int64, error) {
+	base := filepath.Base(filename)
 	if ext := filepath.Ext(base); ext != ".go" && ext != ".sql" {
-		return 0, errors.New("not a recognized migration file type")
+		return 0, errors.New("migration file does not have .sql or .go file extension")
 	}
-
 	idx := strings.Index(base, "_")
 	if idx < 0 {
 		return 0, errors.New("no filename separator '_' found")
 	}
-
-	n, e := strconv.ParseInt(base[:idx], 10, 64)
-	if e == nil && n <= 0 {
-		return 0, errors.New("migration IDs must be greater than zero")
+	n, err := strconv.ParseInt(base[:idx], 10, 64)
+	if err != nil {
+		return 0, err
 	}
-
-	return n, e
+	if n < 1 {
+		return 0, errors.New("migration version must be greater than zero")
+	}
+	return n, nil
 }
 
 func truncateDuration(d time.Duration) time.Duration {
