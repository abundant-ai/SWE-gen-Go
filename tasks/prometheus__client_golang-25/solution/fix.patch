diff --git a/Makefile b/Makefile
index 3ba28b1..8ba9db0 100644
--- a/Makefile
+++ b/Makefile
@@ -59,8 +59,7 @@ dependencies: source_path $(GOCC)
 	$(GO) get github.com/matttproud/gocheck
 
 test: build
-	$(MAKE) -C prometheus test
-	$(MAKE) -C examples test
+	$(GO) test ./...
 
 advice: test
 	$(MAKE) -C prometheus advice
diff --git a/extraction/metricfamilyprocessor.go b/extraction/metricfamilyprocessor.go
index 15e5186..c16f5ea 100644
--- a/extraction/metricfamilyprocessor.go
+++ b/extraction/metricfamilyprocessor.go
@@ -33,7 +33,7 @@ type metricFamilyProcessor struct{}
 // more details.
 var MetricFamilyProcessor = new(metricFamilyProcessor)
 
-func (m *metricFamilyProcessor) ProcessSingle(i io.Reader, r chan<- *Result, o *ProcessOptions) error {
+func (m *metricFamilyProcessor) ProcessSingle(i io.Reader, out Ingester, o *ProcessOptions) error {
 	family := new(dto.MetricFamily)
 
 	for {
@@ -49,16 +49,24 @@ func (m *metricFamilyProcessor) ProcessSingle(i io.Reader, r chan<- *Result, o *
 
 		switch *family.Type {
 		case dto.MetricType_COUNTER:
-			extractCounter(r, o, family)
+			if err := extractCounter(out, o, family); err != nil {
+				return err
+			}
 		case dto.MetricType_GAUGE:
-			extractGauge(r, o, family)
+			if err := extractGauge(out, o, family); err != nil {
+				return err
+			}
 		case dto.MetricType_SUMMARY:
-			extractSummary(r, o, family)
+			if err := extractSummary(out, o, family); err != nil {
+				return err
+			}
 		}
 	}
+
+	return nil
 }
 
-func extractCounter(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
+func extractCounter(out Ingester, o *ProcessOptions, f *dto.MetricFamily) error {
 	samples := make(model.Samples, 0, len(f.Metric))
 
 	for _, m := range f.Metric {
@@ -73,9 +81,6 @@ func extractCounter(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
 		sample.Metric = model.Metric{}
 		metric := sample.Metric
 
-		for l, v := range o.BaseLabels {
-			metric[l] = v
-		}
 		for _, p := range m.Label {
 			metric[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
 		}
@@ -85,12 +90,10 @@ func extractCounter(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
 		sample.Value = model.SampleValue(m.Counter.GetValue())
 	}
 
-	r <- &Result{
-		Samples: samples,
-	}
+	return out.Ingest(&Result{Samples: samples})
 }
 
-func extractGauge(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
+func extractGauge(out Ingester, o *ProcessOptions, f *dto.MetricFamily) error {
 	samples := make(model.Samples, 0, len(f.Metric))
 
 	for _, m := range f.Metric {
@@ -105,9 +108,6 @@ func extractGauge(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
 		sample.Metric = model.Metric{}
 		metric := sample.Metric
 
-		for l, v := range o.BaseLabels {
-			metric[l] = v
-		}
 		for _, p := range m.Label {
 			metric[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
 		}
@@ -117,12 +117,10 @@ func extractGauge(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
 		sample.Value = model.SampleValue(m.Gauge.GetValue())
 	}
 
-	r <- &Result{
-		Samples: samples,
-	}
+	return out.Ingest(&Result{Samples: samples})
 }
 
-func extractSummary(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
+func extractSummary(out Ingester, o *ProcessOptions, f *dto.MetricFamily) error {
 	// BUG(matt): Lack of dumping of sum or count.
 	samples := make(model.Samples, 0, len(f.Metric))
 
@@ -139,9 +137,6 @@ func extractSummary(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
 			sample.Metric = model.Metric{}
 			metric := sample.Metric
 
-			for l, v := range o.BaseLabels {
-				metric[l] = v
-			}
 			for _, p := range m.Label {
 				metric[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
 			}
@@ -154,7 +149,5 @@ func extractSummary(r chan<- *Result, o *ProcessOptions, f *dto.MetricFamily) {
 		}
 	}
 
-	r <- &Result{
-		Samples: samples,
-	}
+	return out.Ingest(&Result{Samples: samples})
 }
diff --git a/extraction/processor.go b/extraction/processor.go
index da4b6d9..e832452 100644
--- a/extraction/processor.go
+++ b/extraction/processor.go
@@ -25,9 +25,11 @@ import (
 type ProcessOptions struct {
 	// Timestamp is added to each value interpreted from the stream.
 	Timestamp time.Time
+}
 
-	// BaseLabels are labels that are accumulated onto each sample, if any.
-	BaseLabels model.LabelSet
+// Ingester consumes result streams in whatever way is desired by the user.
+type Ingester interface {
+	Ingest(*Result) error
 }
 
 // Processor is responsible for decoding the actual message responses from
@@ -36,7 +38,7 @@ type ProcessOptions struct {
 type Processor interface {
 	// ProcessSingle treats the input as a single self-contained message body and
 	// transforms it accordingly.  It has no support for streaming.
-	ProcessSingle(in io.Reader, out chan<- *Result, o *ProcessOptions) error
+	ProcessSingle(in io.Reader, out Ingester, o *ProcessOptions) error
 }
 
 // Helper function to convert map[string]string into LabelSet.
@@ -53,35 +55,40 @@ func labelSet(labels map[string]string) model.LabelSet {
 	return labelset
 }
 
-// Helper function to merge a target's base labels ontop of the labels of an
-// exported sample. If a label is already defined in the exported sample, we
-// assume that we are scraping an intermediate exporter and attach
-// "exporter_"-prefixes to Prometheus' own base labels.
-func mergeTargetLabels(entityLabels, targetLabels model.LabelSet) model.LabelSet {
-	if targetLabels == nil {
-		targetLabels = model.LabelSet{}
+// Result encapsulates the outcome from processing samples from a source.
+type Result struct {
+	Err     error
+	Samples model.Samples
+}
+
+func (r *Result) equal(o *Result) bool {
+	if r == o {
+		return true
 	}
 
-	result := model.LabelSet{}
+	if r.Err != o.Err {
+		if r.Err == nil || o.Err == nil {
+			return false
+		}
 
-	for label, value := range entityLabels {
-		result[label] = value
+		if r.Err.Error() != o.Err.Error() {
+			return false
+		}
 	}
 
-	for label, labelValue := range targetLabels {
-		if _, exists := result[label]; exists {
-			result[model.ExporterLabelPrefix+label] = labelValue
-		} else {
-			result[label] = labelValue
+	if len(r.Samples) != len(o.Samples) {
+		return false
+	}
+
+	for i, mine := range r.Samples {
+		other := o.Samples[i]
+
+		if !mine.Equal(other) {
+			return false
 		}
 	}
-	return result
-}
 
-// Result encapsulates the outcome from processing samples from a source.
-type Result struct {
-	Err     error
-	Samples model.Samples
+	return true
 }
 
 // A basic interface only useful in testing contexts for dispensing the time
diff --git a/extraction/processor0_0_1.go b/extraction/processor0_0_1.go
index 178ae61..50d4cf4 100644
--- a/extraction/processor0_0_1.go
+++ b/extraction/processor0_0_1.go
@@ -55,7 +55,7 @@ type entity001 []struct {
 	} `json:"metric"`
 }
 
-func (p *processor001) ProcessSingle(in io.Reader, out chan<- *Result, o *ProcessOptions) error {
+func (p *processor001) ProcessSingle(in io.Reader, out Ingester, o *ProcessOptions) error {
 	// TODO(matt): Replace with plain-jane JSON unmarshalling.
 	buffer, err := ioutil.ReadAll(in)
 	if err != nil {
@@ -71,15 +71,16 @@ func (p *processor001) ProcessSingle(in io.Reader, out chan<- *Result, o *Proces
 	pendingSamples := model.Samples{}
 	for _, entity := range entities {
 		for _, value := range entity.Metric.Value {
-			entityLabels := labelSet(entity.BaseLabels).Merge(labelSet(value.Labels))
-			labels := mergeTargetLabels(entityLabels, o.BaseLabels)
+			labels := labelSet(entity.BaseLabels).Merge(labelSet(value.Labels))
 
 			switch entity.Metric.MetricType {
 			case gauge001, counter001:
 				sampleValue, ok := value.Value.(float64)
 				if !ok {
 					err = fmt.Errorf("Could not convert value from %s %s to float64.", entity, value)
-					out <- &Result{Err: err}
+					if err := out.Ingest(&Result{Err: err}); err != nil {
+						return err
+					}
 					continue
 				}
 
@@ -95,7 +96,9 @@ func (p *processor001) ProcessSingle(in io.Reader, out chan<- *Result, o *Proces
 				sampleValue, ok := value.Value.(map[string]interface{})
 				if !ok {
 					err = fmt.Errorf("Could not convert value from %q to a map[string]interface{}.", value.Value)
-					out <- &Result{Err: err}
+					if err := out.Ingest(&Result{Err: err}); err != nil {
+						return err
+					}
 					continue
 				}
 
@@ -103,7 +106,9 @@ func (p *processor001) ProcessSingle(in io.Reader, out chan<- *Result, o *Proces
 					individualValue, ok := percentileValue.(float64)
 					if !ok {
 						err = fmt.Errorf("Could not convert value from %q to a float64.", percentileValue)
-						out <- &Result{Err: err}
+						if err := out.Ingest(&Result{Err: err}); err != nil {
+							return err
+						}
 						continue
 					}
 
@@ -127,7 +132,7 @@ func (p *processor001) ProcessSingle(in io.Reader, out chan<- *Result, o *Proces
 		}
 	}
 	if len(pendingSamples) > 0 {
-		out <- &Result{Samples: pendingSamples}
+		return out.Ingest(&Result{Samples: pendingSamples})
 	}
 
 	return nil
diff --git a/extraction/processor0_0_2.go b/extraction/processor0_0_2.go
index 2c7b566..14a3e5a 100644
--- a/extraction/processor0_0_2.go
+++ b/extraction/processor0_0_2.go
@@ -37,7 +37,7 @@ type counter002 struct {
 
 type processor002 struct{}
 
-func (p *processor002) ProcessSingle(in io.Reader, out chan<- *Result, o *ProcessOptions) error {
+func (p *processor002) ProcessSingle(in io.Reader, out Ingester, o *ProcessOptions) error {
 	// Processor for telemetry schema version 0.0.2.
 	// container for telemetry data
 	var entities []struct {
@@ -60,15 +60,15 @@ func (p *processor002) ProcessSingle(in io.Reader, out chan<- *Result, o *Proces
 			var values []counter002
 
 			if err := json.Unmarshal(entity.Metric.Values, &values); err != nil {
-				out <- &Result{
-					Err: fmt.Errorf("Could not extract %s value: %s", entity.Metric.Type, err),
+				err := fmt.Errorf("Could not extract %s value: %s", entity.Metric.Type, err)
+				if err := out.Ingest(&Result{Err: err}); err != nil {
+					return err
 				}
 				continue
 			}
 
 			for _, counter := range values {
-				entityLabels := labelSet(entity.BaseLabels).Merge(labelSet(counter.Labels))
-				labels := mergeTargetLabels(entityLabels, o.BaseLabels)
+				labels := labelSet(entity.BaseLabels).Merge(labelSet(counter.Labels))
 
 				pendingSamples = append(pendingSamples, &model.Sample{
 					Metric:    model.Metric(labels),
@@ -81,17 +81,17 @@ func (p *processor002) ProcessSingle(in io.Reader, out chan<- *Result, o *Proces
 			var values []histogram002
 
 			if err := json.Unmarshal(entity.Metric.Values, &values); err != nil {
-				out <- &Result{
-					Err: fmt.Errorf("Could not extract %s value: %s", entity.Metric.Type, err),
+				err := fmt.Errorf("Could not extract %s value: %s", entity.Metric.Type, err)
+				if err := out.Ingest(&Result{Err: err}); err != nil {
+					return err
 				}
 				continue
 			}
 
 			for _, histogram := range values {
 				for percentile, value := range histogram.Values {
-					entityLabels := labelSet(entity.BaseLabels).Merge(labelSet(histogram.Labels))
-					entityLabels[model.LabelName("percentile")] = model.LabelValue(percentile)
-					labels := mergeTargetLabels(entityLabels, o.BaseLabels)
+					labels := labelSet(entity.BaseLabels).Merge(labelSet(histogram.Labels))
+					labels[model.LabelName("percentile")] = model.LabelValue(percentile)
 
 					pendingSamples = append(pendingSamples, &model.Sample{
 						Metric:    model.Metric(labels),
@@ -102,14 +102,15 @@ func (p *processor002) ProcessSingle(in io.Reader, out chan<- *Result, o *Proces
 			}
 
 		default:
-			out <- &Result{
-				Err: fmt.Errorf("Unknown metric type %q", entity.Metric.Type),
+			err := fmt.Errorf("Unknown metric type %q", entity.Metric.Type)
+			if err := out.Ingest(&Result{Err: err}); err != nil {
+				return err
 			}
 		}
 	}
 
 	if len(pendingSamples) > 0 {
-		out <- &Result{Samples: pendingSamples}
+		return out.Ingest(&Result{Samples: pendingSamples})
 	}
 
 	return nil
diff --git a/model/sample.go b/model/sample.go
index 845d5b2..8f5db32 100644
--- a/model/sample.go
+++ b/model/sample.go
@@ -24,6 +24,10 @@ type Sample struct {
 }
 
 func (s *Sample) Equal(o *Sample) bool {
+	if s == o {
+		return true
+	}
+
 	if !s.Metric.Equal(o.Metric) {
 		return false
 	}
