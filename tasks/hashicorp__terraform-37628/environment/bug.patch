diff --git a/internal/command/meta.go b/internal/command/meta.go
index 1626109fbf..0dc89ecdd0 100644
--- a/internal/command/meta.go
+++ b/internal/command/meta.go
@@ -272,9 +272,6 @@ type Meta struct {
 	// Used with commands which write state to allow users to write remote
 	// state even if the remote and local Terraform versions don't match.
 	ignoreRemoteVersion bool
-
-	// set to true if query files should be parsed
-	includeQueryFiles bool
 }
 
 type testingOverrides struct {
diff --git a/internal/command/meta_config.go b/internal/command/meta_config.go
index 6485a43479..3887d77db4 100644
--- a/internal/command/meta_config.go
+++ b/internal/command/meta_config.go
@@ -38,7 +38,7 @@ func (m *Meta) normalizePath(path string) string {
 // loadConfig reads a configuration from the given directory, which should
 // contain a root module and have already have any required descendant modules
 // installed.
-func (m *Meta) loadConfig(rootDir string) (*configs.Config, tfdiags.Diagnostics) {
+func (m *Meta) loadConfig(rootDir string, parserOpts ...configs.Option) (*configs.Config, tfdiags.Diagnostics) {
 	var diags tfdiags.Diagnostics
 	rootDir = m.normalizePath(rootDir)
 
@@ -48,7 +48,7 @@ func (m *Meta) loadConfig(rootDir string) (*configs.Config, tfdiags.Diagnostics)
 		return nil, diags
 	}
 
-	config, hclDiags := loader.LoadConfig(rootDir)
+	config, hclDiags := loader.LoadConfig(rootDir, parserOpts...)
 	diags = diags.Append(hclDiags)
 	return config, diags
 }
@@ -353,9 +353,8 @@ func (m *Meta) registerSynthConfigSource(filename string, src []byte) {
 func (m *Meta) initConfigLoader() (*configload.Loader, error) {
 	if m.configLoader == nil {
 		loader, err := configload.NewLoader(&configload.Config{
-			ModulesDir:        m.modulesDir(),
-			Services:          m.Services,
-			IncludeQueryFiles: m.includeQueryFiles,
+			ModulesDir: m.modulesDir(),
+			Services:   m.Services,
 		})
 		if err != nil {
 			return nil, err
diff --git a/internal/command/plan_test.go b/internal/command/plan_test.go
index b3e726c8c0..e77ae0eb6c 100644
--- a/internal/command/plan_test.go
+++ b/internal/command/plan_test.go
@@ -1588,56 +1588,6 @@ func TestPlan_jsonGoldenReference(t *testing.T) {
 	checkGoldenReference(t, output, "plan")
 }
 
-// Tests related to how plan command behaves when there are query files in the configuration path
-func TestPlan_QueryFiles(t *testing.T) {
-	// a plan succeeds regardless of valid or invalid
-	// tfquery files in the configuration path
-	t.Run("with invalid query files in the config path", func(t *testing.T) {
-		td := t.TempDir()
-		testCopyDir(t, testFixturePath("query/invalid-syntax"), td)
-		t.Chdir(td)
-
-		p := planFixtureProvider()
-		view, done := testView(t)
-		c := &PlanCommand{
-			Meta: Meta{
-				testingOverrides: metaOverridesForProvider(p),
-				View:             view,
-			},
-		}
-
-		args := []string{}
-		code := c.Run(args)
-		output := done(t)
-		if code != 0 {
-			t.Fatalf("bad: %d\n\n%s", code, output.Stderr())
-		}
-	})
-
-	// the duplicate in the query should not matter because query files are not processed
-	t.Run("with duplicate variables across query and plan file", func(t *testing.T) {
-		td := t.TempDir()
-		testCopyDir(t, testFixturePath("query/duplicate-variables"), td)
-		t.Chdir(td)
-
-		p := planFixtureProvider()
-		view, done := testView(t)
-		c := &PlanCommand{
-			Meta: Meta{
-				testingOverrides: metaOverridesForProvider(p),
-				View:             view,
-			},
-		}
-
-		args := []string{"-var", "instance_name=foo"}
-		code := c.Run(args)
-		output := done(t)
-		if code != 0 {
-			t.Fatalf("bad: %d\n\n%s", code, output.Stderr())
-		}
-	})
-}
-
 // planFixtureSchema returns a schema suitable for processing the
 // configuration in testdata/plan . This schema should be
 // assigned to a mock provider named "test".
diff --git a/internal/command/query.go b/internal/command/query.go
index 5faf2f0616..6e1d00d730 100644
--- a/internal/command/query.go
+++ b/internal/command/query.go
@@ -75,7 +75,6 @@ func (c *QueryCommand) Run(rawArgs []string) int {
 	// migrated to views.
 	c.Meta.color = !common.NoColor
 	c.Meta.Color = c.Meta.color
-	c.Meta.includeQueryFiles = true
 
 	// Parse and validate flags
 	args, diags := arguments.ParseQuery(rawArgs)
diff --git a/internal/command/query_test.go b/internal/command/query_test.go
index 36e048456d..864194988f 100644
--- a/internal/command/query_test.go
+++ b/internal/command/query_test.go
@@ -80,7 +80,7 @@ configuration file (.tfquery.hcl file) and try again.
 			name:        "invalid query syntax",
 			directory:   "invalid-syntax",
 			expectedOut: "",
-			initCode:    0,
+			initCode:    1,
 			expectedErr: []string{`
 Error: Unsupported block type
 
@@ -173,6 +173,21 @@ value. Use a -var or -var-file command line argument to provide a value for
 this variable.
 `},
 		},
+		{
+			name:        "error - duplicate variable across .tf and .tfquery files",
+			directory:   "duplicate-variables",
+			expectedOut: "",
+			expectedErr: []string{`
+Error: Duplicate variable declaration
+
+  on query.tfquery.hcl line 2:
+   2: variable "instance_name" {
+
+A variable named "instance_name" was already declared at main.tf:15,1-25.
+Variable names must be unique within a module.
+`},
+			initCode: 1,
+		},
 	}
 
 	for _, ts := range tests {
diff --git a/internal/configs/config_build_test.go b/internal/configs/config_build_test.go
index 1537de6e62..496d03b249 100644
--- a/internal/configs/config_build_test.go
+++ b/internal/configs/config_build_test.go
@@ -227,12 +227,7 @@ func TestBuildConfigInvalidModules(t *testing.T) {
 			path := filepath.Join(testDir, name)
 			parser.AllowLanguageExperiments(true)
 
-			opts := []Option{MatchTestFiles("tests")}
-			if name == "list-in-child-module" {
-				opts = append(opts, MatchQueryFiles())
-			}
-
-			mod, diags := parser.LoadConfigDir(path, opts...)
+			mod, diags := parser.LoadConfigDirWithTests(path, "tests")
 			if diags.HasErrors() {
 				// these tests should only trigger errors that are caught in
 				// the config loader.
@@ -270,7 +265,7 @@ func TestBuildConfigInvalidModules(t *testing.T) {
 					// for simplicity, these tests will treat all source
 					// addresses as relative to the root module
 					sourcePath := filepath.Join(path, req.SourceAddr.String())
-					mod, diags := parser.LoadConfigDir(sourcePath, opts...)
+					mod, diags := parser.LoadConfigDir(sourcePath)
 					version, _ := version.NewVersion("1.0.0")
 					return mod, version, diags
 				}),
diff --git a/internal/configs/configload/loader.go b/internal/configs/configload/loader.go
index 07dfff0db6..07d68b30dd 100644
--- a/internal/configs/configload/loader.go
+++ b/internal/configs/configload/loader.go
@@ -27,8 +27,6 @@ type Loader struct {
 	// modules is used to install and locate descendant modules that are
 	// referenced (directly or indirectly) from the root module.
 	modules moduleMgr
-
-	parserOpts []configs.Option
 }
 
 // Config is used with NewLoader to specify configuration arguments for the
@@ -45,10 +43,6 @@ type Config struct {
 	// not supported, which should be true only in specialized circumstances
 	// such as in tests.
 	Services *disco.Disco
-
-	// IncludeQueryFiles is set to true if query files should be parsed
-	// when running query commands.
-	IncludeQueryFiles bool
 }
 
 // NewLoader creates and returns a loader that reads configuration from the
@@ -71,7 +65,6 @@ func NewLoader(config *Config) (*Loader, error) {
 			Services:   config.Services,
 			Registry:   reg,
 		},
-		parserOpts: make([]configs.Option, 0),
 	}
 
 	err := ret.modules.readModuleManifestSnapshot()
@@ -79,10 +72,6 @@ func NewLoader(config *Config) (*Loader, error) {
 		return nil, fmt.Errorf("failed to read module manifest: %s", err)
 	}
 
-	if config.IncludeQueryFiles {
-		ret.parserOpts = append(ret.parserOpts, configs.MatchQueryFiles())
-	}
-
 	return ret, nil
 }
 
@@ -133,7 +122,7 @@ func (l *Loader) Sources() map[string][]byte {
 // least one Terraform configuration file. This is a wrapper around calling
 // the same method name on the loader's parser.
 func (l *Loader) IsConfigDir(path string) bool {
-	return l.parser.IsConfigDir(path, l.parserOpts...)
+	return l.parser.IsConfigDir(path)
 }
 
 // ImportSources writes into the receiver's source code map the given source
diff --git a/internal/configs/configload/loader_load.go b/internal/configs/configload/loader_load.go
index 3b9407a32b..f7b776b860 100644
--- a/internal/configs/configload/loader_load.go
+++ b/internal/configs/configload/loader_load.go
@@ -22,14 +22,14 @@ import (
 //
 // LoadConfig performs the basic syntax and uniqueness validations that are
 // required to process the individual modules
-func (l *Loader) LoadConfig(rootDir string) (*configs.Config, hcl.Diagnostics) {
-	return l.loadConfig(l.parser.LoadConfigDir(rootDir, l.parserOpts...))
+func (l *Loader) LoadConfig(rootDir string, parserOpts ...configs.Option) (*configs.Config, hcl.Diagnostics) {
+	return l.loadConfig(l.parser.LoadConfigDir(rootDir, parserOpts...))
 }
 
 // LoadConfigWithTests matches LoadConfig, except the configs.Config contains
 // any relevant .tftest.hcl files.
 func (l *Loader) LoadConfigWithTests(rootDir string, testDir string) (*configs.Config, hcl.Diagnostics) {
-	return l.loadConfig(l.parser.LoadConfigDir(rootDir, append(l.parserOpts, configs.MatchTestFiles(testDir))...))
+	return l.loadConfig(l.parser.LoadConfigDirWithTests(rootDir, testDir))
 }
 
 func (l *Loader) loadConfig(rootMod *configs.Module, diags hcl.Diagnostics) (*configs.Config, hcl.Diagnostics) {
diff --git a/internal/configs/configload/loader_snapshot.go b/internal/configs/configload/loader_snapshot.go
index 46efab362c..d8260cddd7 100644
--- a/internal/configs/configload/loader_snapshot.go
+++ b/internal/configs/configload/loader_snapshot.go
@@ -24,7 +24,7 @@ import (
 // creates an in-memory snapshot of the configuration files used, which can
 // be later used to create a loader that may read only from this snapshot.
 func (l *Loader) LoadConfigWithSnapshot(rootDir string) (*configs.Config, *Snapshot, hcl.Diagnostics) {
-	rootMod, diags := l.parser.LoadConfigDir(rootDir, l.parserOpts...)
+	rootMod, diags := l.parser.LoadConfigDir(rootDir)
 	if rootMod == nil {
 		return nil, nil, diags
 	}
diff --git a/internal/configs/configload/testing.go b/internal/configs/configload/testing.go
index 537e86ac2c..bc90b2ef3c 100644
--- a/internal/configs/configload/testing.go
+++ b/internal/configs/configload/testing.go
@@ -4,10 +4,9 @@
 package configload
 
 import (
+	"io/ioutil"
 	"os"
 	"testing"
-
-	"github.com/hashicorp/terraform/internal/configs"
 )
 
 // NewLoaderForTests is a variant of NewLoader that is intended to be more
@@ -21,10 +20,10 @@ import (
 // In the case of any errors, t.Fatal (or similar) will be called to halt
 // execution of the test, so the calling test does not need to handle errors
 // itself.
-func NewLoaderForTests(t testing.TB, parserOpts ...configs.Option) (*Loader, func()) {
+func NewLoaderForTests(t testing.TB) (*Loader, func()) {
 	t.Helper()
 
-	modulesDir, err := os.MkdirTemp("", "tf-configs")
+	modulesDir, err := ioutil.TempDir("", "tf-configs")
 	if err != nil {
 		t.Fatalf("failed to create temporary modules dir: %s", err)
 		return nil, func() {}
@@ -37,7 +36,6 @@ func NewLoaderForTests(t testing.TB, parserOpts ...configs.Option) (*Loader, fun
 	loader, err := NewLoader(&Config{
 		ModulesDir: modulesDir,
 	})
-	loader.parserOpts = append(loader.parserOpts, parserOpts...)
 	if err != nil {
 		cleanup()
 		t.Fatalf("failed to create config loader: %s", err)
diff --git a/internal/configs/parser_config_dir.go b/internal/configs/parser_config_dir.go
index a4c220febc..9c296bc013 100644
--- a/internal/configs/parser_config_dir.go
+++ b/internal/configs/parser_config_dir.go
@@ -153,8 +153,8 @@ func (p Parser) ConfigDirFiles(dir string, opts ...Option) (primary, override []
 // exists and contains at least one Terraform config file (with a .tf or
 // .tf.json extension.). Note, we explicitely exclude checking for tests here
 // as tests must live alongside actual .tf config files. Same goes for query files.
-func (p *Parser) IsConfigDir(path string, opts ...Option) bool {
-	pathSet, _ := p.dirFileSet(path, opts...)
+func (p *Parser) IsConfigDir(path string) bool {
+	pathSet, _ := p.dirFileSet(path)
 	return (len(pathSet.Primary) + len(pathSet.Override)) > 0
 }
 
diff --git a/internal/configs/parser_config_dir_test.go b/internal/configs/parser_config_dir_test.go
index 2fe176ca68..0c77b20217 100644
--- a/internal/configs/parser_config_dir_test.go
+++ b/internal/configs/parser_config_dir_test.go
@@ -205,7 +205,7 @@ func TestParserLoadConfigDirWithQueries(t *testing.T) {
 	for _, test := range tests {
 		t.Run(test.name, func(t *testing.T) {
 			parser := NewParser(nil)
-			mod, diags := parser.LoadConfigDir(test.directory, MatchQueryFiles())
+			mod, diags := parser.LoadConfigDir(test.directory)
 			if len(test.diagnostics) > 0 {
 				if !diags.HasErrors() {
 					t.Errorf("expected errors, but found none")
diff --git a/internal/configs/parser_file_matcher.go b/internal/configs/parser_file_matcher.go
index 6644b421ee..92d26fb4aa 100644
--- a/internal/configs/parser_file_matcher.go
+++ b/internal/configs/parser_file_matcher.go
@@ -59,8 +59,8 @@ func (p *Parser) dirFileSet(dir string, opts ...Option) (ConfigFileSet, hcl.Diag
 
 	// Set up the parser configuration
 	cfg := &parserConfig{
-		// We always match .tf files
-		matchers:      []FileMatcher{&moduleFiles{}},
+		// We always match .tf files and .tfquery.hcl files
+		matchers:      []FileMatcher{&moduleFiles{}, &queryFiles{}},
 		testDirectory: DefaultTestDirectory,
 		fs:            p.fs,
 	}
@@ -139,13 +139,6 @@ func MatchTestFiles(dir string) Option {
 	}
 }
 
-// MatchQueryFiles adds a matcher for Terraform query files (.tfquery.hcl and .tfquery.json)
-func MatchQueryFiles() Option {
-	return func(o *parserConfig) {
-		o.matchers = append(o.matchers, &queryFiles{})
-	}
-}
-
 // moduleFiles matches regular Terraform configuration files (.tf and .tf.json)
 type moduleFiles struct{}
 
diff --git a/internal/initwd/testing.go b/internal/initwd/testing.go
index 4331529131..8c99778e1c 100644
--- a/internal/initwd/testing.go
+++ b/internal/initwd/testing.go
@@ -53,7 +53,7 @@ func LoadConfigForTests(t *testing.T, rootDir string, testsDir string) (*configs
 		t.Fatalf("failed to refresh modules after installation: %s", err)
 	}
 
-	config, hclDiags := loader.LoadConfigWithTests(rootDir, testsDir)
+	config, hclDiags := loader.LoadConfig(rootDir, configs.MatchTestFiles(testsDir))
 	diags = diags.Append(hclDiags)
 	return config, loader, cleanup, diags
 }
diff --git a/internal/terraform/terraform_test.go b/internal/terraform/terraform_test.go
index a988d30fc6..e6e9dc8d07 100644
--- a/internal/terraform/terraform_test.go
+++ b/internal/terraform/terraform_test.go
@@ -97,8 +97,6 @@ func testModuleInline(t testing.TB, sources map[string]string) *configs.Config {
 		t.Fatal(err)
 	}
 
-	var queryOpt configs.Option
-
 	for path, configStr := range sources {
 		dir := filepath.Dir(path)
 		if dir != "." {
@@ -118,18 +116,9 @@ func testModuleInline(t testing.TB, sources map[string]string) *configs.Config {
 		if err != nil {
 			t.Fatalf("Error creating temporary file for config: %s", err)
 		}
-
-		if strings.HasSuffix(path, "tfquery.hcl") || strings.HasSuffix(path, "tfquery.json") {
-			queryOpt = configs.MatchQueryFiles()
-		}
-	}
-
-	var parserOpts []configs.Option
-	if queryOpt != nil {
-		parserOpts = append(parserOpts, queryOpt)
 	}
 
-	loader, cleanup := configload.NewLoaderForTests(t, parserOpts...)
+	loader, cleanup := configload.NewLoaderForTests(t)
 	defer cleanup()
 
 	// We need to be able to exercise experimental features in our integration tests.
@@ -150,7 +139,7 @@ func testModuleInline(t testing.TB, sources map[string]string) *configs.Config {
 		t.Fatalf("failed to refresh modules after installation: %s", err)
 	}
 
-	config, diags := loader.LoadConfigWithTests(cfgPath, "tests")
+	config, diags := loader.LoadConfig(cfgPath, configs.MatchTestFiles("tests"))
 	if diags.HasErrors() {
 		t.Fatal(diags.Error())
 	}
