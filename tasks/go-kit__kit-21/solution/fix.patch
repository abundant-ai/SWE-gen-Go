diff --git a/log/json_logger.go b/log/json_logger.go
new file mode 100644
index 0000000..8907c8f
--- /dev/null
+++ b/log/json_logger.go
@@ -0,0 +1,45 @@
+package log
+
+import (
+	"encoding/json"
+	"fmt"
+	"io"
+)
+
+type jsonLogger struct {
+	io.Writer
+}
+
+// NewJSONLogger returns a Logger that encodes keyvals to the Writer as a
+// single JSON object.
+func NewJSONLogger(w io.Writer) Logger {
+	return &jsonLogger{w}
+}
+
+func (l *jsonLogger) Log(keyvals ...interface{}) error {
+	if len(keyvals)%2 == 1 {
+		panic("odd number of keyvals")
+	}
+	m := make(map[string]interface{}, len(keyvals)/2)
+	for i := 0; i < len(keyvals); i += 2 {
+		merge(m, keyvals[i], keyvals[i+1])
+	}
+	return json.NewEncoder(l.Writer).Encode(m)
+}
+
+func merge(dst map[string]interface{}, k, v interface{}) map[string]interface{} {
+	var key string
+	switch x := k.(type) {
+	case string:
+		key = x
+	case fmt.Stringer:
+		key = x.String()
+	default:
+		key = fmt.Sprintf("%v", x)
+	}
+	if x, ok := v.(error); ok {
+		v = x.Error()
+	}
+	dst[key] = v
+	return dst
+}
diff --git a/log/levels.go b/log/levels.go
new file mode 100644
index 0000000..4c7079b
--- /dev/null
+++ b/log/levels.go
@@ -0,0 +1,60 @@
+package log
+
+// Levels provides a default set of leveled loggers.
+type Levels struct {
+	Debug Logger
+	Info  Logger
+	Error Logger
+}
+
+type levelOptions struct {
+	levelKey   string
+	debugValue string
+	infoValue  string
+	errorValue string
+}
+
+// LevelOption sets a parameter for leveled loggers.
+type LevelOption func(*levelOptions)
+
+// LevelKey sets the key for the field used to indicate log level. By default,
+// the key is "level".
+func LevelKey(key string) LevelOption {
+	return func(o *levelOptions) { o.levelKey = key }
+}
+
+// DebugLevelValue sets the value for the field used to indicate the debug log
+// level. By default, the value is "DEBUG".
+func DebugLevelValue(value string) LevelOption {
+	return func(o *levelOptions) { o.debugValue = value }
+}
+
+// InfoLevelValue sets the value for the field used to indicate the debug log
+// level. By default, the value is "INFO".
+func InfoLevelValue(value string) LevelOption {
+	return func(o *levelOptions) { o.infoValue = value }
+}
+
+// ErrorLevelValue sets the value for the field used to indicate the debug log
+// level. By default, the value is "ERROR".
+func ErrorLevelValue(value string) LevelOption {
+	return func(o *levelOptions) { o.errorValue = value }
+}
+
+// NewLevels returns a new set of leveled loggers based on the base logger.
+func NewLevels(base Logger, options ...LevelOption) Levels {
+	opts := &levelOptions{
+		levelKey:   "level",
+		debugValue: "DEBUG",
+		infoValue:  "INFO",
+		errorValue: "ERROR",
+	}
+	for _, option := range options {
+		option(opts)
+	}
+	return Levels{
+		Debug: With(base, opts.levelKey, opts.debugValue),
+		Info:  With(base, opts.levelKey, opts.infoValue),
+		Error: With(base, opts.levelKey, opts.errorValue),
+	}
+}
diff --git a/log/log.go b/log/log.go
new file mode 100644
index 0000000..3059238
--- /dev/null
+++ b/log/log.go
@@ -0,0 +1,33 @@
+package log
+
+// Logger is the least-common-denominator interface for all log operations.
+type Logger interface {
+	Log(keyvals ...interface{}) error
+}
+
+// With new, contextualized Logger with the passed keyvals already applied.
+func With(logger Logger, keyvals ...interface{}) Logger {
+	if w, ok := logger.(Wither); ok {
+		return w.With(keyvals...)
+	}
+	return LoggerFunc(func(kvs ...interface{}) error {
+		return logger.Log(append(keyvals, kvs...)...)
+	})
+}
+
+// LoggerFunc is an adapter to allow use of ordinary functions as Loggers. If
+// f is a function with the appropriate signature, LoggerFunc(f) is a Logger
+// object that calls f.
+type LoggerFunc func(...interface{}) error
+
+// Log implements Logger by calling f(keyvals...).
+func (f LoggerFunc) Log(keyvals ...interface{}) error {
+	return f(keyvals...)
+}
+
+// Wither describes an optimization that Logger implementations may make. If a
+// Logger implements Wither, the package-level With function will invoke it
+// when creating a new, contextual logger.
+type Wither interface {
+	With(keyvals ...interface{}) Logger
+}
diff --git a/log/prefix_logger.go b/log/prefix_logger.go
new file mode 100644
index 0000000..f37324a
--- /dev/null
+++ b/log/prefix_logger.go
@@ -0,0 +1,36 @@
+package log
+
+import (
+	"fmt"
+	"io"
+)
+
+type prefixLogger struct {
+	io.Writer
+}
+
+// NewPrefixLogger returns a basic logger that encodes keyvals as simple "k=v"
+// pairs to the Writer.
+func NewPrefixLogger(w io.Writer) Logger {
+	return &prefixLogger{w}
+}
+
+func (l prefixLogger) Log(keyvals ...interface{}) error {
+	if len(keyvals)%2 == 1 {
+		panic("odd number of keyvals")
+	}
+	for i := 0; i < len(keyvals); i += 2 {
+		if i != 0 {
+			if _, err := fmt.Fprint(l.Writer, " "); err != nil {
+				return err
+			}
+		}
+		if _, err := fmt.Fprintf(l.Writer, "%s=%v", keyvals[i], keyvals[i+1]); err != nil {
+			return err
+		}
+	}
+	if _, err := fmt.Fprintln(l.Writer); err != nil {
+		return err
+	}
+	return nil
+}
diff --git a/log/stdlib_writer.go b/log/stdlib_writer.go
new file mode 100644
index 0000000..fcdea1e
--- /dev/null
+++ b/log/stdlib_writer.go
@@ -0,0 +1,100 @@
+package log
+
+import (
+	"io"
+	"regexp"
+)
+
+// StdlibWriter wraps a Logger and allows it to be passed to the stdlib
+// logger's SetOutput. It will extract date/timestamps, filenames, and
+// messages, and place them under relevant keys.
+type StdlibWriter struct {
+	Logger
+	timestampKey string
+	fileKey      string
+	messageKey   string
+}
+
+// StdlibWriterOption sets a parameter for the StdlibWriter.
+type StdlibWriterOption func(*StdlibWriter)
+
+// TimestampKey sets the key for the timestamp field. By default, it's "ts".
+func TimestampKey(key string) StdlibWriterOption {
+	return func(w *StdlibWriter) { w.timestampKey = key }
+}
+
+// FileKey sets the key for the file and line field. By default, it's "file".
+func FileKey(key string) StdlibWriterOption {
+	return func(w *StdlibWriter) { w.fileKey = key }
+}
+
+// MessageKey sets the key for the actual log message. By default, it's "msg".
+func MessageKey(key string) StdlibWriterOption {
+	return func(w *StdlibWriter) { w.messageKey = key }
+}
+
+// NewStdlibWriter returns a new StdlibWriter wrapper around the passed
+// logger. It's designed to be passed to log.SetOutput.
+func NewStdlibWriter(logger Logger, options ...StdlibWriterOption) io.Writer {
+	w := StdlibWriter{
+		Logger:       logger,
+		timestampKey: "ts",
+		fileKey:      "file",
+		messageKey:   "msg",
+	}
+	for _, option := range options {
+		option(&w)
+	}
+	return w
+}
+
+func (w StdlibWriter) Write(p []byte) (int, error) {
+	result := subexps(p)
+	keyvals := []interface{}{}
+	var timestamp string
+	if date, ok := result["date"]; ok && date != "" {
+		timestamp = date
+	}
+	if time, ok := result["time"]; ok && time != "" {
+		if timestamp != "" {
+			timestamp += " "
+		}
+		timestamp += time
+	}
+	if timestamp != "" {
+		keyvals = append(keyvals, w.timestampKey, timestamp)
+	}
+	if file, ok := result["file"]; ok && file != "" {
+		keyvals = append(keyvals, w.fileKey, file)
+	}
+	if msg, ok := result["msg"]; ok {
+		keyvals = append(keyvals, w.messageKey, msg)
+	}
+	if err := w.Logger.Log(keyvals...); err != nil {
+		return 0, err
+	}
+	return len(p), nil
+}
+
+const (
+	logRegexpDate = `(?P<date>[0-9]{4}/[0-9]{2}/[0-9]{2})?[ ]?`
+	logRegexpTime = `(?P<time>[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?)?[ ]?`
+	logRegexpFile = `(?P<file>[^:]+:[0-9]+)?`
+	logRegexpMsg  = `(: )?(?P<msg>.*)`
+)
+
+var (
+	logRegexp = regexp.MustCompile(logRegexpDate + logRegexpTime + logRegexpFile + logRegexpMsg)
+)
+
+func subexps(line []byte) map[string]string {
+	m := logRegexp.FindSubmatch(line)
+	if len(m) < len(logRegexp.SubexpNames()) {
+		return map[string]string{}
+	}
+	result := map[string]string{}
+	for i, name := range logRegexp.SubexpNames() {
+		result[name] = string(m[i])
+	}
+	return result
+}
