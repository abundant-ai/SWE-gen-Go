diff --git a/log/benchmark_test.go b/log/benchmark_test.go
deleted file mode 100644
index 1a23159..0000000
--- a/log/benchmark_test.go
+++ /dev/null
@@ -1,21 +0,0 @@
-package log_test
-
-import (
-	"testing"
-
-	"github.com/peterbourgon/gokit/log"
-)
-
-func benchmarkRunner(b *testing.B, logger log.Logger, f func(log.Logger)) {
-	logger = log.With(logger, "common_key", "common_value")
-	b.ReportAllocs()
-	b.ResetTimer()
-	for i := 0; i < b.N; i++ {
-		f(logger)
-	}
-}
-
-var (
-	baseMessage = func(logger log.Logger) { logger.Log("foo_key", "foo_value") }
-	withMessage = func(logger log.Logger) { log.With(logger, "a", "b").Log("c", "d") }
-)
diff --git a/log/json_logger.go b/log/json_logger.go
deleted file mode 100644
index 8907c8f..0000000
--- a/log/json_logger.go
+++ /dev/null
@@ -1,45 +0,0 @@
-package log
-
-import (
-	"encoding/json"
-	"fmt"
-	"io"
-)
-
-type jsonLogger struct {
-	io.Writer
-}
-
-// NewJSONLogger returns a Logger that encodes keyvals to the Writer as a
-// single JSON object.
-func NewJSONLogger(w io.Writer) Logger {
-	return &jsonLogger{w}
-}
-
-func (l *jsonLogger) Log(keyvals ...interface{}) error {
-	if len(keyvals)%2 == 1 {
-		panic("odd number of keyvals")
-	}
-	m := make(map[string]interface{}, len(keyvals)/2)
-	for i := 0; i < len(keyvals); i += 2 {
-		merge(m, keyvals[i], keyvals[i+1])
-	}
-	return json.NewEncoder(l.Writer).Encode(m)
-}
-
-func merge(dst map[string]interface{}, k, v interface{}) map[string]interface{} {
-	var key string
-	switch x := k.(type) {
-	case string:
-		key = x
-	case fmt.Stringer:
-		key = x.String()
-	default:
-		key = fmt.Sprintf("%v", x)
-	}
-	if x, ok := v.(error); ok {
-		v = x.Error()
-	}
-	dst[key] = v
-	return dst
-}
diff --git a/log/json_logger_test.go b/log/json_logger_test.go
deleted file mode 100644
index f724de1..0000000
--- a/log/json_logger_test.go
+++ /dev/null
@@ -1,29 +0,0 @@
-package log_test
-
-import (
-	"bytes"
-	"errors"
-	"io/ioutil"
-	"testing"
-
-	"github.com/peterbourgon/gokit/log"
-)
-
-func TestJSONLogger(t *testing.T) {
-	buf := &bytes.Buffer{}
-	logger := log.NewJSONLogger(buf)
-	if err := logger.Log("err", errors.New("err"), "m", map[string]int{"0": 0}, "a", []int{1, 2, 3}); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := `{"a":[1,2,3],"err":"err","m":{"0":0}}`+"\n", buf.String(); want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-}
-
-func BenchmarkJSONLoggerSimple(b *testing.B) {
-	benchmarkRunner(b, log.NewJSONLogger(ioutil.Discard), baseMessage)
-}
-
-func BenchmarkJSONLoggerContextual(b *testing.B) {
-	benchmarkRunner(b, log.NewJSONLogger(ioutil.Discard), withMessage)
-}
diff --git a/log/levels.go b/log/levels.go
deleted file mode 100644
index 4c7079b..0000000
--- a/log/levels.go
+++ /dev/null
@@ -1,60 +0,0 @@
-package log
-
-// Levels provides a default set of leveled loggers.
-type Levels struct {
-	Debug Logger
-	Info  Logger
-	Error Logger
-}
-
-type levelOptions struct {
-	levelKey   string
-	debugValue string
-	infoValue  string
-	errorValue string
-}
-
-// LevelOption sets a parameter for leveled loggers.
-type LevelOption func(*levelOptions)
-
-// LevelKey sets the key for the field used to indicate log level. By default,
-// the key is "level".
-func LevelKey(key string) LevelOption {
-	return func(o *levelOptions) { o.levelKey = key }
-}
-
-// DebugLevelValue sets the value for the field used to indicate the debug log
-// level. By default, the value is "DEBUG".
-func DebugLevelValue(value string) LevelOption {
-	return func(o *levelOptions) { o.debugValue = value }
-}
-
-// InfoLevelValue sets the value for the field used to indicate the debug log
-// level. By default, the value is "INFO".
-func InfoLevelValue(value string) LevelOption {
-	return func(o *levelOptions) { o.infoValue = value }
-}
-
-// ErrorLevelValue sets the value for the field used to indicate the debug log
-// level. By default, the value is "ERROR".
-func ErrorLevelValue(value string) LevelOption {
-	return func(o *levelOptions) { o.errorValue = value }
-}
-
-// NewLevels returns a new set of leveled loggers based on the base logger.
-func NewLevels(base Logger, options ...LevelOption) Levels {
-	opts := &levelOptions{
-		levelKey:   "level",
-		debugValue: "DEBUG",
-		infoValue:  "INFO",
-		errorValue: "ERROR",
-	}
-	for _, option := range options {
-		option(opts)
-	}
-	return Levels{
-		Debug: With(base, opts.levelKey, opts.debugValue),
-		Info:  With(base, opts.levelKey, opts.infoValue),
-		Error: With(base, opts.levelKey, opts.errorValue),
-	}
-}
diff --git a/log/levels_test.go b/log/levels_test.go
deleted file mode 100644
index a906c7a..0000000
--- a/log/levels_test.go
+++ /dev/null
@@ -1,45 +0,0 @@
-package log_test
-
-import (
-	"bytes"
-	"testing"
-
-	"github.com/peterbourgon/gokit/log"
-)
-
-func TestDefaultLevels(t *testing.T) {
-	buf := bytes.Buffer{}
-	levels := log.NewLevels(log.NewPrefixLogger(&buf))
-
-	levels.Debug.Log("msg", "ðŸ‘¨") // of course you'd want to do this
-	if want, have := "level=DEBUG msg=ðŸ‘¨\n", buf.String(); want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-
-	buf.Reset()
-	levels.Info.Log("msg", "ðŸš€")
-	if want, have := "level=INFO msg=ðŸš€\n", buf.String(); want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-
-	buf.Reset()
-	levels.Error.Log("msg", "ðŸµ")
-	if want, have := "level=ERROR msg=ðŸµ\n", buf.String(); want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-}
-
-func TestModifiedLevels(t *testing.T) {
-	buf := bytes.Buffer{}
-	levels := log.NewLevels(
-		log.NewJSONLogger(&buf),
-		log.LevelKey("l"),
-		log.DebugLevelValue("â›„"),
-		log.InfoLevelValue("ðŸŒœ"),
-		log.ErrorLevelValue("ðŸŒŠ"),
-	)
-	log.With(levels.Debug, "easter_island", "ðŸ—¿").Log("msg", "ðŸ’ƒðŸ’ƒðŸ’ƒ")
-	if want, have := `{"easter_island":"ðŸ—¿","l":"â›„","msg":"ðŸ’ƒðŸ’ƒðŸ’ƒ"}`+"\n", buf.String(); want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-}
diff --git a/log/log.go b/log/log.go
deleted file mode 100644
index 3059238..0000000
--- a/log/log.go
+++ /dev/null
@@ -1,33 +0,0 @@
-package log
-
-// Logger is the least-common-denominator interface for all log operations.
-type Logger interface {
-	Log(keyvals ...interface{}) error
-}
-
-// With new, contextualized Logger with the passed keyvals already applied.
-func With(logger Logger, keyvals ...interface{}) Logger {
-	if w, ok := logger.(Wither); ok {
-		return w.With(keyvals...)
-	}
-	return LoggerFunc(func(kvs ...interface{}) error {
-		return logger.Log(append(keyvals, kvs...)...)
-	})
-}
-
-// LoggerFunc is an adapter to allow use of ordinary functions as Loggers. If
-// f is a function with the appropriate signature, LoggerFunc(f) is a Logger
-// object that calls f.
-type LoggerFunc func(...interface{}) error
-
-// Log implements Logger by calling f(keyvals...).
-func (f LoggerFunc) Log(keyvals ...interface{}) error {
-	return f(keyvals...)
-}
-
-// Wither describes an optimization that Logger implementations may make. If a
-// Logger implements Wither, the package-level With function will invoke it
-// when creating a new, contextual logger.
-type Wither interface {
-	With(keyvals ...interface{}) Logger
-}
diff --git a/log/log_test.go b/log/log_test.go
deleted file mode 100644
index de002e6..0000000
--- a/log/log_test.go
+++ /dev/null
@@ -1,35 +0,0 @@
-package log_test
-
-import (
-	"bytes"
-	"testing"
-
-	"github.com/peterbourgon/gokit/log"
-)
-
-func TestWith(t *testing.T) {
-	buf := &bytes.Buffer{}
-	logger := log.NewJSONLogger(buf)
-	logger = log.With(logger, "a", 123)
-	logger = log.With(logger, "b", "c") // With should stack
-	if err := logger.Log("msg", "message"); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := `{"a":123,"b":"c","msg":"message"}`+"\n", buf.String(); want != have {
-		t.Errorf("want\n\t%#v, have\n\t%#v", want, have)
-	}
-}
-
-func TestWither(t *testing.T) {
-	logger := &mylogger{}
-	log.With(logger, "a", "b").Log("c", "d")
-	if want, have := 1, logger.withs; want != have {
-		t.Errorf("want %d, have %d", want, have)
-	}
-}
-
-type mylogger struct{ withs int }
-
-func (l *mylogger) Log(keyvals ...interface{}) error { return nil }
-
-func (l *mylogger) With(keyvals ...interface{}) log.Logger { l.withs++; return l }
diff --git a/log/prefix_logger.go b/log/prefix_logger.go
deleted file mode 100644
index f37324a..0000000
--- a/log/prefix_logger.go
+++ /dev/null
@@ -1,36 +0,0 @@
-package log
-
-import (
-	"fmt"
-	"io"
-)
-
-type prefixLogger struct {
-	io.Writer
-}
-
-// NewPrefixLogger returns a basic logger that encodes keyvals as simple "k=v"
-// pairs to the Writer.
-func NewPrefixLogger(w io.Writer) Logger {
-	return &prefixLogger{w}
-}
-
-func (l prefixLogger) Log(keyvals ...interface{}) error {
-	if len(keyvals)%2 == 1 {
-		panic("odd number of keyvals")
-	}
-	for i := 0; i < len(keyvals); i += 2 {
-		if i != 0 {
-			if _, err := fmt.Fprint(l.Writer, " "); err != nil {
-				return err
-			}
-		}
-		if _, err := fmt.Fprintf(l.Writer, "%s=%v", keyvals[i], keyvals[i+1]); err != nil {
-			return err
-		}
-	}
-	if _, err := fmt.Fprintln(l.Writer); err != nil {
-		return err
-	}
-	return nil
-}
diff --git a/log/prefix_logger_test.go b/log/prefix_logger_test.go
deleted file mode 100644
index f0bb609..0000000
--- a/log/prefix_logger_test.go
+++ /dev/null
@@ -1,50 +0,0 @@
-package log_test
-
-import (
-	"bytes"
-	"errors"
-	"io/ioutil"
-	"testing"
-
-	"github.com/peterbourgon/gokit/log"
-)
-
-func TestPrefixLogger(t *testing.T) {
-	buf := &bytes.Buffer{}
-	logger := log.NewPrefixLogger(buf)
-
-	if err := logger.Log("hello", "world"); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := "hello=world\n", buf.String(); want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-
-	buf.Reset()
-	if err := logger.Log("a", 1, "err", errors.New("error")); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := "a=1 err=error\n", buf.String(); want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-
-	buf.Reset()
-	if err := logger.Log("std_map", map[int]int{1: 2}, "my_map", mymap{0: 0}); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := "std_map=map[1:2] my_map=special_behavior\n", buf.String(); want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-}
-
-type mymap map[int]int
-
-func (m mymap) String() string { return "special_behavior" }
-
-func BenchmarkPrefixLoggerSimple(b *testing.B) {
-	benchmarkRunner(b, log.NewPrefixLogger(ioutil.Discard), baseMessage)
-}
-
-func BenchmarkPrefixLoggerContextual(b *testing.B) {
-	benchmarkRunner(b, log.NewPrefixLogger(ioutil.Discard), withMessage)
-}
diff --git a/log/stdlib_writer.go b/log/stdlib_writer.go
deleted file mode 100644
index fcdea1e..0000000
--- a/log/stdlib_writer.go
+++ /dev/null
@@ -1,100 +0,0 @@
-package log
-
-import (
-	"io"
-	"regexp"
-)
-
-// StdlibWriter wraps a Logger and allows it to be passed to the stdlib
-// logger's SetOutput. It will extract date/timestamps, filenames, and
-// messages, and place them under relevant keys.
-type StdlibWriter struct {
-	Logger
-	timestampKey string
-	fileKey      string
-	messageKey   string
-}
-
-// StdlibWriterOption sets a parameter for the StdlibWriter.
-type StdlibWriterOption func(*StdlibWriter)
-
-// TimestampKey sets the key for the timestamp field. By default, it's "ts".
-func TimestampKey(key string) StdlibWriterOption {
-	return func(w *StdlibWriter) { w.timestampKey = key }
-}
-
-// FileKey sets the key for the file and line field. By default, it's "file".
-func FileKey(key string) StdlibWriterOption {
-	return func(w *StdlibWriter) { w.fileKey = key }
-}
-
-// MessageKey sets the key for the actual log message. By default, it's "msg".
-func MessageKey(key string) StdlibWriterOption {
-	return func(w *StdlibWriter) { w.messageKey = key }
-}
-
-// NewStdlibWriter returns a new StdlibWriter wrapper around the passed
-// logger. It's designed to be passed to log.SetOutput.
-func NewStdlibWriter(logger Logger, options ...StdlibWriterOption) io.Writer {
-	w := StdlibWriter{
-		Logger:       logger,
-		timestampKey: "ts",
-		fileKey:      "file",
-		messageKey:   "msg",
-	}
-	for _, option := range options {
-		option(&w)
-	}
-	return w
-}
-
-func (w StdlibWriter) Write(p []byte) (int, error) {
-	result := subexps(p)
-	keyvals := []interface{}{}
-	var timestamp string
-	if date, ok := result["date"]; ok && date != "" {
-		timestamp = date
-	}
-	if time, ok := result["time"]; ok && time != "" {
-		if timestamp != "" {
-			timestamp += " "
-		}
-		timestamp += time
-	}
-	if timestamp != "" {
-		keyvals = append(keyvals, w.timestampKey, timestamp)
-	}
-	if file, ok := result["file"]; ok && file != "" {
-		keyvals = append(keyvals, w.fileKey, file)
-	}
-	if msg, ok := result["msg"]; ok {
-		keyvals = append(keyvals, w.messageKey, msg)
-	}
-	if err := w.Logger.Log(keyvals...); err != nil {
-		return 0, err
-	}
-	return len(p), nil
-}
-
-const (
-	logRegexpDate = `(?P<date>[0-9]{4}/[0-9]{2}/[0-9]{2})?[ ]?`
-	logRegexpTime = `(?P<time>[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?)?[ ]?`
-	logRegexpFile = `(?P<file>[^:]+:[0-9]+)?`
-	logRegexpMsg  = `(: )?(?P<msg>.*)`
-)
-
-var (
-	logRegexp = regexp.MustCompile(logRegexpDate + logRegexpTime + logRegexpFile + logRegexpMsg)
-)
-
-func subexps(line []byte) map[string]string {
-	m := logRegexp.FindSubmatch(line)
-	if len(m) < len(logRegexp.SubexpNames()) {
-		return map[string]string{}
-	}
-	result := map[string]string{}
-	for i, name := range logRegexp.SubexpNames() {
-		result[name] = string(m[i])
-	}
-	return result
-}
diff --git a/log/stdlib_writer_test.go b/log/stdlib_writer_test.go
deleted file mode 100644
index e972206..0000000
--- a/log/stdlib_writer_test.go
+++ /dev/null
@@ -1,133 +0,0 @@
-package log
-
-import (
-	"bytes"
-	"fmt"
-	"log"
-	"testing"
-	"time"
-)
-
-func TestStdlibWriterUsage(t *testing.T) {
-	buf := &bytes.Buffer{}
-	logger := NewPrefixLogger(buf)
-	writer := NewStdlibWriter(logger)
-	log.SetOutput(writer)
-
-	now := time.Now()
-	date := now.Format("2006/01/02")
-	time := now.Format("15:04:05")
-
-	for flag, want := range map[int]string{
-		0:                                      "msg=hello\n",
-		log.Ldate:                              "ts=" + date + " msg=hello\n",
-		log.Ltime:                              "ts=" + time + " msg=hello\n",
-		log.Ldate | log.Ltime:                  "ts=" + date + " " + time + " msg=hello\n",
-		log.Lshortfile:                         "file=stdlib_writer_test.go:32 msg=hello\n",
-		log.Lshortfile | log.Ldate:             "ts=" + date + " file=stdlib_writer_test.go:32 msg=hello\n",
-		log.Lshortfile | log.Ldate | log.Ltime: "ts=" + date + " " + time + " file=stdlib_writer_test.go:32 msg=hello\n",
-	} {
-		buf.Reset()
-		log.SetFlags(flag)
-		log.Print("hello")
-		if have := buf.String(); want != have {
-			t.Errorf("flag=%d: want %#v, have %#v", flag, want, have)
-		}
-	}
-}
-
-func TestStdLibWriterExtraction(t *testing.T) {
-	buf := &bytes.Buffer{}
-	logger := NewPrefixLogger(buf)
-	writer := NewStdlibWriter(logger)
-	for input, want := range map[string]string{
-		"hello":                                            "msg=hello\n",
-		"2009/01/23: hello":                                "ts=2009/01/23 msg=hello\n",
-		"2009/01/23 01:23:23: hello":                       "ts=2009/01/23 01:23:23 msg=hello\n",
-		"01:23:23: hello":                                  "ts=01:23:23 msg=hello\n",
-		"2009/01/23 01:23:23.123123: hello":                "ts=2009/01/23 01:23:23.123123 msg=hello\n",
-		"2009/01/23 01:23:23.123123 /a/b/c/d.go:23: hello": "ts=2009/01/23 01:23:23.123123 file=/a/b/c/d.go:23 msg=hello\n",
-		"01:23:23.123123 /a/b/c/d.go:23: hello":            "ts=01:23:23.123123 file=/a/b/c/d.go:23 msg=hello\n",
-		"2009/01/23 01:23:23 /a/b/c/d.go:23: hello":        "ts=2009/01/23 01:23:23 file=/a/b/c/d.go:23 msg=hello\n",
-		"2009/01/23 /a/b/c/d.go:23: hello":                 "ts=2009/01/23 file=/a/b/c/d.go:23 msg=hello\n",
-		"/a/b/c/d.go:23: hello":                            "file=/a/b/c/d.go:23 msg=hello\n",
-	} {
-		buf.Reset()
-		fmt.Fprintf(writer, input)
-		if have := buf.String(); want != have {
-			t.Errorf("%q: want %#v, have %#v", input, want, have)
-		}
-	}
-}
-
-func TestStdlibWriterSubexps(t *testing.T) {
-	for input, wantMap := range map[string]map[string]string{
-		"hello world": map[string]string{
-			"date": "",
-			"time": "",
-			"file": "",
-			"msg":  "hello world",
-		},
-		"2009/01/23: hello world": map[string]string{
-			"date": "2009/01/23",
-			"time": "",
-			"file": "",
-			"msg":  "hello world",
-		},
-		"2009/01/23 01:23:23: hello world": map[string]string{
-			"date": "2009/01/23",
-			"time": "01:23:23",
-			"file": "",
-			"msg":  "hello world",
-		},
-		"01:23:23: hello world": map[string]string{
-			"date": "",
-			"time": "01:23:23",
-			"file": "",
-			"msg":  "hello world",
-		},
-		"2009/01/23 01:23:23.123123: hello world": map[string]string{
-			"date": "2009/01/23",
-			"time": "01:23:23.123123",
-			"file": "",
-			"msg":  "hello world",
-		},
-		"2009/01/23 01:23:23.123123 /a/b/c/d.go:23: hello world": map[string]string{
-			"date": "2009/01/23",
-			"time": "01:23:23.123123",
-			"file": "/a/b/c/d.go:23",
-			"msg":  "hello world",
-		},
-		"01:23:23.123123 /a/b/c/d.go:23: hello world": map[string]string{
-			"date": "",
-			"time": "01:23:23.123123",
-			"file": "/a/b/c/d.go:23",
-			"msg":  "hello world",
-		},
-		"2009/01/23 01:23:23 /a/b/c/d.go:23: hello world": map[string]string{
-			"date": "2009/01/23",
-			"time": "01:23:23",
-			"file": "/a/b/c/d.go:23",
-			"msg":  "hello world",
-		},
-		"2009/01/23 /a/b/c/d.go:23: hello world": map[string]string{
-			"date": "2009/01/23",
-			"time": "",
-			"file": "/a/b/c/d.go:23",
-			"msg":  "hello world",
-		},
-		"/a/b/c/d.go:23: hello world": map[string]string{
-			"date": "",
-			"time": "",
-			"file": "/a/b/c/d.go:23",
-			"msg":  "hello world",
-		},
-	} {
-		haveMap := subexps([]byte(input))
-		for key, want := range wantMap {
-			if have := haveMap[key]; want != have {
-				t.Errorf("%q: %q: want %q, have %q", input, key, want, have)
-			}
-		}
-	}
-}
