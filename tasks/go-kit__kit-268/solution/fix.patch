diff --git a/metrics/dogstatsd/emitter.go b/metrics/dogstatsd/emitter.go
new file mode 100644
index 0000000..9d8cdf3
--- /dev/null
+++ b/metrics/dogstatsd/emitter.go
@@ -0,0 +1,159 @@
+package dogstatsd
+
+import (
+	"bytes"
+	"fmt"
+	"net"
+	"time"
+
+	"github.com/go-kit/kit/log"
+	"github.com/go-kit/kit/metrics"
+	"github.com/go-kit/kit/util/conn"
+)
+
+// Emitter is a struct to manage connections and orchestrate the emission of
+// metrics to a DogStatsd process.
+type Emitter struct {
+	prefix  string
+	keyVals chan keyVal
+	mgr     *conn.Manager
+	logger  log.Logger
+	quitc   chan chan struct{}
+}
+
+type keyVal struct {
+	key string
+	val string
+}
+
+func stringToKeyVal(key string, keyVals chan keyVal) chan string {
+	vals := make(chan string)
+	go func() {
+		for val := range vals {
+			keyVals <- keyVal{key: key, val: val}
+		}
+	}()
+	return vals
+}
+
+// NewEmitter will return an Emitter that will prefix all metrics names with the
+// given prefix. Once started, it will attempt to create a connection with the
+// given network and address via `net.Dial` and periodically post metrics to the
+// connection in the DogStatsD protocol.
+func NewEmitter(network, address string, metricsPrefix string, flushInterval time.Duration, logger log.Logger) *Emitter {
+	return NewEmitterDial(net.Dial, network, address, metricsPrefix, flushInterval, logger)
+}
+
+// NewEmitterDial is the same as NewEmitter, but allows you to specify your own
+// Dialer function. This is primarily useful for tests.
+func NewEmitterDial(dialer conn.Dialer, network, address string, metricsPrefix string, flushInterval time.Duration, logger log.Logger) *Emitter {
+	e := &Emitter{
+		prefix:  metricsPrefix,
+		mgr:     conn.NewManager(dialer, network, address, time.After, logger),
+		logger:  logger,
+		keyVals: make(chan keyVal),
+		quitc:   make(chan chan struct{}),
+	}
+	go e.loop(flushInterval)
+	return e
+}
+
+// NewCounter returns a Counter that emits observations in the DogStatsD protocol
+// via the Emitter's connection manager. Observations are buffered for the
+// report interval or until the buffer exceeds a max packet size, whichever
+// comes first. Fields are ignored.
+func (e *Emitter) NewCounter(key string) metrics.Counter {
+	key = e.prefix + key
+	return &counter{
+		key: key,
+		c:   stringToKeyVal(key, e.keyVals),
+	}
+}
+
+// NewHistogram returns a Histogram that emits observations in the DogStatsD
+// protocol via the Emitter's conection manager. Observations are buffered for
+// the reporting interval or until the buffer exceeds a max packet size,
+// whichever comes first. Fields are ignored.
+//
+// NewHistogram is mapped to a statsd Timing, so observations should represent
+// milliseconds. If you observe in units of nanoseconds, you can make the
+// translation with a ScaledHistogram:
+//
+//    NewScaledHistogram(histogram, time.Millisecond)
+//
+// You can also enforce the constraint in a typesafe way with a millisecond
+// TimeHistogram:
+//
+//    NewTimeHistogram(histogram, time.Millisecond)
+//
+// TODO: support for sampling.
+func (e *Emitter) NewHistogram(key string) metrics.Histogram {
+	key = e.prefix + key
+	return &histogram{
+		key: key,
+		h:   stringToKeyVal(key, e.keyVals),
+	}
+}
+
+// NewGauge returns a Gauge that emits values in the DogStatsD protocol via the
+// the Emitter's connection manager. Values are buffered for the report
+// interval or until the buffer exceeds a max packet size, whichever comes
+// first. Fields are ignored.
+//
+// TODO: support for sampling
+func (e *Emitter) NewGauge(key string) metrics.Gauge {
+	key = e.prefix + key
+	return &gauge{
+		key: key,
+		g:   stringToKeyVal(key, e.keyVals),
+	}
+}
+
+func (e *Emitter) loop(d time.Duration) {
+	ticker := time.NewTicker(d)
+	defer ticker.Stop()
+	buf := &bytes.Buffer{}
+	for {
+		select {
+		case kv := <-e.keyVals:
+			fmt.Fprintf(buf, "%s:%s\n", kv.key, kv.val)
+			if buf.Len() > maxBufferSize {
+				e.Flush(buf)
+			}
+
+		case <-ticker.C:
+			e.Flush(buf)
+
+		case q := <-e.quitc:
+			e.Flush(buf)
+			close(q)
+			return
+		}
+	}
+}
+
+// Stop will flush the current metrics and close the active connection. Calling
+// stop more than once is a programmer error.
+func (e *Emitter) Stop() {
+	q := make(chan struct{})
+	e.quitc <- q
+	<-q
+}
+
+// Flush will write the given buffer to a connection provided by the Emitter's
+// connection manager.
+func (e *Emitter) Flush(buf *bytes.Buffer) {
+	conn := e.mgr.Take()
+	if conn == nil {
+		e.logger.Log("during", "flush", "err", "connection unavailable")
+		return
+	}
+
+	_, err := conn.Write(buf.Bytes())
+	if err != nil {
+		e.logger.Log("during", "flush", "err", err)
+	}
+	buf.Reset()
+
+	e.mgr.Put(err)
+}
diff --git a/metrics/graphite/emitter.go b/metrics/graphite/emitter.go
new file mode 100644
index 0000000..87e633c
--- /dev/null
+++ b/metrics/graphite/emitter.go
@@ -0,0 +1,159 @@
+package graphite
+
+import (
+	"bufio"
+	"fmt"
+	"io"
+	"net"
+	"sync"
+	"time"
+
+	"github.com/go-kit/kit/log"
+	"github.com/go-kit/kit/metrics"
+	"github.com/go-kit/kit/util/conn"
+)
+
+// Emitter is a struct to manage connections and orchestrate the emission of
+// metrics to a Graphite system.
+type Emitter struct {
+	mtx        sync.Mutex
+	prefix     string
+	mgr        *conn.Manager
+	counters   []*counter
+	histograms []*windowedHistogram
+	gauges     []*gauge
+	logger     log.Logger
+	quitc      chan chan struct{}
+}
+
+// NewEmitter will return an Emitter that will prefix all metrics names with the
+// given prefix. Once started, it will attempt to create a connection with the
+// given network and address via `net.Dial` and periodically post metrics to the
+// connection in the Graphite plaintext protocol.
+func NewEmitter(network, address string, metricsPrefix string, flushInterval time.Duration, logger log.Logger) *Emitter {
+	return NewEmitterDial(net.Dial, network, address, metricsPrefix, flushInterval, logger)
+}
+
+// NewEmitterDial is the same as NewEmitter, but allows you to specify your own
+// Dialer function. This is primarily useful for tests.
+func NewEmitterDial(dialer conn.Dialer, network, address string, metricsPrefix string, flushInterval time.Duration, logger log.Logger) *Emitter {
+	e := &Emitter{
+		prefix: metricsPrefix,
+		mgr:    conn.NewManager(dialer, network, address, time.After, logger),
+		logger: logger,
+		quitc:  make(chan chan struct{}),
+	}
+	go e.loop(flushInterval)
+	return e
+}
+
+// NewCounter returns a Counter whose value will be periodically emitted in
+// a Graphite-compatible format once the Emitter is started. Fields are ignored.
+func (e *Emitter) NewCounter(name string) metrics.Counter {
+	e.mtx.Lock()
+	defer e.mtx.Unlock()
+	c := newCounter(name)
+	e.counters = append(e.counters, c)
+	return c
+}
+
+// NewHistogram is taken from http://github.com/codahale/metrics. It returns a
+// windowed HDR histogram which drops data older than five minutes.
+//
+// The histogram exposes metrics for each passed quantile as gauges. Quantiles
+// should be integers in the range 1..99. The gauge names are assigned by using
+// the passed name as a prefix and appending "_pNN" e.g. "_p50".
+//
+// The values of this histogram will be periodically emitted in a
+// Graphite-compatible format once the Emitter is started. Fields are ignored.
+func (e *Emitter) NewHistogram(name string, minValue, maxValue int64, sigfigs int, quantiles ...int) (metrics.Histogram, error) {
+	gauges := map[int]metrics.Gauge{}
+	for _, quantile := range quantiles {
+		if quantile <= 0 || quantile >= 100 {
+			return nil, fmt.Errorf("invalid quantile %d", quantile)
+		}
+		gauges[quantile] = e.gauge(fmt.Sprintf("%s_p%02d", name, quantile))
+	}
+	h := newWindowedHistogram(name, minValue, maxValue, sigfigs, gauges, e.logger)
+
+	e.mtx.Lock()
+	defer e.mtx.Unlock()
+	e.histograms = append(e.histograms, h)
+	return h, nil
+}
+
+// NewGauge returns a Gauge whose value will be periodically emitted in a
+// Graphite-compatible format once the Emitter is started. Fields are ignored.
+func (e *Emitter) NewGauge(name string) metrics.Gauge {
+	e.mtx.Lock()
+	defer e.mtx.Unlock()
+	return e.gauge(name)
+}
+
+func (e *Emitter) gauge(name string) metrics.Gauge {
+	g := &gauge{name, 0}
+	e.gauges = append(e.gauges, g)
+	return g
+}
+
+func (e *Emitter) loop(d time.Duration) {
+	ticker := time.NewTicker(d)
+	defer ticker.Stop()
+
+	for {
+		select {
+		case <-ticker.C:
+			e.Flush()
+
+		case q := <-e.quitc:
+			e.Flush()
+			close(q)
+			return
+		}
+	}
+}
+
+// Stop will flush the current metrics and close the active connection. Calling
+// stop more than once is a programmer error.
+func (e *Emitter) Stop() {
+	q := make(chan struct{})
+	e.quitc <- q
+	<-q
+}
+
+// Flush will write the current metrics to the Emitter's connection in the
+// Graphite plaintext protocol.
+func (e *Emitter) Flush() {
+	e.mtx.Lock() // one flush at a time
+	defer e.mtx.Unlock()
+
+	conn := e.mgr.Take()
+	if conn == nil {
+		e.logger.Log("during", "flush", "err", "connection unavailable")
+		return
+	}
+
+	err := e.flush(conn)
+	if err != nil {
+		e.logger.Log("during", "flush", "err", err)
+	}
+	e.mgr.Put(err)
+}
+
+func (e *Emitter) flush(w io.Writer) error {
+	bw := bufio.NewWriter(w)
+
+	for _, c := range e.counters {
+		c.flush(bw, e.prefix)
+	}
+
+	for _, h := range e.histograms {
+		h.flush(bw, e.prefix)
+	}
+
+	for _, g := range e.gauges {
+		g.flush(bw, e.prefix)
+	}
+
+	return bw.Flush()
+}
diff --git a/metrics/graphite/graphite.go b/metrics/graphite/graphite.go
new file mode 100644
index 0000000..6736cc2
--- /dev/null
+++ b/metrics/graphite/graphite.go
@@ -0,0 +1,186 @@
+// Package graphite implements a Graphite backend for package metrics. Metrics
+// will be emitted to a Graphite server in the plaintext protocol which looks
+// like:
+//
+//   "<metric path> <metric value> <metric timestamp>"
+//
+// See http://graphite.readthedocs.io/en/latest/feeding-carbon.html#the-plaintext-protocol.
+// The current implementation ignores fields.
+package graphite
+
+import (
+	"fmt"
+	"io"
+	"math"
+	"sort"
+	"sync"
+	"sync/atomic"
+	"time"
+
+	"github.com/codahale/hdrhistogram"
+
+	"github.com/go-kit/kit/log"
+	"github.com/go-kit/kit/metrics"
+)
+
+func newCounter(name string) *counter {
+	return &counter{name, 0}
+}
+
+func newGauge(name string) *gauge {
+	return &gauge{name, 0}
+}
+
+// counter implements the metrics.counter interface but also provides a
+// Flush method to emit the current counter values in the Graphite plaintext
+// protocol.
+type counter struct {
+	key   string
+	count uint64
+}
+
+func (c *counter) Name() string { return c.key }
+
+// With currently ignores fields.
+func (c *counter) With(metrics.Field) metrics.Counter { return c }
+
+func (c *counter) Add(delta uint64) { atomic.AddUint64(&c.count, delta) }
+
+func (c *counter) get() uint64 { return atomic.LoadUint64(&c.count) }
+
+// flush will emit the current counter value in the Graphite plaintext
+// protocol to the given io.Writer.
+func (c *counter) flush(w io.Writer, prefix string) {
+	fmt.Fprintf(w, "%s.count %d %d\n", prefix+c.Name(), c.get(), time.Now().Unix())
+}
+
+// gauge implements the metrics.gauge interface but also provides a
+// Flush method to emit the current counter values in the Graphite plaintext
+// protocol.
+type gauge struct {
+	key   string
+	value uint64 // math.Float64bits
+}
+
+func (g *gauge) Name() string { return g.key }
+
+// With currently ignores fields.
+func (g *gauge) With(metrics.Field) metrics.Gauge { return g }
+
+func (g *gauge) Add(delta float64) {
+	for {
+		old := atomic.LoadUint64(&g.value)
+		new := math.Float64bits(math.Float64frombits(old) + delta)
+		if atomic.CompareAndSwapUint64(&g.value, old, new) {
+			return
+		}
+	}
+}
+
+func (g *gauge) Set(value float64) {
+	atomic.StoreUint64(&g.value, math.Float64bits(value))
+}
+
+func (g *gauge) Get() float64 {
+	return math.Float64frombits(atomic.LoadUint64(&g.value))
+}
+
+// Flush will emit the current gauge value in the Graphite plaintext
+// protocol to the given io.Writer.
+func (g *gauge) flush(w io.Writer, prefix string) {
+	fmt.Fprintf(w, "%s %.2f %d\n", prefix+g.Name(), g.Get(), time.Now().Unix())
+}
+
+// windowedHistogram is taken from http://github.com/codahale/metrics. It
+// is a windowed HDR histogram which drops data older than five minutes.
+//
+// The histogram exposes metrics for each passed quantile as gauges. Quantiles
+// should be integers in the range 1..99. The gauge names are assigned by using
+// the passed name as a prefix and appending "_pNN" e.g. "_p50".
+//
+// The values of this histogram will be periodically emitted in a
+// Graphite-compatible format once the GraphiteProvider is started. Fields are ignored.
+type windowedHistogram struct {
+	mtx  sync.Mutex
+	hist *hdrhistogram.WindowedHistogram
+
+	name   string
+	gauges map[int]metrics.Gauge
+	logger log.Logger
+}
+
+func newWindowedHistogram(name string, minValue, maxValue int64, sigfigs int, quantiles map[int]metrics.Gauge, logger log.Logger) *windowedHistogram {
+	h := &windowedHistogram{
+		hist:   hdrhistogram.NewWindowed(5, minValue, maxValue, sigfigs),
+		name:   name,
+		gauges: quantiles,
+		logger: logger,
+	}
+	go h.rotateLoop(1 * time.Minute)
+	return h
+}
+
+func (h *windowedHistogram) Name() string { return h.name }
+
+func (h *windowedHistogram) With(metrics.Field) metrics.Histogram { return h }
+
+func (h *windowedHistogram) Observe(value int64) {
+	h.mtx.Lock()
+	err := h.hist.Current.RecordValue(value)
+	h.mtx.Unlock()
+
+	if err != nil {
+		h.logger.Log("err", err, "msg", "unable to record histogram value")
+		return
+	}
+
+	for q, gauge := range h.gauges {
+		gauge.Set(float64(h.hist.Current.ValueAtQuantile(float64(q))))
+	}
+}
+
+func (h *windowedHistogram) Distribution() ([]metrics.Bucket, []metrics.Quantile) {
+	bars := h.hist.Merge().Distribution()
+	buckets := make([]metrics.Bucket, len(bars))
+	for i, bar := range bars {
+		buckets[i] = metrics.Bucket{
+			From:  bar.From,
+			To:    bar.To,
+			Count: bar.Count,
+		}
+	}
+	quantiles := make([]metrics.Quantile, 0, len(h.gauges))
+	for quantile, gauge := range h.gauges {
+		quantiles = append(quantiles, metrics.Quantile{
+			Quantile: quantile,
+			Value:    int64(gauge.Get()),
+		})
+	}
+	sort.Sort(quantileSlice(quantiles))
+	return buckets, quantiles
+}
+
+func (h *windowedHistogram) flush(w io.Writer, prefix string) {
+	name := prefix + h.Name()
+	hist := h.hist.Merge()
+	now := time.Now().Unix()
+	fmt.Fprintf(w, "%s.count %d %d\n", name, hist.TotalCount(), now)
+	fmt.Fprintf(w, "%s.min %d %d\n", name, hist.Min(), now)
+	fmt.Fprintf(w, "%s.max %d %d\n", name, hist.Max(), now)
+	fmt.Fprintf(w, "%s.mean %.2f %d\n", name, hist.Mean(), now)
+	fmt.Fprintf(w, "%s.std-dev %.2f %d\n", name, hist.StdDev(), now)
+}
+
+func (h *windowedHistogram) rotateLoop(d time.Duration) {
+	for range time.Tick(d) {
+		h.mtx.Lock()
+		h.hist.Rotate()
+		h.mtx.Unlock()
+	}
+}
+
+type quantileSlice []metrics.Quantile
+
+func (a quantileSlice) Len() int           { return len(a) }
+func (a quantileSlice) Less(i, j int) bool { return a[i].Quantile < a[j].Quantile }
+func (a quantileSlice) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
diff --git a/metrics/provider/providers.go b/metrics/provider/providers.go
new file mode 100644
index 0000000..34cdf33
--- /dev/null
+++ b/metrics/provider/providers.go
@@ -0,0 +1,259 @@
+package provider
+
+import (
+	"errors"
+	"time"
+
+	"github.com/prometheus/client_golang/prometheus"
+
+	"github.com/go-kit/kit/log"
+	"github.com/go-kit/kit/metrics"
+	"github.com/go-kit/kit/metrics/discard"
+	"github.com/go-kit/kit/metrics/dogstatsd"
+	kitexp "github.com/go-kit/kit/metrics/expvar"
+	"github.com/go-kit/kit/metrics/graphite"
+	kitprom "github.com/go-kit/kit/metrics/prometheus"
+	"github.com/go-kit/kit/metrics/statsd"
+)
+
+// Provider represents a union set of constructors and lifecycle management
+// functions for each supported metrics backend. It should be used by those who
+// need to easily swap out implementations, e.g. dynamically, or at a single
+// point in an intermediating framework.
+type Provider interface {
+	NewCounter(name, help string) metrics.Counter
+	NewHistogram(name, help string, min, max int64, sigfigs int, quantiles ...int) (metrics.Histogram, error)
+	NewGauge(name, help string) metrics.Gauge
+	Stop()
+}
+
+// NewGraphiteProvider will return a Provider implementation that is a simple
+// wrapper around a graphite.Emitter. All metric names will be prefixed with the
+// given value and data will be emitted once every interval. If no network value
+// is given, it will default to "udp".
+func NewGraphiteProvider(network, address, prefix string, interval time.Duration, logger log.Logger) (Provider, error) {
+	if network == "" {
+		network = "udp"
+	}
+	if address == "" {
+		return nil, errors.New("address is required")
+	}
+	return graphiteProvider{
+		e: graphite.NewEmitter(network, address, prefix, interval, logger),
+	}, nil
+}
+
+type graphiteProvider struct {
+	e *graphite.Emitter
+}
+
+var _ Provider = graphiteProvider{}
+
+// NewCounter implements Provider. Help is ignored.
+func (p graphiteProvider) NewCounter(name, _ string) metrics.Counter {
+	return p.e.NewCounter(name)
+}
+
+// NewHistogram implements Provider. Help is ignored.
+func (p graphiteProvider) NewHistogram(name, _ string, min, max int64, sigfigs int, quantiles ...int) (metrics.Histogram, error) {
+	return p.e.NewHistogram(name, min, max, sigfigs, quantiles...)
+}
+
+// NewGauge implements Provider. Help is ignored.
+func (p graphiteProvider) NewGauge(name, _ string) metrics.Gauge {
+	return p.e.NewGauge(name)
+}
+
+// Stop implements Provider.
+func (p graphiteProvider) Stop() {
+	p.e.Stop()
+}
+
+// NewStatsdProvider will return a Provider implementation that is a simple
+// wrapper around a statsd.Emitter. All metric names will be prefixed with the
+// given value and data will be emitted once every interval or when the buffer
+// has reached its max size. If no network value is given, it will default to
+// "udp".
+func NewStatsdProvider(network, address, prefix string, interval time.Duration, logger log.Logger) (Provider, error) {
+	if network == "" {
+		network = "udp"
+	}
+	if address == "" {
+		return nil, errors.New("address is required")
+	}
+	return statsdProvider{
+		e: statsd.NewEmitter(network, address, prefix, interval, logger),
+	}, nil
+}
+
+type statsdProvider struct {
+	e *statsd.Emitter
+}
+
+var _ Provider = statsdProvider{}
+
+// NewCounter implements Provider. Help is ignored.
+func (p statsdProvider) NewCounter(name, _ string) metrics.Counter {
+	return p.e.NewCounter(name)
+}
+
+// NewHistogram implements Provider. Help is ignored.
+func (p statsdProvider) NewHistogram(name, _ string, min, max int64, sigfigs int, quantiles ...int) (metrics.Histogram, error) {
+	return p.e.NewHistogram(name), nil
+}
+
+// NewGauge implements Provider. Help is ignored.
+func (p statsdProvider) NewGauge(name, _ string) metrics.Gauge {
+	return p.e.NewGauge(name)
+}
+
+// Stop will call the underlying statsd.Emitter's Stop method.
+func (p statsdProvider) Stop() {
+	p.e.Stop()
+}
+
+// NewDogStatsdProvider will return a Provider implementation that is a simple
+// wrapper around a dogstatsd.Emitter. All metric names will be prefixed with
+// the given value and data will be emitted once every interval or when the
+// buffer has reached its max size. If no network value is given, it will
+// default to "udp".
+func NewDogStatsdProvider(network, address, prefix string, interval time.Duration, logger log.Logger) (Provider, error) {
+	if network == "" {
+		network = "udp"
+	}
+	if address == "" {
+		return nil, errors.New("address is required")
+	}
+	return dogstatsdProvider{
+		e: dogstatsd.NewEmitter(network, address, prefix, interval, logger),
+	}, nil
+}
+
+type dogstatsdProvider struct {
+	e *dogstatsd.Emitter
+}
+
+var _ Provider = dogstatsdProvider{}
+
+// NewCounter implements Provider. Help is ignored.
+func (p dogstatsdProvider) NewCounter(name, _ string) metrics.Counter {
+	return p.e.NewCounter(name)
+}
+
+// NewHistogram implements Provider. Help is ignored.
+func (p dogstatsdProvider) NewHistogram(name, _ string, min, max int64, sigfigs int, quantiles ...int) (metrics.Histogram, error) {
+	return p.e.NewHistogram(name), nil
+}
+
+// NewGauge implements Provider. Help is ignored.
+func (p dogstatsdProvider) NewGauge(name, _ string) metrics.Gauge {
+	return p.e.NewGauge(name)
+}
+
+// Stop will call the underlying statsd.Emitter's Stop method.
+func (p dogstatsdProvider) Stop() {
+	p.e.Stop()
+}
+
+// NewExpvarProvider is a very thin wrapper over the expvar package.
+// If a prefix is provided, it will prefix all metric names.
+func NewExpvarProvider(prefix string) Provider {
+	return expvarProvider{prefix: prefix}
+}
+
+type expvarProvider struct {
+	prefix string
+}
+
+var _ Provider = expvarProvider{}
+
+// NewCounter implements Provider. Help is ignored.
+func (p expvarProvider) NewCounter(name, _ string) metrics.Counter {
+	return kitexp.NewCounter(p.prefix + name)
+}
+
+// NewHistogram implements Provider. Help is ignored.
+func (p expvarProvider) NewHistogram(name, _ string, min, max int64, sigfigs int, quantiles ...int) (metrics.Histogram, error) {
+	return kitexp.NewHistogram(p.prefix+name, min, max, sigfigs, quantiles...), nil
+}
+
+// NewGauge implements Provider. Help is ignored.
+func (p expvarProvider) NewGauge(name, _ string) metrics.Gauge {
+	return kitexp.NewGauge(p.prefix + name)
+}
+
+// Stop is a no-op.
+func (expvarProvider) Stop() {}
+
+type prometheusProvider struct {
+	namespace string
+	subsystem string
+}
+
+var _ Provider = prometheusProvider{}
+
+// NewPrometheusProvider returns a Prometheus provider that uses the provided
+// namespace and subsystem for all metrics.
+func NewPrometheusProvider(namespace, subsystem string) Provider {
+	return prometheusProvider{
+		namespace: namespace,
+		subsystem: subsystem,
+	}
+}
+
+// NewCounter implements Provider.
+func (p prometheusProvider) NewCounter(name, help string) metrics.Counter {
+	return kitprom.NewCounter(prometheus.CounterOpts{
+		Namespace: p.namespace,
+		Subsystem: p.subsystem,
+		Name:      name,
+		Help:      help,
+	}, nil)
+}
+
+// NewHistogram ignores all parameters except name and help.
+func (p prometheusProvider) NewHistogram(name, help string, _, _ int64, _ int, _ ...int) (metrics.Histogram, error) {
+	return kitprom.NewHistogram(prometheus.HistogramOpts{
+		Namespace: p.namespace,
+		Subsystem: p.subsystem,
+		Name:      name,
+		Help:      help,
+	}, nil), nil
+}
+
+// NewGauge implements Provider.
+func (p prometheusProvider) NewGauge(name, help string) metrics.Gauge {
+	return kitprom.NewGauge(prometheus.GaugeOpts{
+		Namespace: p.namespace,
+		Subsystem: p.subsystem,
+		Name:      name,
+		Help:      help,
+	}, nil)
+}
+
+// Stop is a no-op.
+func (prometheusProvider) Stop() {}
+
+var _ Provider = discardProvider{}
+
+// NewDiscardProvider returns a provider that will discard all metrics.
+func NewDiscardProvider() Provider {
+	return discardProvider{}
+}
+
+type discardProvider struct{}
+
+func (p discardProvider) NewCounter(name string, _ string) metrics.Counter {
+	return discard.NewCounter(name)
+}
+
+func (p discardProvider) NewHistogram(name string, _ string, _ int64, _ int64, _ int, _ ...int) (metrics.Histogram, error) {
+	return discard.NewHistogram(name), nil
+}
+
+func (p discardProvider) NewGauge(name string, _ string) metrics.Gauge {
+	return discard.NewGauge(name)
+}
+
+// Stop is a no-op.
+func (p discardProvider) Stop() {}
diff --git a/metrics/statsd/emitter.go b/metrics/statsd/emitter.go
new file mode 100644
index 0000000..f47aada
--- /dev/null
+++ b/metrics/statsd/emitter.go
@@ -0,0 +1,159 @@
+package statsd
+
+import (
+	"bytes"
+	"fmt"
+	"net"
+	"time"
+
+	"github.com/go-kit/kit/log"
+	"github.com/go-kit/kit/metrics"
+	"github.com/go-kit/kit/util/conn"
+)
+
+// Emitter is a struct to manage connections and orchestrate the emission of
+// metrics to a Statsd process.
+type Emitter struct {
+	prefix  string
+	keyVals chan keyVal
+	mgr     *conn.Manager
+	logger  log.Logger
+	quitc   chan chan struct{}
+}
+
+type keyVal struct {
+	key string
+	val string
+}
+
+func stringToKeyVal(key string, keyVals chan keyVal) chan string {
+	vals := make(chan string)
+	go func() {
+		for val := range vals {
+			keyVals <- keyVal{key: key, val: val}
+		}
+	}()
+	return vals
+}
+
+// NewEmitter will return an Emitter that will prefix all metrics names with the
+// given prefix. Once started, it will attempt to create a connection with the
+// given network and address via `net.Dial` and periodically post metrics to the
+// connection in the statsd protocol.
+func NewEmitter(network, address string, metricsPrefix string, flushInterval time.Duration, logger log.Logger) *Emitter {
+	return NewEmitterDial(net.Dial, network, address, metricsPrefix, flushInterval, logger)
+}
+
+// NewEmitterDial is the same as NewEmitter, but allows you to specify your own
+// Dialer function. This is primarily useful for tests.
+func NewEmitterDial(dialer conn.Dialer, network, address string, metricsPrefix string, flushInterval time.Duration, logger log.Logger) *Emitter {
+	e := &Emitter{
+		prefix:  metricsPrefix,
+		mgr:     conn.NewManager(dialer, network, address, time.After, logger),
+		logger:  logger,
+		keyVals: make(chan keyVal),
+		quitc:   make(chan chan struct{}),
+	}
+	go e.loop(flushInterval)
+	return e
+}
+
+// NewCounter returns a Counter that emits observations in the statsd protocol
+// via the Emitter's connection manager. Observations are buffered for the
+// report interval or until the buffer exceeds a max packet size, whichever
+// comes first. Fields are ignored.
+func (e *Emitter) NewCounter(key string) metrics.Counter {
+	key = e.prefix + key
+	return &counter{
+		key: key,
+		c:   stringToKeyVal(key, e.keyVals),
+	}
+}
+
+// NewHistogram returns a Histogram that emits observations in the statsd
+// protocol via the Emitter's conection manager. Observations are buffered for
+// the reporting interval or until the buffer exceeds a max packet size,
+// whichever comes first. Fields are ignored.
+//
+// NewHistogram is mapped to a statsd Timing, so observations should represent
+// milliseconds. If you observe in units of nanoseconds, you can make the
+// translation with a ScaledHistogram:
+//
+//    NewScaledHistogram(histogram, time.Millisecond)
+//
+// You can also enforce the constraint in a typesafe way with a millisecond
+// TimeHistogram:
+//
+//    NewTimeHistogram(histogram, time.Millisecond)
+//
+// TODO: support for sampling.
+func (e *Emitter) NewHistogram(key string) metrics.Histogram {
+	key = e.prefix + key
+	return &histogram{
+		key: key,
+		h:   stringToKeyVal(key, e.keyVals),
+	}
+}
+
+// NewGauge returns a Gauge that emits values in the statsd protocol via the
+// the Emitter's connection manager. Values are buffered for the report
+// interval or until the buffer exceeds a max packet size, whichever comes
+// first. Fields are ignored.
+//
+// TODO: support for sampling
+func (e *Emitter) NewGauge(key string) metrics.Gauge {
+	key = e.prefix + key
+	return &gauge{
+		key: key,
+		g:   stringToKeyVal(key, e.keyVals),
+	}
+}
+
+func (e *Emitter) loop(d time.Duration) {
+	ticker := time.NewTicker(d)
+	defer ticker.Stop()
+	buf := &bytes.Buffer{}
+	for {
+		select {
+		case kv := <-e.keyVals:
+			fmt.Fprintf(buf, "%s:%s\n", kv.key, kv.val)
+			if buf.Len() > maxBufferSize {
+				e.Flush(buf)
+			}
+
+		case <-ticker.C:
+			e.Flush(buf)
+
+		case q := <-e.quitc:
+			e.Flush(buf)
+			close(q)
+			return
+		}
+	}
+}
+
+// Stop will flush the current metrics and close the active connection. Calling
+// stop more than once is a programmer error.
+func (e *Emitter) Stop() {
+	q := make(chan struct{})
+	e.quitc <- q
+	<-q
+}
+
+// Flush will write the given buffer to a connection provided by the Emitter's
+// connection manager.
+func (e *Emitter) Flush(buf *bytes.Buffer) {
+	conn := e.mgr.Take()
+	if conn == nil {
+		e.logger.Log("during", "flush", "err", "connection unavailable")
+		return
+	}
+
+	_, err := conn.Write(buf.Bytes())
+	if err != nil {
+		e.logger.Log("during", "flush", "err", err)
+	}
+	buf.Reset()
+
+	e.mgr.Put(err)
+}
diff --git a/metrics/teststat/graphite.go b/metrics/teststat/graphite.go
new file mode 100644
index 0000000..6b52e71
--- /dev/null
+++ b/metrics/teststat/graphite.go
@@ -0,0 +1,63 @@
+package teststat
+
+import (
+	"fmt"
+	"math"
+	"regexp"
+	"strconv"
+	"testing"
+)
+
+// AssertGraphiteNormalHistogram ensures the expvar Histogram referenced by
+// metricName abides a normal distribution.
+func AssertGraphiteNormalHistogram(t *testing.T, prefix, metricName string, mean, stdev int64, quantiles []int, gPayload string) {
+	// check for hdr histo data
+	wants := map[string]int64{"count": 1234, "min": 15, "max": 83}
+	for key, want := range wants {
+		re := regexp.MustCompile(fmt.Sprintf("%s%s.%s (\\d*)", prefix, metricName, key))
+		res := re.FindAllStringSubmatch(gPayload, 1)
+		if res == nil {
+			t.Error("did not find metrics log for", key, "in \n", gPayload)
+			continue
+		}
+
+		if len(res[0]) == 1 {
+			t.Fatalf("%q: bad regex, please check the test scenario", key)
+		}
+
+		have, err := strconv.ParseInt(res[0][1], 10, 64)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		if want != have {
+			t.Errorf("key %s: want %d, have %d", key, want, have)
+		}
+	}
+
+	const tolerance int = 2
+	wants = map[string]int64{".std-dev": stdev, ".mean": mean}
+	for _, quantile := range quantiles {
+		wants[fmt.Sprintf("_p%02d", quantile)] = normalValueAtQuantile(mean, stdev, quantile)
+	}
+	// check for quantile gauges
+	for key, want := range wants {
+		re := regexp.MustCompile(fmt.Sprintf("%s%s%s (\\d*\\.\\d*)", prefix, metricName, key))
+		res := re.FindAllStringSubmatch(gPayload, 1)
+		if res == nil {
+			t.Errorf("did not find metrics log for %s", key)
+			continue
+		}
+
+		if len(res[0]) == 1 {
+			t.Fatalf("%q: bad regex found, please check the test scenario", key)
+		}
+		have, err := strconv.ParseFloat(res[0][1], 64)
+		if err != nil {
+			t.Fatal(err)
+		}
+		if int(math.Abs(float64(want)-have)) > tolerance {
+			t.Errorf("key %s: want %.2f, have %.2f", key, want, have)
+		}
+	}
+}
diff --git a/util/conn/manager.go b/util/conn/manager.go
new file mode 100644
index 0000000..d260362
--- /dev/null
+++ b/util/conn/manager.go
@@ -0,0 +1,105 @@
+package conn
+
+import (
+	"net"
+	"time"
+
+	"github.com/go-kit/kit/log"
+)
+
+// Dialer dials a network and address. net.Dial is a good default Dialer.
+type Dialer func(network, address string) (net.Conn, error)
+
+// AfterFunc imitates time.After.
+type AfterFunc func(time.Duration) <-chan time.Time
+
+// Manager manages a net.Conn. Clients should take the conn when they want to
+// use it, and put back whatever error they receive from an e.g. Write. When a
+// non-nil error is put, the conn is invalidated and a new conn is established.
+// Connection failures are retried after an exponential backoff.
+type Manager struct {
+	dial    Dialer
+	network string
+	address string
+	after   AfterFunc
+	logger  log.Logger
+
+	takec chan net.Conn
+	putc  chan error
+}
+
+func NewManager(d Dialer, network, address string, after AfterFunc, logger log.Logger) *Manager {
+	m := &Manager{
+		dial:    d,
+		network: network,
+		address: address,
+		after:   after,
+		logger:  logger,
+
+		takec: make(chan net.Conn),
+		putc:  make(chan error),
+	}
+	go m.loop()
+	return m
+}
+
+func (m *Manager) Take() net.Conn {
+	return <-m.takec
+}
+
+func (m *Manager) Put(err error) {
+	m.putc <- err
+}
+
+func (m *Manager) loop() {
+	var (
+		conn       = dial(m.dial, m.network, m.address, m.logger) // may block slightly
+		connc      = make(chan net.Conn)
+		reconnectc <-chan time.Time // initially nil
+		backoff    = time.Second
+	)
+
+	for {
+		select {
+		case <-reconnectc:
+			reconnectc = nil
+			go func() { connc <- dial(m.dial, m.network, m.address, m.logger) }()
+
+		case conn = <-connc:
+			if conn == nil {
+				backoff = exponential(backoff)
+				reconnectc = m.after(backoff)
+			} else {
+				backoff = time.Second
+				reconnectc = nil
+			}
+
+		case m.takec <- conn:
+			// might be nil
+
+		case err := <-m.putc:
+			if err != nil && conn != nil {
+				m.logger.Log("err", err)
+				conn = nil                            // connection is bad
+				reconnectc = m.after(time.Nanosecond) // trigger immediately
+			}
+		}
+	}
+}
+
+func dial(d Dialer, network, address string, logger log.Logger) net.Conn {
+	conn, err := d(network, address)
+	if err != nil {
+		logger.Log("err", err)
+		conn = nil
+	}
+	return conn
+}
+
+func exponential(d time.Duration) time.Duration {
+	d *= 2
+	if d > time.Minute {
+		d = time.Minute
+	}
+	return d
+}
