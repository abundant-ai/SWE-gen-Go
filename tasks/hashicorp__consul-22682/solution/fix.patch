diff --git a/.changelog/22682.txt b/.changelog/22682.txt
new file mode 100644
index 0000000000..152ec0dc07
--- /dev/null
+++ b/.changelog/22682.txt
@@ -0,0 +1,3 @@
+```release-note:security
+agent: Add the KV Validations to block path traversal allowing access to unauthorized endpoints.
+```
diff --git a/agent/kvs_endpoint.go b/agent/kvs_endpoint.go
index 436d67653e..1776627e0b 100644
--- a/agent/kvs_endpoint.go
+++ b/agent/kvs_endpoint.go
@@ -8,6 +8,8 @@ import (
 	"fmt"
 	"io"
 	"net/http"
+	"path"
+	"regexp"
 	"strconv"
 	"strings"
 
@@ -23,7 +25,32 @@ func (s *HTTPHandlers) KVSEndpoint(resp http.ResponseWriter, req *http.Request)
 	}
 
 	// Pull out the key name, validation left to each sub-handler
-	args.Key = strings.TrimPrefix(req.URL.Path, "/v1/kv/")
+	rawKey := strings.TrimPrefix(req.URL.Path, "/v1/kv/")
+
+	// Use path.Clean but preserve trailing slash for directory keys
+	// Special case: if rawKey is empty, don't clean it (path.Clean("") returns ".")
+	var cleanedKey string
+	if rawKey == "" {
+		cleanedKey = ""
+	} else {
+		cleanedKey = path.Clean(rawKey)
+		if strings.HasSuffix(rawKey, "/") && !strings.HasSuffix(cleanedKey, "/") {
+			cleanedKey += "/"
+		}
+	}
+	args.Key = cleanedKey
+
+	// Validate key format unless unprintable character filter is disabled
+	// The DisableHTTPUnprintableCharFilter flag allows access to keys with
+	// unprintable characters for cleanup purposes
+	if !s.agent.config.DisableHTTPUnprintableCharFilter && args.Key != "" {
+		// Allowed key pattern: a-zA-Z0-9 ,-_./
+		// https://developer.hashicorp.com/consul/docs/automate/kv#using-consul-kv
+		kvKeyPattern := `^[a-zA-Z0-9,_./\-?&=]+$`
+		if err := validateKVKey(args.Key, kvKeyPattern); err != nil {
+			return nil, fmt.Errorf("invalid key name, keys should respect the %q format", kvKeyPattern)
+		}
+	}
 
 	// Check for a key list
 	keyList := false
@@ -302,3 +329,21 @@ func conflictingFlags(resp http.ResponseWriter, req *http.Request, flags ...stri
 
 	return false
 }
+
+func validateKVKey(key string, pattern string) error {
+	if len(key) == 0 {
+		return fmt.Errorf("invalid key name, keys should respect the %q format", pattern)
+	}
+
+	matched, err := regexp.MatchString(pattern, key)
+	if err != nil {
+		return fmt.Errorf("failed to validate key: %w", err)
+	}
+	if !matched {
+		return fmt.Errorf("invalid key name, keys should respect the %q format", pattern)
+	}
+	if strings.Contains(key, "..") {
+		return fmt.Errorf("invalid key name, path traversal is not allowed")
+	}
+	return nil
+}
