diff --git a/array.go b/array.go
index 3d4d49f..5be3704 100644
--- a/array.go
+++ b/array.go
@@ -29,113 +29,113 @@ import (
 // Array constructs a field with the given key and ArrayMarshaler. It provides
 // a flexible, but still type-safe and efficient, way to add array-like types
 // to the logging context. The struct's MarshalLogArray method is called lazily.
-func Array(key string, val zapcore.ArrayMarshaler) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.ArrayMarshalerType, Interface: val}
+func Array(key string, val zapcore.ArrayMarshaler) Field {
+	return Field{Key: key, Type: zapcore.ArrayMarshalerType, Interface: val}
 }
 
 // Bools constructs a field that carries a slice of bools.
-func Bools(key string, bs []bool) zapcore.Field {
+func Bools(key string, bs []bool) Field {
 	return Array(key, bools(bs))
 }
 
 // ByteStrings constructs a field that carries a slice of []byte, each of which
 // must be UTF-8 encoded text.
-func ByteStrings(key string, bss [][]byte) zapcore.Field {
+func ByteStrings(key string, bss [][]byte) Field {
 	return Array(key, byteStringsArray(bss))
 }
 
 // Complex128s constructs a field that carries a slice of complex numbers.
-func Complex128s(key string, nums []complex128) zapcore.Field {
+func Complex128s(key string, nums []complex128) Field {
 	return Array(key, complex128s(nums))
 }
 
 // Complex64s constructs a field that carries a slice of complex numbers.
-func Complex64s(key string, nums []complex64) zapcore.Field {
+func Complex64s(key string, nums []complex64) Field {
 	return Array(key, complex64s(nums))
 }
 
 // Durations constructs a field that carries a slice of time.Durations.
-func Durations(key string, ds []time.Duration) zapcore.Field {
+func Durations(key string, ds []time.Duration) Field {
 	return Array(key, durations(ds))
 }
 
 // Float64s constructs a field that carries a slice of floats.
-func Float64s(key string, nums []float64) zapcore.Field {
+func Float64s(key string, nums []float64) Field {
 	return Array(key, float64s(nums))
 }
 
 // Float32s constructs a field that carries a slice of floats.
-func Float32s(key string, nums []float32) zapcore.Field {
+func Float32s(key string, nums []float32) Field {
 	return Array(key, float32s(nums))
 }
 
 // Ints constructs a field that carries a slice of integers.
-func Ints(key string, nums []int) zapcore.Field {
+func Ints(key string, nums []int) Field {
 	return Array(key, ints(nums))
 }
 
 // Int64s constructs a field that carries a slice of integers.
-func Int64s(key string, nums []int64) zapcore.Field {
+func Int64s(key string, nums []int64) Field {
 	return Array(key, int64s(nums))
 }
 
 // Int32s constructs a field that carries a slice of integers.
-func Int32s(key string, nums []int32) zapcore.Field {
+func Int32s(key string, nums []int32) Field {
 	return Array(key, int32s(nums))
 }
 
 // Int16s constructs a field that carries a slice of integers.
-func Int16s(key string, nums []int16) zapcore.Field {
+func Int16s(key string, nums []int16) Field {
 	return Array(key, int16s(nums))
 }
 
 // Int8s constructs a field that carries a slice of integers.
-func Int8s(key string, nums []int8) zapcore.Field {
+func Int8s(key string, nums []int8) Field {
 	return Array(key, int8s(nums))
 }
 
 // Strings constructs a field that carries a slice of strings.
-func Strings(key string, ss []string) zapcore.Field {
+func Strings(key string, ss []string) Field {
 	return Array(key, stringArray(ss))
 }
 
 // Times constructs a field that carries a slice of time.Times.
-func Times(key string, ts []time.Time) zapcore.Field {
+func Times(key string, ts []time.Time) Field {
 	return Array(key, times(ts))
 }
 
 // Uints constructs a field that carries a slice of unsigned integers.
-func Uints(key string, nums []uint) zapcore.Field {
+func Uints(key string, nums []uint) Field {
 	return Array(key, uints(nums))
 }
 
 // Uint64s constructs a field that carries a slice of unsigned integers.
-func Uint64s(key string, nums []uint64) zapcore.Field {
+func Uint64s(key string, nums []uint64) Field {
 	return Array(key, uint64s(nums))
 }
 
 // Uint32s constructs a field that carries a slice of unsigned integers.
-func Uint32s(key string, nums []uint32) zapcore.Field {
+func Uint32s(key string, nums []uint32) Field {
 	return Array(key, uint32s(nums))
 }
 
 // Uint16s constructs a field that carries a slice of unsigned integers.
-func Uint16s(key string, nums []uint16) zapcore.Field {
+func Uint16s(key string, nums []uint16) Field {
 	return Array(key, uint16s(nums))
 }
 
 // Uint8s constructs a field that carries a slice of unsigned integers.
-func Uint8s(key string, nums []uint8) zapcore.Field {
+func Uint8s(key string, nums []uint8) Field {
 	return Array(key, uint8s(nums))
 }
 
 // Uintptrs constructs a field that carries a slice of pointer addresses.
-func Uintptrs(key string, us []uintptr) zapcore.Field {
+func Uintptrs(key string, us []uintptr) Field {
 	return Array(key, uintptrs(us))
 }
 
 // Errors constructs a field that carries a slice of errors.
-func Errors(key string, errs []error) zapcore.Field {
+func Errors(key string, errs []error) Field {
 	return Array(key, errArray(errs))
 }
 
diff --git a/config.go b/config.go
index b0658ed..dae1303 100644
--- a/config.go
+++ b/config.go
@@ -210,7 +210,7 @@ func (cfg Config) buildOptions(errSink zapcore.WriteSyncer) []Option {
 	}
 
 	if len(cfg.InitialFields) > 0 {
-		fs := make([]zapcore.Field, 0, len(cfg.InitialFields))
+		fs := make([]Field, 0, len(cfg.InitialFields))
 		keys := make([]string, 0, len(cfg.InitialFields))
 		for k := range cfg.InitialFields {
 			keys = append(keys, k)
diff --git a/error.go b/error.go
index 2bff30d..65982a5 100644
--- a/error.go
+++ b/error.go
@@ -31,7 +31,7 @@ var _errArrayElemPool = sync.Pool{New: func() interface{} {
 }}
 
 // Error is shorthand for the common idiom NamedError("error", err).
-func Error(err error) zapcore.Field {
+func Error(err error) Field {
 	return NamedError("error", err)
 }
 
@@ -42,11 +42,11 @@ func Error(err error) zapcore.Field {
 //
 // For the common case in which the key is simply "error", the Error function
 // is shorter and less repetitive.
-func NamedError(key string, err error) zapcore.Field {
+func NamedError(key string, err error) Field {
 	if err == nil {
 		return Skip()
 	}
-	return zapcore.Field{Key: key, Type: zapcore.ErrorType, Interface: err}
+	return Field{Key: key, Type: zapcore.ErrorType, Interface: err}
 }
 
 type errArray []error
diff --git a/field.go b/field.go
index 3347408..5130e13 100644
--- a/field.go
+++ b/field.go
@@ -28,10 +28,14 @@ import (
 	"go.uber.org/zap/zapcore"
 )
 
+// Field is an alias for Field. Aliasing this type dramatically
+// improves the navigability of this package's API documentation.
+type Field = zapcore.Field
+
 // Skip constructs a no-op field, which is often useful when handling invalid
 // inputs in other Field constructors.
-func Skip() zapcore.Field {
-	return zapcore.Field{Type: zapcore.SkipType}
+func Skip() Field {
+	return Field{Type: zapcore.SkipType}
 }
 
 // Binary constructs a field that carries an opaque binary blob.
@@ -39,112 +43,112 @@ func Skip() zapcore.Field {
 // Binary data is serialized in an encoding-appropriate format. For example,
 // zap's JSON encoder base64-encodes binary blobs. To log UTF-8 encoded text,
 // use ByteString.
-func Binary(key string, val []byte) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.BinaryType, Interface: val}
+func Binary(key string, val []byte) Field {
+	return Field{Key: key, Type: zapcore.BinaryType, Interface: val}
 }
 
 // Bool constructs a field that carries a bool.
-func Bool(key string, val bool) zapcore.Field {
+func Bool(key string, val bool) Field {
 	var ival int64
 	if val {
 		ival = 1
 	}
-	return zapcore.Field{Key: key, Type: zapcore.BoolType, Integer: ival}
+	return Field{Key: key, Type: zapcore.BoolType, Integer: ival}
 }
 
 // ByteString constructs a field that carries UTF-8 encoded text as a []byte.
 // To log opaque binary blobs (which aren't necessarily valid UTF-8), use
 // Binary.
-func ByteString(key string, val []byte) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.ByteStringType, Interface: val}
+func ByteString(key string, val []byte) Field {
+	return Field{Key: key, Type: zapcore.ByteStringType, Interface: val}
 }
 
 // Complex128 constructs a field that carries a complex number. Unlike most
 // numeric fields, this costs an allocation (to convert the complex128 to
 // interface{}).
-func Complex128(key string, val complex128) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Complex128Type, Interface: val}
+func Complex128(key string, val complex128) Field {
+	return Field{Key: key, Type: zapcore.Complex128Type, Interface: val}
 }
 
 // Complex64 constructs a field that carries a complex number. Unlike most
 // numeric fields, this costs an allocation (to convert the complex64 to
 // interface{}).
-func Complex64(key string, val complex64) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Complex64Type, Interface: val}
+func Complex64(key string, val complex64) Field {
+	return Field{Key: key, Type: zapcore.Complex64Type, Interface: val}
 }
 
 // Float64 constructs a field that carries a float64. The way the
 // floating-point value is represented is encoder-dependent, so marshaling is
 // necessarily lazy.
-func Float64(key string, val float64) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Float64Type, Integer: int64(math.Float64bits(val))}
+func Float64(key string, val float64) Field {
+	return Field{Key: key, Type: zapcore.Float64Type, Integer: int64(math.Float64bits(val))}
 }
 
 // Float32 constructs a field that carries a float32. The way the
 // floating-point value is represented is encoder-dependent, so marshaling is
 // necessarily lazy.
-func Float32(key string, val float32) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}
+func Float32(key string, val float32) Field {
+	return Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}
 }
 
 // Int constructs a field with the given key and value.
-func Int(key string, val int) zapcore.Field {
+func Int(key string, val int) Field {
 	return Int64(key, int64(val))
 }
 
 // Int64 constructs a field with the given key and value.
-func Int64(key string, val int64) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Int64Type, Integer: val}
+func Int64(key string, val int64) Field {
+	return Field{Key: key, Type: zapcore.Int64Type, Integer: val}
 }
 
 // Int32 constructs a field with the given key and value.
-func Int32(key string, val int32) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}
+func Int32(key string, val int32) Field {
+	return Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}
 }
 
 // Int16 constructs a field with the given key and value.
-func Int16(key string, val int16) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}
+func Int16(key string, val int16) Field {
+	return Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}
 }
 
 // Int8 constructs a field with the given key and value.
-func Int8(key string, val int8) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}
+func Int8(key string, val int8) Field {
+	return Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}
 }
 
 // String constructs a field with the given key and value.
-func String(key string, val string) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.StringType, String: val}
+func String(key string, val string) Field {
+	return Field{Key: key, Type: zapcore.StringType, String: val}
 }
 
 // Uint constructs a field with the given key and value.
-func Uint(key string, val uint) zapcore.Field {
+func Uint(key string, val uint) Field {
 	return Uint64(key, uint64(val))
 }
 
 // Uint64 constructs a field with the given key and value.
-func Uint64(key string, val uint64) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}
+func Uint64(key string, val uint64) Field {
+	return Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}
 }
 
 // Uint32 constructs a field with the given key and value.
-func Uint32(key string, val uint32) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}
+func Uint32(key string, val uint32) Field {
+	return Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}
 }
 
 // Uint16 constructs a field with the given key and value.
-func Uint16(key string, val uint16) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}
+func Uint16(key string, val uint16) Field {
+	return Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}
 }
 
 // Uint8 constructs a field with the given key and value.
-func Uint8(key string, val uint8) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}
+func Uint8(key string, val uint8) Field {
+	return Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}
 }
 
 // Uintptr constructs a field with the given key and value.
-func Uintptr(key string, val uintptr) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}
+func Uintptr(key string, val uintptr) Field {
+	return Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}
 }
 
 // Reflect constructs a field with the given key and an arbitrary object. It uses
@@ -154,8 +158,8 @@ func Uintptr(key string, val uintptr) zapcore.Field {
 //
 // If encoding fails (e.g., trying to serialize a map[int]string to JSON), Reflect
 // includes the error message in the final log output.
-func Reflect(key string, val interface{}) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.ReflectType, Interface: val}
+func Reflect(key string, val interface{}) Field {
+	return Field{Key: key, Type: zapcore.ReflectType, Interface: val}
 }
 
 // Namespace creates a named, isolated scope within the logger's context. All
@@ -163,27 +167,27 @@ func Reflect(key string, val interface{}) zapcore.Field {
 //
 // This helps prevent key collisions when injecting loggers into sub-components
 // or third-party libraries.
-func Namespace(key string) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.NamespaceType}
+func Namespace(key string) Field {
+	return Field{Key: key, Type: zapcore.NamespaceType}
 }
 
 // Stringer constructs a field with the given key and the output of the value's
 // String method. The Stringer's String method is called lazily.
-func Stringer(key string, val fmt.Stringer) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.StringerType, Interface: val}
+func Stringer(key string, val fmt.Stringer) Field {
+	return Field{Key: key, Type: zapcore.StringerType, Interface: val}
 }
 
-// Time constructs a zapcore.Field with the given key and value. The encoder
+// Time constructs a Field with the given key and value. The encoder
 // controls how the time is serialized.
-func Time(key string, val time.Time) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.TimeType, Integer: val.UnixNano(), Interface: val.Location()}
+func Time(key string, val time.Time) Field {
+	return Field{Key: key, Type: zapcore.TimeType, Integer: val.UnixNano(), Interface: val.Location()}
 }
 
 // Stack constructs a field that stores a stacktrace of the current goroutine
 // under provided key. Keep in mind that taking a stacktrace is eager and
 // expensive (relatively speaking); this function both makes an allocation and
 // takes about two microseconds.
-func Stack(key string) zapcore.Field {
+func Stack(key string) Field {
 	// Returning the stacktrace as a string costs an allocation, but saves us
 	// from expanding the zapcore.Field union struct to include a byte slice. Since
 	// taking a stacktrace is already so expensive (~10us), the extra allocation
@@ -193,16 +197,16 @@ func Stack(key string) zapcore.Field {
 
 // Duration constructs a field with the given key and value. The encoder
 // controls how the duration is serialized.
-func Duration(key string, val time.Duration) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.DurationType, Integer: int64(val)}
+func Duration(key string, val time.Duration) Field {
+	return Field{Key: key, Type: zapcore.DurationType, Integer: int64(val)}
 }
 
 // Object constructs a field with the given key and ObjectMarshaler. It
 // provides a flexible, but still type-safe and efficient, way to add map- or
 // struct-like user-defined types to the logging context. The struct's
 // MarshalLogObject method is called lazily.
-func Object(key string, val zapcore.ObjectMarshaler) zapcore.Field {
-	return zapcore.Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}
+func Object(key string, val zapcore.ObjectMarshaler) Field {
+	return Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}
 }
 
 // Any takes a key and an arbitrary value and chooses the best way to represent
@@ -212,7 +216,7 @@ func Object(key string, val zapcore.ObjectMarshaler) zapcore.Field {
 // Since byte/uint8 and rune/int32 are aliases, Any can't differentiate between
 // them. To minimize surprises, []byte values are treated as binary blobs, byte
 // values are treated as uint8, and runes are always treated as integers.
-func Any(key string, value interface{}) zapcore.Field {
+func Any(key string, value interface{}) Field {
 	switch val := value.(type) {
 	case zapcore.ObjectMarshaler:
 		return Object(key, val)
diff --git a/global.go b/global.go
index 7c9a674..d02232e 100644
--- a/global.go
+++ b/global.go
@@ -138,7 +138,7 @@ func redirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {
 	}, nil
 }
 
-func levelToFunc(logger *Logger, lvl zapcore.Level) (func(string, ...zapcore.Field), error) {
+func levelToFunc(logger *Logger, lvl zapcore.Level) (func(string, ...Field), error) {
 	switch lvl {
 	case DebugLevel:
 		return logger.Debug, nil
@@ -159,7 +159,7 @@ func levelToFunc(logger *Logger, lvl zapcore.Level) (func(string, ...zapcore.Fie
 }
 
 type loggerWriter struct {
-	logFunc func(msg string, fields ...zapcore.Field)
+	logFunc func(msg string, fields ...Field)
 }
 
 func (l *loggerWriter) Write(p []byte) (int, error) {
diff --git a/logger.go b/logger.go
index 7d8824b..dc8f6e3 100644
--- a/logger.go
+++ b/logger.go
@@ -156,7 +156,7 @@ func (log *Logger) WithOptions(opts ...Option) *Logger {
 
 // With creates a child logger and adds structured context to it. Fields added
 // to the child don't affect the parent, and vice versa.
-func (log *Logger) With(fields ...zapcore.Field) *Logger {
+func (log *Logger) With(fields ...Field) *Logger {
 	if len(fields) == 0 {
 		return log
 	}
@@ -174,7 +174,7 @@ func (log *Logger) Check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {
 
 // Debug logs a message at DebugLevel. The message includes any fields passed
 // at the log site, as well as any fields accumulated on the logger.
-func (log *Logger) Debug(msg string, fields ...zapcore.Field) {
+func (log *Logger) Debug(msg string, fields ...Field) {
 	if ce := log.check(DebugLevel, msg); ce != nil {
 		ce.Write(fields...)
 	}
@@ -182,7 +182,7 @@ func (log *Logger) Debug(msg string, fields ...zapcore.Field) {
 
 // Info logs a message at InfoLevel. The message includes any fields passed
 // at the log site, as well as any fields accumulated on the logger.
-func (log *Logger) Info(msg string, fields ...zapcore.Field) {
+func (log *Logger) Info(msg string, fields ...Field) {
 	if ce := log.check(InfoLevel, msg); ce != nil {
 		ce.Write(fields...)
 	}
@@ -190,7 +190,7 @@ func (log *Logger) Info(msg string, fields ...zapcore.Field) {
 
 // Warn logs a message at WarnLevel. The message includes any fields passed
 // at the log site, as well as any fields accumulated on the logger.
-func (log *Logger) Warn(msg string, fields ...zapcore.Field) {
+func (log *Logger) Warn(msg string, fields ...Field) {
 	if ce := log.check(WarnLevel, msg); ce != nil {
 		ce.Write(fields...)
 	}
@@ -198,7 +198,7 @@ func (log *Logger) Warn(msg string, fields ...zapcore.Field) {
 
 // Error logs a message at ErrorLevel. The message includes any fields passed
 // at the log site, as well as any fields accumulated on the logger.
-func (log *Logger) Error(msg string, fields ...zapcore.Field) {
+func (log *Logger) Error(msg string, fields ...Field) {
 	if ce := log.check(ErrorLevel, msg); ce != nil {
 		ce.Write(fields...)
 	}
@@ -210,7 +210,7 @@ func (log *Logger) Error(msg string, fields ...zapcore.Field) {
 // If the logger is in development mode, it then panics (DPanic means
 // "development panic"). This is useful for catching errors that are
 // recoverable, but shouldn't ever happen.
-func (log *Logger) DPanic(msg string, fields ...zapcore.Field) {
+func (log *Logger) DPanic(msg string, fields ...Field) {
 	if ce := log.check(DPanicLevel, msg); ce != nil {
 		ce.Write(fields...)
 	}
@@ -220,7 +220,7 @@ func (log *Logger) DPanic(msg string, fields ...zapcore.Field) {
 // at the log site, as well as any fields accumulated on the logger.
 //
 // The logger then panics, even if logging at PanicLevel is disabled.
-func (log *Logger) Panic(msg string, fields ...zapcore.Field) {
+func (log *Logger) Panic(msg string, fields ...Field) {
 	if ce := log.check(PanicLevel, msg); ce != nil {
 		ce.Write(fields...)
 	}
@@ -231,7 +231,7 @@ func (log *Logger) Panic(msg string, fields ...zapcore.Field) {
 //
 // The logger then calls os.Exit(1), even if logging at FatalLevel is
 // disabled.
-func (log *Logger) Fatal(msg string, fields ...zapcore.Field) {
+func (log *Logger) Fatal(msg string, fields ...Field) {
 	if ce := log.check(FatalLevel, msg); ce != nil {
 		ce.Write(fields...)
 	}
diff --git a/options.go b/options.go
index d0f9422..7a6b0fc 100644
--- a/options.go
+++ b/options.go
@@ -55,7 +55,7 @@ func Hooks(hooks ...func(zapcore.Entry) error) Option {
 }
 
 // Fields adds fields to the Logger.
-func Fields(fs ...zapcore.Field) Option {
+func Fields(fs ...Field) Option {
 	return optionFunc(func(log *Logger) {
 		log.core = log.core.With(fs)
 	})
diff --git a/sugar.go b/sugar.go
index 9cda009..77ca227 100644
--- a/sugar.go
+++ b/sugar.go
@@ -62,9 +62,9 @@ func (s *SugaredLogger) Named(name string) *SugaredLogger {
 }
 
 // With adds a variadic number of fields to the logging context. It accepts a
-// mix of strongly-typed zapcore.Field objects and loosely-typed key-value
-// pairs. When processing pairs, the first element of the pair is used as the
-// field key and the second as the field value.
+// mix of strongly-typed Field objects and loosely-typed key-value pairs. When
+// processing pairs, the first element of the pair is used as the field key
+// and the second as the field value.
 //
 // For example,
 //   sugaredLogger.With(
@@ -235,19 +235,19 @@ func (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interf
 	}
 }
 
-func (s *SugaredLogger) sweetenFields(args []interface{}) []zapcore.Field {
+func (s *SugaredLogger) sweetenFields(args []interface{}) []Field {
 	if len(args) == 0 {
 		return nil
 	}
 
 	// Allocate enough space for the worst case; if users pass only structured
 	// fields, we shouldn't penalize them with extra allocations.
-	fields := make([]zapcore.Field, 0, len(args))
+	fields := make([]Field, 0, len(args))
 	var invalid invalidPairs
 
 	for i := 0; i < len(args); {
 		// This is a strongly-typed field. Consume it and move on.
-		if f, ok := args[i].(zapcore.Field); ok {
+		if f, ok := args[i].(Field); ok {
 			fields = append(fields, f)
 			i++
 			continue
