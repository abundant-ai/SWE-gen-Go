diff --git a/internal/terraform/node_action_trigger_apply.go b/internal/terraform/node_action_trigger_apply.go
index 124de5768a..2700611f5d 100644
--- a/internal/terraform/node_action_trigger_apply.go
+++ b/internal/terraform/node_action_trigger_apply.go
@@ -28,7 +28,7 @@ var (
 )
 
 func (n *nodeActionTriggerApplyExpand) Name() string {
-	return fmt.Sprintf("%s (apply)", n.nodeAbstractActionTriggerExpand.Name())
+	return fmt.Sprintf("%s (apply - %s)", n.nodeAbstractActionTriggerExpand.Name(), n.relativeTiming)
 }
 
 func (n *nodeActionTriggerApplyExpand) DynamicExpand(ctx EvalContext) (*Graph, tfdiags.Diagnostics) {
diff --git a/internal/terraform/node_action_trigger_plan.go b/internal/terraform/node_action_trigger_plan.go
index 9a8b34d1f8..04ff5d2d42 100644
--- a/internal/terraform/node_action_trigger_plan.go
+++ b/internal/terraform/node_action_trigger_plan.go
@@ -15,6 +15,8 @@ import (
 
 type nodeActionTriggerPlanExpand struct {
 	*nodeAbstractActionTriggerExpand
+
+	resourceTargets []addrs.Targetable
 }
 
 var (
@@ -74,6 +76,24 @@ func (n *nodeActionTriggerPlanExpand) DynamicExpand(ctx EvalContext) (*Graph, tf
 		for _, key := range keys {
 			absResourceInstanceAddr := n.lifecycleActionTrigger.resourceAddress.Absolute(module).Instance(key)
 
+			// If the triggering resource was targeted, make sure the instance
+			// that triggered this was targeted specifically.
+			// This is necessary since the expansion of a resource instance (and of an action trigger)
+			// happens during the graph walk / execution, therefore the target transformer can not
+			// filter out individual instances, this needs to happen during the graph walk / execution.
+			if n.resourceTargets != nil {
+				matched := false
+				for _, resourceTarget := range n.resourceTargets {
+					if resourceTarget.TargetContains(absResourceInstanceAddr) {
+						matched = true
+						break
+					}
+				}
+				if !matched {
+					continue
+				}
+			}
+
 			// The n.Addr was derived from the ActionRef hcl.Expression referenced inside the resource's lifecycle block, and has not yet been
 			// expanded or fully evaluated, so we will do that now.
 			// Grab the instance key, necessary if the action uses [count.index] or [each.key]
@@ -122,3 +142,7 @@ func (n *nodeActionTriggerPlanExpand) DynamicExpand(ctx EvalContext) (*Graph, tf
 	addRootNodeToGraph(&g)
 	return &g, diags
 }
+
+func (n *nodeActionTriggerPlanExpand) SetResourceTargets(addrs []addrs.Targetable) {
+	n.resourceTargets = addrs
+}
diff --git a/internal/terraform/transform_action_diff.go b/internal/terraform/transform_action_diff.go
index 40b69b99bc..6c42f6f719 100644
--- a/internal/terraform/transform_action_diff.go
+++ b/internal/terraform/transform_action_diff.go
@@ -52,7 +52,6 @@ func (t *ActionDiffTransformer) Transform(g *Graph) error {
 			if (beforeMatches || afterMatches) && atn.lifecycleActionTrigger.actionTriggerBlockIndex == lat.ActionTriggerBlockIndex && atn.lifecycleActionTrigger.actionListIndex == lat.ActionsListIndex {
 				atn.actionInvocationInstances = append(atn.actionInvocationInstances, ai)
 			}
-
 		}
 	}
 
diff --git a/internal/terraform/transform_targets.go b/internal/terraform/transform_targets.go
index 0e3a1192d6..b299e57ce9 100644
--- a/internal/terraform/transform_targets.go
+++ b/internal/terraform/transform_targets.go
@@ -63,7 +63,10 @@ func (t *TargetsTransformer) selectTargetedNodes(g *Graph, addrs []addrs.Targeta
 
 	for _, v := range vertices {
 		if t.nodeIsTarget(v, addrs) {
-			targetedNodes.Add(v)
+			// We need to add everything this node depends on or that is closely associated with
+			// this node. In case of resource nodes, action triggers are considered closely related
+			// since they belong to the resource.
+			t.addVertexDependenciesToTargetedNodes(g, v, targetedNodes, addrs)
 
 			// We inform nodes that ask about the list of targets - helps for nodes
 			// that need to dynamically expand. Note that this only occurs for nodes
@@ -72,8 +75,13 @@ func (t *TargetsTransformer) selectTargetedNodes(g *Graph, addrs []addrs.Targeta
 				tn.SetTargets(addrs)
 			}
 
-			for _, d := range g.Ancestors(v) {
-				targetedNodes.Add(d)
+			if _, ok := v.(*nodeExpandPlannableResource); ok {
+				// We want to also set the resource instance triggers on the related action triggers
+				for _, d := range g.UpEdges(v) {
+					if actionTrigger, ok := d.(*nodeActionTriggerPlanExpand); ok {
+						actionTrigger.SetResourceTargets(addrs)
+					}
+				}
 			}
 		}
 	}
@@ -188,3 +196,39 @@ func (t *TargetsTransformer) nodeIsTarget(v dag.Vertex, targets []addrs.Targetab
 
 	return false
 }
+
+// addVertexDependenciesToTargetedNodes adds dependencies of the targeted vertex to the
+// targetedNodes set. This includes all ancestors in the graph.
+// It also includes all action trigger nodes in the graph. Actions are planned after the
+// triggering node has planned so that we can ensure the actions are only planned if the triggering
+// resource has an action (Create / Update) corresponding to one of the events in the action trigger
+// blocks event list.
+func (t *TargetsTransformer) addVertexDependenciesToTargetedNodes(g *Graph, v dag.Vertex, targetedNodes dag.Set, addrs []addrs.Targetable) {
+	if targetedNodes.Include(v) {
+		return
+	}
+	targetedNodes.Add(v)
+
+	for _, d := range g.Ancestors(v) {
+		t.addVertexDependenciesToTargetedNodes(g, d, targetedNodes, addrs)
+	}
+
+	if _, ok := v.(*nodeExpandPlannableResource); ok {
+		// We want to also add the action triggers related to this resource
+		for _, d := range g.UpEdges(v) {
+			if _, ok := d.(*nodeActionTriggerPlanExpand); ok {
+				t.addVertexDependenciesToTargetedNodes(g, d, targetedNodes, addrs)
+			}
+		}
+	}
+
+	// An applyable resources might have an associated after_* triggered action.
+	// We need to add that action to the targeted nodes as well, together with all its dependencies.
+	if _, ok := v.(*nodeExpandApplyableResource); ok {
+		for _, f := range g.UpEdges(v) {
+			if _, ok := f.(*nodeActionTriggerApplyExpand); ok {
+				t.addVertexDependenciesToTargetedNodes(g, f, targetedNodes, addrs)
+			}
+		}
+	}
+}
