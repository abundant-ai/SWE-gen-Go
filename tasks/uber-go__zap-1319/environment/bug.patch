diff --git a/logger.go b/logger.go
index 6205fe4..e9b49cc 100644
--- a/logger.go
+++ b/logger.go
@@ -185,28 +185,6 @@ func (log *Logger) With(fields ...Field) *Logger {
 	return l
 }
 
-// WithLazy creates a child logger and adds structured context to it lazily.
-//
-// The fields are evaluated only if the logger is further chained with [With]
-// or is written to with any of the log level methods.
-// Until that occurs, the logger may retain references to objects inside the fields,
-// and logging will reflect the state of an object at the time of logging,
-// not the time of WithLazy().
-//
-// WithLazy provides a worthwhile performance optimization for contextual loggers
-// when the likelihood of using the child logger is low,
-// such as error paths and rarely taken branches.
-//
-// Similar to [With], fields added to the child don't affect the parent, and vice versa.
-func (log *Logger) WithLazy(fields ...Field) *Logger {
-	if len(fields) == 0 {
-		return log
-	}
-	return log.WithOptions(WrapCore(func(core zapcore.Core) zapcore.Core {
-		return zapcore.NewLazyWith(core, fields)
-	}))
-}
-
 // Level reports the minimum enabled level for this logger.
 //
 // For NopLoggers, this is [zapcore.InvalidLevel].
diff --git a/logger_bench_test.go b/logger_bench_test.go
index 9d41298..c7207af 100644
--- a/logger_bench_test.go
+++ b/logger_bench_test.go
@@ -199,28 +199,17 @@ func BenchmarkAddCallerAndStacktrace(b *testing.B) {
 		}
 	})
 }
-
 func Benchmark5WithsUsed(b *testing.B) {
-	benchmarkWithUsed(b, (*Logger).With, 5, true)
+	benchmarkWithUsed(b, 5, true)
 }
 
 // This benchmark will be used in future as a
 // baseline for improving
 func Benchmark5WithsNotUsed(b *testing.B) {
-	benchmarkWithUsed(b, (*Logger).With, 5, false)
-}
-
-func Benchmark5WithLazysUsed(b *testing.B) {
-	benchmarkWithUsed(b, (*Logger).WithLazy, 5, true)
-}
-
-// This benchmark will be used in future as a
-// baseline for improving
-func Benchmark5WithLazysNotUsed(b *testing.B) {
-	benchmarkWithUsed(b, (*Logger).WithLazy, 5, false)
+	benchmarkWithUsed(b, 5, false)
 }
 
-func benchmarkWithUsed(b *testing.B, withMethod func(*Logger, ...zapcore.Field) *Logger, N int, use bool) {
+func benchmarkWithUsed(b *testing.B, N int, use bool) {
 	keys := make([]string, N)
 	values := make([]string, N)
 	for i := 0; i < N; i++ {
@@ -232,7 +221,7 @@ func benchmarkWithUsed(b *testing.B, withMethod func(*Logger, ...zapcore.Field)
 
 	withBenchedLogger(b, func(log *Logger) {
 		for i := 0; i < N; i++ {
-			log = withMethod(log, String(keys[i], values[i]))
+			log = log.With(String(keys[i], values[i]))
 		}
 		if use {
 			log.Info("used")
diff --git a/logger_test.go b/logger_test.go
index c371b81..5b1d77b 100644
--- a/logger_test.go
+++ b/logger_test.go
@@ -22,8 +22,6 @@ package zap
 
 import (
 	"errors"
-	"fmt"
-	"strconv"
 	"sync"
 	"sync/atomic"
 	"testing"
@@ -126,250 +124,58 @@ func TestLoggerInitialFields(t *testing.T) {
 }
 
 func TestLoggerWith(t *testing.T) {
+	fieldOpts := opts(Fields(Int("foo", 42)))
+	withLogger(t, DebugLevel, fieldOpts, func(logger *Logger, logs *observer.ObservedLogs) {
+		// Child loggers should have copy-on-write semantics, so two children
+		// shouldn't stomp on each other's fields or affect the parent's fields.
+		logger.With(String("one", "two")).Info("")
+		logger.With(String("three", "four")).Info("")
+		logger.With(String("five", "six")).With(String("seven", "eight")).Info("")
+		logger.Info("")
 
-	tests := []struct {
-		name          string
-		initialFields []Field
-		withMethod    func(*Logger, ...Field) *Logger
-	}{
-		{
-			"regular non lazy logger",
-			[]Field{Int("foo", 42)},
-			(*Logger).With,
-		},
-		{
-			"regular non lazy logger no initial fields",
-			[]Field{},
-			(*Logger).With,
-		},
-		{
-			"lazy with logger",
-			[]Field{Int("foo", 42)},
-			(*Logger).WithLazy,
-		},
-		{
-			"lazy with logger no initial fields",
-			[]Field{},
-			(*Logger).WithLazy,
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			withLogger(t, DebugLevel, opts(Fields(tt.initialFields...)), func(logger *Logger, logs *observer.ObservedLogs) {
-				// Child loggers should have copy-on-write semantics, so two children
-				// shouldn't stomp on each other's fields or affect the parent's fields.
-				tt.withMethod(logger).Info("")
-				tt.withMethod(logger, String("one", "two")).Info("")
-				tt.withMethod(logger, String("three", "four")).Info("")
-				tt.withMethod(logger, String("five", "six")).With(String("seven", "eight")).Info("")
-				logger.Info("")
-
-				assert.Equal(t, []observer.LoggedEntry{
-					{Context: tt.initialFields},
-					{Context: append(tt.initialFields, String("one", "two"))},
-					{Context: append(tt.initialFields, String("three", "four"))},
-					{Context: append(tt.initialFields, String("five", "six"), String("seven", "eight"))},
-					{Context: tt.initialFields},
-				}, logs.AllUntimed(), "Unexpected cross-talk between child loggers.")
-			})
-		})
-	}
+		assert.Equal(t, []observer.LoggedEntry{
+			{Context: []Field{Int("foo", 42), String("one", "two")}},
+			{Context: []Field{Int("foo", 42), String("three", "four")}},
+			{Context: []Field{Int("foo", 42), String("five", "six"), String("seven", "eight")}},
+			{Context: []Field{Int("foo", 42)}},
+		}, logs.AllUntimed(), "Unexpected cross-talk between child loggers.")
+	})
 }
 
 func TestLoggerWithCaptures(t *testing.T) {
-	type withF func(*Logger, ...Field) *Logger
-	tests := []struct {
-		name        string
-		withMethods []withF
-		wantJSON    []string
-	}{
-		{
-			name:        "regular with captures arguments at time of With",
-			withMethods: []withF{(*Logger).With},
-			wantJSON: []string{
-				`{
-					"m": "hello 0",
-					"a0": [0],
-					"b0": [1]
-				}`,
-				`{
-					"m": "world 0",
-					"a0": [0],
-					"c0": [2]
-				}`,
-			},
-		},
-		{
-			name:        "lazy with captures arguments at time of With or Logging",
-			withMethods: []withF{(*Logger).WithLazy},
-			wantJSON: []string{
-				`{
-					"m": "hello 0",
-					"a0": [1],
-					"b0": [1]
-				}`,
-				`{
-					"m": "world 0",
-					"a0": [1],
-					"c0": [2]
-				}`,
-			},
-		},
-		{
-			name:        "2x With captures arguments at time of each With",
-			withMethods: []withF{(*Logger).With, (*Logger).With},
-			wantJSON: []string{
-				`{
-					"m": "hello 0",
-					"a0": [0],
-					"b0": [1]
-				}`,
-				`{
-					"m": "world 0",
-					"a0": [0],
-					"c0": [2]
-				}`,
-				`{
-					"m": "hello 1",
-					"a0": [0],
-					"c0": [2],
-					"a1": [10],
-					"b1": [11]
-				}`,
-				`{
-					"m": "world 1",
-					"a0": [0],
-					"c0": [2],
-					"a1": [10],
-					"c1": [12]
-				}`,
-			},
-		},
-		{
-			name:        "2x WithLazy. Captures arguments only at logging time.",
-			withMethods: []withF{(*Logger).WithLazy, (*Logger).WithLazy},
-			wantJSON: []string{
-				`{
-					"m": "hello 0",
-					"a0": [1],
-					"b0": [1]
-				}`,
-				`{
-					"m": "world 0",
-					"a0": [1],
-					"c0": [2]
-				}`,
-				`{
-					"m": "hello 1",
-					"a0": [1],
-					"c0": [2],
-					"a1": [11],
-					"b1": [11]
-				}`,
-				`{
-					"m": "world 1",
-					"a0": [1],
-					"c0": [2],
-					"a1": [11],
-					"c1": [12]
-				}`,
-			},
-		},
-		{
-			name:        "WithLazy then With",
-			withMethods: []withF{(*Logger).WithLazy, (*Logger).With},
-			wantJSON: []string{
-				`{
-					"m": "hello 0",
-					"a0": [1],
-					"b0": [1]
-				}`,
-				`{
-					"m": "world 0",
-					"a0": [1],
-					"c0": [2]
-				}`,
-				`{
-					"m": "hello 1",
-					"a0": [1],
-					"c0": [2],
-					"a1": [10],
-					"b1": [11]
-				}`,
-				`{
-					"m": "world 1",
-					"a0": [1],
-					"c0": [2],
-					"a1": [10],
-					"c1": [12]
-				}`,
-			},
-		},
-		{
-			name:        "With then WithLazy",
-			withMethods: []withF{(*Logger).With, (*Logger).WithLazy},
-			wantJSON: []string{
-				`{
-					"m": "hello 0",
-					"a0": [0],
-					"b0": [1]
-				}`,
-				`{
-					"m": "world 0",
-					"a0": [0],
-					"c0": [2]
-				}`,
-				`{
-					"m": "hello 1",
-					"a0": [0],
-					"c0": [2],
-					"a1": [11],
-					"b1": [11]
-				}`,
-				`{
-					"m": "world 1",
-					"a0": [0],
-					"c0": [2],
-					"a1": [11],
-					"c1": [12]
-				}`,
-			},
-		},
-	}
+	enc := zapcore.NewJSONEncoder(zapcore.EncoderConfig{
+		MessageKey: "m",
+	})
 
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			enc := zapcore.NewJSONEncoder(zapcore.EncoderConfig{
-				MessageKey: "m",
-			})
+	var bs ztest.Buffer
+	logger := New(zapcore.NewCore(enc, &bs, DebugLevel))
 
-			var bs ztest.Buffer
-			logger := New(zapcore.NewCore(enc, &bs, DebugLevel))
-
-			for i, withMethod := range tt.withMethods {
-
-				iStr := strconv.Itoa(i)
-				x := 10 * i
-				arr := zapcore.ArrayMarshalerFunc(func(enc zapcore.ArrayEncoder) error {
-					enc.AppendInt(x)
-					return nil
-				})
-
-				// Demonstrate the arguments are captured when With() and Info() are invoked.
-				logger = withMethod(logger, Array("a"+iStr, arr))
-				x++
-				logger.Info(fmt.Sprintf("hello %d", i), Array("b"+iStr, arr))
-				x++
-				logger = withMethod(logger, Array("c"+iStr, arr))
-				logger.Info(fmt.Sprintf("world %d", i))
-			}
+	x := 0
+	arr := zapcore.ArrayMarshalerFunc(func(enc zapcore.ArrayEncoder) error {
+		enc.AppendInt(x)
+		return nil
+	})
 
-			if lines := bs.Lines(); assert.Len(t, lines, len(tt.wantJSON)) {
-				for i, want := range tt.wantJSON {
-					assert.JSONEq(t, want, lines[i], "Unexpected output from the %d'th log.", i)
-				}
-			}
-		})
+	// Demonstrate the arguments are captured when With() and Info() are invoked.
+	logger = logger.With(Array("a", arr))
+	x = 1
+	logger.Info("hello", Array("b", arr))
+	x = 2
+	logger = logger.With(Array("c", arr))
+	logger.Info("world")
+
+	if lines := bs.Lines(); assert.Len(t, lines, 2) {
+		assert.JSONEq(t, `{
+			"m": "hello",
+			"a": [0],
+			"b": [1]
+		}`, lines[0], "Unexpected output from first log.")
+
+		assert.JSONEq(t, `{
+			"m": "world",
+			"a": [0],
+			"c": [2]
+		}`, lines[1], "Unexpected output from second log.")
 	}
 }
 
diff --git a/zapcore/lazy_with.go b/zapcore/lazy_with.go
deleted file mode 100644
index 05288d6..0000000
--- a/zapcore/lazy_with.go
+++ /dev/null
@@ -1,54 +0,0 @@
-// Copyright (c) 2023 Uber Technologies, Inc.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights
-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-// copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-// THE SOFTWARE.
-
-package zapcore
-
-import "sync"
-
-type lazyWithCore struct {
-	Core
-	sync.Once
-	fields []Field
-}
-
-// NewLazyWith wraps a Core with a "lazy" Core that will only encode fields if
-// the logger is written to (or is further chained in a lon-lazy manner).
-func NewLazyWith(core Core, fields []Field) Core {
-	return &lazyWithCore{
-		Core:   core,
-		fields: fields,
-	}
-}
-
-func (d *lazyWithCore) initOnce() {
-	d.Once.Do(func() {
-		d.Core = d.Core.With(d.fields)
-	})
-}
-
-func (d *lazyWithCore) With(fields []Field) Core {
-	d.initOnce()
-	return d.Core.With(fields)
-}
-
-func (d *lazyWithCore) Check(e Entry, ce *CheckedEntry) *CheckedEntry {
-	d.initOnce()
-	return d.Core.Check(e, ce)
-}
diff --git a/zapcore/lazy_with_test.go b/zapcore/lazy_with_test.go
deleted file mode 100644
index 6402969..0000000
--- a/zapcore/lazy_with_test.go
+++ /dev/null
@@ -1,150 +0,0 @@
-// Copyright (c) 2023 Uber Technologies, Inc.
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to deal
-// in the Software without restriction, including without limitation the rights
-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-// copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-// THE SOFTWARE.
-
-package zapcore_test
-
-import (
-	"sync/atomic"
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-	"go.uber.org/zap/zapcore"
-	"go.uber.org/zap/zaptest/observer"
-)
-
-type proxyCore struct {
-	zapcore.Core
-
-	withCount  atomic.Int64
-	checkCount atomic.Int64
-}
-
-func newProxyCore(inner zapcore.Core) *proxyCore {
-	return &proxyCore{Core: inner}
-}
-
-func (p *proxyCore) With(fields []zapcore.Field) zapcore.Core {
-	p.withCount.Add(1)
-	return p.Core.With(fields)
-}
-
-func (p *proxyCore) Check(e zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {
-	p.checkCount.Add(1)
-	return p.Core.Check(e, ce)
-}
-
-func withLazyCore(f func(zapcore.Core, *proxyCore, *observer.ObservedLogs), initialFields ...zapcore.Field) {
-	infoLogger, infoLogs := observer.New(zapcore.InfoLevel)
-	proxyCore := newProxyCore(infoLogger)
-	lazyCore := zapcore.NewLazyWith(proxyCore, initialFields)
-	f(lazyCore, proxyCore, infoLogs)
-}
-
-func TestLazyCore(t *testing.T) {
-	tests := []struct {
-		name          string
-		entries       []zapcore.Entry
-		initialFields []zapcore.Field
-		withChains    [][]zapcore.Field
-		wantLogs      []observer.LoggedEntry
-	}{
-		{
-			name:     "no logging, no with, inner core with never called, inner core check never called",
-			wantLogs: []observer.LoggedEntry{},
-		},
-		{
-			name: "2 logs, 1 dropped, no with, inner core with called once, inner core check never called",
-			entries: []zapcore.Entry{
-				{Level: zapcore.DebugLevel, Message: "log-at-debug"},
-				{Level: zapcore.WarnLevel, Message: "log-at-warn"},
-			},
-			wantLogs: []observer.LoggedEntry{
-				{Entry: zapcore.Entry{
-					Level:   zapcore.WarnLevel,
-					Message: "log-at-warn"},
-					Context: []zapcore.Field{},
-				},
-			},
-		},
-		{
-			name: "no logs, 2-chained with, inner core with called once, inner core check never called",
-			withChains: [][]zapcore.Field{
-				{makeInt64Field("a", 11), makeInt64Field("b", 22)},
-				{makeInt64Field("c", 33), makeInt64Field("d", 44)},
-			},
-			wantLogs: []observer.LoggedEntry{},
-		},
-		{
-			name: "2 logs, 1 dropped, 2-chained with, inner core with called once, inner core check never called",
-			entries: []zapcore.Entry{
-				{Level: zapcore.DebugLevel, Message: "log-at-debug"},
-				{Level: zapcore.WarnLevel, Message: "log-at-warn"},
-			},
-			withChains: [][]zapcore.Field{
-				{makeInt64Field("a", 11), makeInt64Field("b", 22)},
-				{makeInt64Field("c", 33), makeInt64Field("d", 44)},
-			},
-			wantLogs: []observer.LoggedEntry{
-				{Entry: zapcore.Entry{
-					Level:   zapcore.WarnLevel,
-					Message: "log-at-warn"},
-					Context: []zapcore.Field{
-						makeInt64Field("a", 11),
-						makeInt64Field("b", 22),
-						makeInt64Field("c", 33),
-						makeInt64Field("d", 44),
-					},
-				},
-			},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			withLazyCore(func(lazy zapcore.Core, proxy *proxyCore, logs *observer.ObservedLogs) {
-				checkCounts := func(withCount int64, msg string) {
-					assert.Equal(t, withCount, proxy.withCount.Load(), msg)
-				}
-				checkCounts(0, "expected no with calls because the logger is not used yet")
-
-				for _, chain := range tt.withChains {
-					lazy = lazy.With(chain)
-				}
-				if len(tt.withChains) > 0 {
-					checkCounts(1, "expected with calls because the logger was with-chained")
-				} else {
-					checkCounts(0, "expected no with calls because the logger is not used yet")
-				}
-
-				for _, ent := range tt.entries {
-					if ce := lazy.Check(ent, nil); ce != nil {
-						ce.Write()
-					}
-				}
-				if len(tt.entries) > 0 || len(tt.withChains) > 0 {
-					checkCounts(1, "expected with calls because the logger had entries or with chains")
-				} else {
-					checkCounts(0, "expected no with calls because the logger is not used yet")
-				}
-				assert.Zero(t, proxy.checkCount.Load(), "expected no check calls because the inner core is copied")
-				assert.Equal(t, tt.wantLogs, logs.AllUntimed())
-			}, tt.initialFields...)
-		})
-	}
-}
