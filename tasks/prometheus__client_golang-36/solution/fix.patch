diff --git a/prometheus/go_collector.go b/prometheus/go_collector.go
new file mode 100644
index 0000000..d7b7a20
--- /dev/null
+++ b/prometheus/go_collector.go
@@ -0,0 +1,31 @@
+package prometheus
+
+import (
+	"runtime"
+)
+
+type goCollector struct {
+	goroutines Gauge
+}
+
+// NewGoCollector returns a collector which exports metrics about the current
+// go process.
+func NewGoCollector() *goCollector {
+	return &goCollector{
+		goroutines: NewGauge(GaugeOpts{
+			Name: "process_goroutines",
+			Help: "Number of goroutines that currently exist.",
+		}),
+	}
+}
+
+// Describe returns all descriptions of the collector.
+func (c *goCollector) Describe(ch chan<- *Desc) {
+	ch <- c.goroutines.Desc()
+}
+
+// Collect returns the current state of all metrics of the collector.
+func (c *goCollector) Collect(ch chan<- Metric) {
+	c.goroutines.Set(float64(runtime.NumGoroutine()))
+	ch <- c.goroutines
+}
diff --git a/prometheus/process_collector.go b/prometheus/process_collector.go
new file mode 100644
index 0000000..60c5912
--- /dev/null
+++ b/prometheus/process_collector.go
@@ -0,0 +1,121 @@
+package prometheus
+
+import "github.com/prometheus/procfs"
+
+type processCollector struct {
+	pid             int
+	collectFn       func(chan<- Metric)
+	pidFn           func() int
+	cpuTotal        Counter
+	openFDs, maxFDs Gauge
+	vsize, rss      Gauge
+	startTime       Gauge
+}
+
+// NewProcessCollector returns a collector which exports the current state of
+// process metrics including cpu, memory and file descriptor usage as well as
+// the process start time for the given process id under the given namespace.
+func NewProcessCollector(pid int, namespace string) *processCollector {
+	return NewProcessCollectorPIDFn(func() int { return pid }, namespace)
+}
+
+// NewProcessCollectorPIDFn returns a collector which exports the current state
+// of process metrics including cpu, memory and file descriptor usage as well
+// as the process start time under the given namespace. The given pidFn is
+// called on each collect and is used to determine the process to export
+// metrics for.
+func NewProcessCollectorPIDFn(
+	pidFn func() int,
+	namespace string,
+) *processCollector {
+	c := processCollector{
+		pidFn:     pidFn,
+		collectFn: noopCollect,
+
+		cpuTotal: NewCounter(CounterOpts{
+			Namespace: namespace,
+			Name:      "process_cpu_seconds_total",
+			Help:      "Total user and system CPU time spent in seconds.",
+		}),
+		openFDs: NewGauge(GaugeOpts{
+			Namespace: namespace,
+			Name:      "process_open_fds",
+			Help:      "Number of open file descriptors.",
+		}),
+		maxFDs: NewGauge(GaugeOpts{
+			Namespace: namespace,
+			Name:      "process_max_fds",
+			Help:      "Maximum number of open file descriptors.",
+		}),
+		vsize: NewGauge(GaugeOpts{
+			Namespace: namespace,
+			Name:      "process_virtual_memory_bytes",
+			Help:      "Virtual memory size in bytes.",
+		}),
+		rss: NewGauge(GaugeOpts{
+			Namespace: namespace,
+			Name:      "process_resident_memory_bytes",
+			Help:      "Resident memory size in bytes.",
+		}),
+		startTime: NewGauge(GaugeOpts{
+			Namespace: namespace,
+			Name:      "process_start_time_seconds",
+			Help:      "Start time of the process since unix epoch in seconds.",
+		}),
+	}
+
+	// Use procfs to export metrics if available.
+	if _, err := procfs.NewStat(); err == nil {
+		c.collectFn = c.procfsCollect
+	}
+
+	return &c
+}
+
+// Describe returns all descriptions of the collector.
+func (c *processCollector) Describe(ch chan<- *Desc) {
+	ch <- c.cpuTotal.Desc()
+	ch <- c.openFDs.Desc()
+	ch <- c.maxFDs.Desc()
+	ch <- c.vsize.Desc()
+	ch <- c.rss.Desc()
+	ch <- c.startTime.Desc()
+}
+
+// Collect returns the current state of all metrics of the collector.
+func (c *processCollector) Collect(ch chan<- Metric) {
+	c.collectFn(ch)
+}
+
+func noopCollect(ch chan<- Metric) {}
+
+func (c *processCollector) procfsCollect(ch chan<- Metric) {
+	p, err := procfs.NewProc(c.pidFn())
+	if err != nil {
+		return
+	}
+
+	if stat, err := p.NewStat(); err == nil {
+		c.cpuTotal.Set(stat.CPUTime())
+		ch <- c.cpuTotal
+		c.vsize.Set(float64(stat.VirtualMemory()))
+		ch <- c.vsize
+		c.rss.Set(float64(stat.ResidentMemory()))
+		ch <- c.rss
+
+		if startTime, err := stat.StartTime(); err == nil {
+			c.startTime.Set(startTime)
+			ch <- c.startTime
+		}
+	}
+
+	if fds, err := p.FileDescriptorsLen(); err == nil {
+		c.openFDs.Set(float64(fds))
+		ch <- c.openFDs
+	}
+
+	if limits, err := p.NewLimits(); err == nil {
+		c.maxFDs.Set(float64(limits.OpenFiles))
+		ch <- c.maxFDs
+	}
+}
diff --git a/prometheus/registry.go b/prometheus/registry.go
index 65ea520..8485f9a 100644
--- a/prometheus/registry.go
+++ b/prometheus/registry.go
@@ -21,12 +21,14 @@ package prometheus
 
 import (
 	"bytes"
+	"compress/gzip"
 	"errors"
 	"fmt"
 	"hash/fnv"
 	"io"
 	"net/http"
 	"net/url"
+	"os"
 	"sort"
 	"strings"
 	"sync"
@@ -34,7 +36,6 @@ import (
 	dto "github.com/prometheus/client_model/go"
 
 	"code.google.com/p/goprotobuf/proto"
-	"compress/gzip"
 
 	"github.com/prometheus/client_golang/_vendor/goautoneg"
 	"github.com/prometheus/client_golang/model"
@@ -42,7 +43,7 @@ import (
 )
 
 var (
-	defRegistry   = newRegistry()
+	defRegistry   = newDefaultRegistry()
 	errAlreadyReg = errors.New("duplicate metrics collector registration attempted")
 )
 
@@ -643,6 +644,13 @@ func newRegistry() *registry {
 	}
 }
 
+func newDefaultRegistry() *registry {
+	r := newRegistry()
+	r.Register(NewProcessCollector(os.Getpid(), ""))
+	r.Register(NewGoCollector())
+	return r
+}
+
 func chooseEncoder(req *http.Request) (encoder, string) {
 	accepts := goautoneg.ParseAccept(req.Header.Get(acceptHeader))
 	for _, accept := range accepts {
