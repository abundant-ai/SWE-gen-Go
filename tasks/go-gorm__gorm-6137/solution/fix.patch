diff --git a/callbacks/preload.go b/callbacks/preload.go
index ea2570b..15669c8 100644
--- a/callbacks/preload.go
+++ b/callbacks/preload.go
@@ -3,6 +3,7 @@ package callbacks
 import (
 	"fmt"
 	"reflect"
+	"strings"
 
 	"gorm.io/gorm"
 	"gorm.io/gorm/clause"
@@ -10,6 +11,98 @@ import (
 	"gorm.io/gorm/utils"
 )
 
+// parsePreloadMap extracts nested preloads. e.g.
+//
+//	// schema has a "k0" relation and a "k7.k8" embedded relation
+//	parsePreloadMap(schema, map[string][]interface{}{
+//		clause.Associations: {"arg1"},
+//		"k1":                {"arg2"},
+//		"k2.k3":             {"arg3"},
+//		"k4.k5.k6":          {"arg4"},
+//	})
+//	// preloadMap is
+//	map[string]map[string][]interface{}{
+//		"k0": {},
+//		"k7": {
+//			"k8": {},
+//		},
+//		"k1": {},
+//		"k2": {
+//			"k3": {"arg3"},
+//		},
+//		"k4": {
+//			"k5.k6": {"arg4"},
+//		},
+//	}
+func parsePreloadMap(s *schema.Schema, preloads map[string][]interface{}) map[string]map[string][]interface{} {
+	preloadMap := map[string]map[string][]interface{}{}
+	setPreloadMap := func(name, value string, args []interface{}) {
+		if _, ok := preloadMap[name]; !ok {
+			preloadMap[name] = map[string][]interface{}{}
+		}
+		if value != "" {
+			preloadMap[name][value] = args
+		}
+	}
+
+	for name, args := range preloads {
+		preloadFields := strings.Split(name, ".")
+		value := strings.TrimPrefix(strings.TrimPrefix(name, preloadFields[0]), ".")
+		if preloadFields[0] == clause.Associations {
+			for _, relation := range s.Relationships.Relations {
+				if relation.Schema == s {
+					setPreloadMap(relation.Name, value, args)
+				}
+			}
+
+			for embedded, embeddedRelations := range s.Relationships.EmbeddedRelations {
+				for _, value := range embeddedValues(embeddedRelations) {
+					setPreloadMap(embedded, value, args)
+				}
+			}
+		} else {
+			setPreloadMap(preloadFields[0], value, args)
+		}
+	}
+	return preloadMap
+}
+
+func embeddedValues(embeddedRelations *schema.Relationships) []string {
+	if embeddedRelations == nil {
+		return nil
+	}
+	names := make([]string, 0, len(embeddedRelations.Relations)+len(embeddedRelations.EmbeddedRelations))
+	for _, relation := range embeddedRelations.Relations {
+		// skip first struct name
+		names = append(names, strings.Join(relation.Field.BindNames[1:], "."))
+	}
+	for _, relations := range embeddedRelations.EmbeddedRelations {
+		names = append(names, embeddedValues(relations)...)
+	}
+	return names
+}
+
+func preloadEmbedded(tx *gorm.DB, relationships *schema.Relationships, s *schema.Schema, preloads map[string][]interface{}, as []interface{}) error {
+	if relationships == nil {
+		return nil
+	}
+	preloadMap := parsePreloadMap(s, preloads)
+	for name := range preloadMap {
+		if embeddedRelations := relationships.EmbeddedRelations[name]; embeddedRelations != nil {
+			if err := preloadEmbedded(tx, embeddedRelations, s, preloadMap[name], as); err != nil {
+				return err
+			}
+		} else if rel := relationships.Relations[name]; rel != nil {
+			if err := preload(tx, rel, append(preloads[name], as), preloadMap[name]); err != nil {
+				return err
+			}
+		} else {
+			return fmt.Errorf("%s: %w (embedded) for schema %s", name, gorm.ErrUnsupportedRelation, s.Name)
+		}
+	}
+	return nil
+}
+
 func preload(tx *gorm.DB, rel *schema.Relationship, conds []interface{}, preloads map[string][]interface{}) error {
 	var (
 		reflectValue     = tx.Statement.ReflectValue
diff --git a/callbacks/query.go b/callbacks/query.go
index c87f17b..95db1f0 100644
--- a/callbacks/query.go
+++ b/callbacks/query.go
@@ -267,32 +267,7 @@ func Preload(db *gorm.DB) {
 			return
 		}
 
-		preloadMap := map[string]map[string][]interface{}{}
-		for name := range db.Statement.Preloads {
-			preloadFields := strings.Split(name, ".")
-			if preloadFields[0] == clause.Associations {
-				for _, rel := range db.Statement.Schema.Relationships.Relations {
-					if rel.Schema == db.Statement.Schema {
-						if _, ok := preloadMap[rel.Name]; !ok {
-							preloadMap[rel.Name] = map[string][]interface{}{}
-						}
-
-						if value := strings.TrimPrefix(strings.TrimPrefix(name, preloadFields[0]), "."); value != "" {
-							preloadMap[rel.Name][value] = db.Statement.Preloads[name]
-						}
-					}
-				}
-			} else {
-				if _, ok := preloadMap[preloadFields[0]]; !ok {
-					preloadMap[preloadFields[0]] = map[string][]interface{}{}
-				}
-
-				if value := strings.TrimPrefix(strings.TrimPrefix(name, preloadFields[0]), "."); value != "" {
-					preloadMap[preloadFields[0]][value] = db.Statement.Preloads[name]
-				}
-			}
-		}
-
+		preloadMap := parsePreloadMap(db.Statement.Schema, db.Statement.Preloads)
 		preloadNames := make([]string, 0, len(preloadMap))
 		for key := range preloadMap {
 			preloadNames = append(preloadNames, key)
@@ -312,7 +287,9 @@ func Preload(db *gorm.DB) {
 		preloadDB.Statement.Unscoped = db.Statement.Unscoped
 
 		for _, name := range preloadNames {
-			if rel := preloadDB.Statement.Schema.Relationships.Relations[name]; rel != nil {
+			if relations := preloadDB.Statement.Schema.Relationships.EmbeddedRelations[name]; relations != nil {
+				db.AddError(preloadEmbedded(preloadDB.Table("").Session(&gorm.Session{Context: db.Statement.Context, SkipHooks: db.Statement.SkipHooks}), relations, db.Statement.Schema, preloadMap[name], db.Statement.Preloads[clause.Associations]))
+			} else if rel := preloadDB.Statement.Schema.Relationships.Relations[name]; rel != nil {
 				db.AddError(preload(preloadDB.Table("").Session(&gorm.Session{Context: db.Statement.Context, SkipHooks: db.Statement.SkipHooks}), rel, append(db.Statement.Preloads[name], db.Statement.Preloads[clause.Associations]...), preloadMap[name]))
 			} else {
 				db.AddError(fmt.Errorf("%s: %w for schema %s", name, gorm.ErrUnsupportedRelation, db.Statement.Schema.Name))
diff --git a/schema/field.go b/schema/field.go
index 00beb06..921f3c4 100644
--- a/schema/field.go
+++ b/schema/field.go
@@ -89,6 +89,10 @@ type Field struct {
 	NewValuePool           FieldNewValuePool
 }
 
+func (field *Field) BindName() string {
+	return strings.Join(field.BindNames, ".")
+}
+
 // ParseField parses reflect.StructField to Field
 func (schema *Schema) ParseField(fieldStruct reflect.StructField) *Field {
 	var (
diff --git a/schema/relationship.go b/schema/relationship.go
index b33b94a..e03dcc5 100644
--- a/schema/relationship.go
+++ b/schema/relationship.go
@@ -27,6 +27,8 @@ type Relationships struct {
 	HasMany   []*Relationship
 	Many2Many []*Relationship
 	Relations map[string]*Relationship
+
+	EmbeddedRelations map[string]*Relationships
 }
 
 type Relationship struct {
@@ -106,7 +108,7 @@ func (schema *Schema) parseRelation(field *Field) *Relationship {
 	}
 
 	if schema.err == nil {
-		schema.Relationships.Relations[relation.Name] = relation
+		schema.setRelation(relation)
 		switch relation.Type {
 		case HasOne:
 			schema.Relationships.HasOne = append(schema.Relationships.HasOne, relation)
@@ -122,6 +124,39 @@ func (schema *Schema) parseRelation(field *Field) *Relationship {
 	return relation
 }
 
+func (schema *Schema) setRelation(relation *Relationship) {
+	// set non-embedded relation
+	if rel := schema.Relationships.Relations[relation.Name]; rel != nil {
+		if len(rel.Field.BindNames) > 1 {
+			schema.Relationships.Relations[relation.Name] = relation
+		}
+	} else {
+		schema.Relationships.Relations[relation.Name] = relation
+	}
+
+	// set embedded relation
+	if len(relation.Field.BindNames) <= 1 {
+		return
+	}
+	relationships := &schema.Relationships
+	for i, name := range relation.Field.BindNames {
+		if i < len(relation.Field.BindNames)-1 {
+			if relationships.EmbeddedRelations == nil {
+				relationships.EmbeddedRelations = map[string]*Relationships{}
+			}
+			if r := relationships.EmbeddedRelations[name]; r == nil {
+				relationships.EmbeddedRelations[name] = &Relationships{}
+			}
+			relationships = relationships.EmbeddedRelations[name]
+		} else {
+			if relationships.Relations == nil {
+				relationships.Relations = map[string]*Relationship{}
+			}
+			relationships.Relations[relation.Name] = relation
+		}
+	}
+}
+
 // User has many Toys, its `Polymorphic` is `Owner`, Pet has one Toy, its `Polymorphic` is `Owner`
 //
 //	type User struct {
@@ -166,6 +201,11 @@ func (schema *Schema) buildPolymorphicRelation(relation *Relationship, field *Fi
 			}
 		}
 
+		if primaryKeyField == nil {
+			schema.err = fmt.Errorf("invalid polymorphic type %v for %v on field %s, missing primaryKey field", relation.FieldSchema, schema, field.Name)
+			return
+		}
+
 		// use same data type for foreign keys
 		if copyableDataType(primaryKeyField.DataType) {
 			relation.Polymorphic.PolymorphicID.DataType = primaryKeyField.DataType
@@ -443,6 +483,7 @@ func (schema *Schema) guessRelation(relation *Relationship, field *Field, cgl gu
 			primaryFields = primarySchema.PrimaryFields
 		}
 
+	primaryFieldLoop:
 		for _, primaryField := range primaryFields {
 			lookUpName := primarySchemaName + primaryField.Name
 			if gl == guessBelongs {
@@ -454,11 +495,18 @@ func (schema *Schema) guessRelation(relation *Relationship, field *Field, cgl gu
 				lookUpNames = append(lookUpNames, strings.TrimSuffix(lookUpName, primaryField.Name)+"ID", strings.TrimSuffix(lookUpName, primaryField.Name)+"Id", schema.namer.ColumnName(foreignSchema.Table, strings.TrimSuffix(lookUpName, primaryField.Name)+"ID"))
 			}
 
+			for _, name := range lookUpNames {
+				if f := foreignSchema.LookUpFieldByBindName(field.BindNames, name); f != nil {
+					foreignFields = append(foreignFields, f)
+					primaryFields = append(primaryFields, primaryField)
+					continue primaryFieldLoop
+				}
+			}
 			for _, name := range lookUpNames {
 				if f := foreignSchema.LookUpField(name); f != nil {
 					foreignFields = append(foreignFields, f)
 					primaryFields = append(primaryFields, primaryField)
-					break
+					continue primaryFieldLoop
 				}
 			}
 		}
diff --git a/schema/schema.go b/schema/schema.go
index 17bdb25..e13a5ed 100644
--- a/schema/schema.go
+++ b/schema/schema.go
@@ -6,6 +6,7 @@ import (
 	"fmt"
 	"go/ast"
 	"reflect"
+	"strings"
 	"sync"
 
 	"gorm.io/gorm/clause"
@@ -25,6 +26,7 @@ type Schema struct {
 	PrimaryFieldDBNames       []string
 	Fields                    []*Field
 	FieldsByName              map[string]*Field
+	FieldsByBindName          map[string]*Field // embedded fields is 'Embed.Field'
 	FieldsByDBName            map[string]*Field
 	FieldsWithDefaultDBValue  []*Field // fields with default value assigned by database
 	Relationships             Relationships
@@ -67,6 +69,27 @@ func (schema Schema) LookUpField(name string) *Field {
 	return nil
 }
 
+// LookUpFieldByBindName looks for the closest field in the embedded struct.
+//
+//	type Struct struct {
+//		Embedded struct {
+//			ID string // is selected by LookUpFieldByBindName([]string{"Embedded", "ID"}, "ID")
+//		}
+//		ID string // is selected by LookUpFieldByBindName([]string{"ID"}, "ID")
+//	}
+func (schema Schema) LookUpFieldByBindName(bindNames []string, name string) *Field {
+	if len(bindNames) == 0 {
+		return nil
+	}
+	for i := len(bindNames) - 1; i >= 0; i-- {
+		find := strings.Join(bindNames[:i], ".") + "." + name
+		if field, ok := schema.FieldsByBindName[find]; ok {
+			return field
+		}
+	}
+	return nil
+}
+
 type Tabler interface {
 	TableName() string
 }
@@ -140,15 +163,16 @@ func ParseWithSpecialTableName(dest interface{}, cacheStore *sync.Map, namer Nam
 	}
 
 	schema := &Schema{
-		Name:           modelType.Name(),
-		ModelType:      modelType,
-		Table:          tableName,
-		FieldsByName:   map[string]*Field{},
-		FieldsByDBName: map[string]*Field{},
-		Relationships:  Relationships{Relations: map[string]*Relationship{}},
-		cacheStore:     cacheStore,
-		namer:          namer,
-		initialized:    make(chan struct{}),
+		Name:             modelType.Name(),
+		ModelType:        modelType,
+		Table:            tableName,
+		FieldsByName:     map[string]*Field{},
+		FieldsByBindName: map[string]*Field{},
+		FieldsByDBName:   map[string]*Field{},
+		Relationships:    Relationships{Relations: map[string]*Relationship{}},
+		cacheStore:       cacheStore,
+		namer:            namer,
+		initialized:      make(chan struct{}),
 	}
 	// When the schema initialization is completed, the channel will be closed
 	defer close(schema.initialized)
@@ -176,6 +200,7 @@ func ParseWithSpecialTableName(dest interface{}, cacheStore *sync.Map, namer Nam
 			field.DBName = namer.ColumnName(schema.Table, field.Name)
 		}
 
+		bindName := field.BindName()
 		if field.DBName != "" {
 			// nonexistence or shortest path or first appear prioritized if has permission
 			if v, ok := schema.FieldsByDBName[field.DBName]; !ok || ((field.Creatable || field.Updatable || field.Readable) && len(field.BindNames) < len(v.BindNames)) {
@@ -184,6 +209,7 @@ func ParseWithSpecialTableName(dest interface{}, cacheStore *sync.Map, namer Nam
 				}
 				schema.FieldsByDBName[field.DBName] = field
 				schema.FieldsByName[field.Name] = field
+				schema.FieldsByBindName[bindName] = field
 
 				if v != nil && v.PrimaryKey {
 					for idx, f := range schema.PrimaryFields {
@@ -202,6 +228,9 @@ func ParseWithSpecialTableName(dest interface{}, cacheStore *sync.Map, namer Nam
 		if of, ok := schema.FieldsByName[field.Name]; !ok || of.TagSettings["-"] == "-" {
 			schema.FieldsByName[field.Name] = field
 		}
+		if of, ok := schema.FieldsByBindName[bindName]; !ok || of.TagSettings["-"] == "-" {
+			schema.FieldsByBindName[bindName] = field
+		}
 
 		field.setupValuerAndSetter()
 	}
@@ -293,6 +322,7 @@ func ParseWithSpecialTableName(dest interface{}, cacheStore *sync.Map, namer Nam
 					return schema, schema.err
 				} else {
 					schema.FieldsByName[field.Name] = field
+					schema.FieldsByBindName[field.BindName()] = field
 				}
 			}
 
