diff --git a/prometheus/benchmark_test.go b/prometheus/benchmark_test.go
index 046efd0..4a05721 100644
--- a/prometheus/benchmark_test.go
+++ b/prometheus/benchmark_test.go
@@ -18,94 +18,18 @@ import (
 	"testing"
 )
 
-func BenchmarkCounter(b *testing.B) {
-	type fns []func(*CounterVec) Counter
-
-	twoConstraint := func(_ string) string {
-		return "two"
-	}
-
-	deLV := func(m *CounterVec) Counter {
-		return m.WithLabelValues("eins", "zwei", "drei")
-	}
-	frLV := func(m *CounterVec) Counter {
-		return m.WithLabelValues("une", "deux", "trois")
-	}
-	nlLV := func(m *CounterVec) Counter {
-		return m.WithLabelValues("een", "twee", "drie")
-	}
-
-	deML := func(m *CounterVec) Counter {
-		return m.With(Labels{"two": "zwei", "one": "eins", "three": "drei"})
-	}
-	frML := func(m *CounterVec) Counter {
-		return m.With(Labels{"two": "deux", "one": "une", "three": "trois"})
-	}
-	nlML := func(m *CounterVec) Counter {
-		return m.With(Labels{"two": "twee", "one": "een", "three": "drie"})
-	}
-
-	deLabels := Labels{"two": "zwei", "one": "eins", "three": "drei"}
-	dePML := func(m *CounterVec) Counter {
-		return m.With(deLabels)
-	}
-	frLabels := Labels{"two": "deux", "one": "une", "three": "trois"}
-	frPML := func(m *CounterVec) Counter {
-		return m.With(frLabels)
-	}
-	nlLabels := Labels{"two": "twee", "one": "een", "three": "drie"}
-	nlPML := func(m *CounterVec) Counter {
-		return m.With(nlLabels)
-	}
-
-	table := []struct {
-		name       string
-		constraint LabelConstraint
-		counters   fns
-	}{
-		{"With Label Values", nil, fns{deLV}},
-		{"With Label Values and Constraint", twoConstraint, fns{deLV}},
-		{"With triple Label Values", nil, fns{deLV, frLV, nlLV}},
-		{"With triple Label Values and Constraint", twoConstraint, fns{deLV, frLV, nlLV}},
-		{"With repeated Label Values", nil, fns{deLV, deLV}},
-		{"With repeated Label Values and Constraint", twoConstraint, fns{deLV, deLV}},
-		{"With Mapped Labels", nil, fns{deML}},
-		{"With Mapped Labels and Constraint", twoConstraint, fns{deML}},
-		{"With triple Mapped Labels", nil, fns{deML, frML, nlML}},
-		{"With triple Mapped Labels and Constraint", twoConstraint, fns{deML, frML, nlML}},
-		{"With repeated Mapped Labels", nil, fns{deML, deML}},
-		{"With repeated Mapped Labels and Constraint", twoConstraint, fns{deML, deML}},
-		{"With Prepared Mapped Labels", nil, fns{dePML}},
-		{"With Prepared Mapped Labels and Constraint", twoConstraint, fns{dePML}},
-		{"With triple Prepared Mapped Labels", nil, fns{dePML, frPML, nlPML}},
-		{"With triple Prepared Mapped Labels and Constraint", twoConstraint, fns{dePML, frPML, nlPML}},
-		{"With repeated Prepared Mapped Labels", nil, fns{dePML, dePML}},
-		{"With repeated Prepared Mapped Labels and Constraint", twoConstraint, fns{dePML, dePML}},
-	}
-
-	for _, t := range table {
-		b.Run(t.name, func(b *testing.B) {
-			m := V2.NewCounterVec(
-				CounterVecOpts{
-					CounterOpts: CounterOpts{
-						Name: "benchmark_counter",
-						Help: "A counter to benchmark it.",
-					},
-					VariableLabels: ConstrainedLabels{
-						ConstrainedLabel{Name: "one"},
-						ConstrainedLabel{Name: "two", Constraint: t.constraint},
-						ConstrainedLabel{Name: "three"},
-					},
-				},
-			)
-			b.ReportAllocs()
-			b.ResetTimer()
-			for i := 0; i < b.N; i++ {
-				for _, fn := range t.counters {
-					fn(m).Inc()
-				}
-			}
-		})
+func BenchmarkCounterWithLabelValues(b *testing.B) {
+	m := NewCounterVec(
+		CounterOpts{
+			Name: "benchmark_counter",
+			Help: "A counter to benchmark it.",
+		},
+		[]string{"one", "two", "three"},
+	)
+	b.ReportAllocs()
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		m.WithLabelValues("eins", "zwei", "drei").Inc()
 	}
 }
 
@@ -132,6 +56,37 @@ func BenchmarkCounterWithLabelValuesConcurrent(b *testing.B) {
 	wg.Wait()
 }
 
+func BenchmarkCounterWithMappedLabels(b *testing.B) {
+	m := NewCounterVec(
+		CounterOpts{
+			Name: "benchmark_counter",
+			Help: "A counter to benchmark it.",
+		},
+		[]string{"one", "two", "three"},
+	)
+	b.ReportAllocs()
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		m.With(Labels{"two": "zwei", "one": "eins", "three": "drei"}).Inc()
+	}
+}
+
+func BenchmarkCounterWithPreparedMappedLabels(b *testing.B) {
+	m := NewCounterVec(
+		CounterOpts{
+			Name: "benchmark_counter",
+			Help: "A counter to benchmark it.",
+		},
+		[]string{"one", "two", "three"},
+	)
+	b.ReportAllocs()
+	b.ResetTimer()
+	labels := Labels{"two": "zwei", "one": "eins", "three": "drei"}
+	for i := 0; i < b.N; i++ {
+		m.With(labels).Inc()
+	}
+}
+
 func BenchmarkCounterNoLabels(b *testing.B) {
 	m := NewCounter(CounterOpts{
 		Name: "benchmark_counter",
diff --git a/prometheus/counter.go b/prometheus/counter.go
index d8ade9b..62de4dc 100644
--- a/prometheus/counter.go
+++ b/prometheus/counter.go
@@ -202,8 +202,8 @@ func (v2) NewCounterVec(opts CounterVecOpts) *CounterVec {
 	)
 	return &CounterVec{
 		MetricVec: NewMetricVec(desc, func(lvs ...string) Metric {
-			if len(lvs) != len(desc.variableLabels.names) {
-				panic(makeInconsistentCardinalityError(desc.fqName, desc.variableLabels.names, lvs))
+			if len(lvs) != len(desc.variableLabels) {
+				panic(makeInconsistentCardinalityError(desc.fqName, desc.variableLabels.labelNames(), lvs))
 			}
 			result := &counter{desc: desc, labelPairs: MakeLabelPairs(desc, lvs), now: time.Now}
 			result.init(result) // Init self-collection.
diff --git a/prometheus/desc.go b/prometheus/desc.go
index 68ffe3c..deedc2d 100644
--- a/prometheus/desc.go
+++ b/prometheus/desc.go
@@ -52,7 +52,7 @@ type Desc struct {
 	constLabelPairs []*dto.LabelPair
 	// variableLabels contains names of labels and normalization function for
 	// which the metric maintains variable values.
-	variableLabels *compiledLabels
+	variableLabels ConstrainedLabels
 	// id is a hash of the values of the ConstLabels and fqName. This
 	// must be unique among all registered descriptors and can therefore be
 	// used as an identifier of the descriptor.
@@ -93,7 +93,7 @@ func (v2) NewDesc(fqName, help string, variableLabels ConstrainableLabels, const
 	d := &Desc{
 		fqName:         fqName,
 		help:           help,
-		variableLabels: variableLabels.compile(),
+		variableLabels: variableLabels.constrainedLabels(),
 	}
 	if !model.IsValidMetricName(model.LabelValue(fqName)) {
 		d.err = fmt.Errorf("%q is not a valid metric name", fqName)
@@ -103,7 +103,7 @@ func (v2) NewDesc(fqName, help string, variableLabels ConstrainableLabels, const
 	// their sorted label names) plus the fqName (at position 0).
 	labelValues := make([]string, 1, len(constLabels)+1)
 	labelValues[0] = fqName
-	labelNames := make([]string, 0, len(constLabels)+len(d.variableLabels.names))
+	labelNames := make([]string, 0, len(constLabels)+len(d.variableLabels))
 	labelNameSet := map[string]struct{}{}
 	// First add only the const label names and sort them...
 	for labelName := range constLabels {
@@ -128,13 +128,13 @@ func (v2) NewDesc(fqName, help string, variableLabels ConstrainableLabels, const
 	// Now add the variable label names, but prefix them with something that
 	// cannot be in a regular label name. That prevents matching the label
 	// dimension with a different mix between preset and variable labels.
-	for _, label := range d.variableLabels.names {
-		if !checkLabelName(label) {
-			d.err = fmt.Errorf("%q is not a valid label name for metric %q", label, fqName)
+	for _, label := range d.variableLabels {
+		if !checkLabelName(label.Name) {
+			d.err = fmt.Errorf("%q is not a valid label name for metric %q", label.Name, fqName)
 			return d
 		}
-		labelNames = append(labelNames, "$"+label)
-		labelNameSet[label] = struct{}{}
+		labelNames = append(labelNames, "$"+label.Name)
+		labelNameSet[label.Name] = struct{}{}
 	}
 	if len(labelNames) != len(labelNameSet) {
 		d.err = fmt.Errorf("duplicate label names in constant and variable labels for metric %q", fqName)
@@ -189,19 +189,11 @@ func (d *Desc) String() string {
 			fmt.Sprintf("%s=%q", lp.GetName(), lp.GetValue()),
 		)
 	}
-	vlStrings := make([]string, 0, len(d.variableLabels.names))
-	for _, vl := range d.variableLabels.names {
-		if fn, ok := d.variableLabels.labelConstraints[vl]; ok && fn != nil {
-			vlStrings = append(vlStrings, fmt.Sprintf("c(%s)", vl))
-		} else {
-			vlStrings = append(vlStrings, vl)
-		}
-	}
 	return fmt.Sprintf(
-		"Desc{fqName: %q, help: %q, constLabels: {%s}, variableLabels: {%s}}",
+		"Desc{fqName: %q, help: %q, constLabels: {%s}, variableLabels: %v}",
 		d.fqName,
 		d.help,
 		strings.Join(lpStrings, ","),
-		strings.Join(vlStrings, ","),
+		d.variableLabels,
 	)
 }
diff --git a/prometheus/examples_test.go b/prometheus/examples_test.go
index f15c340..d52a718 100644
--- a/prometheus/examples_test.go
+++ b/prometheus/examples_test.go
@@ -292,9 +292,9 @@ func ExampleRegister() {
 
 	// Output:
 	// taskCounter registered.
-	// taskCounterVec not registered: a previously registered descriptor with the same fully-qualified name as Desc{fqName: "worker_pool_completed_tasks_total", help: "Total number of tasks completed.", constLabels: {}, variableLabels: {worker_id}} has different label names or a different help string
+	// taskCounterVec not registered: a previously registered descriptor with the same fully-qualified name as Desc{fqName: "worker_pool_completed_tasks_total", help: "Total number of tasks completed.", constLabels: {}, variableLabels: [{worker_id <nil>}]} has different label names or a different help string
 	// taskCounter unregistered.
-	// taskCounterVec not registered: a previously registered descriptor with the same fully-qualified name as Desc{fqName: "worker_pool_completed_tasks_total", help: "Total number of tasks completed.", constLabels: {}, variableLabels: {worker_id}} has different label names or a different help string
+	// taskCounterVec not registered: a previously registered descriptor with the same fully-qualified name as Desc{fqName: "worker_pool_completed_tasks_total", help: "Total number of tasks completed.", constLabels: {}, variableLabels: [{worker_id <nil>}]} has different label names or a different help string
 	// taskCounterVec registered.
 	// Worker initialization failed: inconsistent label cardinality: expected 1 label values but got 2 in []string{"42", "spurious arg"}
 	// notMyCounter is nil.
diff --git a/prometheus/expvar_collector.go b/prometheus/expvar_collector.go
index de5a856..c41ab37 100644
--- a/prometheus/expvar_collector.go
+++ b/prometheus/expvar_collector.go
@@ -48,7 +48,7 @@ func (e *expvarCollector) Collect(ch chan<- Metric) {
 			continue
 		}
 		var v interface{}
-		labels := make([]string, len(desc.variableLabels.names))
+		labels := make([]string, len(desc.variableLabels))
 		if err := json.Unmarshal([]byte(expVar.String()), &v); err != nil {
 			ch <- NewInvalidMetric(desc, err)
 			continue
diff --git a/prometheus/gauge.go b/prometheus/gauge.go
index d2bce21..f1ea6c7 100644
--- a/prometheus/gauge.go
+++ b/prometheus/gauge.go
@@ -166,8 +166,8 @@ func (v2) NewGaugeVec(opts GaugeVecOpts) *GaugeVec {
 	)
 	return &GaugeVec{
 		MetricVec: NewMetricVec(desc, func(lvs ...string) Metric {
-			if len(lvs) != len(desc.variableLabels.names) {
-				panic(makeInconsistentCardinalityError(desc.fqName, desc.variableLabels.names, lvs))
+			if len(lvs) != len(desc.variableLabels) {
+				panic(makeInconsistentCardinalityError(desc.fqName, desc.variableLabels.labelNames(), lvs))
 			}
 			result := &gauge{desc: desc, labelPairs: MakeLabelPairs(desc, lvs)}
 			result.init(result) // Init self-collection.
diff --git a/prometheus/gauge_test.go b/prometheus/gauge_test.go
index f35889a..b70da7d 100644
--- a/prometheus/gauge_test.go
+++ b/prometheus/gauge_test.go
@@ -170,7 +170,7 @@ func TestGaugeFunc(t *testing.T) {
 		func() float64 { return 3.1415 },
 	)
 
-	if expected, got := `Desc{fqName: "test_name", help: "test help", constLabels: {a="1",b="2"}, variableLabels: {}}`, gf.Desc().String(); expected != got {
+	if expected, got := `Desc{fqName: "test_name", help: "test help", constLabels: {a="1",b="2"}, variableLabels: []}`, gf.Desc().String(); expected != got {
 		t.Errorf("expected %q, got %q", expected, got)
 	}
 
diff --git a/prometheus/histogram.go b/prometheus/histogram.go
index eaf4a49..8d818af 100644
--- a/prometheus/histogram.go
+++ b/prometheus/histogram.go
@@ -499,12 +499,12 @@ func NewHistogram(opts HistogramOpts) Histogram {
 }
 
 func newHistogram(desc *Desc, opts HistogramOpts, labelValues ...string) Histogram {
-	if len(desc.variableLabels.names) != len(labelValues) {
-		panic(makeInconsistentCardinalityError(desc.fqName, desc.variableLabels.names, labelValues))
+	if len(desc.variableLabels) != len(labelValues) {
+		panic(makeInconsistentCardinalityError(desc.fqName, desc.variableLabels.labelNames(), labelValues))
 	}
 
-	for _, n := range desc.variableLabels.names {
-		if n == bucketLabel {
+	for _, n := range desc.variableLabels {
+		if n.Name == bucketLabel {
 			panic(errBucketLabelNotAllowed)
 		}
 	}
@@ -1230,7 +1230,7 @@ func NewConstHistogram(
 	if desc.err != nil {
 		return nil, desc.err
 	}
-	if err := validateLabelValues(labelValues, len(desc.variableLabels.names)); err != nil {
+	if err := validateLabelValues(labelValues, len(desc.variableLabels)); err != nil {
 		return nil, err
 	}
 	return &constHistogram{
diff --git a/prometheus/labels.go b/prometheus/labels.go
index b3c4eca..63ff868 100644
--- a/prometheus/labels.go
+++ b/prometheus/labels.go
@@ -32,15 +32,19 @@ import (
 // create a Desc.
 type Labels map[string]string
 
-// LabelConstraint normalizes label values.
-type LabelConstraint func(string) string
-
 // ConstrainedLabels represents a label name and its constrain function
 // to normalize label values. This type is commonly used when constructing
 // metric vector Collectors.
 type ConstrainedLabel struct {
 	Name       string
-	Constraint LabelConstraint
+	Constraint func(string) string
+}
+
+func (cl ConstrainedLabel) Constrain(v string) string {
+	if cl.Constraint == nil {
+		return v
+	}
+	return cl.Constraint(v)
 }
 
 // ConstrainableLabels is an interface that allows creating of labels that can
@@ -54,7 +58,7 @@ type ConstrainedLabel struct {
 //	  },
 //	})
 type ConstrainableLabels interface {
-	compile() *compiledLabels
+	constrainedLabels() ConstrainedLabels
 	labelNames() []string
 }
 
@@ -63,20 +67,8 @@ type ConstrainableLabels interface {
 // metric vector Collectors.
 type ConstrainedLabels []ConstrainedLabel
 
-func (cls ConstrainedLabels) compile() *compiledLabels {
-	compiled := &compiledLabels{
-		names:            make([]string, len(cls)),
-		labelConstraints: map[string]LabelConstraint{},
-	}
-
-	for i, label := range cls {
-		compiled.names[i] = label.Name
-		if label.Constraint != nil {
-			compiled.labelConstraints[label.Name] = label.Constraint
-		}
-	}
-
-	return compiled
+func (cls ConstrainedLabels) constrainedLabels() ConstrainedLabels {
+	return cls
 }
 
 func (cls ConstrainedLabels) labelNames() []string {
@@ -100,36 +92,18 @@ func (cls ConstrainedLabels) labelNames() []string {
 //	}
 type UnconstrainedLabels []string
 
-func (uls UnconstrainedLabels) compile() *compiledLabels {
-	return &compiledLabels{
-		names: uls,
+func (uls UnconstrainedLabels) constrainedLabels() ConstrainedLabels {
+	constrainedLabels := make([]ConstrainedLabel, len(uls))
+	for i, l := range uls {
+		constrainedLabels[i] = ConstrainedLabel{Name: l}
 	}
+	return constrainedLabels
 }
 
 func (uls UnconstrainedLabels) labelNames() []string {
 	return uls
 }
 
-type compiledLabels struct {
-	names            []string
-	labelConstraints map[string]LabelConstraint
-}
-
-func (cls *compiledLabels) compile() *compiledLabels {
-	return cls
-}
-
-func (cls *compiledLabels) labelNames() []string {
-	return cls.names
-}
-
-func (cls *compiledLabels) constrain(labelName, value string) string {
-	if fn, ok := cls.labelConstraints[labelName]; ok && fn != nil {
-		return fn(value)
-	}
-	return value
-}
-
 // reservedLabelPrefix is a prefix which is not legal in user-supplied
 // label names.
 const reservedLabelPrefix = "__"
diff --git a/prometheus/promhttp/http_test.go b/prometheus/promhttp/http_test.go
index 8ca1927..36d231a 100644
--- a/prometheus/promhttp/http_test.go
+++ b/prometheus/promhttp/http_test.go
@@ -128,11 +128,11 @@ func TestHandlerErrorHandling(t *testing.T) {
 		t.Fatalf("unexpected number of done invokes, want 0, got %d", got)
 	}
 
-	wantMsg := `error gathering metrics: error collecting metric Desc{fqName: "invalid_metric", help: "not helpful", constLabels: {}, variableLabels: {}}: collect error
+	wantMsg := `error gathering metrics: error collecting metric Desc{fqName: "invalid_metric", help: "not helpful", constLabels: {}, variableLabels: []}: collect error
 `
 	wantErrorBody := `An error has occurred while serving metrics:
 
-error collecting metric Desc{fqName: "invalid_metric", help: "not helpful", constLabels: {}, variableLabels: {}}: collect error
+error collecting metric Desc{fqName: "invalid_metric", help: "not helpful", constLabels: {}, variableLabels: []}: collect error
 `
 	wantOKBody1 := `# HELP name docstring
 # TYPE name counter
diff --git a/prometheus/registry.go b/prometheus/registry.go
index 22d6f99..44da943 100644
--- a/prometheus/registry.go
+++ b/prometheus/registry.go
@@ -963,9 +963,9 @@ func checkDescConsistency(
 	// Is the desc consistent with the content of the metric?
 	lpsFromDesc := make([]*dto.LabelPair, len(desc.constLabelPairs), len(dtoMetric.Label))
 	copy(lpsFromDesc, desc.constLabelPairs)
-	for _, l := range desc.variableLabels.names {
+	for _, l := range desc.variableLabels {
 		lpsFromDesc = append(lpsFromDesc, &dto.LabelPair{
-			Name: proto.String(l),
+			Name: proto.String(l.Name),
 		})
 	}
 	if len(lpsFromDesc) != len(dtoMetric.Label) {
diff --git a/prometheus/summary.go b/prometheus/summary.go
index 440f29e..dd35926 100644
--- a/prometheus/summary.go
+++ b/prometheus/summary.go
@@ -188,12 +188,12 @@ func NewSummary(opts SummaryOpts) Summary {
 }
 
 func newSummary(desc *Desc, opts SummaryOpts, labelValues ...string) Summary {
-	if len(desc.variableLabels.names) != len(labelValues) {
-		panic(makeInconsistentCardinalityError(desc.fqName, desc.variableLabels.names, labelValues))
+	if len(desc.variableLabels) != len(labelValues) {
+		panic(makeInconsistentCardinalityError(desc.fqName, desc.variableLabels.labelNames(), labelValues))
 	}
 
-	for _, n := range desc.variableLabels.names {
-		if n == quantileLabel {
+	for _, n := range desc.variableLabels {
+		if n.Name == quantileLabel {
 			panic(errQuantileLabelNotAllowed)
 		}
 	}
@@ -737,7 +737,7 @@ func NewConstSummary(
 	if desc.err != nil {
 		return nil, desc.err
 	}
-	if err := validateLabelValues(labelValues, len(desc.variableLabels.names)); err != nil {
+	if err := validateLabelValues(labelValues, len(desc.variableLabels)); err != nil {
 		return nil, err
 	}
 	return &constSummary{
diff --git a/prometheus/value.go b/prometheus/value.go
index 4bf5727..5f6bb80 100644
--- a/prometheus/value.go
+++ b/prometheus/value.go
@@ -105,7 +105,7 @@ func NewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues
 	if desc.err != nil {
 		return nil, desc.err
 	}
-	if err := validateLabelValues(labelValues, len(desc.variableLabels.names)); err != nil {
+	if err := validateLabelValues(labelValues, len(desc.variableLabels)); err != nil {
 		return nil, err
 	}
 
@@ -176,19 +176,19 @@ func populateMetric(
 // This function is only needed for custom Metric implementations. See MetricVec
 // example.
 func MakeLabelPairs(desc *Desc, labelValues []string) []*dto.LabelPair {
-	totalLen := len(desc.variableLabels.names) + len(desc.constLabelPairs)
+	totalLen := len(desc.variableLabels) + len(desc.constLabelPairs)
 	if totalLen == 0 {
 		// Super fast path.
 		return nil
 	}
-	if len(desc.variableLabels.names) == 0 {
+	if len(desc.variableLabels) == 0 {
 		// Moderately fast path.
 		return desc.constLabelPairs
 	}
 	labelPairs := make([]*dto.LabelPair, 0, totalLen)
-	for i, l := range desc.variableLabels.names {
+	for i, l := range desc.variableLabels {
 		labelPairs = append(labelPairs, &dto.LabelPair{
-			Name:  proto.String(l),
+			Name:  proto.String(l.Name),
 			Value: proto.String(labelValues[i]),
 		})
 	}
diff --git a/prometheus/vec.go b/prometheus/vec.go
index 955cfd5..f0d0015 100644
--- a/prometheus/vec.go
+++ b/prometheus/vec.go
@@ -20,6 +20,24 @@ import (
 	"github.com/prometheus/common/model"
 )
 
+var labelsPool = &sync.Pool{
+	New: func() interface{} {
+		return make(Labels)
+	},
+}
+
+func getLabelsFromPool() Labels {
+	return labelsPool.Get().(Labels)
+}
+
+func putLabelsToPool(labels Labels) {
+	for k := range labels {
+		delete(labels, k)
+	}
+
+	labelsPool.Put(labels)
+}
+
 // MetricVec is a Collector to bundle metrics of the same name that differ in
 // their label values. MetricVec is not used directly but as a building block
 // for implementations of vectors of a given metric type, like GaugeVec,
@@ -73,7 +91,6 @@ func NewMetricVec(desc *Desc, newMetric func(lvs ...string) Metric) *MetricVec {
 // See also the CounterVec example.
 func (m *MetricVec) DeleteLabelValues(lvs ...string) bool {
 	lvs = constrainLabelValues(m.desc, lvs, m.curry)
-
 	h, err := m.hashLabelValues(lvs)
 	if err != nil {
 		return false
@@ -93,8 +110,8 @@ func (m *MetricVec) DeleteLabelValues(lvs ...string) bool {
 // This method is used for the same purpose as DeleteLabelValues(...string). See
 // there for pros and cons of the two methods.
 func (m *MetricVec) Delete(labels Labels) bool {
-	labels, closer := constrainLabels(m.desc, labels)
-	defer closer()
+	labels = constrainLabels(m.desc, labels)
+	defer putLabelsToPool(labels)
 
 	h, err := m.hashLabels(labels)
 	if err != nil {
@@ -111,8 +128,8 @@ func (m *MetricVec) Delete(labels Labels) bool {
 // Note that curried labels will never be matched if deleting from the curried vector.
 // To match curried labels with DeletePartialMatch, it must be called on the base vector.
 func (m *MetricVec) DeletePartialMatch(labels Labels) int {
-	labels, closer := constrainLabels(m.desc, labels)
-	defer closer()
+	labels = constrainLabels(m.desc, labels)
+	defer putLabelsToPool(labels)
 
 	return m.metricMap.deleteByLabels(labels, m.curry)
 }
@@ -152,11 +169,11 @@ func (m *MetricVec) CurryWith(labels Labels) (*MetricVec, error) {
 		oldCurry = m.curry
 		iCurry   int
 	)
-	for i, labelName := range m.desc.variableLabels.names {
-		val, ok := labels[labelName]
+	for i, label := range m.desc.variableLabels {
+		val, ok := labels[label.Name]
 		if iCurry < len(oldCurry) && oldCurry[iCurry].index == i {
 			if ok {
-				return nil, fmt.Errorf("label name %q is already curried", labelName)
+				return nil, fmt.Errorf("label name %q is already curried", label.Name)
 			}
 			newCurry = append(newCurry, oldCurry[iCurry])
 			iCurry++
@@ -164,10 +181,7 @@ func (m *MetricVec) CurryWith(labels Labels) (*MetricVec, error) {
 			if !ok {
 				continue // Label stays uncurried.
 			}
-			newCurry = append(newCurry, curriedLabelValue{
-				i,
-				m.desc.variableLabels.constrain(labelName, val),
-			})
+			newCurry = append(newCurry, curriedLabelValue{i, label.Constrain(val)})
 		}
 	}
 	if l := len(oldCurry) + len(labels) - len(newCurry); l > 0 {
@@ -236,8 +250,8 @@ func (m *MetricVec) GetMetricWithLabelValues(lvs ...string) (Metric, error) {
 // around MetricVec, implementing a vector for a specific Metric implementation,
 // for example GaugeVec.
 func (m *MetricVec) GetMetricWith(labels Labels) (Metric, error) {
-	labels, closer := constrainLabels(m.desc, labels)
-	defer closer()
+	labels = constrainLabels(m.desc, labels)
+	defer putLabelsToPool(labels)
 
 	h, err := m.hashLabels(labels)
 	if err != nil {
@@ -248,7 +262,7 @@ func (m *MetricVec) GetMetricWith(labels Labels) (Metric, error) {
 }
 
 func (m *MetricVec) hashLabelValues(vals []string) (uint64, error) {
-	if err := validateLabelValues(vals, len(m.desc.variableLabels.names)-len(m.curry)); err != nil {
+	if err := validateLabelValues(vals, len(m.desc.variableLabels)-len(m.curry)); err != nil {
 		return 0, err
 	}
 
@@ -257,7 +271,7 @@ func (m *MetricVec) hashLabelValues(vals []string) (uint64, error) {
 		curry         = m.curry
 		iVals, iCurry int
 	)
-	for i := 0; i < len(m.desc.variableLabels.names); i++ {
+	for i := 0; i < len(m.desc.variableLabels); i++ {
 		if iCurry < len(curry) && curry[iCurry].index == i {
 			h = m.hashAdd(h, curry[iCurry].value)
 			iCurry++
@@ -271,7 +285,7 @@ func (m *MetricVec) hashLabelValues(vals []string) (uint64, error) {
 }
 
 func (m *MetricVec) hashLabels(labels Labels) (uint64, error) {
-	if err := validateValuesInLabels(labels, len(m.desc.variableLabels.names)-len(m.curry)); err != nil {
+	if err := validateValuesInLabels(labels, len(m.desc.variableLabels)-len(m.curry)); err != nil {
 		return 0, err
 	}
 
@@ -280,17 +294,17 @@ func (m *MetricVec) hashLabels(labels Labels) (uint64, error) {
 		curry  = m.curry
 		iCurry int
 	)
-	for i, labelName := range m.desc.variableLabels.names {
-		val, ok := labels[labelName]
+	for i, label := range m.desc.variableLabels {
+		val, ok := labels[label.Name]
 		if iCurry < len(curry) && curry[iCurry].index == i {
 			if ok {
-				return 0, fmt.Errorf("label name %q is already curried", labelName)
+				return 0, fmt.Errorf("label name %q is already curried", label.Name)
 			}
 			h = m.hashAdd(h, curry[iCurry].value)
 			iCurry++
 		} else {
 			if !ok {
-				return 0, fmt.Errorf("label name %q missing in label map", labelName)
+				return 0, fmt.Errorf("label name %q missing in label map", label.Name)
 			}
 			h = m.hashAdd(h, val)
 		}
@@ -468,7 +482,7 @@ func valueMatchesVariableOrCurriedValue(targetValue string, index int, values []
 func matchPartialLabels(desc *Desc, values []string, labels Labels, curry []curriedLabelValue) bool {
 	for l, v := range labels {
 		// Check if the target label exists in our metrics and get the index.
-		varLabelIndex, validLabel := indexOf(l, desc.variableLabels.names)
+		varLabelIndex, validLabel := indexOf(l, desc.variableLabels.labelNames())
 		if validLabel {
 			// Check the value of that label against the target value.
 			// We don't consider curried values in partial matches.
@@ -612,7 +626,7 @@ func matchLabels(desc *Desc, values []string, labels Labels, curry []curriedLabe
 		return false
 	}
 	iCurry := 0
-	for i, k := range desc.variableLabels.names {
+	for i, k := range desc.variableLabels {
 		if iCurry < len(curry) && curry[iCurry].index == i {
 			if values[i] != curry[iCurry].value {
 				return false
@@ -620,7 +634,7 @@ func matchLabels(desc *Desc, values []string, labels Labels, curry []curriedLabe
 			iCurry++
 			continue
 		}
-		if values[i] != labels[k] {
+		if values[i] != labels[k.Name] {
 			return false
 		}
 	}
@@ -630,13 +644,13 @@ func matchLabels(desc *Desc, values []string, labels Labels, curry []curriedLabe
 func extractLabelValues(desc *Desc, labels Labels, curry []curriedLabelValue) []string {
 	labelValues := make([]string, len(labels)+len(curry))
 	iCurry := 0
-	for i, k := range desc.variableLabels.names {
+	for i, k := range desc.variableLabels {
 		if iCurry < len(curry) && curry[iCurry].index == i {
 			labelValues[i] = curry[iCurry].value
 			iCurry++
 			continue
 		}
-		labelValues[i] = labels[k]
+		labelValues[i] = labels[k.Name]
 	}
 	return labelValues
 }
@@ -656,37 +670,20 @@ func inlineLabelValues(lvs []string, curry []curriedLabelValue) []string {
 	return labelValues
 }
 
-var labelsPool = &sync.Pool{
-	New: func() interface{} {
-		return make(Labels)
-	},
-}
-
-func constrainLabels(desc *Desc, labels Labels) (Labels, func()) {
-	if len(desc.variableLabels.labelConstraints) == 0 {
-		// Fast path when there's no constraints
-		return labels, func() {}
-	}
-
-	constrainedLabels := labelsPool.Get().(Labels)
+func constrainLabels(desc *Desc, labels Labels) Labels {
+	constrainedLabels := getLabelsFromPool()
 	for l, v := range labels {
-		constrainedLabels[l] = desc.variableLabels.constrain(l, v)
-	}
-
-	return constrainedLabels, func() {
-		for k := range constrainedLabels {
-			delete(constrainedLabels, k)
+		if i, ok := indexOf(l, desc.variableLabels.labelNames()); ok {
+			v = desc.variableLabels[i].Constrain(v)
 		}
-		labelsPool.Put(constrainedLabels)
+
+		constrainedLabels[l] = v
 	}
+
+	return constrainedLabels
 }
 
 func constrainLabelValues(desc *Desc, lvs []string, curry []curriedLabelValue) []string {
-	if len(desc.variableLabels.labelConstraints) == 0 {
-		// Fast path when there's no constraints
-		return lvs
-	}
-
 	constrainedValues := make([]string, len(lvs))
 	var iCurry, iLVs int
 	for i := 0; i < len(lvs)+len(curry); i++ {
@@ -695,11 +692,8 @@ func constrainLabelValues(desc *Desc, lvs []string, curry []curriedLabelValue) [
 			continue
 		}
 
-		if i < len(desc.variableLabels.names) {
-			constrainedValues[iLVs] = desc.variableLabels.constrain(
-				desc.variableLabels.names[i],
-				lvs[iLVs],
-			)
+		if i < len(desc.variableLabels) {
+			constrainedValues[iLVs] = desc.variableLabels[i].Constrain(lvs[iLVs])
 		} else {
 			constrainedValues[iLVs] = lvs[iLVs]
 		}
