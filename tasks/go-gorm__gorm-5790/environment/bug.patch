diff --git a/callbacks/query.go b/callbacks/query.go
index 6793676..26ee8c3 100644
--- a/callbacks/query.go
+++ b/callbacks/query.go
@@ -117,20 +117,12 @@ func BuildQuerySQL(db *gorm.DB) {
 				} else if relation, ok := db.Statement.Schema.Relationships.Relations[join.Name]; ok {
 					tableAliasName := relation.Name
 
-					columnStmt := gorm.Statement{
-						Table: tableAliasName, DB: db, Schema: relation.FieldSchema,
-						Selects: join.Selects, Omits: join.Omits,
-					}
-
-					selectColumns, restricted := columnStmt.SelectAndOmitColumns(false, false)
 					for _, s := range relation.FieldSchema.DBNames {
-						if v, ok := selectColumns[s]; (ok && v) || (!ok && !restricted) {
-							clauseSelect.Columns = append(clauseSelect.Columns, clause.Column{
-								Table: tableAliasName,
-								Name:  s,
-								Alias: tableAliasName + "__" + s,
-							})
-						}
+						clauseSelect.Columns = append(clauseSelect.Columns, clause.Column{
+							Table: tableAliasName,
+							Name:  s,
+							Alias: tableAliasName + "__" + s,
+						})
 					}
 
 					exprs := make([]clause.Expression, len(relation.References))
diff --git a/chainable_api.go b/chainable_api.go
index 6d48d56..ab3a1a3 100644
--- a/chainable_api.go
+++ b/chainable_api.go
@@ -10,11 +10,10 @@ import (
 )
 
 // Model specify the model you would like to run db operations
-//
-//	// update all users's name to `hello`
-//	db.Model(&User{}).Update("name", "hello")
-//	// if user's primary key is non-blank, will use it as condition, then will only update the user's name to `hello`
-//	db.Model(&user).Update("name", "hello")
+//    // update all users's name to `hello`
+//    db.Model(&User{}).Update("name", "hello")
+//    // if user's primary key is non-blank, will use it as condition, then will only update the user's name to `hello`
+//    db.Model(&user).Update("name", "hello")
 func (db *DB) Model(value interface{}) (tx *DB) {
 	tx = db.getInstance()
 	tx.Statement.Model = value
@@ -180,21 +179,18 @@ func (db *DB) Or(query interface{}, args ...interface{}) (tx *DB) {
 }
 
 // Joins specify Joins conditions
-//
-//	db.Joins("Account").Find(&user)
-//	db.Joins("JOIN emails ON emails.user_id = users.id AND emails.email = ?", "jinzhu@example.org").Find(&user)
-//	db.Joins("Account", DB.Select("id").Where("user_id = users.id AND name = ?", "someName").Model(&Account{}))
+//     db.Joins("Account").Find(&user)
+//     db.Joins("JOIN emails ON emails.user_id = users.id AND emails.email = ?", "jinzhu@example.org").Find(&user)
+//     db.Joins("Account", DB.Select("id").Where("user_id = users.id AND name = ?", "someName").Model(&Account{}))
 func (db *DB) Joins(query string, args ...interface{}) (tx *DB) {
 	tx = db.getInstance()
 
 	if len(args) == 1 {
 		if db, ok := args[0].(*DB); ok {
-			j := join{Name: query, Conds: args, Selects: db.Statement.Selects, Omits: db.Statement.Omits}
 			if where, ok := db.Statement.Clauses["WHERE"].Expression.(clause.Where); ok {
-				j.On = &where
+				tx.Statement.Joins = append(tx.Statement.Joins, join{Name: query, Conds: args, On: &where})
+				return
 			}
-			tx.Statement.Joins = append(tx.Statement.Joins, j)
-			return
 		}
 	}
 
@@ -223,9 +219,8 @@ func (db *DB) Having(query interface{}, args ...interface{}) (tx *DB) {
 }
 
 // Order specify order when retrieve records from database
-//
-//	db.Order("name DESC")
-//	db.Order(clause.OrderByColumn{Column: clause.Column{Name: "name"}, Desc: true})
+//     db.Order("name DESC")
+//     db.Order(clause.OrderByColumn{Column: clause.Column{Name: "name"}, Desc: true})
 func (db *DB) Order(value interface{}) (tx *DB) {
 	tx = db.getInstance()
 
@@ -261,18 +256,17 @@ func (db *DB) Offset(offset int) (tx *DB) {
 }
 
 // Scopes pass current database connection to arguments `func(DB) DB`, which could be used to add conditions dynamically
+//     func AmountGreaterThan1000(db *gorm.DB) *gorm.DB {
+//         return db.Where("amount > ?", 1000)
+//     }
 //
-//	func AmountGreaterThan1000(db *gorm.DB) *gorm.DB {
-//	    return db.Where("amount > ?", 1000)
-//	}
-//
-//	func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB {
-//	    return func (db *gorm.DB) *gorm.DB {
-//	        return db.Scopes(AmountGreaterThan1000).Where("status in (?)", status)
-//	    }
-//	}
+//     func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB {
+//         return func (db *gorm.DB) *gorm.DB {
+//             return db.Scopes(AmountGreaterThan1000).Where("status in (?)", status)
+//         }
+//     }
 //
-//	db.Scopes(AmountGreaterThan1000, OrderStatus([]string{"paid", "shipped"})).Find(&orders)
+//     db.Scopes(AmountGreaterThan1000, OrderStatus([]string{"paid", "shipped"})).Find(&orders)
 func (db *DB) Scopes(funcs ...func(*DB) *DB) (tx *DB) {
 	tx = db.getInstance()
 	tx.Statement.scopes = append(tx.Statement.scopes, funcs...)
@@ -280,8 +274,7 @@ func (db *DB) Scopes(funcs ...func(*DB) *DB) (tx *DB) {
 }
 
 // Preload preload associations with given conditions
-//
-//	db.Preload("Orders", "state NOT IN (?)", "cancelled").Find(&users)
+//    db.Preload("Orders", "state NOT IN (?)", "cancelled").Find(&users)
 func (db *DB) Preload(query string, args ...interface{}) (tx *DB) {
 	tx = db.getInstance()
 	if tx.Statement.Preloads == nil {
diff --git a/statement.go b/statement.go
index d4d20cb..d05d299 100644
--- a/statement.go
+++ b/statement.go
@@ -49,11 +49,9 @@ type Statement struct {
 }
 
 type join struct {
-	Name    string
-	Conds   []interface{}
-	On      *clause.Where
-	Selects []string
-	Omits   []string
+	Name  string
+	Conds []interface{}
+	On    *clause.Where
 }
 
 // StatementModifier statement modifier interface
@@ -546,9 +544,8 @@ func (stmt *Statement) clone() *Statement {
 }
 
 // SetColumn set column's value
-//
-//	stmt.SetColumn("Name", "jinzhu") // Hooks Method
-//	stmt.SetColumn("Name", "jinzhu", true) // Callbacks Method
+//   stmt.SetColumn("Name", "jinzhu") // Hooks Method
+//   stmt.SetColumn("Name", "jinzhu", true) // Callbacks Method
 func (stmt *Statement) SetColumn(name string, value interface{}, fromCallbacks ...bool) {
 	if v, ok := stmt.Dest.(map[string]interface{}); ok {
 		v[name] = value
diff --git a/tests/joins_test.go b/tests/joins_test.go
index 091fb98..7519db8 100644
--- a/tests/joins_test.go
+++ b/tests/joins_test.go
@@ -260,46 +260,3 @@ func TestJoinWithSameColumnName(t *testing.T) {
 		t.Fatalf("wrong pet name")
 	}
 }
-
-func TestJoinArgsWithDB(t *testing.T) {
-	user := *GetUser("joins-args-db", Config{Pets: 2})
-	DB.Save(&user)
-
-	// test where
-	var user1 User
-	onQuery := DB.Where(&Pet{Name: "joins-args-db_pet_2"})
-	if err := DB.Joins("NamedPet", onQuery).Where("users.name = ?", user.Name).First(&user1).Error; err != nil {
-		t.Fatalf("Failed to load with joins on, got error: %v", err)
-	}
-
-	AssertEqual(t, user1.NamedPet.Name, "joins-args-db_pet_2")
-
-	// test where and omit
-	onQuery2 := DB.Where(&Pet{Name: "joins-args-db_pet_2"}).Omit("Name")
-	var user2 User
-	if err := DB.Joins("NamedPet", onQuery2).Where("users.name = ?", user.Name).First(&user2).Error; err != nil {
-		t.Fatalf("Failed to load with joins on, got error: %v", err)
-	}
-	AssertEqual(t, user2.NamedPet.ID, user1.NamedPet.ID)
-	AssertEqual(t, user2.NamedPet.Name, "")
-
-	// test where and select
-	onQuery3 := DB.Where(&Pet{Name: "joins-args-db_pet_2"}).Select("Name")
-	var user3 User
-	if err := DB.Joins("NamedPet", onQuery3).Where("users.name = ?", user.Name).First(&user3).Error; err != nil {
-		t.Fatalf("Failed to load with joins on, got error: %v", err)
-	}
-	AssertEqual(t, user3.NamedPet.ID, 0)
-	AssertEqual(t, user3.NamedPet.Name, "joins-args-db_pet_2")
-
-	// test select
-	onQuery4 := DB.Select("ID")
-	var user4 User
-	if err := DB.Joins("NamedPet", onQuery4).Where("users.name = ?", user.Name).First(&user4).Error; err != nil {
-		t.Fatalf("Failed to load with joins on, got error: %v", err)
-	}
-	if user4.NamedPet.ID == 0 {
-		t.Fatal("Pet ID can not be empty")
-	}
-	AssertEqual(t, user4.NamedPet.Name, "")
-}
