diff --git a/log/json_logger.go b/log/json_logger.go
index 8950460..8907c8f 100644
--- a/log/json_logger.go
+++ b/log/json_logger.go
@@ -4,7 +4,6 @@ import (
 	"encoding/json"
 	"fmt"
 	"io"
-	"reflect"
 )
 
 type jsonLogger struct {
@@ -18,59 +17,29 @@ func NewJSONLogger(w io.Writer) Logger {
 }
 
 func (l *jsonLogger) Log(keyvals ...interface{}) error {
-	n := (len(keyvals) + 1) / 2 // +1 to handle case when len is odd
-	m := make(map[string]interface{}, n)
+	if len(keyvals)%2 == 1 {
+		panic("odd number of keyvals")
+	}
+	m := make(map[string]interface{}, len(keyvals)/2)
 	for i := 0; i < len(keyvals); i += 2 {
-		k := keyvals[i]
-		var v interface{} = ErrMissingValue
-		if i+1 < len(keyvals) {
-			v = keyvals[i+1]
-		}
-		merge(m, k, v)
+		merge(m, keyvals[i], keyvals[i+1])
 	}
 	return json.NewEncoder(l.Writer).Encode(m)
 }
 
-func merge(dst map[string]interface{}, k, v interface{}) {
+func merge(dst map[string]interface{}, k, v interface{}) map[string]interface{} {
 	var key string
 	switch x := k.(type) {
 	case string:
 		key = x
 	case fmt.Stringer:
-		key = safeString(x)
+		key = x.String()
 	default:
-		key = fmt.Sprint(x)
+		key = fmt.Sprintf("%v", x)
 	}
 	if x, ok := v.(error); ok {
-		v = safeError(x)
+		v = x.Error()
 	}
 	dst[key] = v
-}
-
-func safeString(str fmt.Stringer) (s string) {
-	defer func() {
-		if panicVal := recover(); panicVal != nil {
-			if v := reflect.ValueOf(str); v.Kind() == reflect.Ptr && v.IsNil() {
-				s = "NULL"
-			} else {
-				panic(panicVal)
-			}
-		}
-	}()
-	s = str.String()
-	return
-}
-
-func safeError(err error) (s interface{}) {
-	defer func() {
-		if panicVal := recover(); panicVal != nil {
-			if v := reflect.ValueOf(err); v.Kind() == reflect.Ptr && v.IsNil() {
-				s = nil
-			} else {
-				panic(panicVal)
-			}
-		}
-	}()
-	s = err.Error()
-	return
+	return dst
 }
diff --git a/log/json_logger_test.go b/log/json_logger_test.go
index 3a320f6..b668da4 100644
--- a/log/json_logger_test.go
+++ b/log/json_logger_test.go
@@ -10,67 +10,16 @@ import (
 )
 
 func TestJSONLogger(t *testing.T) {
-	t.Parallel()
 	buf := &bytes.Buffer{}
 	logger := log.NewJSONLogger(buf)
 	if err := logger.Log("err", errors.New("err"), "m", map[string]int{"0": 0}, "a", []int{1, 2, 3}); err != nil {
 		t.Fatal(err)
 	}
 	if want, have := `{"a":[1,2,3],"err":"err","m":{"0":0}}`+"\n", buf.String(); want != have {
-		t.Errorf("\nwant %#v\nhave %#v", want, have)
+		t.Errorf("want %#v, have %#v", want, have)
 	}
 }
 
-func TestJSONLoggerMissingValue(t *testing.T) {
-	t.Parallel()
-	buf := &bytes.Buffer{}
-	logger := log.NewJSONLogger(buf)
-	if err := logger.Log("k"); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := `{"k":"(MISSING)"}`+"\n", buf.String(); want != have {
-		t.Errorf("\nwant %#v\nhave %#v", want, have)
-	}
-}
-
-func TestJSONLoggerNilStringerKey(t *testing.T) {
-	t.Parallel()
-
-	buf := &bytes.Buffer{}
-	logger := log.NewJSONLogger(buf)
-	if err := logger.Log((*stringer)(nil), "v"); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := `{"NULL":"v"}`+"\n", buf.String(); want != have {
-		t.Errorf("\nwant %#v\nhave %#v", want, have)
-	}
-}
-
-func TestJSONLoggerNilErrorValue(t *testing.T) {
-	t.Parallel()
-
-	buf := &bytes.Buffer{}
-	logger := log.NewJSONLogger(buf)
-	if err := logger.Log("err", (*stringError)(nil)); err != nil {
-		t.Fatal(err)
-	}
-	if want, have := `{"err":null}`+"\n", buf.String(); want != have {
-		t.Errorf("\nwant %#v\nhave %#v", want, have)
-	}
-}
-
-type stringer string
-
-func (s stringer) String() string {
-	return string(s)
-}
-
-type stringError string
-
-func (s stringError) Error() string {
-	return string(s)
-}
-
 func BenchmarkJSONLoggerSimple(b *testing.B) {
 	benchmarkRunner(b, log.NewJSONLogger(ioutil.Discard), baseMessage)
 }
diff --git a/log/log.go b/log/log.go
index 0b16a8f..fe7fa5a 100644
--- a/log/log.go
+++ b/log/log.go
@@ -4,10 +4,7 @@
 // key/value data.
 package log
 
-import (
-	"errors"
-	"sync/atomic"
-)
+import "sync/atomic"
 
 // Logger is the fundamental interface for all log operations. Log creates a
 // log event from keyvals, a variadic sequence of alternating keys and values.
@@ -18,10 +15,6 @@ type Logger interface {
 	Log(keyvals ...interface{}) error
 }
 
-// ErrMissingValue is appended to keyvals slices with odd length to substitute
-// the missing value.
-var ErrMissingValue = errors.New("(MISSING)")
-
 // NewContext returns a new Context that logs to logger.
 func NewContext(logger Logger) Context {
 	if c, ok := logger.(Context); ok {
@@ -44,10 +37,10 @@ type Context struct {
 // stored context with their generated value, appends keyvals, and passes the
 // result to the wrapped Logger.
 func (l Context) Log(keyvals ...interface{}) error {
-	kvs := append(l.keyvals, keyvals...)
-	if len(kvs)%2 != 0 {
-		kvs = append(kvs, ErrMissingValue)
+	if len(keyvals)%2 != 0 {
+		panic("bad keyvals")
 	}
+	kvs := append(l.keyvals, keyvals...)
 	if l.hasValuer {
 		// If no keyvals were appended above then we must copy l.keyvals so
 		// that future log events will reevaluate the stored Valuers.
@@ -64,17 +57,17 @@ func (l Context) With(keyvals ...interface{}) Context {
 	if len(keyvals) == 0 {
 		return l
 	}
-	kvs := append(l.keyvals, keyvals...)
-	if len(kvs)%2 != 0 {
-		kvs = append(kvs, ErrMissingValue)
+	if len(keyvals)%2 != 0 {
+		panic("bad keyvals")
 	}
+	// Limiting the capacity of the stored keyvals ensures that a new
+	// backing array is created if the slice must grow in Log or With.
+	// Using the extra capacity without copying risks a data race that
+	// would violate the Logger interface contract.
+	n := len(l.keyvals) + len(keyvals)
 	return Context{
-		logger: l.logger,
-		// Limiting the capacity of the stored keyvals ensures that a new
-		// backing array is created if the slice must grow in Log or With.
-		// Using the extra capacity without copying risks a data race that
-		// would violate the Logger interface contract.
-		keyvals:   kvs[:len(kvs):len(kvs)],
+		logger:    l.logger,
+		keyvals:   append(l.keyvals, keyvals...)[:n:n],
 		hasValuer: l.hasValuer || containsValuer(keyvals),
 	}
 }
@@ -85,19 +78,16 @@ func (l Context) WithPrefix(keyvals ...interface{}) Context {
 	if len(keyvals) == 0 {
 		return l
 	}
+	if len(keyvals)%2 != 0 {
+		panic("bad keyvals")
+	}
 	// Limiting the capacity of the stored keyvals ensures that a new
 	// backing array is created if the slice must grow in Log or With.
 	// Using the extra capacity without copying risks a data race that
 	// would violate the Logger interface contract.
 	n := len(l.keyvals) + len(keyvals)
-	if len(keyvals)%2 != 0 {
-		n++
-	}
 	kvs := make([]interface{}, 0, n)
 	kvs = append(kvs, keyvals...)
-	if len(kvs)%2 != 0 {
-		kvs = append(kvs, ErrMissingValue)
-	}
 	kvs = append(kvs, l.keyvals...)
 	return Context{
 		logger:    l.logger,
diff --git a/log/log_test.go b/log/log_test.go
index 01173d0..fd03f54 100644
--- a/log/log_test.go
+++ b/log/log_test.go
@@ -11,7 +11,6 @@ import (
 var discard = log.Logger(log.LoggerFunc(func(...interface{}) error { return nil }))
 
 func TestContext(t *testing.T) {
-	t.Parallel()
 	buf := &bytes.Buffer{}
 	logger := log.NewLogfmtLogger(buf)
 
@@ -37,32 +36,18 @@ func TestContext(t *testing.T) {
 	}
 }
 
-func TestContextMissingValue(t *testing.T) {
-	t.Parallel()
-	var output []interface{}
-	logger := log.Logger(log.LoggerFunc(func(keyvals ...interface{}) error {
-		output = keyvals
-		return nil
-	}))
-
-	lc := log.NewContext(logger)
-
-	lc.Log("k")
-	if want, have := 2, len(output); want != have {
-		t.Errorf("want len(output) == %v, have %v", want, have)
-	}
-	if want, have := log.ErrMissingValue, output[1]; want != have {
-		t.Errorf("want %#v, have %#v", want, have)
-	}
-
-	lc.With("k1").WithPrefix("k0").Log("k2")
-	if want, have := 6, len(output); want != have {
-		t.Errorf("want len(output) == %v, have %v", want, have)
+func TestContextWithPrefix(t *testing.T) {
+	buf := &bytes.Buffer{}
+	kvs := []interface{}{"a", 123}
+	logger := log.NewJSONLogger(buf)
+	lc := log.NewContext(logger).With(kvs...)
+	kvs[1] = 0             // WithPrefix should copy its key values
+	lc = lc.With("b", "c") // WithPrefix should stack
+	if err := lc.Log("msg", "message"); err != nil {
+		t.Fatal(err)
 	}
-	for i := 1; i < 6; i += 2 {
-		if want, have := log.ErrMissingValue, output[i]; want != have {
-			t.Errorf("want output[%d] == %#v, have %#v", i, want, have)
-		}
+	if want, have := `{"a":123,"b":"c","msg":"message"}`+"\n", buf.String(); want != have {
+		t.Errorf("\nwant: %s\nhave: %s", want, have)
 	}
 }
 
