diff --git a/internal/xds/balancer/clusterresolver/configbuilder.go b/internal/xds/balancer/clusterresolver/configbuilder.go
index 6aabc935..702ba76c 100644
--- a/internal/xds/balancer/clusterresolver/configbuilder.go
+++ b/internal/xds/balancer/clusterresolver/configbuilder.go
@@ -280,7 +280,7 @@ func priorityLocalitiesToClusterImpl(localities []xdsresource.Locality, priority
 			// populate a new locality weight attribute for each address The
 			// attribute will have the weight (as an integer) of the locality
 			// the address is part of." - A52
-			resolverEndpoint = wrrlocality.SetAddrInfoInEndpoint(resolverEndpoint, wrrlocality.AddrInfo{LocalityWeight: lw})
+			resolverEndpoint = wrrlocality.SetAddrInfo(resolverEndpoint, wrrlocality.AddrInfo{LocalityWeight: lw})
 			var ew uint32 = 1
 			if endpoint.Weight != 0 {
 				ew = endpoint.Weight
diff --git a/internal/xds/balancer/wrrlocality/balancer.go b/internal/xds/balancer/wrrlocality/balancer.go
index b11aaa17..f5f2a89d 100644
--- a/internal/xds/balancer/wrrlocality/balancer.go
+++ b/internal/xds/balancer/wrrlocality/balancer.go
@@ -113,16 +113,9 @@ type AddrInfo struct {
 	LocalityWeight uint32
 }
 
-// SetAddrInfo returns a copy of addr in which the BalancerAttributes field is
+// SetAddrInfo returns a copy of endpoint in which the Attributes field is
 // updated with AddrInfo.
-func SetAddrInfo(addr resolver.Address, addrInfo AddrInfo) resolver.Address {
-	addr.BalancerAttributes = addr.BalancerAttributes.WithValue(attributeKey{}, addrInfo)
-	return addr
-}
-
-// SetAddrInfoInEndpoint returns a copy of endpoint in which the Attributes
-// field is updated with AddrInfo.
-func SetAddrInfoInEndpoint(endpoint resolver.Endpoint, addrInfo AddrInfo) resolver.Endpoint {
+func SetAddrInfo(endpoint resolver.Endpoint, addrInfo AddrInfo) resolver.Endpoint {
 	endpoint.Attributes = endpoint.Attributes.WithValue(attributeKey{}, addrInfo)
 	return endpoint
 }
@@ -131,10 +124,10 @@ func (a AddrInfo) String() string {
 	return fmt.Sprintf("Locality Weight: %d", a.LocalityWeight)
 }
 
-// getAddrInfo returns the AddrInfo stored in the BalancerAttributes field of
-// addr. Returns false if no AddrInfo found.
-func getAddrInfo(addr resolver.Address) (AddrInfo, bool) {
-	v := addr.BalancerAttributes.Value(attributeKey{})
+// getAddrInfo returns the AddrInfo stored in the Attributes field of
+// ep. Returns false if no AddrInfo found.
+func getAddrInfo(ep resolver.Endpoint) (AddrInfo, bool) {
+	v := ep.Attributes.Value(attributeKey{})
 	ai, ok := v.(AddrInfo)
 	return ai, ok
 }
@@ -166,15 +159,15 @@ func (b *wrrLocalityBalancer) UpdateClientConnState(s balancer.ClientConnState)
 	}
 
 	weightedTargets := make(map[string]weightedtarget.Target)
-	for _, addr := range s.ResolverState.Addresses {
+	for _, ep := range s.ResolverState.Endpoints {
 		// This get of LocalityID could potentially return a zero value. This
 		// shouldn't happen though (this attribute that is set actually gets
 		// used to build localities in the first place), and thus don't error
 		// out, and just build a weighted target with undefined behavior.
-		locality := xdsinternal.LocalityString(xdsinternal.GetLocalityID(addr))
-		ai, ok := getAddrInfo(addr)
+		locality := xdsinternal.LocalityString(xdsinternal.LocalityIDFromEndpoint(ep))
+		ai, ok := getAddrInfo(ep)
 		if !ok {
-			return fmt.Errorf("xds_wrr_locality: missing locality weight information in address %q", addr)
+			return fmt.Errorf("xds_wrr_locality: missing locality weight information in endpoint %q", ep)
 		}
 		weightedTargets[locality] = weightedtarget.Target{Weight: ai.LocalityWeight, ChildPolicy: lbCfg.ChildPolicy}
 	}
diff --git a/internal/xds/xds.go b/internal/xds/xds.go
index 866fc53b..b05d8660 100644
--- a/internal/xds/xds.go
+++ b/internal/xds/xds.go
@@ -105,6 +105,12 @@ func SetLocalityIDInEndpoint(endpoint resolver.Endpoint, l clients.Locality) res
 	return endpoint
 }
 
+// LocalityIDFromEndpoint returns the locality ID of ep.
+func LocalityIDFromEndpoint(ep resolver.Endpoint) clients.Locality {
+	path, _ := ep.Attributes.Value(localityKey).(clients.Locality)
+	return path
+}
+
 // UnknownCSMLabels are TelemetryLabels emitted from CDS if CSM Telemetry Label
 // data is not present in the CDS Resource.
 var UnknownCSMLabels = map[string]string{
diff --git a/interop/orcalb.go b/interop/orcalb.go
index b19defb6..a0466899 100644
--- a/interop/orcalb.go
+++ b/interop/orcalb.go
@@ -29,6 +29,7 @@ import (
 	"google.golang.org/grpc/balancer/base"
 	"google.golang.org/grpc/connectivity"
 	"google.golang.org/grpc/orca"
+	"google.golang.org/grpc/resolver"
 )
 
 func init() {
@@ -59,18 +60,33 @@ func (o *orcab) ExitIdle() {
 	}
 }
 
+// endpointsToAddrs flattens a list of endpoints to addresses to maintain
+// existing behavior.
+// TODO: https://github.com/grpc/grpc-go/issues/8809 - delegate subchannel
+// management to the pickfirst balancer using the endpoint sharding balancer.
+func endpointsToAddrs(eps []resolver.Endpoint) []resolver.Address {
+	addrs := make([]resolver.Address, 0, len(eps))
+	for _, ep := range eps {
+		if len(ep.Addresses) == 0 {
+			continue
+		}
+		addrs = append(addrs, ep.Addresses[0])
+	}
+	return addrs
+}
+
 func (o *orcab) UpdateClientConnState(s balancer.ClientConnState) error {
 	if o.sc != nil {
-		o.sc.UpdateAddresses(s.ResolverState.Addresses)
+		o.sc.UpdateAddresses(endpointsToAddrs(s.ResolverState.Endpoints))
 		return nil
 	}
 
-	if len(s.ResolverState.Addresses) == 0 {
-		o.ResolverError(fmt.Errorf("produced no addresses"))
-		return fmt.Errorf("resolver produced no addresses")
+	if len(s.ResolverState.Endpoints) == 0 {
+		o.ResolverError(fmt.Errorf("produced no endpoints"))
+		return fmt.Errorf("resolver produced no endpoints")
 	}
 	var err error
-	o.sc, err = o.cc.NewSubConn(s.ResolverState.Addresses, balancer.NewSubConnOptions{StateListener: o.updateSubConnState})
+	o.sc, err = o.cc.NewSubConn(endpointsToAddrs(s.ResolverState.Endpoints), balancer.NewSubConnOptions{StateListener: o.updateSubConnState})
 	if err != nil {
 		o.cc.UpdateState(balancer.State{ConnectivityState: connectivity.TransientFailure, Picker: base.NewErrPicker(fmt.Errorf("error creating subconn: %v", err))})
 		return nil
